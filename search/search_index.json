{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AlphaPEM AlphaPEM is an open-source software package for simulating proton exchange membrane fuel cell (PEMFC) systems for embedded applications. It is based on a physics-based, one-dimensional (1D), dynamic, two-phase, and non-isothermal model. It quickly simulates the internal states and voltage dynamics of PEMFC systems for all current densities and operating conditions imposed on it. In particular, it is possible to apply a step current density or use current profiles to generate polarization curves or electrochemical impedance spectroscopy (EIS) curves. It can also automatically calibrate the undetermined parameters of the model to simulate a given real fuel cell system. A detailed presentation of this program was published in the peer-reviewed journal SoftwareX. Improvements to AlphaPEM , such as the addition of heat transfer modelling and spatial extension to 1D+1D, will be available in the future. Table of Contents Installation Major updates Work in progress Related publications Installation To install AlphaPEM , follow these steps in a shell: Clone the repository: git clone https://github.com/gassraphael/AlphaPEM.git Navigate to the project directory: cd AlphaPEM Update the Python package manager, pip, to the latest available version: pip install --upgrade pip Install the required dependencies (eventually in a specific environment): pip install numpy scipy matplotlib colorama pygad python3 -m pip install git+https://github.com/RedFantom/ttkthemes Major updates V1.1 - 2025.07.16 - This version of AlphaPEM includes: the addition of heat transfer to the program, in cooperation with Pedro Affonso Nobrega (PERSEE, MINES PSL). an improvement of the initial variable values: the algorithm waits for a given time (approximately 2 virtual hours) to reach equilibrium, and then the experiment starts (step/pola/EIS). V1.0 - 2024.09.05 - This version of AlphaPEM corresponds to the one developed during Rapha\u00ebl Gass's PhD from 2021 to 2024. It is based on a physics-based, one-dimensional (1D), dynamic, two-phase, and isothermal model. Work in progress The polarization curves from the EH-31 fuel cell example are no longer calibrated due to recent modifications made to the equations. A calibration of the undeterminate parameters will be performed in the future to correct this issue. If accurate examples are required, the V1.0 version of AlphaPEM can be used. Related publications The detailed model description and simulation results can be found in the following articles and thesis. Published journal papers: AlphaPEM: An Open-Source Dynamic 1D Physics-Based Pem Fuel Cell Model for Embedded Applications (2025, 1st author) In the SoftwareX journal, in arXiv , in HAL or in SSRN (postprint). The objective of this work is to highlight the AlphaPEM software, which has been published as open-source on GitHub. The first version of this PEM fuel cell simulator is based on the dynamic 1D model developed during 2021-2024. An Advanced 1D Physics-Based Model for PEM Hydrogen Fuel Cells With Enhanced Overvoltage Prediction (2025, 1st author) In the International Journal of Hydrogen Energy , in arXiv , in HAL or in SSRN (postprint). The aim of this study was to introduce the dynamic 1D model developed during 2021-2024, emphasizing the adjustment of the equations for this specific model and their numerical resolution. Furthermore, a novel coefficient is proposed to establish a physical relationship between the voltage drop at high currents, the quantity of liquid water in the cell, and operating conditions. A Critical Review of Proton Exchange Membrane Fuel Cells Matter Transports and Voltage Polarisation for Modelling (2024, 1st author) In the Journal of the Electrochemical Society or in HAL (postprint). The aim of this work was to compile, within a single article, all the equations required for the physical modeling of a fuel cell. Each equation is complemented with explanations, critical analysis, and suggestions for potential enhancements. Thesis manuscript: Advanced physical modeling of PEM fuel cells to enhance their performances (2024, 1st author) In HAL (final version). The objective of this thesis was to develop an advanced model for PEMFCs to optimize their control and improve performance. A 1D, dynamic, two-phase, isothermal model was proposed, leading to the development of the open-source software AlphaPEM, which enables accurate simulations and facilitates predictive control strategies for enhanced fuel cell operation.","title":"Home"},{"location":"#alphapem","text":"AlphaPEM is an open-source software package for simulating proton exchange membrane fuel cell (PEMFC) systems for embedded applications. It is based on a physics-based, one-dimensional (1D), dynamic, two-phase, and non-isothermal model. It quickly simulates the internal states and voltage dynamics of PEMFC systems for all current densities and operating conditions imposed on it. In particular, it is possible to apply a step current density or use current profiles to generate polarization curves or electrochemical impedance spectroscopy (EIS) curves. It can also automatically calibrate the undetermined parameters of the model to simulate a given real fuel cell system. A detailed presentation of this program was published in the peer-reviewed journal SoftwareX. Improvements to AlphaPEM , such as the addition of heat transfer modelling and spatial extension to 1D+1D, will be available in the future.","title":"AlphaPEM"},{"location":"#table-of-contents","text":"Installation Major updates Work in progress Related publications","title":"Table of Contents"},{"location":"#installation","text":"To install AlphaPEM , follow these steps in a shell: Clone the repository: git clone https://github.com/gassraphael/AlphaPEM.git Navigate to the project directory: cd AlphaPEM Update the Python package manager, pip, to the latest available version: pip install --upgrade pip Install the required dependencies (eventually in a specific environment): pip install numpy scipy matplotlib colorama pygad python3 -m pip install git+https://github.com/RedFantom/ttkthemes","title":"Installation"},{"location":"#major-updates","text":"V1.1 - 2025.07.16 - This version of AlphaPEM includes: the addition of heat transfer to the program, in cooperation with Pedro Affonso Nobrega (PERSEE, MINES PSL). an improvement of the initial variable values: the algorithm waits for a given time (approximately 2 virtual hours) to reach equilibrium, and then the experiment starts (step/pola/EIS). V1.0 - 2024.09.05 - This version of AlphaPEM corresponds to the one developed during Rapha\u00ebl Gass's PhD from 2021 to 2024. It is based on a physics-based, one-dimensional (1D), dynamic, two-phase, and isothermal model.","title":"Major updates"},{"location":"#work-in-progress","text":"The polarization curves from the EH-31 fuel cell example are no longer calibrated due to recent modifications made to the equations. A calibration of the undeterminate parameters will be performed in the future to correct this issue. If accurate examples are required, the V1.0 version of AlphaPEM can be used.","title":"Work in progress"},{"location":"#related-publications","text":"The detailed model description and simulation results can be found in the following articles and thesis. Published journal papers: AlphaPEM: An Open-Source Dynamic 1D Physics-Based Pem Fuel Cell Model for Embedded Applications (2025, 1st author) In the SoftwareX journal, in arXiv , in HAL or in SSRN (postprint). The objective of this work is to highlight the AlphaPEM software, which has been published as open-source on GitHub. The first version of this PEM fuel cell simulator is based on the dynamic 1D model developed during 2021-2024. An Advanced 1D Physics-Based Model for PEM Hydrogen Fuel Cells With Enhanced Overvoltage Prediction (2025, 1st author) In the International Journal of Hydrogen Energy , in arXiv , in HAL or in SSRN (postprint). The aim of this study was to introduce the dynamic 1D model developed during 2021-2024, emphasizing the adjustment of the equations for this specific model and their numerical resolution. Furthermore, a novel coefficient is proposed to establish a physical relationship between the voltage drop at high currents, the quantity of liquid water in the cell, and operating conditions. A Critical Review of Proton Exchange Membrane Fuel Cells Matter Transports and Voltage Polarisation for Modelling (2024, 1st author) In the Journal of the Electrochemical Society or in HAL (postprint). The aim of this work was to compile, within a single article, all the equations required for the physical modeling of a fuel cell. Each equation is complemented with explanations, critical analysis, and suggestions for potential enhancements. Thesis manuscript: Advanced physical modeling of PEM fuel cells to enhance their performances (2024, 1st author) In HAL (final version). The objective of this thesis was to develop an advanced model for PEMFCs to optimize their control and improve performance. A 1D, dynamic, two-phase, isothermal model was proposed, leading to the development of the open-source software AlphaPEM, which enables accurate simulations and facilitates predictive control strategies for enhanced fuel cell operation.","title":"Related publications"},{"location":"about/","text":"Contributions Authors AlphaPEM is firstly developed by Rapha\u00ebl Gass during his PhD thesis from 2021 to 2024, supervised by Prof. Zhongliang Li, Prof. Rachid Outbib, Prof. Samir Jemei and Prof. Daniel Hissel. Financial support This work has been supported: - from 2021 to 2024 by French National Research Agency via project DEAL (Grant no. ANR-20-CE05-0016-01), the Region Provence-Alpes-C\u00f4te d\u2019Azur, the EIPHI Graduate School (contract ANR-17-EURE-0002) and the Region Bourgogne Franche-Comt\u00e9. Licenses AlphaPEM is licensed under the GNU GPL 3.0. See the LICENSE file for more details. It also includes components licensed under the BSD-3-Clause license : calibration/parameter_calibration.py from PyGAD . New contributors Contributions from the community are welcome! If you would like to contribute to AlphaPEM , please follow these steps: Fork the repository. Create a new branch ( git checkout -b feature/YourFeature ). Commit your changes ( git commit -am 'Add some feature' ). Push to the branch ( git push origin feature/YourFeature ). Create a new Pull Request. Contact For any questions or support, please contact me at gassraphael@proton.me .","title":"About"},{"location":"about/#contributions","text":"","title":"Contributions"},{"location":"about/#authors","text":"AlphaPEM is firstly developed by Rapha\u00ebl Gass during his PhD thesis from 2021 to 2024, supervised by Prof. Zhongliang Li, Prof. Rachid Outbib, Prof. Samir Jemei and Prof. Daniel Hissel.","title":"Authors"},{"location":"about/#financial-support","text":"This work has been supported: - from 2021 to 2024 by French National Research Agency via project DEAL (Grant no. ANR-20-CE05-0016-01), the Region Provence-Alpes-C\u00f4te d\u2019Azur, the EIPHI Graduate School (contract ANR-17-EURE-0002) and the Region Bourgogne Franche-Comt\u00e9.","title":"Financial support"},{"location":"about/#licenses","text":"AlphaPEM is licensed under the GNU GPL 3.0. See the LICENSE file for more details. It also includes components licensed under the BSD-3-Clause license : calibration/parameter_calibration.py from PyGAD .","title":"Licenses"},{"location":"about/#new-contributors","text":"Contributions from the community are welcome! If you would like to contribute to AlphaPEM , please follow these steps: Fork the repository. Create a new branch ( git checkout -b feature/YourFeature ). Commit your changes ( git commit -am 'Add some feature' ). Push to the branch ( git push origin feature/YourFeature ). Create a new Pull Request.","title":"New contributors"},{"location":"about/#contact","text":"For any questions or support, please contact me at gassraphael@proton.me .","title":"Contact"},{"location":"functions/GUI/","text":"GUI This file is designated for executing the AlphaPEM software package through a graphical user interface (GUI). Most of the functionalities are available, but some are not implemented. about () This function displays information about the program and its author in a dialog box when the \"About\" button is clicked. Source code in GUI.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 def about (): \"\"\"This function displays information about the program and its author in a dialog box when the \"About\" button is clicked. \"\"\" msg = \"AlphaPEM is an open-source software package for simulating proton exchange membrane fuel cell (PEMFC) \" \\ \"systems using physics-based models for embedded applications. \\n It is based on a physics-based, \" \\ \"one-dimensional (1D), dynamic, two-phase, and isothermal model. It can quickly simulate the internal \" \\ \"states and voltage dynamics of PEMFC systems, and produce polarization and EIS curves. It can also \" \\ \"automatically calibrate the undetermined parameters of the model to simulate a given real fuel cell \" \\ \"system.\" \\ \" \\n\\n AlphaPEM is firstly developed by Rapha\u00ebl Gass during his PhD thesis from 2021 to 2024, supervised by \" \\ \"Prof. Zhongliang Li, Prof. Rachid Outbib, Prof. Samir Jemei and Prof. Daniel Hissel. \\n It has been \" \\ \"supported by French National Research Agency via project DEAL (Grant no. ANR-20-CE05-0016-01), the Region \" \\ \"Provence-Alpes-C\u00f4te d\u2019Azur, the EIPHI Graduate School (contract ANR-17-EURE-0002) and the Region \" \\ \"Bourgogne Franche-Comt\u00e9.\" \\ \" \\n\\n It is related to the following articles:\" \\ \" \\n - Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a,\" \\ \" \\n - Gass et al 2024 SSRN http://dx.doi.org/10.2139/ssrn.4812343.\" \\ \" \\n\\n More information can be found in:\" \\ \" \\n - GitHub webpage: https://github.com/gassraphael/AlphaPEM\" \\ \" \\n - Documentation webpage: to do\" \\ \" \\n\\n If you want to contact me, please send an email to: gassraphael@proton.me.\" # Create a new top-level window about_window = tk . Toplevel () about_window . title ( 'About this program' ) # Set the size of the window about_window . geometry ( '730x460' ) # Width x Height # Create a label with the message label = ttk . Label ( about_window , text = msg , wraplength = 700 ) # wraplength to wrap text within the given width label . pack ( padx = 15 , pady = 15 ) # Add padding around the label # Create an OK button to close the window ok_button = ttk . Button ( about_window , text = 'OK' , command = about_window . destroy ) ok_button . pack ( pady = 10 ) control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) This function is responsible for validating the user inputs by calling the value_control() function. If the input is valid, it then calls the show_current_button function to perform the requested action based on the button_type. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in GUI.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function is responsible for validating the user inputs by calling the value_control() function. If the input is valid, it then calls the show_current_button function to perform the requested action based on the button_type. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # Control the values value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) # Activate the action show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) create_application () This function creates the main application window and setting its title. It calls the main_frame() function to create the main graphical elements of the window. Source code in GUI.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def create_application (): \"\"\"This function creates the main application window and setting its title. It calls the main_frame() function to create the main graphical elements of the window. \"\"\" # Create the main application window root = ThemedTk ( theme = \"arc\" ) root . configure ( background = '#f5f6f7' ) root . title ( \"AlphaPEM\" ) # Create a canvas and add a scrollbar to it canvas = tk . Canvas ( root ) scrollbar = ttk . Scrollbar ( root , command = canvas . yview ) canvas . configure ( yscrollcommand = scrollbar . set ) frame = ttk . Frame ( canvas ) # Create a frame inside the canvas to add your widgets # Add all the widgets to the frame main_frame ( frame , canvas ) canvas . create_window (( 0 , 0 ), window = frame , anchor = 'nw' ) # Add the frame to the canvas # Adjust the main window and canvas size frame . update_idletasks () root . geometry ( f \" { frame . winfo_width () } x { frame . winfo_height () } \" ) canvas . configure ( scrollregion = canvas . bbox ( 'all' )) canvas . pack ( fill = 'both' , expand = True , side = 'left' ) # Organize the widgets scrollbar . pack ( fill = 'y' , side = 'right' ) root . mainloop () main_frame ( root , canvas ) This function creates the main graphical elements, such as labels, entry widgets, radio buttons, and buttons. It arranges them in the application window (root). It also initializes the choice dictionary variables for various parameters and settings. Parameters: root : ThemedTk The main application window where the graphical elements will be placed. canvas : tk.Canvas The canvas where the main graphical elements will be placed. Source code in GUI.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def main_frame ( root , canvas ): \"\"\"This function creates the main graphical elements, such as labels, entry widgets, radio buttons, and buttons. It arranges them in the application window (root). It also initializes the choice dictionary variables for various parameters and settings. Parameters: ----------- root : ThemedTk The main application window where the graphical elements will be placed. canvas : tk.Canvas The canvas where the main graphical elements will be placed. \"\"\" # Create a custom styles style = ttk . Style () style . configure ( 'Custom.TFrame' , background = '#f5f6f7' ) style . configure ( 'Blue.TButton' , foreground = 'blue' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to blue style . configure ( 'Green.TButton' , foreground = 'green' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to green style . configure ( 'Red.TButton' , foreground = 'red' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to red style . configure ( 'Black.TButton' , foreground = 'black' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to black style . configure ( 'Big.TButton' , font = ( 'cmr10' , 12 , 'bold' )) # Create control variables to track the visibility state of some frame show_info_undetermined_parameters = tk . BooleanVar ( value = False ) show_info_current_density_parameters = tk . BooleanVar ( value = False ) show_info_computing_parameters = tk . BooleanVar ( value = False ) # Create the frames to hold the different set of information # Fuel cell type and operating conditions operating_conditions_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) operating_conditions_frame . grid ( row = 1 , column = 0 , padx = 5 , pady = 5 ) # Accessible physical parameters accessible_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) accessible_parameters_frame . grid ( row = 3 , column = 0 , padx = 5 , pady = 5 ) # Undetermined physical parameters undetermined_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) undetermined_parameters_frame . grid ( row = 5 , column = 0 , padx = 5 , pady = 5 ) undetermined_parameters_frame . grid_remove () # Hide the frame by default # Current density parameters current_density_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) current_density_parameters_frame . grid ( row = 7 , column = 0 , padx = 5 , pady = 5 ) current_density_parameters_frame . grid_remove () # Hide the frame by default # Computing parameters computing_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) computing_parameters_frame . grid ( row = 9 , column = 0 , padx = 5 , pady = 5 ) computing_parameters_frame . grid_remove () # Hide the frame by default # Model possibilities and current density choice model_possibilities_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) model_possibilities_frame . grid ( row = 11 , column = 0 , padx = 5 , pady = 5 ) # Import the current density parameters from the settings file for default value ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) = current_density_parameters () f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # Create the choice dictionaries choice_operating_conditions = \\ { 'Temperature - Tfc (\u00b0C)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'Anode pressure - Pa (bar)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Cathode pressure - Pc (bar)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Anode stoichiometry - Sa' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Cathode stoichiometry - Sc' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 3 , 'label_column' : 3 }, 'Anode humidity - \u03a6a' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Cathode humidity - \u03a6c' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 3 }} choice_accessible_parameters = \\ { 'AGC thickness - Hagc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 1 }, 'CGC thickness - Hcgc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 3 }, 'AGC width - Wagc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 5 }, 'CGC width - Wcgc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'GC cumulated length - Lgc (m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Active area - Aact (cm\u00b2)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 5 }} choice_undetermined_parameters = \\ { 'GDL thickness - Hgdl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 1 }, 'MPL thickness - Hmpl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 3 }, 'ACL thickness - Hacl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 5 }, 'CCL thickness - Hccl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 1 }, 'Membrane thickness - Hmem (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 3 }, 'GDL porosity - \u03b5_gdl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 1 , 'label_column' : 5 }, 'CL porosity - \u03b5_cl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 1 , 'label_column' : 5 }, 'MPL porosity - \u03b5_mpl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'Ionomer volume fraction - \u03b5_mc' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Compression ratio - \u03b5_c' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Capillary exponent - e' : { 'value' : tk . IntVar ( undetermined_parameters_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Electron resistance \\n - Re (\u00b5\u03a9.m\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 3 }, 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 5 }, 'Overpotential correction \\n exponent - \u03ba_c' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 1 }, 'Limit liquid saturation \\n coefficient - a_slim' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 3 }, 'Limit liquid saturation \\n coefficient - b_slim' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 5 }, 'Limit liquid saturation \\n coefficient - a_switch' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 1 }, 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 3 }} choice_current_density_parameters = \\ { 'Stabilisation time \\n - \u0394t_ini_step (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_ini_step' ] / 60 ), 'label_row' : 0 , 'label_column' : 3 }, 'Loading time \\n - \u0394t_load_step (s)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_load_step' ]), 'label_row' : 0 , 'label_column' : 5 }, 'Breaking time \\n - \u0394t_break_step (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_break_step' ] / 60 ), 'label_row' : 1 , 'label_column' : 3 }, 'Current density step \\n - i_step (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'i_step' ] / 1e4 ), 'label_row' : 1 , 'label_column' : 5 }, 'Stabilisation time \\n - \u0394t_ini_pola (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_ini_pola' ] / 60 ), 'label_row' : 2 , 'label_column' : 3 }, 'Loading time \\n - \u0394t_load_pola (s)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_load_pola' ]), 'label_row' : 2 , 'label_column' : 5 }, 'Breaking time \\n - \u0394t_break_pola (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_break_pola' ] / 60 ), 'label_row' : 3 , 'label_column' : 3 }, 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_i_pola' ] / 1e4 ), 'label_row' : 3 , 'label_column' : 5 }, 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , 1.5 ), 'label_row' : 4 , 'label_column' : 3 }, 'Static current \\n - i_EIS (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , i_EIS ), 'label_row' : 5 , 'label_column' : 3 }, 'Current ratio \\n - ratio_EIS (%)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , ratio_EIS ), 'label_row' : 5 , 'label_column' : 5 }, 'Number of points \\n calculated - nb_points_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , nb_points_EIS ), 'label_row' : 6 , 'label_column' : 3 }, 'Power of the \\n initial frequency \\n - f_power_min_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , f_power_min_EIS ), 'label_row' : 6 , 'label_column' : 5 }, 'Power of the \\n final frequency \\n - f_power_max_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , f_power_max_EIS ), 'label_row' : 7 , 'label_column' : 3 }, 'Number of frequencies \\n tested - nb_f_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , nb_f_EIS ), 'label_row' : 7 , 'label_column' : 5 }} choice_computing_parameters = \\ { 'Time for dynamic \\n display - \u0394t_dyn_step (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 300 ), 'label_row' : 0 , 'label_column' : 1 }, 'Purge time - t_purge (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 0.6 ), 'label_row' : 0 , 'label_column' : 3 }, 'Time between two purges \\n - \u0394t_purge (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 15 ), 'label_row' : 0 , 'label_column' : 5 }, 'Number of GDL nodes - n_gdl' : { 'value' : tk . IntVar ( computing_parameters_frame , 5 ), 'label_row' : 1 , 'label_column' : 1 }} choice_buttons = \\ { 'type_fuel_cell' : { 'value' : tk . StringVar ( operating_conditions_frame , 'Enter your specifications' ), 'label_row' : 0 }, 'type_auxiliary' : { 'value' : tk . IntVar ( model_possibilities_frame , 2 ), 'label_row' : 1 }, 'type_control' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 2 }, 'type_purge' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 3 }, 'type_display' : { 'value' : tk . IntVar ( model_possibilities_frame , 1 ), 'label_row' : 4 }, 'type_plot' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 5 }} # Displays operating conditions and physical parameters on the screen (without their values) # Display the dropdown menu buttons ttk . Button ( root , text = 'Undetermined physical parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( undetermined_parameters_frame , show_info_undetermined_parameters , canvas )) . \\ grid ( row = 4 , column = 0 , padx = 5 , pady = 5 ) ttk . Button ( root , text = 'Current density parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( current_density_parameters_frame , show_info_current_density_parameters , canvas )) . \\ grid ( row = 6 , column = 0 , padx = 5 , pady = 5 ) ttk . Button ( root , text = 'Computing parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( computing_parameters_frame , show_info_computing_parameters , canvas )) . \\ grid ( row = 8 , column = 0 , padx = 5 , pady = 5 ) # Display the labels display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) # Displays the value of the operating conditions and physical parameters on the screen. display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) # Display the radiobuttons on the screen display_radiobuttons ( model_possibilities_frame , choice_buttons ) # Display the 'type of fuel cell' widget on the screen. ttk . Label ( operating_conditions_frame , text = 'Fuel cell:' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 2 ) ttk . OptionMenu ( operating_conditions_frame , choice_buttons [ 'type_fuel_cell' ][ 'value' ], 'Enter your specifications' , 'Enter your specifications' , 'EH-31 1.5 bar (2021)' , 'EH-31 2.0 bar (2021)' , 'EH-31 2.25 bar (2021)' , 'EH-31 2.5 bar (2021)' , 'Linhao Fan (2010)' , command = lambda value : changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons )) . \\ grid ( row = 0 , column = 2 , columnspan = 2 ) # Display the action buttons to select the type of current density to be applied. ttk . Label ( model_possibilities_frame , text = 'Current density:' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 6 , column = 0 , columnspan = 2 , sticky = \"w\" ) current_button = { 'Step curve' : 0 , 'Pola curve' : 1 , 'EIS curve' : 2 } # Button to generate the step curve ttk . Button ( model_possibilities_frame , text = 'Step curve' , style = 'Blue.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'Step curve' ])) \\ . grid ( row = 6 , column = 2 , padx = 10 , pady = 20 ) # Button to generate the Pola curve ttk . Button ( model_possibilities_frame , text = 'Pola curve' , style = 'Green.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'Pola curve' ])) \\ . grid ( row = 6 , column = 3 , padx = 10 , pady = 20 ) # Button to generate the EIS curve ttk . Button ( model_possibilities_frame , text = 'EIS curve' , style = 'Red.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'EIS curve' ])) \\ . grid ( row = 6 , column = 4 , padx = 10 , pady = 20 ) # About button ttk . Button ( model_possibilities_frame , text = 'About' , style = 'Black.TButton' , command = about ) \\ . grid ( row = 6 , column = 5 , ipadx = 12 ) # Ensure the frame sizes are updated root . update_idletasks () set_equal_width ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , model_possibilities_frame ) show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) This function determines the action to be performed based on the button_type. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in GUI.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 def show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function determines the action to be performed based on the button_type. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # Retrieves parameter values for predefined stacks and keeps them in their standard unit, or converts user-selected # quantities into standard units. ( T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , Aact , Hgdl , Hmpl , Hacl , Hccl , Hmem , Hagc , Hcgc , Wagc , Wcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , epsilon_mc , epsilon_c , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl , step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , t_purge , delta_t_purge , n_gdl , type_fuel_cell , type_auxiliary , type_control , type_purge , type_display , type_plot ) = recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ) # Initialize the operating inputs and parameters dictionaries. current_parameters = { 'step_current_parameters' : step_current_parameters , 'pola_current_parameters' : pola_current_parameters , 'pola_current_for_cali_parameters' : pola_current_for_cali_parameters , 'i_EIS' : i_EIS , 'ratio_EIS' : ratio_EIS , 't_EIS' : t_EIS , 'f_EIS' : f_EIS } accessible_physical_parameters = { 'Aact' : Aact , 'Hagc' : Hagc , 'Hcgc' : Hcgc , 'Wagc' : Wagc , 'Wcgc' : Wcgc , 'Lgc' : Lgc } undetermined_physical_parameters = { 'Hgdl' : Hgdl , 'Hmpl' : Hmpl , 'Hmem' : Hmem , 'Hacl' : Hacl , 'Hccl' : Hccl , 'epsilon_gdl' : epsilon_gdl , 'epsilon_cl' : epsilon_cl , 'epsilon_mpl' : epsilon_mpl , 'epsilon_mc' : epsilon_mc , 'epsilon_c' : epsilon_c , 'e' : e , 'kappa_co' : kappa_co , 'i0_c_ref' : i0_c_ref , 'kappa_c' : kappa_c , 'a_slim' : a_slim , 'b_slim' : b_slim , 'a_switch' : a_switch , 'C_scl' : C_scl } if current_button == 0 : type_current = \"step\" current_density = step_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des } computing_parameters = { 'n_gdl' : n_gdl , 't_purge' : t_purge , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) if current_button == 1 : type_current = \"polarization\" current_density = polarization_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des } computing_parameters = { 'n_gdl' : n_gdl , 't_purge' : t_purge , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) if current_button == 2 : type_current = \"EIS\" current_density = EIS_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des } computing_parameters = { 'n_gdl' : n_gdl , 't_purge' : t_purge , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) toggle_info ( frame , show_info , canvas ) Toggles the visibility of the given frame and updates the scroll region of the given canvas. Parameters: frame ( Frame ) \u2013 The frame to show or hide. show_info ( BooleanVar ) \u2013 A boolean variable to track the current visibility state. canvas ( Canvas ) \u2013 The canvas to update the scroll region. Source code in GUI.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def toggle_info ( frame , show_info , canvas ): \"\"\" Toggles the visibility of the given frame and updates the scroll region of the given canvas. Parameters ---------- frame : ttk.Frame The frame to show or hide. show_info : tk.BooleanVar A boolean variable to track the current visibility state. canvas : tk.Canvas The canvas to update the scroll region. \"\"\" if show_info . get (): frame . grid_remove () # Hide the info frame show_info . set ( False ) # Update the visibility state else : frame . grid () # Show the info frame show_info . set ( True ) # Update the visibility state canvas . update_idletasks () # Update the scroll region of the given canvas. canvas . configure ( scrollregion = canvas . bbox ( 'all' ))","title":"GUI"},{"location":"functions/GUI/#gui","text":"This file is designated for executing the AlphaPEM software package through a graphical user interface (GUI). Most of the functionalities are available, but some are not implemented.","title":"GUI"},{"location":"functions/GUI/#GUI.about","text":"This function displays information about the program and its author in a dialog box when the \"About\" button is clicked. Source code in GUI.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 def about (): \"\"\"This function displays information about the program and its author in a dialog box when the \"About\" button is clicked. \"\"\" msg = \"AlphaPEM is an open-source software package for simulating proton exchange membrane fuel cell (PEMFC) \" \\ \"systems using physics-based models for embedded applications. \\n It is based on a physics-based, \" \\ \"one-dimensional (1D), dynamic, two-phase, and isothermal model. It can quickly simulate the internal \" \\ \"states and voltage dynamics of PEMFC systems, and produce polarization and EIS curves. It can also \" \\ \"automatically calibrate the undetermined parameters of the model to simulate a given real fuel cell \" \\ \"system.\" \\ \" \\n\\n AlphaPEM is firstly developed by Rapha\u00ebl Gass during his PhD thesis from 2021 to 2024, supervised by \" \\ \"Prof. Zhongliang Li, Prof. Rachid Outbib, Prof. Samir Jemei and Prof. Daniel Hissel. \\n It has been \" \\ \"supported by French National Research Agency via project DEAL (Grant no. ANR-20-CE05-0016-01), the Region \" \\ \"Provence-Alpes-C\u00f4te d\u2019Azur, the EIPHI Graduate School (contract ANR-17-EURE-0002) and the Region \" \\ \"Bourgogne Franche-Comt\u00e9.\" \\ \" \\n\\n It is related to the following articles:\" \\ \" \\n - Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a,\" \\ \" \\n - Gass et al 2024 SSRN http://dx.doi.org/10.2139/ssrn.4812343.\" \\ \" \\n\\n More information can be found in:\" \\ \" \\n - GitHub webpage: https://github.com/gassraphael/AlphaPEM\" \\ \" \\n - Documentation webpage: to do\" \\ \" \\n\\n If you want to contact me, please send an email to: gassraphael@proton.me.\" # Create a new top-level window about_window = tk . Toplevel () about_window . title ( 'About this program' ) # Set the size of the window about_window . geometry ( '730x460' ) # Width x Height # Create a label with the message label = ttk . Label ( about_window , text = msg , wraplength = 700 ) # wraplength to wrap text within the given width label . pack ( padx = 15 , pady = 15 ) # Add padding around the label # Create an OK button to close the window ok_button = ttk . Button ( about_window , text = 'OK' , command = about_window . destroy ) ok_button . pack ( pady = 10 )","title":"about"},{"location":"functions/GUI/#GUI.control_current_button","text":"This function is responsible for validating the user inputs by calling the value_control() function. If the input is valid, it then calls the show_current_button function to perform the requested action based on the button_type. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in GUI.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function is responsible for validating the user inputs by calling the value_control() function. If the input is valid, it then calls the show_current_button function to perform the requested action based on the button_type. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # Control the values value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) # Activate the action show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button )","title":"control_current_button"},{"location":"functions/GUI/#GUI.create_application","text":"This function creates the main application window and setting its title. It calls the main_frame() function to create the main graphical elements of the window. Source code in GUI.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def create_application (): \"\"\"This function creates the main application window and setting its title. It calls the main_frame() function to create the main graphical elements of the window. \"\"\" # Create the main application window root = ThemedTk ( theme = \"arc\" ) root . configure ( background = '#f5f6f7' ) root . title ( \"AlphaPEM\" ) # Create a canvas and add a scrollbar to it canvas = tk . Canvas ( root ) scrollbar = ttk . Scrollbar ( root , command = canvas . yview ) canvas . configure ( yscrollcommand = scrollbar . set ) frame = ttk . Frame ( canvas ) # Create a frame inside the canvas to add your widgets # Add all the widgets to the frame main_frame ( frame , canvas ) canvas . create_window (( 0 , 0 ), window = frame , anchor = 'nw' ) # Add the frame to the canvas # Adjust the main window and canvas size frame . update_idletasks () root . geometry ( f \" { frame . winfo_width () } x { frame . winfo_height () } \" ) canvas . configure ( scrollregion = canvas . bbox ( 'all' )) canvas . pack ( fill = 'both' , expand = True , side = 'left' ) # Organize the widgets scrollbar . pack ( fill = 'y' , side = 'right' ) root . mainloop ()","title":"create_application"},{"location":"functions/GUI/#GUI.main_frame","text":"This function creates the main graphical elements, such as labels, entry widgets, radio buttons, and buttons. It arranges them in the application window (root). It also initializes the choice dictionary variables for various parameters and settings. Parameters: root : ThemedTk The main application window where the graphical elements will be placed. canvas : tk.Canvas The canvas where the main graphical elements will be placed. Source code in GUI.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def main_frame ( root , canvas ): \"\"\"This function creates the main graphical elements, such as labels, entry widgets, radio buttons, and buttons. It arranges them in the application window (root). It also initializes the choice dictionary variables for various parameters and settings. Parameters: ----------- root : ThemedTk The main application window where the graphical elements will be placed. canvas : tk.Canvas The canvas where the main graphical elements will be placed. \"\"\" # Create a custom styles style = ttk . Style () style . configure ( 'Custom.TFrame' , background = '#f5f6f7' ) style . configure ( 'Blue.TButton' , foreground = 'blue' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to blue style . configure ( 'Green.TButton' , foreground = 'green' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to green style . configure ( 'Red.TButton' , foreground = 'red' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to red style . configure ( 'Black.TButton' , foreground = 'black' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to black style . configure ( 'Big.TButton' , font = ( 'cmr10' , 12 , 'bold' )) # Create control variables to track the visibility state of some frame show_info_undetermined_parameters = tk . BooleanVar ( value = False ) show_info_current_density_parameters = tk . BooleanVar ( value = False ) show_info_computing_parameters = tk . BooleanVar ( value = False ) # Create the frames to hold the different set of information # Fuel cell type and operating conditions operating_conditions_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) operating_conditions_frame . grid ( row = 1 , column = 0 , padx = 5 , pady = 5 ) # Accessible physical parameters accessible_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) accessible_parameters_frame . grid ( row = 3 , column = 0 , padx = 5 , pady = 5 ) # Undetermined physical parameters undetermined_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) undetermined_parameters_frame . grid ( row = 5 , column = 0 , padx = 5 , pady = 5 ) undetermined_parameters_frame . grid_remove () # Hide the frame by default # Current density parameters current_density_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) current_density_parameters_frame . grid ( row = 7 , column = 0 , padx = 5 , pady = 5 ) current_density_parameters_frame . grid_remove () # Hide the frame by default # Computing parameters computing_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) computing_parameters_frame . grid ( row = 9 , column = 0 , padx = 5 , pady = 5 ) computing_parameters_frame . grid_remove () # Hide the frame by default # Model possibilities and current density choice model_possibilities_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) model_possibilities_frame . grid ( row = 11 , column = 0 , padx = 5 , pady = 5 ) # Import the current density parameters from the settings file for default value ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) = current_density_parameters () f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # Create the choice dictionaries choice_operating_conditions = \\ { 'Temperature - Tfc (\u00b0C)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'Anode pressure - Pa (bar)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Cathode pressure - Pc (bar)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Anode stoichiometry - Sa' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Cathode stoichiometry - Sc' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 3 , 'label_column' : 3 }, 'Anode humidity - \u03a6a' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Cathode humidity - \u03a6c' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 3 }} choice_accessible_parameters = \\ { 'AGC thickness - Hagc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 1 }, 'CGC thickness - Hcgc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 3 }, 'AGC width - Wagc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 5 }, 'CGC width - Wcgc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'GC cumulated length - Lgc (m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Active area - Aact (cm\u00b2)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 5 }} choice_undetermined_parameters = \\ { 'GDL thickness - Hgdl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 1 }, 'MPL thickness - Hmpl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 3 }, 'ACL thickness - Hacl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 5 }, 'CCL thickness - Hccl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 1 }, 'Membrane thickness - Hmem (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 3 }, 'GDL porosity - \u03b5_gdl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 1 , 'label_column' : 5 }, 'CL porosity - \u03b5_cl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 1 , 'label_column' : 5 }, 'MPL porosity - \u03b5_mpl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'Ionomer volume fraction - \u03b5_mc' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Compression ratio - \u03b5_c' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Capillary exponent - e' : { 'value' : tk . IntVar ( undetermined_parameters_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Electron resistance \\n - Re (\u00b5\u03a9.m\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 3 }, 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 5 }, 'Overpotential correction \\n exponent - \u03ba_c' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 1 }, 'Limit liquid saturation \\n coefficient - a_slim' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 3 }, 'Limit liquid saturation \\n coefficient - b_slim' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 5 }, 'Limit liquid saturation \\n coefficient - a_switch' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 1 }, 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 3 }} choice_current_density_parameters = \\ { 'Stabilisation time \\n - \u0394t_ini_step (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_ini_step' ] / 60 ), 'label_row' : 0 , 'label_column' : 3 }, 'Loading time \\n - \u0394t_load_step (s)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_load_step' ]), 'label_row' : 0 , 'label_column' : 5 }, 'Breaking time \\n - \u0394t_break_step (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_break_step' ] / 60 ), 'label_row' : 1 , 'label_column' : 3 }, 'Current density step \\n - i_step (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'i_step' ] / 1e4 ), 'label_row' : 1 , 'label_column' : 5 }, 'Stabilisation time \\n - \u0394t_ini_pola (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_ini_pola' ] / 60 ), 'label_row' : 2 , 'label_column' : 3 }, 'Loading time \\n - \u0394t_load_pola (s)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_load_pola' ]), 'label_row' : 2 , 'label_column' : 5 }, 'Breaking time \\n - \u0394t_break_pola (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_break_pola' ] / 60 ), 'label_row' : 3 , 'label_column' : 3 }, 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_i_pola' ] / 1e4 ), 'label_row' : 3 , 'label_column' : 5 }, 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , 1.5 ), 'label_row' : 4 , 'label_column' : 3 }, 'Static current \\n - i_EIS (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , i_EIS ), 'label_row' : 5 , 'label_column' : 3 }, 'Current ratio \\n - ratio_EIS (%)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , ratio_EIS ), 'label_row' : 5 , 'label_column' : 5 }, 'Number of points \\n calculated - nb_points_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , nb_points_EIS ), 'label_row' : 6 , 'label_column' : 3 }, 'Power of the \\n initial frequency \\n - f_power_min_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , f_power_min_EIS ), 'label_row' : 6 , 'label_column' : 5 }, 'Power of the \\n final frequency \\n - f_power_max_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , f_power_max_EIS ), 'label_row' : 7 , 'label_column' : 3 }, 'Number of frequencies \\n tested - nb_f_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , nb_f_EIS ), 'label_row' : 7 , 'label_column' : 5 }} choice_computing_parameters = \\ { 'Time for dynamic \\n display - \u0394t_dyn_step (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 300 ), 'label_row' : 0 , 'label_column' : 1 }, 'Purge time - t_purge (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 0.6 ), 'label_row' : 0 , 'label_column' : 3 }, 'Time between two purges \\n - \u0394t_purge (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 15 ), 'label_row' : 0 , 'label_column' : 5 }, 'Number of GDL nodes - n_gdl' : { 'value' : tk . IntVar ( computing_parameters_frame , 5 ), 'label_row' : 1 , 'label_column' : 1 }} choice_buttons = \\ { 'type_fuel_cell' : { 'value' : tk . StringVar ( operating_conditions_frame , 'Enter your specifications' ), 'label_row' : 0 }, 'type_auxiliary' : { 'value' : tk . IntVar ( model_possibilities_frame , 2 ), 'label_row' : 1 }, 'type_control' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 2 }, 'type_purge' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 3 }, 'type_display' : { 'value' : tk . IntVar ( model_possibilities_frame , 1 ), 'label_row' : 4 }, 'type_plot' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 5 }} # Displays operating conditions and physical parameters on the screen (without their values) # Display the dropdown menu buttons ttk . Button ( root , text = 'Undetermined physical parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( undetermined_parameters_frame , show_info_undetermined_parameters , canvas )) . \\ grid ( row = 4 , column = 0 , padx = 5 , pady = 5 ) ttk . Button ( root , text = 'Current density parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( current_density_parameters_frame , show_info_current_density_parameters , canvas )) . \\ grid ( row = 6 , column = 0 , padx = 5 , pady = 5 ) ttk . Button ( root , text = 'Computing parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( computing_parameters_frame , show_info_computing_parameters , canvas )) . \\ grid ( row = 8 , column = 0 , padx = 5 , pady = 5 ) # Display the labels display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) # Displays the value of the operating conditions and physical parameters on the screen. display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) # Display the radiobuttons on the screen display_radiobuttons ( model_possibilities_frame , choice_buttons ) # Display the 'type of fuel cell' widget on the screen. ttk . Label ( operating_conditions_frame , text = 'Fuel cell:' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 2 ) ttk . OptionMenu ( operating_conditions_frame , choice_buttons [ 'type_fuel_cell' ][ 'value' ], 'Enter your specifications' , 'Enter your specifications' , 'EH-31 1.5 bar (2021)' , 'EH-31 2.0 bar (2021)' , 'EH-31 2.25 bar (2021)' , 'EH-31 2.5 bar (2021)' , 'Linhao Fan (2010)' , command = lambda value : changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons )) . \\ grid ( row = 0 , column = 2 , columnspan = 2 ) # Display the action buttons to select the type of current density to be applied. ttk . Label ( model_possibilities_frame , text = 'Current density:' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 6 , column = 0 , columnspan = 2 , sticky = \"w\" ) current_button = { 'Step curve' : 0 , 'Pola curve' : 1 , 'EIS curve' : 2 } # Button to generate the step curve ttk . Button ( model_possibilities_frame , text = 'Step curve' , style = 'Blue.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'Step curve' ])) \\ . grid ( row = 6 , column = 2 , padx = 10 , pady = 20 ) # Button to generate the Pola curve ttk . Button ( model_possibilities_frame , text = 'Pola curve' , style = 'Green.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'Pola curve' ])) \\ . grid ( row = 6 , column = 3 , padx = 10 , pady = 20 ) # Button to generate the EIS curve ttk . Button ( model_possibilities_frame , text = 'EIS curve' , style = 'Red.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'EIS curve' ])) \\ . grid ( row = 6 , column = 4 , padx = 10 , pady = 20 ) # About button ttk . Button ( model_possibilities_frame , text = 'About' , style = 'Black.TButton' , command = about ) \\ . grid ( row = 6 , column = 5 , ipadx = 12 ) # Ensure the frame sizes are updated root . update_idletasks () set_equal_width ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , model_possibilities_frame )","title":"main_frame"},{"location":"functions/GUI/#GUI.show_current_button","text":"This function determines the action to be performed based on the button_type. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in GUI.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 def show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function determines the action to be performed based on the button_type. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # Retrieves parameter values for predefined stacks and keeps them in their standard unit, or converts user-selected # quantities into standard units. ( T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , Aact , Hgdl , Hmpl , Hacl , Hccl , Hmem , Hagc , Hcgc , Wagc , Wcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , epsilon_mc , epsilon_c , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl , step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , t_purge , delta_t_purge , n_gdl , type_fuel_cell , type_auxiliary , type_control , type_purge , type_display , type_plot ) = recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ) # Initialize the operating inputs and parameters dictionaries. current_parameters = { 'step_current_parameters' : step_current_parameters , 'pola_current_parameters' : pola_current_parameters , 'pola_current_for_cali_parameters' : pola_current_for_cali_parameters , 'i_EIS' : i_EIS , 'ratio_EIS' : ratio_EIS , 't_EIS' : t_EIS , 'f_EIS' : f_EIS } accessible_physical_parameters = { 'Aact' : Aact , 'Hagc' : Hagc , 'Hcgc' : Hcgc , 'Wagc' : Wagc , 'Wcgc' : Wcgc , 'Lgc' : Lgc } undetermined_physical_parameters = { 'Hgdl' : Hgdl , 'Hmpl' : Hmpl , 'Hmem' : Hmem , 'Hacl' : Hacl , 'Hccl' : Hccl , 'epsilon_gdl' : epsilon_gdl , 'epsilon_cl' : epsilon_cl , 'epsilon_mpl' : epsilon_mpl , 'epsilon_mc' : epsilon_mc , 'epsilon_c' : epsilon_c , 'e' : e , 'kappa_co' : kappa_co , 'i0_c_ref' : i0_c_ref , 'kappa_c' : kappa_c , 'a_slim' : a_slim , 'b_slim' : b_slim , 'a_switch' : a_switch , 'C_scl' : C_scl } if current_button == 0 : type_current = \"step\" current_density = step_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des } computing_parameters = { 'n_gdl' : n_gdl , 't_purge' : t_purge , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) if current_button == 1 : type_current = \"polarization\" current_density = polarization_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des } computing_parameters = { 'n_gdl' : n_gdl , 't_purge' : t_purge , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) if current_button == 2 : type_current = \"EIS\" current_density = EIS_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des } computing_parameters = { 'n_gdl' : n_gdl , 't_purge' : t_purge , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters )","title":"show_current_button"},{"location":"functions/GUI/#GUI.toggle_info","text":"Toggles the visibility of the given frame and updates the scroll region of the given canvas. Parameters: frame ( Frame ) \u2013 The frame to show or hide. show_info ( BooleanVar ) \u2013 A boolean variable to track the current visibility state. canvas ( Canvas ) \u2013 The canvas to update the scroll region. Source code in GUI.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def toggle_info ( frame , show_info , canvas ): \"\"\" Toggles the visibility of the given frame and updates the scroll region of the given canvas. Parameters ---------- frame : ttk.Frame The frame to show or hide. show_info : tk.BooleanVar A boolean variable to track the current visibility state. canvas : tk.Canvas The canvas to update the scroll region. \"\"\" if show_info . get (): frame . grid_remove () # Hide the info frame show_info . set ( False ) # Update the visibility state else : frame . grid () # Show the info frame show_info . set ( True ) # Update the visibility state canvas . update_idletasks () # Update the scroll region of the given canvas. canvas . configure ( scrollregion = canvas . bbox ( 'all' ))","title":"toggle_info"},{"location":"functions/main/","text":"main This file is designated for executing the AlphaPEM software package. Most of it should remain unaltered for regular program usage. In the section \"AlphaPEM settings\", users can select various preconfigured configurations for execution: the fuel cell, current density, auxiliary system, control strategy, purge, display and plot used. Adjustments to these configurations can be made within setting.py or current_densities.py and their associated files.","title":"Main"},{"location":"functions/main/#main","text":"This file is designated for executing the AlphaPEM software package. Most of it should remain unaltered for regular program usage. In the section \"AlphaPEM settings\", users can select various preconfigured configurations for execution: the fuel cell, current density, auxiliary system, control strategy, purge, display and plot used. Adjustments to these configurations can be made within setting.py or current_densities.py and their associated files.","title":"main"},{"location":"functions/calibration/experimental_values/","text":"Experimental values This file is designated for executing the AlphaPEM software package. plot_experimental_polarisation_curve ( type_fuel_cell , i_fc_t , U_exp_t , ax ) This function plots the experimental polarisation curve on the same graph as the model results. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. i_fc_t ( ndarray ) \u2013 Current density values. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. ax ( Axes ) \u2013 Axes object on which the experimental data is plotted. Source code in calibration/experimental_values.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def plot_experimental_polarisation_curve ( type_fuel_cell , i_fc_t , U_exp_t , ax ): \"\"\" This function plots the experimental polarisation curve on the same graph as the model results. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. i_fc_t : numpy.ndarray Current density values. U_exp_t : numpy.ndarray Experimental values of the voltage. ax : matplotlib.axes.Axes Axes object on which the experimental data is plotted. \"\"\" if type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"s\" , color = \"black\" , label = \"Exp. - P = 1.5 bar\" ) elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P = 2.0 bar\" ) elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"^\" , color = \"black\" , label = \"Exp. - P = 2.25 bar\" ) elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"p\" , color = \"black\" , label = \"Exp. - P = 2.5 bar\" ) elif type_fuel_cell == \"BX_1.0\" : # at 1.0 atm ax . scatter ( i_fc_t , U_exp_t , linewidths = 3.5 , marker = \"s\" , color = \"black\" , label = \"Exp. - P = 1.0 atm\" ) elif type_fuel_cell == \"BX_1.35\" : # at 1.35 atm ax . scatter ( i_fc_t , U_exp_t , linewidths = 3.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P = 1.35 atm\" ) elif type_fuel_cell == \"LF\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 3.5 , marker = \"s\" , color = \"black\" , label = \"Experimental data\" ) ax . legend ( loc = 'best' , markerscale = 0.5 ) pola_exp_values ( type_fuel_cell ) This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used to compare the model results with the experimental data. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. Returns: i_exp_t ( ndarray ) \u2013 Experimental values of the current density. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. Source code in calibration/experimental_values.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def pola_exp_values ( type_fuel_cell ): \"\"\" This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used to compare the model results with the experimental data. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. Returns ------- i_exp_t : numpy.ndarray Experimental values of the current density. U_exp_t : numpy.ndarray Experimental values of the voltage. \"\"\" if type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar # # Current density # i_exp_t = np.zeros(37) # i_exp_t[0], i_exp_t[1], i_exp_t[2], i_exp_t[3], i_exp_t[4] = 0.050, 0.068, 0.089, 0.110, 0.147 # i_exp_t[5], i_exp_t[6], i_exp_t[7], i_exp_t[8], i_exp_t[9] = 0.185, 0.233, 0.293, 0.352, 0.395 # i_exp_t[10], i_exp_t[11], i_exp_t[12], i_exp_t[13], i_exp_t[14] = 0.455, 0.510, 0.556, 0.620, 0.672 # i_exp_t[15], i_exp_t[16], i_exp_t[17], i_exp_t[18], i_exp_t[19] = 0.738, 0.799, 0.850, 0.892, 0.942 # i_exp_t[20], i_exp_t[21], i_exp_t[22], i_exp_t[23], i_exp_t[24] = 1.039, 1.139, 1.212, 1.269, 1.360 # i_exp_t[25], i_exp_t[26], i_exp_t[27], i_exp_t[28], i_exp_t[29] = 1.432, 1.525, 1.604, 1.683, 1.765 # i_exp_t[30], i_exp_t[31], i_exp_t[32], i_exp_t[33], i_exp_t[34] = 1.878, 1.966, 2.050, 2.109, 2.151 # i_exp_t[35], i_exp_t[36] = 2.188, 2.246 # # Voltage # U_exp_t = np.zeros(37) # U_exp_t[0], U_exp_t[1], U_exp_t[2], U_exp_t[3], U_exp_t[4] = 0.900, 0.882, 0.865, 0.850, 0.834 # U_exp_t[5], U_exp_t[6], U_exp_t[7], U_exp_t[8], U_exp_t[9] = 0.823, 0.811, 0.794, 0.781, 0.772 # U_exp_t[10], U_exp_t[11], U_exp_t[12], U_exp_t[13], U_exp_t[14] = 0.761, 0.752, 0.745, 0.735, 0.728 # U_exp_t[15], U_exp_t[16], U_exp_t[17], U_exp_t[18], U_exp_t[19] = 0.719, 0.712, 0.706, 0.700, 0.694 # U_exp_t[20], U_exp_t[21], U_exp_t[22], U_exp_t[23], U_exp_t[24] = 0.681, 0.668, 0.660, 0.653, 0.641 # U_exp_t[25], U_exp_t[26], U_exp_t[27], U_exp_t[28], U_exp_t[29] = 0.634, 0.622, 0.610, 0.599, 0.586 # U_exp_t[30], U_exp_t[31], U_exp_t[32], U_exp_t[33], U_exp_t[34] = 0.570, 0.556, 0.540, 0.530, 0.521 # U_exp_t[35], U_exp_t[36] = 0.513, 0.500 # Current density i_exp_t = np . zeros ( 29 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.068 , 0.089 , 0.110 , 0.147 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.185 , 0.233 , 0.293 , 0.352 , 0.395 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.455 , 0.510 , 0.556 , 0.620 , 0.672 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.738 , 0.799 , 0.850 , 0.892 , 0.942 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 1.039 , 1.139 , 1.212 , 1.269 , 1.360 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ] = 1.432 , 1.525 , 1.604 , 1.683 # Voltage U_exp_t = np . zeros ( 29 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.882 , 0.865 , 0.850 , 0.834 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.823 , 0.811 , 0.794 , 0.781 , 0.772 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.761 , 0.752 , 0.745 , 0.735 , 0.728 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.719 , 0.712 , 0.706 , 0.700 , 0.694 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.681 , 0.668 , 0.660 , 0.653 , 0.641 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ] = 0.634 , 0.622 , 0.610 , 0.599 elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar # # Current density # i_exp_t = np.zeros(49) # i_exp_t[0], i_exp_t[1], i_exp_t[2], i_exp_t[3], i_exp_t[4] = 0.050, 0.057, 0.079, 0.106, 0.135 # i_exp_t[5], i_exp_t[6], i_exp_t[7], i_exp_t[8], i_exp_t[9] = 0.171, 0.206, 0.242, 0.302, 0.346 # i_exp_t[10], i_exp_t[11], i_exp_t[12], i_exp_t[13], i_exp_t[14] = 0.395, 0.434, 0.476, 0.531, 0.570 # i_exp_t[15], i_exp_t[16], i_exp_t[17], i_exp_t[18], i_exp_t[19] = 0.623, 0.681, 0.731, 0.779, 0.822 # i_exp_t[20], i_exp_t[21], i_exp_t[22], i_exp_t[23], i_exp_t[24] = 0.868, 0.930, 0.976, 1.031, 1.090 # i_exp_t[25], i_exp_t[26], i_exp_t[27], i_exp_t[28], i_exp_t[29] = 1.134, 1.205, 1.242, 1.312, 1.358 # i_exp_t[30], i_exp_t[31], i_exp_t[32], i_exp_t[33], i_exp_t[34] = 1.403, 1.453, 1.501, 1.569, 1.634, # i_exp_t[35], i_exp_t[36], i_exp_t[37], i_exp_t[38], i_exp_t[39] = 1.725, 1.786, 1.857, 1.924, 1.979 # i_exp_t[40], i_exp_t[41], i_exp_t[42], i_exp_t[43], i_exp_t[44] = 2.050, 2.125, 2.168, 2.214, 2.258 # i_exp_t[45], i_exp_t[46], i_exp_t[47], i_exp_t[48] = 2.308, 2.348, 2.413, 2.459 # # Voltage # U_exp_t = np.zeros(49) # U_exp_t[0], U_exp_t[1], U_exp_t[2], U_exp_t[3], U_exp_t[4] = 0.900, 0.889, 0.874, 0.860, 0.853 # U_exp_t[5], U_exp_t[6], U_exp_t[7], U_exp_t[8], U_exp_t[9] = 0.845, 0.837, 0.830, 0.817, 0.808 # U_exp_t[10], U_exp_t[11], U_exp_t[12], U_exp_t[13], U_exp_t[14] = 0.800, 0.792, 0.786, 0.779, 0.772 # U_exp_t[15], U_exp_t[16], U_exp_t[17], U_exp_t[18], U_exp_t[19] = 0.765, 0.759, 0.753, 0.747, 0.742, # U_exp_t[20], U_exp_t[21], U_exp_t[22], U_exp_t[23], U_exp_t[24] = 0.737, 0.730, 0.726, 0.720, 0.714, # U_exp_t[25], U_exp_t[26], U_exp_t[27], U_exp_t[28], U_exp_t[29] = 0.710, 0.702, 0.698, 0.690, 0.684 # U_exp_t[30], U_exp_t[31], U_exp_t[32], U_exp_t[33], U_exp_t[34] = 0.679, 0.673, 0.668, 0.659, 0.651 # U_exp_t[35], U_exp_t[36], U_exp_t[37], U_exp_t[38], U_exp_t[39] = 0.640, 0.631, 0.620, 0.608, 0.598 # U_exp_t[40], U_exp_t[41], U_exp_t[42], U_exp_t[43], U_exp_t[44] = 0.586, 0.573, 0.565, 0.557, 0.548 # U_exp_t[45], U_exp_t[46], U_exp_t[47], U_exp_t[48] = 0.537, 0.528, 0.513, 0.502 # Current density i_exp_t = np . zeros ( 28 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.057 , 0.079 , 0.106 , 0.135 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.171 , 0.206 , 0.242 , 0.302 , 0.346 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.395 , 0.434 , 0.476 , 0.531 , 0.570 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.623 , 0.681 , 0.731 , 0.779 , 0.822 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.868 , 0.930 , 0.976 , 1.031 , 1.090 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ] = 1.134 , 1.205 , 1.242 # Voltage U_exp_t = np . zeros ( 28 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.889 , 0.874 , 0.860 , 0.853 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.845 , 0.837 , 0.830 , 0.817 , 0.808 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.800 , 0.792 , 0.786 , 0.779 , 0.772 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.765 , 0.759 , 0.753 , 0.747 , 0.742 , U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.737 , 0.730 , 0.726 , 0.720 , 0.714 , U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ] = 0.710 , 0.702 , 0.698 elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar # # Current density # i_exp_t = np.zeros(54) # i_exp_t[0], i_exp_t[1], i_exp_t[2], i_exp_t[3], i_exp_t[4] = 0.056, 0.095, 0.120, 0.138, 0.160 # i_exp_t[5], i_exp_t[6], i_exp_t[7], i_exp_t[8], i_exp_t[9] = 0.183, 0.218, 0.248, 0.279, 0.315 # i_exp_t[10], i_exp_t[11], i_exp_t[12], i_exp_t[13], i_exp_t[14] = 0.364, 0.409, 0.477, 0.536, 0.594 # i_exp_t[15], i_exp_t[16], i_exp_t[17], i_exp_t[18], i_exp_t[19] = 0.641, 0.697, 0.748, 0.809, 0.866 # i_exp_t[20], i_exp_t[21], i_exp_t[22], i_exp_t[23], i_exp_t[24] = 0.944, 1.011, 1.074, 1.142, 1.193 # i_exp_t[25], i_exp_t[26], i_exp_t[27], i_exp_t[28], i_exp_t[29] = 1.252, 1.322, 1.381, 1.442, 1.496 # i_exp_t[30], i_exp_t[31], i_exp_t[32], i_exp_t[33], i_exp_t[34] = 1.545, 1.599, 1.675, 1.746, 1.827 # i_exp_t[35], i_exp_t[36], i_exp_t[37], i_exp_t[38], i_exp_t[39] = 1.868, 1.918, 2.004, 2.053, 2.114 # i_exp_t[40], i_exp_t[41], i_exp_t[42], i_exp_t[43], i_exp_t[44] = 2.156, 2.209, 2.257, 2.310, 2.356 # i_exp_t[45], i_exp_t[46], i_exp_t[47], i_exp_t[48], i_exp_t[49] = 2.403, 2.468, 2.513, 2.552, 2.600 # i_exp_t[50], i_exp_t[51], i_exp_t[52], i_exp_t[53] = 2.636, 2.679, 2.728, 2.794 # # Voltage # U_exp_t = np.zeros(54) # U_exp_t[0], U_exp_t[1], U_exp_t[2], U_exp_t[3], U_exp_t[4] = 0.894, 0.882, 0.873, 0.867, 0.861 # U_exp_t[5], U_exp_t[6], U_exp_t[7], U_exp_t[8], U_exp_t[9] = 0.854, 0.847, 0.840, 0.834, 0.827 # U_exp_t[10], U_exp_t[11], U_exp_t[12], U_exp_t[13], U_exp_t[14] = 0.819, 0.812, 0.801, 0.793, 0.786 # U_exp_t[15], U_exp_t[16], U_exp_t[17], U_exp_t[18], U_exp_t[19] = 0.781, 0.775, 0.771, 0.764, 0.759 # U_exp_t[20], U_exp_t[21], U_exp_t[22], U_exp_t[23], U_exp_t[24] = 0.751, 0.746, 0.740, 0.734, 0.728 # U_exp_t[25], U_exp_t[26], U_exp_t[27], U_exp_t[28], U_exp_t[29] = 0.723, 0.715, 0.709, 0.703, 0.698 # U_exp_t[30], U_exp_t[31], U_exp_t[32], U_exp_t[33], U_exp_t[34] = 0.692, 0.686, 0.678, 0.670, 0.660 # U_exp_t[35], U_exp_t[36], U_exp_t[37], U_exp_t[38], U_exp_t[39] = 0.654, 0.647, 0.635, 0.628, 0.618 # U_exp_t[40], U_exp_t[41], U_exp_t[42], U_exp_t[43], U_exp_t[44] = 0.613, 0.604, 0.596, 0.587, 0.580 # U_exp_t[45], U_exp_t[46], U_exp_t[47], U_exp_t[48], U_exp_t[49] = 0.570, 0.559, 0.551, 0.545, 0.536 # U_exp_t[50], U_exp_t[51], U_exp_t[52], U_exp_t[53] = 0.528, 0.520, 0.511, 0.497 # Current density i_exp_t = np . zeros ( 33 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.056 , 0.095 , 0.120 , 0.138 , 0.160 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.183 , 0.218 , 0.248 , 0.279 , 0.315 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.364 , 0.409 , 0.477 , 0.536 , 0.594 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.641 , 0.697 , 0.748 , 0.809 , 0.866 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.944 , 1.011 , 1.074 , 1.142 , 1.193 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.252 , 1.322 , 1.381 , 1.442 , 1.496 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ] = 1.545 , 1.599 , 1.675 # Voltage U_exp_t = np . zeros ( 33 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.894 , 0.882 , 0.873 , 0.867 , 0.861 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.854 , 0.847 , 0.840 , 0.834 , 0.827 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.819 , 0.812 , 0.801 , 0.793 , 0.786 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.781 , 0.775 , 0.771 , 0.764 , 0.759 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.751 , 0.746 , 0.740 , 0.734 , 0.728 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.723 , 0.715 , 0.709 , 0.703 , 0.698 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ] = 0.692 , 0.686 , 0.678 elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar # # Current density # i_exp_t = np.zeros(56) # i_exp_t[0], i_exp_t[1], i_exp_t[2], i_exp_t[3], i_exp_t[4] = 0.057, 0.070, 0.082, 0.101, 0.127 # i_exp_t[5], i_exp_t[6], i_exp_t[7], i_exp_t[8], i_exp_t[9] = 0.145, 0.168, 0.200, 0.234, 0.267 # i_exp_t[10], i_exp_t[11], i_exp_t[12], i_exp_t[13], i_exp_t[14] = 0.296, 0.331, 0.355, 0.388, 0.423 # i_exp_t[15], i_exp_t[16], i_exp_t[17], i_exp_t[18], i_exp_t[19] = 0.467, 0.527, 0.577, 0.632, 0.685 # i_exp_t[20], i_exp_t[21], i_exp_t[22], i_exp_t[23], i_exp_t[24] = 0.740, 0.789, 0.845, 0.898, 0.953 # i_exp_t[25], i_exp_t[26], i_exp_t[27], i_exp_t[28], i_exp_t[29] = 1.030, 1.124, 1.192, 1.254, 1.314 # i_exp_t[30], i_exp_t[31], i_exp_t[32], i_exp_t[33], i_exp_t[34] = 1.364, 1.434, 1.514, 1.587, 1.643 # i_exp_t[35], i_exp_t[36], i_exp_t[37], i_exp_t[38], i_exp_t[39] = 1.707, 1.769, 1.826, 1.892, 1.972 # i_exp_t[40], i_exp_t[41], i_exp_t[42], i_exp_t[43], i_exp_t[44] = 2.040, 2.124, 2.192, 2.265, 2.358 # i_exp_t[45], i_exp_t[46], i_exp_t[47], i_exp_t[48], i_exp_t[49] = 2.429, 2.508, 2.572, 2.624, 2.691 # i_exp_t[50], i_exp_t[51], i_exp_t[52], i_exp_t[53], i_exp_t[54] = 2.750, 2.822, 2.879, 2.918, 2.956 # i_exp_t[55] = 2.988 # # Voltage # U_exp_t = np.zeros(56) # U_exp_t[0], U_exp_t[1], U_exp_t[2], U_exp_t[3], U_exp_t[4] = 0.900, 0.892, 0.884, 0.875, 0.866 # U_exp_t[5], U_exp_t[6], U_exp_t[7], U_exp_t[8], U_exp_t[9] = 0.861, 0.856, 0.850, 0.845, 0.840 # U_exp_t[10], U_exp_t[11], U_exp_t[12], U_exp_t[13], U_exp_t[14] = 0.835, 0.829, 0.824, 0.820, 0.814 # U_exp_t[15], U_exp_t[16], U_exp_t[17], U_exp_t[18], U_exp_t[19] = 0.807, 0.800, 0.793, 0.787, 0.783 # U_exp_t[20], U_exp_t[21], U_exp_t[22], U_exp_t[23], U_exp_t[24] = 0.778, 0.775, 0.771, 0.767, 0.763 # U_exp_t[25], U_exp_t[26], U_exp_t[27], U_exp_t[28], U_exp_t[29] = 0.758, 0.750, 0.744, 0.738, 0.732 # U_exp_t[30], U_exp_t[31], U_exp_t[32], U_exp_t[33], U_exp_t[34] = 0.726, 0.719, 0.712, 0.703, 0.697 # U_exp_t[35], U_exp_t[36], U_exp_t[37], U_exp_t[38], U_exp_t[39] = 0.691, 0.685, 0.679, 0.672, 0.663 # U_exp_t[40], U_exp_t[41], U_exp_t[42], U_exp_t[43], U_exp_t[44] = 0.657, 0.648, 0.640, 0.632, 0.621 # U_exp_t[45], U_exp_t[46], U_exp_t[47], U_exp_t[48], U_exp_t[49] = 0.610, 0.600, 0.591, 0.584, 0.575 # U_exp_t[50], U_exp_t[51], U_exp_t[52], U_exp_t[53], U_exp_t[54] = 0.566, 0.555, 0.546, 0.537, 0.531 # U_exp_t[55] = 0.524 # Current density i_exp_t = np . zeros ( 33 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.057 , 0.070 , 0.082 , 0.101 , 0.127 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.145 , 0.168 , 0.200 , 0.234 , 0.267 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.296 , 0.331 , 0.355 , 0.388 , 0.423 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.467 , 0.527 , 0.577 , 0.632 , 0.685 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.740 , 0.789 , 0.845 , 0.898 , 0.953 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.030 , 1.124 , 1.192 , 1.254 , 1.314 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ] = 1.364 , 1.434 , 1.514 # Voltage U_exp_t = np . zeros ( 33 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.892 , 0.884 , 0.875 , 0.866 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.861 , 0.856 , 0.850 , 0.845 , 0.840 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.835 , 0.829 , 0.824 , 0.820 , 0.814 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.807 , 0.800 , 0.793 , 0.787 , 0.783 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.778 , 0.775 , 0.771 , 0.767 , 0.763 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.758 , 0.750 , 0.744 , 0.738 , 0.732 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ] = 0.726 , 0.719 , 0.712 elif type_fuel_cell == \"LF\" : # Current density i_exp_t = np . zeros ( 13 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.00 , 0.04 , 0.08 , 0.16 , 0.25 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.32 , 0.39 , 0.48 , 0.64 , 0.80 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ] = 1.00 , 1.20 , 1.40 # Voltage U_exp_t = np . zeros ( 13 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.98 , 0.87 , 0.84 , 0.80 , 0.77 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.74 , 0.72 , 0.69 , 0.65 , 0.60 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ] = 0.54 , 0.46 , 0.32 return i_exp_t * 1e4 , U_exp_t # Conversion in A.m-2 pola_exp_values_calibration ( type_fuel_cell ) This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used for calibrating the model and so are composed of a reduced number of points compare to the pola_exp_values function. These points are specifically chosen to be as few as possible while still providing a good representation of the polarisation curve. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. Returns: i_exp_t ( ndarray ) \u2013 Experimental values of the current density. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. Source code in calibration/experimental_values.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def pola_exp_values_calibration ( type_fuel_cell ): \"\"\" This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used for calibrating the model and so are composed of a reduced number of points compare to the pola_exp_values function. These points are specifically chosen to be as few as possible while still providing a good representation of the polarisation curve. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. Returns ------- i_exp_t : numpy.ndarray Experimental values of the current density. U_exp_t : numpy.ndarray Experimental values of the voltage. \"\"\" if type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar # # Current density # i_exp_cali_t = np.zeros(7) # i_exp_cali_t[0], i_exp_cali_t[1], i_exp_cali_t[2], i_exp_cali_t[3] = 0.050, 0.110, 0.293, 1.039 # i_exp_cali_t[4], i_exp_cali_t[5], i_exp_cali_t[6] = 1.683, 1.966, 2.246 # # Voltage # U_exp_cali_t = np.zeros(7) # U_exp_cali_t[0], U_exp_cali_t[1], U_exp_cali_t[2], U_exp_cali_t[3] = 0.900, 0.850, 0.794, 0.681 # U_exp_cali_t[4], U_exp_cali_t[5], U_exp_cali_t[6] = 0.599, 0.556, 0.500 # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.110 , 0.293 , 1.039 i_exp_cali_t [ 4 ] = 1.683 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.850 , 0.794 , 0.681 U_exp_cali_t [ 4 ] = 0.599 elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar # # Current density # i_exp_cali_t = np.zeros(8) # i_exp_cali_t[0], i_exp_cali_t[1], i_exp_cali_t[2], i_exp_cali_t[3] = 0.050, 0.106, 0.242, 0.681 # i_exp_cali_t[4], i_exp_cali_t[5], i_exp_cali_t[6], i_exp_cali_t[7] = 1.242, 1.501, 1.979, 2.459 # # Voltage # U_exp_cali_t = np.zeros(8) # U_exp_cali_t[0], U_exp_cali_t[1], U_exp_cali_t[2], U_exp_cali_t[3] = 0.900, 0.860, 0.830, 0.759 # U_exp_cali_t[4], U_exp_cali_t[5], U_exp_cali_t[6], U_exp_cali_t[7] = 0.698, 0.668, 0.598, 0.502 # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.106 , 0.242 , 0.681 i_exp_cali_t [ 4 ] = 1.242 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.860 , 0.830 , 0.759 U_exp_cali_t [ 4 ] = 0.698 elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar # # Current density # i_exp_cali_t = np.zeros(8) # i_exp_cali_t[0], i_exp_cali_t[1], i_exp_cali_t[2], i_exp_cali_t[3] = 0.056, 0.183, 0.364, 1.011 # i_exp_cali_t[4], i_exp_cali_t[5], i_exp_cali_t[6], i_exp_cali_t[7] = 1.675, 1.918, 2.356, 2.794 # # Voltage # U_exp_cali_t = np.zeros(8) # U_exp_cali_t[0], U_exp_cali_t[1], U_exp_cali_t[2], U_exp_cali_t[3] = 0.894, 0.854, 0.819, 0.746 # U_exp_cali_t[4], U_exp_cali_t[5], U_exp_cali_t[6], U_exp_cali_t[7] = 0.678, 0.647, 0.580, 0.497 # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.056 , 0.183 , 0.364 , 1.011 i_exp_cali_t [ 4 ] = 1.675 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.894 , 0.854 , 0.819 , 0.746 U_exp_cali_t [ 4 ] = 0.678 elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar # # Current density # i_exp_cali_t = np.zeros(10) # i_exp_cali_t[0], i_exp_cali_t[1], i_exp_cali_t[2], i_exp_cali_t[3] = 0.057, 0.127, 0.296, 0.527 # i_exp_cali_t[4], i_exp_cali_t[5], i_exp_cali_t[6], i_exp_cali_t[7] = 1.030, 1.514, 1.972, 2.358 # i_exp_cali_t[8], i_exp_cali_t[9] = 2.691, 2.988 # # Voltage # U_exp_cali_t = np.zeros(10) # U_exp_cali_t[0], U_exp_cali_t[1], U_exp_cali_t[2], U_exp_cali_t[3] = 0.900, 0.866, 0.835, 0.800 # U_exp_cali_t[4], U_exp_cali_t[5], U_exp_cali_t[6], U_exp_cali_t[7] = 0.758, 0.712, 0.663, 0.621 # U_exp_cali_t[8], U_exp_cali_t[9] = 0.575, 0.524 # Current density i_exp_cali_t = np . zeros ( 6 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.057 , 0.127 , 0.296 , 0.527 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ] = 1.030 , 1.514 # Voltage U_exp_cali_t = np . zeros ( 6 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.866 , 0.835 , 0.800 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ] = 0.758 , 0.712 return i_exp_cali_t * 1e4 , U_exp_cali_t # Conversion in A.m-2","title":"Experimental values"},{"location":"functions/calibration/experimental_values/#experimental-values","text":"This file is designated for executing the AlphaPEM software package.","title":"Experimental values"},{"location":"functions/calibration/experimental_values/#calibration.experimental_values.plot_experimental_polarisation_curve","text":"This function plots the experimental polarisation curve on the same graph as the model results. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. i_fc_t ( ndarray ) \u2013 Current density values. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. ax ( Axes ) \u2013 Axes object on which the experimental data is plotted. Source code in calibration/experimental_values.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def plot_experimental_polarisation_curve ( type_fuel_cell , i_fc_t , U_exp_t , ax ): \"\"\" This function plots the experimental polarisation curve on the same graph as the model results. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. i_fc_t : numpy.ndarray Current density values. U_exp_t : numpy.ndarray Experimental values of the voltage. ax : matplotlib.axes.Axes Axes object on which the experimental data is plotted. \"\"\" if type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"s\" , color = \"black\" , label = \"Exp. - P = 1.5 bar\" ) elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P = 2.0 bar\" ) elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"^\" , color = \"black\" , label = \"Exp. - P = 2.25 bar\" ) elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"p\" , color = \"black\" , label = \"Exp. - P = 2.5 bar\" ) elif type_fuel_cell == \"BX_1.0\" : # at 1.0 atm ax . scatter ( i_fc_t , U_exp_t , linewidths = 3.5 , marker = \"s\" , color = \"black\" , label = \"Exp. - P = 1.0 atm\" ) elif type_fuel_cell == \"BX_1.35\" : # at 1.35 atm ax . scatter ( i_fc_t , U_exp_t , linewidths = 3.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P = 1.35 atm\" ) elif type_fuel_cell == \"LF\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 3.5 , marker = \"s\" , color = \"black\" , label = \"Experimental data\" ) ax . legend ( loc = 'best' , markerscale = 0.5 )","title":"plot_experimental_polarisation_curve"},{"location":"functions/calibration/experimental_values/#calibration.experimental_values.pola_exp_values","text":"This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used to compare the model results with the experimental data. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. Returns: i_exp_t ( ndarray ) \u2013 Experimental values of the current density. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. Source code in calibration/experimental_values.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def pola_exp_values ( type_fuel_cell ): \"\"\" This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used to compare the model results with the experimental data. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. Returns ------- i_exp_t : numpy.ndarray Experimental values of the current density. U_exp_t : numpy.ndarray Experimental values of the voltage. \"\"\" if type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar # # Current density # i_exp_t = np.zeros(37) # i_exp_t[0], i_exp_t[1], i_exp_t[2], i_exp_t[3], i_exp_t[4] = 0.050, 0.068, 0.089, 0.110, 0.147 # i_exp_t[5], i_exp_t[6], i_exp_t[7], i_exp_t[8], i_exp_t[9] = 0.185, 0.233, 0.293, 0.352, 0.395 # i_exp_t[10], i_exp_t[11], i_exp_t[12], i_exp_t[13], i_exp_t[14] = 0.455, 0.510, 0.556, 0.620, 0.672 # i_exp_t[15], i_exp_t[16], i_exp_t[17], i_exp_t[18], i_exp_t[19] = 0.738, 0.799, 0.850, 0.892, 0.942 # i_exp_t[20], i_exp_t[21], i_exp_t[22], i_exp_t[23], i_exp_t[24] = 1.039, 1.139, 1.212, 1.269, 1.360 # i_exp_t[25], i_exp_t[26], i_exp_t[27], i_exp_t[28], i_exp_t[29] = 1.432, 1.525, 1.604, 1.683, 1.765 # i_exp_t[30], i_exp_t[31], i_exp_t[32], i_exp_t[33], i_exp_t[34] = 1.878, 1.966, 2.050, 2.109, 2.151 # i_exp_t[35], i_exp_t[36] = 2.188, 2.246 # # Voltage # U_exp_t = np.zeros(37) # U_exp_t[0], U_exp_t[1], U_exp_t[2], U_exp_t[3], U_exp_t[4] = 0.900, 0.882, 0.865, 0.850, 0.834 # U_exp_t[5], U_exp_t[6], U_exp_t[7], U_exp_t[8], U_exp_t[9] = 0.823, 0.811, 0.794, 0.781, 0.772 # U_exp_t[10], U_exp_t[11], U_exp_t[12], U_exp_t[13], U_exp_t[14] = 0.761, 0.752, 0.745, 0.735, 0.728 # U_exp_t[15], U_exp_t[16], U_exp_t[17], U_exp_t[18], U_exp_t[19] = 0.719, 0.712, 0.706, 0.700, 0.694 # U_exp_t[20], U_exp_t[21], U_exp_t[22], U_exp_t[23], U_exp_t[24] = 0.681, 0.668, 0.660, 0.653, 0.641 # U_exp_t[25], U_exp_t[26], U_exp_t[27], U_exp_t[28], U_exp_t[29] = 0.634, 0.622, 0.610, 0.599, 0.586 # U_exp_t[30], U_exp_t[31], U_exp_t[32], U_exp_t[33], U_exp_t[34] = 0.570, 0.556, 0.540, 0.530, 0.521 # U_exp_t[35], U_exp_t[36] = 0.513, 0.500 # Current density i_exp_t = np . zeros ( 29 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.068 , 0.089 , 0.110 , 0.147 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.185 , 0.233 , 0.293 , 0.352 , 0.395 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.455 , 0.510 , 0.556 , 0.620 , 0.672 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.738 , 0.799 , 0.850 , 0.892 , 0.942 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 1.039 , 1.139 , 1.212 , 1.269 , 1.360 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ] = 1.432 , 1.525 , 1.604 , 1.683 # Voltage U_exp_t = np . zeros ( 29 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.882 , 0.865 , 0.850 , 0.834 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.823 , 0.811 , 0.794 , 0.781 , 0.772 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.761 , 0.752 , 0.745 , 0.735 , 0.728 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.719 , 0.712 , 0.706 , 0.700 , 0.694 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.681 , 0.668 , 0.660 , 0.653 , 0.641 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ] = 0.634 , 0.622 , 0.610 , 0.599 elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar # # Current density # i_exp_t = np.zeros(49) # i_exp_t[0], i_exp_t[1], i_exp_t[2], i_exp_t[3], i_exp_t[4] = 0.050, 0.057, 0.079, 0.106, 0.135 # i_exp_t[5], i_exp_t[6], i_exp_t[7], i_exp_t[8], i_exp_t[9] = 0.171, 0.206, 0.242, 0.302, 0.346 # i_exp_t[10], i_exp_t[11], i_exp_t[12], i_exp_t[13], i_exp_t[14] = 0.395, 0.434, 0.476, 0.531, 0.570 # i_exp_t[15], i_exp_t[16], i_exp_t[17], i_exp_t[18], i_exp_t[19] = 0.623, 0.681, 0.731, 0.779, 0.822 # i_exp_t[20], i_exp_t[21], i_exp_t[22], i_exp_t[23], i_exp_t[24] = 0.868, 0.930, 0.976, 1.031, 1.090 # i_exp_t[25], i_exp_t[26], i_exp_t[27], i_exp_t[28], i_exp_t[29] = 1.134, 1.205, 1.242, 1.312, 1.358 # i_exp_t[30], i_exp_t[31], i_exp_t[32], i_exp_t[33], i_exp_t[34] = 1.403, 1.453, 1.501, 1.569, 1.634, # i_exp_t[35], i_exp_t[36], i_exp_t[37], i_exp_t[38], i_exp_t[39] = 1.725, 1.786, 1.857, 1.924, 1.979 # i_exp_t[40], i_exp_t[41], i_exp_t[42], i_exp_t[43], i_exp_t[44] = 2.050, 2.125, 2.168, 2.214, 2.258 # i_exp_t[45], i_exp_t[46], i_exp_t[47], i_exp_t[48] = 2.308, 2.348, 2.413, 2.459 # # Voltage # U_exp_t = np.zeros(49) # U_exp_t[0], U_exp_t[1], U_exp_t[2], U_exp_t[3], U_exp_t[4] = 0.900, 0.889, 0.874, 0.860, 0.853 # U_exp_t[5], U_exp_t[6], U_exp_t[7], U_exp_t[8], U_exp_t[9] = 0.845, 0.837, 0.830, 0.817, 0.808 # U_exp_t[10], U_exp_t[11], U_exp_t[12], U_exp_t[13], U_exp_t[14] = 0.800, 0.792, 0.786, 0.779, 0.772 # U_exp_t[15], U_exp_t[16], U_exp_t[17], U_exp_t[18], U_exp_t[19] = 0.765, 0.759, 0.753, 0.747, 0.742, # U_exp_t[20], U_exp_t[21], U_exp_t[22], U_exp_t[23], U_exp_t[24] = 0.737, 0.730, 0.726, 0.720, 0.714, # U_exp_t[25], U_exp_t[26], U_exp_t[27], U_exp_t[28], U_exp_t[29] = 0.710, 0.702, 0.698, 0.690, 0.684 # U_exp_t[30], U_exp_t[31], U_exp_t[32], U_exp_t[33], U_exp_t[34] = 0.679, 0.673, 0.668, 0.659, 0.651 # U_exp_t[35], U_exp_t[36], U_exp_t[37], U_exp_t[38], U_exp_t[39] = 0.640, 0.631, 0.620, 0.608, 0.598 # U_exp_t[40], U_exp_t[41], U_exp_t[42], U_exp_t[43], U_exp_t[44] = 0.586, 0.573, 0.565, 0.557, 0.548 # U_exp_t[45], U_exp_t[46], U_exp_t[47], U_exp_t[48] = 0.537, 0.528, 0.513, 0.502 # Current density i_exp_t = np . zeros ( 28 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.057 , 0.079 , 0.106 , 0.135 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.171 , 0.206 , 0.242 , 0.302 , 0.346 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.395 , 0.434 , 0.476 , 0.531 , 0.570 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.623 , 0.681 , 0.731 , 0.779 , 0.822 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.868 , 0.930 , 0.976 , 1.031 , 1.090 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ] = 1.134 , 1.205 , 1.242 # Voltage U_exp_t = np . zeros ( 28 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.889 , 0.874 , 0.860 , 0.853 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.845 , 0.837 , 0.830 , 0.817 , 0.808 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.800 , 0.792 , 0.786 , 0.779 , 0.772 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.765 , 0.759 , 0.753 , 0.747 , 0.742 , U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.737 , 0.730 , 0.726 , 0.720 , 0.714 , U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ] = 0.710 , 0.702 , 0.698 elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar # # Current density # i_exp_t = np.zeros(54) # i_exp_t[0], i_exp_t[1], i_exp_t[2], i_exp_t[3], i_exp_t[4] = 0.056, 0.095, 0.120, 0.138, 0.160 # i_exp_t[5], i_exp_t[6], i_exp_t[7], i_exp_t[8], i_exp_t[9] = 0.183, 0.218, 0.248, 0.279, 0.315 # i_exp_t[10], i_exp_t[11], i_exp_t[12], i_exp_t[13], i_exp_t[14] = 0.364, 0.409, 0.477, 0.536, 0.594 # i_exp_t[15], i_exp_t[16], i_exp_t[17], i_exp_t[18], i_exp_t[19] = 0.641, 0.697, 0.748, 0.809, 0.866 # i_exp_t[20], i_exp_t[21], i_exp_t[22], i_exp_t[23], i_exp_t[24] = 0.944, 1.011, 1.074, 1.142, 1.193 # i_exp_t[25], i_exp_t[26], i_exp_t[27], i_exp_t[28], i_exp_t[29] = 1.252, 1.322, 1.381, 1.442, 1.496 # i_exp_t[30], i_exp_t[31], i_exp_t[32], i_exp_t[33], i_exp_t[34] = 1.545, 1.599, 1.675, 1.746, 1.827 # i_exp_t[35], i_exp_t[36], i_exp_t[37], i_exp_t[38], i_exp_t[39] = 1.868, 1.918, 2.004, 2.053, 2.114 # i_exp_t[40], i_exp_t[41], i_exp_t[42], i_exp_t[43], i_exp_t[44] = 2.156, 2.209, 2.257, 2.310, 2.356 # i_exp_t[45], i_exp_t[46], i_exp_t[47], i_exp_t[48], i_exp_t[49] = 2.403, 2.468, 2.513, 2.552, 2.600 # i_exp_t[50], i_exp_t[51], i_exp_t[52], i_exp_t[53] = 2.636, 2.679, 2.728, 2.794 # # Voltage # U_exp_t = np.zeros(54) # U_exp_t[0], U_exp_t[1], U_exp_t[2], U_exp_t[3], U_exp_t[4] = 0.894, 0.882, 0.873, 0.867, 0.861 # U_exp_t[5], U_exp_t[6], U_exp_t[7], U_exp_t[8], U_exp_t[9] = 0.854, 0.847, 0.840, 0.834, 0.827 # U_exp_t[10], U_exp_t[11], U_exp_t[12], U_exp_t[13], U_exp_t[14] = 0.819, 0.812, 0.801, 0.793, 0.786 # U_exp_t[15], U_exp_t[16], U_exp_t[17], U_exp_t[18], U_exp_t[19] = 0.781, 0.775, 0.771, 0.764, 0.759 # U_exp_t[20], U_exp_t[21], U_exp_t[22], U_exp_t[23], U_exp_t[24] = 0.751, 0.746, 0.740, 0.734, 0.728 # U_exp_t[25], U_exp_t[26], U_exp_t[27], U_exp_t[28], U_exp_t[29] = 0.723, 0.715, 0.709, 0.703, 0.698 # U_exp_t[30], U_exp_t[31], U_exp_t[32], U_exp_t[33], U_exp_t[34] = 0.692, 0.686, 0.678, 0.670, 0.660 # U_exp_t[35], U_exp_t[36], U_exp_t[37], U_exp_t[38], U_exp_t[39] = 0.654, 0.647, 0.635, 0.628, 0.618 # U_exp_t[40], U_exp_t[41], U_exp_t[42], U_exp_t[43], U_exp_t[44] = 0.613, 0.604, 0.596, 0.587, 0.580 # U_exp_t[45], U_exp_t[46], U_exp_t[47], U_exp_t[48], U_exp_t[49] = 0.570, 0.559, 0.551, 0.545, 0.536 # U_exp_t[50], U_exp_t[51], U_exp_t[52], U_exp_t[53] = 0.528, 0.520, 0.511, 0.497 # Current density i_exp_t = np . zeros ( 33 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.056 , 0.095 , 0.120 , 0.138 , 0.160 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.183 , 0.218 , 0.248 , 0.279 , 0.315 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.364 , 0.409 , 0.477 , 0.536 , 0.594 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.641 , 0.697 , 0.748 , 0.809 , 0.866 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.944 , 1.011 , 1.074 , 1.142 , 1.193 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.252 , 1.322 , 1.381 , 1.442 , 1.496 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ] = 1.545 , 1.599 , 1.675 # Voltage U_exp_t = np . zeros ( 33 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.894 , 0.882 , 0.873 , 0.867 , 0.861 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.854 , 0.847 , 0.840 , 0.834 , 0.827 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.819 , 0.812 , 0.801 , 0.793 , 0.786 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.781 , 0.775 , 0.771 , 0.764 , 0.759 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.751 , 0.746 , 0.740 , 0.734 , 0.728 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.723 , 0.715 , 0.709 , 0.703 , 0.698 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ] = 0.692 , 0.686 , 0.678 elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar # # Current density # i_exp_t = np.zeros(56) # i_exp_t[0], i_exp_t[1], i_exp_t[2], i_exp_t[3], i_exp_t[4] = 0.057, 0.070, 0.082, 0.101, 0.127 # i_exp_t[5], i_exp_t[6], i_exp_t[7], i_exp_t[8], i_exp_t[9] = 0.145, 0.168, 0.200, 0.234, 0.267 # i_exp_t[10], i_exp_t[11], i_exp_t[12], i_exp_t[13], i_exp_t[14] = 0.296, 0.331, 0.355, 0.388, 0.423 # i_exp_t[15], i_exp_t[16], i_exp_t[17], i_exp_t[18], i_exp_t[19] = 0.467, 0.527, 0.577, 0.632, 0.685 # i_exp_t[20], i_exp_t[21], i_exp_t[22], i_exp_t[23], i_exp_t[24] = 0.740, 0.789, 0.845, 0.898, 0.953 # i_exp_t[25], i_exp_t[26], i_exp_t[27], i_exp_t[28], i_exp_t[29] = 1.030, 1.124, 1.192, 1.254, 1.314 # i_exp_t[30], i_exp_t[31], i_exp_t[32], i_exp_t[33], i_exp_t[34] = 1.364, 1.434, 1.514, 1.587, 1.643 # i_exp_t[35], i_exp_t[36], i_exp_t[37], i_exp_t[38], i_exp_t[39] = 1.707, 1.769, 1.826, 1.892, 1.972 # i_exp_t[40], i_exp_t[41], i_exp_t[42], i_exp_t[43], i_exp_t[44] = 2.040, 2.124, 2.192, 2.265, 2.358 # i_exp_t[45], i_exp_t[46], i_exp_t[47], i_exp_t[48], i_exp_t[49] = 2.429, 2.508, 2.572, 2.624, 2.691 # i_exp_t[50], i_exp_t[51], i_exp_t[52], i_exp_t[53], i_exp_t[54] = 2.750, 2.822, 2.879, 2.918, 2.956 # i_exp_t[55] = 2.988 # # Voltage # U_exp_t = np.zeros(56) # U_exp_t[0], U_exp_t[1], U_exp_t[2], U_exp_t[3], U_exp_t[4] = 0.900, 0.892, 0.884, 0.875, 0.866 # U_exp_t[5], U_exp_t[6], U_exp_t[7], U_exp_t[8], U_exp_t[9] = 0.861, 0.856, 0.850, 0.845, 0.840 # U_exp_t[10], U_exp_t[11], U_exp_t[12], U_exp_t[13], U_exp_t[14] = 0.835, 0.829, 0.824, 0.820, 0.814 # U_exp_t[15], U_exp_t[16], U_exp_t[17], U_exp_t[18], U_exp_t[19] = 0.807, 0.800, 0.793, 0.787, 0.783 # U_exp_t[20], U_exp_t[21], U_exp_t[22], U_exp_t[23], U_exp_t[24] = 0.778, 0.775, 0.771, 0.767, 0.763 # U_exp_t[25], U_exp_t[26], U_exp_t[27], U_exp_t[28], U_exp_t[29] = 0.758, 0.750, 0.744, 0.738, 0.732 # U_exp_t[30], U_exp_t[31], U_exp_t[32], U_exp_t[33], U_exp_t[34] = 0.726, 0.719, 0.712, 0.703, 0.697 # U_exp_t[35], U_exp_t[36], U_exp_t[37], U_exp_t[38], U_exp_t[39] = 0.691, 0.685, 0.679, 0.672, 0.663 # U_exp_t[40], U_exp_t[41], U_exp_t[42], U_exp_t[43], U_exp_t[44] = 0.657, 0.648, 0.640, 0.632, 0.621 # U_exp_t[45], U_exp_t[46], U_exp_t[47], U_exp_t[48], U_exp_t[49] = 0.610, 0.600, 0.591, 0.584, 0.575 # U_exp_t[50], U_exp_t[51], U_exp_t[52], U_exp_t[53], U_exp_t[54] = 0.566, 0.555, 0.546, 0.537, 0.531 # U_exp_t[55] = 0.524 # Current density i_exp_t = np . zeros ( 33 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.057 , 0.070 , 0.082 , 0.101 , 0.127 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.145 , 0.168 , 0.200 , 0.234 , 0.267 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.296 , 0.331 , 0.355 , 0.388 , 0.423 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.467 , 0.527 , 0.577 , 0.632 , 0.685 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.740 , 0.789 , 0.845 , 0.898 , 0.953 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.030 , 1.124 , 1.192 , 1.254 , 1.314 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ] = 1.364 , 1.434 , 1.514 # Voltage U_exp_t = np . zeros ( 33 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.892 , 0.884 , 0.875 , 0.866 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.861 , 0.856 , 0.850 , 0.845 , 0.840 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.835 , 0.829 , 0.824 , 0.820 , 0.814 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.807 , 0.800 , 0.793 , 0.787 , 0.783 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.778 , 0.775 , 0.771 , 0.767 , 0.763 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.758 , 0.750 , 0.744 , 0.738 , 0.732 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ] = 0.726 , 0.719 , 0.712 elif type_fuel_cell == \"LF\" : # Current density i_exp_t = np . zeros ( 13 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.00 , 0.04 , 0.08 , 0.16 , 0.25 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.32 , 0.39 , 0.48 , 0.64 , 0.80 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ] = 1.00 , 1.20 , 1.40 # Voltage U_exp_t = np . zeros ( 13 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.98 , 0.87 , 0.84 , 0.80 , 0.77 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.74 , 0.72 , 0.69 , 0.65 , 0.60 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ] = 0.54 , 0.46 , 0.32 return i_exp_t * 1e4 , U_exp_t # Conversion in A.m-2","title":"pola_exp_values"},{"location":"functions/calibration/experimental_values/#calibration.experimental_values.pola_exp_values_calibration","text":"This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used for calibrating the model and so are composed of a reduced number of points compare to the pola_exp_values function. These points are specifically chosen to be as few as possible while still providing a good representation of the polarisation curve. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. Returns: i_exp_t ( ndarray ) \u2013 Experimental values of the current density. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. Source code in calibration/experimental_values.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def pola_exp_values_calibration ( type_fuel_cell ): \"\"\" This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used for calibrating the model and so are composed of a reduced number of points compare to the pola_exp_values function. These points are specifically chosen to be as few as possible while still providing a good representation of the polarisation curve. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. Returns ------- i_exp_t : numpy.ndarray Experimental values of the current density. U_exp_t : numpy.ndarray Experimental values of the voltage. \"\"\" if type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar # # Current density # i_exp_cali_t = np.zeros(7) # i_exp_cali_t[0], i_exp_cali_t[1], i_exp_cali_t[2], i_exp_cali_t[3] = 0.050, 0.110, 0.293, 1.039 # i_exp_cali_t[4], i_exp_cali_t[5], i_exp_cali_t[6] = 1.683, 1.966, 2.246 # # Voltage # U_exp_cali_t = np.zeros(7) # U_exp_cali_t[0], U_exp_cali_t[1], U_exp_cali_t[2], U_exp_cali_t[3] = 0.900, 0.850, 0.794, 0.681 # U_exp_cali_t[4], U_exp_cali_t[5], U_exp_cali_t[6] = 0.599, 0.556, 0.500 # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.110 , 0.293 , 1.039 i_exp_cali_t [ 4 ] = 1.683 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.850 , 0.794 , 0.681 U_exp_cali_t [ 4 ] = 0.599 elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar # # Current density # i_exp_cali_t = np.zeros(8) # i_exp_cali_t[0], i_exp_cali_t[1], i_exp_cali_t[2], i_exp_cali_t[3] = 0.050, 0.106, 0.242, 0.681 # i_exp_cali_t[4], i_exp_cali_t[5], i_exp_cali_t[6], i_exp_cali_t[7] = 1.242, 1.501, 1.979, 2.459 # # Voltage # U_exp_cali_t = np.zeros(8) # U_exp_cali_t[0], U_exp_cali_t[1], U_exp_cali_t[2], U_exp_cali_t[3] = 0.900, 0.860, 0.830, 0.759 # U_exp_cali_t[4], U_exp_cali_t[5], U_exp_cali_t[6], U_exp_cali_t[7] = 0.698, 0.668, 0.598, 0.502 # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.106 , 0.242 , 0.681 i_exp_cali_t [ 4 ] = 1.242 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.860 , 0.830 , 0.759 U_exp_cali_t [ 4 ] = 0.698 elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar # # Current density # i_exp_cali_t = np.zeros(8) # i_exp_cali_t[0], i_exp_cali_t[1], i_exp_cali_t[2], i_exp_cali_t[3] = 0.056, 0.183, 0.364, 1.011 # i_exp_cali_t[4], i_exp_cali_t[5], i_exp_cali_t[6], i_exp_cali_t[7] = 1.675, 1.918, 2.356, 2.794 # # Voltage # U_exp_cali_t = np.zeros(8) # U_exp_cali_t[0], U_exp_cali_t[1], U_exp_cali_t[2], U_exp_cali_t[3] = 0.894, 0.854, 0.819, 0.746 # U_exp_cali_t[4], U_exp_cali_t[5], U_exp_cali_t[6], U_exp_cali_t[7] = 0.678, 0.647, 0.580, 0.497 # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.056 , 0.183 , 0.364 , 1.011 i_exp_cali_t [ 4 ] = 1.675 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.894 , 0.854 , 0.819 , 0.746 U_exp_cali_t [ 4 ] = 0.678 elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar # # Current density # i_exp_cali_t = np.zeros(10) # i_exp_cali_t[0], i_exp_cali_t[1], i_exp_cali_t[2], i_exp_cali_t[3] = 0.057, 0.127, 0.296, 0.527 # i_exp_cali_t[4], i_exp_cali_t[5], i_exp_cali_t[6], i_exp_cali_t[7] = 1.030, 1.514, 1.972, 2.358 # i_exp_cali_t[8], i_exp_cali_t[9] = 2.691, 2.988 # # Voltage # U_exp_cali_t = np.zeros(10) # U_exp_cali_t[0], U_exp_cali_t[1], U_exp_cali_t[2], U_exp_cali_t[3] = 0.900, 0.866, 0.835, 0.800 # U_exp_cali_t[4], U_exp_cali_t[5], U_exp_cali_t[6], U_exp_cali_t[7] = 0.758, 0.712, 0.663, 0.621 # U_exp_cali_t[8], U_exp_cali_t[9] = 0.575, 0.524 # Current density i_exp_cali_t = np . zeros ( 6 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.057 , 0.127 , 0.296 , 0.527 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ] = 1.030 , 1.514 # Voltage U_exp_cali_t = np . zeros ( 6 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.866 , 0.835 , 0.800 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ] = 0.758 , 0.712 return i_exp_cali_t * 1e4 , U_exp_cali_t # Conversion in A.m-2","title":"pola_exp_values_calibration"},{"location":"functions/calibration/parameter_calibration/","text":"Parameter Calibration This file is designated for executing the undetermined parameters' calibration. Most of it should remain unaltered for regular program usage. Users can select here the fuel cell to calibrate, along with the undetermined parameters to modify, and the parameters for the Genetic Algorithm. The experimental fuel cell data are stored in the files calibration_modules.py and experimental_values.py. The parameters employed for the Genetic Algorithm here have proven to be effective, though not necessarily optimal.","title":"Parameter calibration"},{"location":"functions/calibration/parameter_calibration/#parameter-calibration","text":"This file is designated for executing the undetermined parameters' calibration. Most of it should remain unaltered for regular program usage. Users can select here the fuel cell to calibrate, along with the undetermined parameters to modify, and the parameters for the Genetic Algorithm. The experimental fuel cell data are stored in the files calibration_modules.py and experimental_values.py. The parameters employed for the Genetic Algorithm here have proven to be effective, though not necessarily optimal.","title":"Parameter Calibration"},{"location":"functions/configuration/current_densities/","text":"Current densities This file contains the functions that generate the current densities for the simulation. EIS_current ( t , parameters ) Represents a current density used for creating an EIS curve and Bode diagrams. The current density is first equilibrated at i_EIS A.m-2 from 0 to t0_EIS seconds using a step increase. Then, a sinusoidal perturbation is added to the current density. This perturbation has an amplitude of (ratio_EIS * i_EIS) A.m-2 and a frequency of f[n_inf] Hz. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarization current density at time t. Source code in configuration/current_densities.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def EIS_current ( t , parameters ): \"\"\" Represents a current density used for creating an EIS curve and Bode diagrams. The current density is first equilibrated at i_EIS A.m-2 from 0 to t0_EIS seconds using a step increase. Then, a sinusoidal perturbation is added to the current density. This perturbation has an amplitude of (ratio_EIS * i_EIS) A.m-2 and a frequency of f[n_inf] Hz. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarization current density at time t. \"\"\" # Initialisation i_EIS , ratio_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ] # (A/m\u00b2, ). i_EIS is the current for which a # ratio_EIS perturbation is added. t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = parameters [ 't_EIS' ] # It is the initial # EIS time after stack equilibrium, a list of time parameters which gives the beginning of each frequency # change, the final time, a list of time parameters which gives the estimated time for reaching equilibrium # at each frequency, and a list of time parameters which gives the estimated time for measuring the voltage # response at each frequency. f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = parameters [ 'f_EIS' ] # It is the power of the initial # frequency: f_min_EIS = 10**f_power_min_EIS, the power of the final frequency, the number of frequencies # tested and the number of points calculated per specific period. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested, # ranged logarithmically. # Current density for the EIS curve if t < t0_EIS : delta_t_ini = 3 * 60 # s. It is the required time for elevating i_fc from 0 to i_EIS without starving the cell. i_fc = i_EIS * ( 1.0 + math . tanh ( 4 * ( t - 2 * ( delta_t_ini / 2 )) / delta_t_ini )) / 2 else : n_inf = np . where ( t_new_start_EIS <= t )[ 0 ][ - 1 ] # It is the number of frequency changes which has been made so far. i_disruption = ( ratio_EIS * i_EIS ) * math . cos ( 2 * math . pi * f [ n_inf ] * t ) i_fc = i_EIS + i_disruption return i_fc polarization_current ( t , parameters ) This function represents a current density used for creating a polarization curve. For the first delta_t_ini_step seconds, the current density is set to 0 A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases by the value of delta_i_pola every delta_t, following C\u221e step current increments, until it reaches i_max_pola. Each increment lasts for delta_t_load_pola seconds. After each increment, there is a pause of delta_t_break_pola seconds to allow the stack to reach equilibrium. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarization current density at time t. Source code in configuration/current_densities.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def polarization_current ( t , parameters ): \"\"\" This function represents a current density used for creating a polarization curve. For the first delta_t_ini_step seconds, the current density is set to 0 A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases by the value of delta_i_pola every delta_t, following C\u221e step current increments, until it reaches i_max_pola. Each increment lasts for delta_t_load_pola seconds. After each increment, there is a pause of delta_t_break_pola seconds to allow the stack to reach equilibrium. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarization current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] # (s). # Loading time for one step current of the polarisation current density function. delta_t_load_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_load_pola' ] # (s). # Breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_break_pola' ] # (s). # Current density step for the polarisation current density function. delta_i_pola = parameters [ 'pola_current_parameters' ][ 'delta_i_pola' ] # (A.m-2). # Maximum current density for the polarization curve. i_max_pola = parameters [ 'pola_current_parameters' ][ 'i_max_pola' ] # (A.m-2). # Calculation of the time parameters # Time of one step. delta_t = delta_t_load_pola + delta_t_break_pola # (s). # Duration of this polarization curve. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola + 1 ) * delta_t # (s). # Number of loads made for this polarization curve. n = int ( tf / delta_t ) # Current density for the polarization curve i_fc = 0 # A.m-2. Initialisation of the current density. for i in range ( n ): i_fc += delta_i_pola * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola - i * delta_t - ( delta_t_load_pola / 2 )) / ( delta_t_load_pola / 2 ))) / 2 return i_fc polarization_current_for_calibration ( t , parameters ) This function represents a current density used for creating a polarisation curve dedicated to the calibration of a specific fuel cell. The principle is similar to the polarization_current function, but it uses experimental values for the current density load. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarisation current density at time t. Source code in configuration/current_densities.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def polarization_current_for_calibration ( t , parameters ): \"\"\"This function represents a current density used for creating a polarisation curve dedicated to the calibration of a specific fuel cell. The principle is similar to the polarization_current function, but it uses experimental values for the current density load. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarisation current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # Loading time for one step current of the polarisation current density function. delta_t_load_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # Breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). type_fuel_cell = parameters [ 'type_fuel_cell' ] # The fuel cell for which the calibration is performed. i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell ) # (A.m-2, V). It is the experimental # current density and voltage values for the calibration. # Calculation of the time parameters # Time of one step. delta_t = delta_t_load_pola_cali + delta_t_break_pola_cali # (s). # Current density for the polarization curve used for calibration i_fc = 0 # A.m-2. Initialisation of the current density. for e in range ( len ( i_exp_cali_t )): if e == 0 : i_fc += i_exp_cali_t [ 0 ] * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola_cali - ( delta_t_load_pola_cali / 2 )) / ( delta_t_load_pola_cali / 2 ))) / 2 else : delta_i_exp_cali = ( i_exp_cali_t [ e ] - i_exp_cali_t [ e - 1 ]) # (A.m-2). It is the difference between the # current density at the current step and the previous one. i_fc += delta_i_exp_cali * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola_cali - e * delta_t - ( delta_t_load_pola_cali / 2 )) / ( delta_t_load_pola_cali / 2 ))) / 2 return i_fc step_current ( t , parameters ) This function represents a step current density experiment. For the first delta_t_ini_step seconds, the current density is set to 0 A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases from 0 to i_step A.m-2 in a step change over delta_t_load seconds. Finally, the current density remains at i_step A.m-2. This is a C\u221e function, which is advantageous for enhancing the overall stability of the results. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The step current density at time t. Source code in configuration/current_densities.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def step_current ( t , parameters ): \"\"\" This function represents a step current density experiment. For the first delta_t_ini_step seconds, the current density is set to 0 A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases from 0 to i_step A.m-2 in a step change over delta_t_load seconds. Finally, the current density remains at i_step A.m-2. This is a C\u221e function, which is advantageous for enhancing the overall stability of the results. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The step current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_step = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] # (s). # Loading time for the step current density function, from 0 to i_step. delta_t_load_step = parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] # (s). # Current density for the step current density function. i_step = parameters [ 'step_current_parameters' ][ 'i_step' ] # (A.m-2). # Step current density return i_step * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_step - ( delta_t_load_step / 2 )) / ( delta_t_load_step / 2 ))) / 2","title":"Current densities"},{"location":"functions/configuration/current_densities/#current-densities","text":"This file contains the functions that generate the current densities for the simulation.","title":"Current densities"},{"location":"functions/configuration/current_densities/#configuration.current_densities.EIS_current","text":"Represents a current density used for creating an EIS curve and Bode diagrams. The current density is first equilibrated at i_EIS A.m-2 from 0 to t0_EIS seconds using a step increase. Then, a sinusoidal perturbation is added to the current density. This perturbation has an amplitude of (ratio_EIS * i_EIS) A.m-2 and a frequency of f[n_inf] Hz. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarization current density at time t. Source code in configuration/current_densities.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def EIS_current ( t , parameters ): \"\"\" Represents a current density used for creating an EIS curve and Bode diagrams. The current density is first equilibrated at i_EIS A.m-2 from 0 to t0_EIS seconds using a step increase. Then, a sinusoidal perturbation is added to the current density. This perturbation has an amplitude of (ratio_EIS * i_EIS) A.m-2 and a frequency of f[n_inf] Hz. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarization current density at time t. \"\"\" # Initialisation i_EIS , ratio_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ] # (A/m\u00b2, ). i_EIS is the current for which a # ratio_EIS perturbation is added. t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = parameters [ 't_EIS' ] # It is the initial # EIS time after stack equilibrium, a list of time parameters which gives the beginning of each frequency # change, the final time, a list of time parameters which gives the estimated time for reaching equilibrium # at each frequency, and a list of time parameters which gives the estimated time for measuring the voltage # response at each frequency. f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = parameters [ 'f_EIS' ] # It is the power of the initial # frequency: f_min_EIS = 10**f_power_min_EIS, the power of the final frequency, the number of frequencies # tested and the number of points calculated per specific period. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested, # ranged logarithmically. # Current density for the EIS curve if t < t0_EIS : delta_t_ini = 3 * 60 # s. It is the required time for elevating i_fc from 0 to i_EIS without starving the cell. i_fc = i_EIS * ( 1.0 + math . tanh ( 4 * ( t - 2 * ( delta_t_ini / 2 )) / delta_t_ini )) / 2 else : n_inf = np . where ( t_new_start_EIS <= t )[ 0 ][ - 1 ] # It is the number of frequency changes which has been made so far. i_disruption = ( ratio_EIS * i_EIS ) * math . cos ( 2 * math . pi * f [ n_inf ] * t ) i_fc = i_EIS + i_disruption return i_fc","title":"EIS_current"},{"location":"functions/configuration/current_densities/#configuration.current_densities.polarization_current","text":"This function represents a current density used for creating a polarization curve. For the first delta_t_ini_step seconds, the current density is set to 0 A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases by the value of delta_i_pola every delta_t, following C\u221e step current increments, until it reaches i_max_pola. Each increment lasts for delta_t_load_pola seconds. After each increment, there is a pause of delta_t_break_pola seconds to allow the stack to reach equilibrium. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarization current density at time t. Source code in configuration/current_densities.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def polarization_current ( t , parameters ): \"\"\" This function represents a current density used for creating a polarization curve. For the first delta_t_ini_step seconds, the current density is set to 0 A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases by the value of delta_i_pola every delta_t, following C\u221e step current increments, until it reaches i_max_pola. Each increment lasts for delta_t_load_pola seconds. After each increment, there is a pause of delta_t_break_pola seconds to allow the stack to reach equilibrium. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarization current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] # (s). # Loading time for one step current of the polarisation current density function. delta_t_load_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_load_pola' ] # (s). # Breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_break_pola' ] # (s). # Current density step for the polarisation current density function. delta_i_pola = parameters [ 'pola_current_parameters' ][ 'delta_i_pola' ] # (A.m-2). # Maximum current density for the polarization curve. i_max_pola = parameters [ 'pola_current_parameters' ][ 'i_max_pola' ] # (A.m-2). # Calculation of the time parameters # Time of one step. delta_t = delta_t_load_pola + delta_t_break_pola # (s). # Duration of this polarization curve. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola + 1 ) * delta_t # (s). # Number of loads made for this polarization curve. n = int ( tf / delta_t ) # Current density for the polarization curve i_fc = 0 # A.m-2. Initialisation of the current density. for i in range ( n ): i_fc += delta_i_pola * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola - i * delta_t - ( delta_t_load_pola / 2 )) / ( delta_t_load_pola / 2 ))) / 2 return i_fc","title":"polarization_current"},{"location":"functions/configuration/current_densities/#configuration.current_densities.polarization_current_for_calibration","text":"This function represents a current density used for creating a polarisation curve dedicated to the calibration of a specific fuel cell. The principle is similar to the polarization_current function, but it uses experimental values for the current density load. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarisation current density at time t. Source code in configuration/current_densities.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def polarization_current_for_calibration ( t , parameters ): \"\"\"This function represents a current density used for creating a polarisation curve dedicated to the calibration of a specific fuel cell. The principle is similar to the polarization_current function, but it uses experimental values for the current density load. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarisation current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # Loading time for one step current of the polarisation current density function. delta_t_load_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # Breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). type_fuel_cell = parameters [ 'type_fuel_cell' ] # The fuel cell for which the calibration is performed. i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell ) # (A.m-2, V). It is the experimental # current density and voltage values for the calibration. # Calculation of the time parameters # Time of one step. delta_t = delta_t_load_pola_cali + delta_t_break_pola_cali # (s). # Current density for the polarization curve used for calibration i_fc = 0 # A.m-2. Initialisation of the current density. for e in range ( len ( i_exp_cali_t )): if e == 0 : i_fc += i_exp_cali_t [ 0 ] * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola_cali - ( delta_t_load_pola_cali / 2 )) / ( delta_t_load_pola_cali / 2 ))) / 2 else : delta_i_exp_cali = ( i_exp_cali_t [ e ] - i_exp_cali_t [ e - 1 ]) # (A.m-2). It is the difference between the # current density at the current step and the previous one. i_fc += delta_i_exp_cali * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola_cali - e * delta_t - ( delta_t_load_pola_cali / 2 )) / ( delta_t_load_pola_cali / 2 ))) / 2 return i_fc","title":"polarization_current_for_calibration"},{"location":"functions/configuration/current_densities/#configuration.current_densities.step_current","text":"This function represents a step current density experiment. For the first delta_t_ini_step seconds, the current density is set to 0 A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases from 0 to i_step A.m-2 in a step change over delta_t_load seconds. Finally, the current density remains at i_step A.m-2. This is a C\u221e function, which is advantageous for enhancing the overall stability of the results. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The step current density at time t. Source code in configuration/current_densities.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def step_current ( t , parameters ): \"\"\" This function represents a step current density experiment. For the first delta_t_ini_step seconds, the current density is set to 0 A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases from 0 to i_step A.m-2 in a step change over delta_t_load seconds. Finally, the current density remains at i_step A.m-2. This is a C\u221e function, which is advantageous for enhancing the overall stability of the results. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The step current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_step = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] # (s). # Loading time for the step current density function, from 0 to i_step. delta_t_load_step = parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] # (s). # Current density for the step current density function. i_step = parameters [ 'step_current_parameters' ][ 'i_step' ] # (A.m-2). # Step current density return i_step * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_step - ( delta_t_load_step / 2 )) / ( delta_t_load_step / 2 ))) / 2","title":"step_current"},{"location":"functions/configuration/settings/","text":"Settings This file is used to set the parameters of the fuel cell system. computing_parameters ( step_current_parameters , Hgdl , Hacl ) This function is used to set the computing parameters of the fuel cell system. Parameters: step_current_parameters ( dict ) \u2013 Parameters for the step current density function. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in meters. Hacl ( float ) \u2013 Thickness of the anode catalyst layer in meters. Returns: n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. t_purge ( tuple ) \u2013 Time parameters for purging the system. It is a tuple containing the purge time 'purge_time' in seconds, and the time between two purges 'delta_purge' in seconds. delta_t_dyn_step : float step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. Source code in configuration/settings.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def computing_parameters ( step_current_parameters , Hgdl , Hacl ): \"\"\"This function is used to set the computing parameters of the fuel cell system. Parameters ---------- step_current_parameters : dict Parameters for the step current density function. Hgdl : float Thickness of the gas diffusion layer in meters. Hacl : float Thickness of the anode catalyst layer in meters. Returns ------- n_gdl : int Number of model nodes placed inside each GDL. t_purge : tuple Time parameters for purging the system. It is a tuple containing the purge time 'purge_time' in seconds, and the time between two purges 'delta_purge' in seconds. delta_t_dyn_step : float step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. \"\"\" n_gdl = max ( 1 , int ( Hgdl / Hacl / 4 )) # It is the number of model points placed inside each GDL. # A good compromise is int(Hgdl/Hacl/4). t_purge = 0.6 , 15 # (s, s). It is the time parameters for purging the system. delta_t_dyn_step = 5 * 60 # (s). Time for dynamic display of the step current density function. step_current_parameters [ 'delta_t_dyn_step' ] = delta_t_dyn_step # Update the step current parameters. return n_gdl , t_purge , step_current_parameters current_density_parameters ( type_current = None ) This function is used to set the parameters of the current density which is imposed to the fuel cell system. Parameters: type_current ( str , default: None ) \u2013 Type of current density which is imposed to the fuel cell system. It can be \"step\", \"polarization\" or \"EIS\". Returns: step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters ( dict ) \u2013 Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS ( float ) \u2013 Parameters for the EIS curve. It is the current for which a perturbation is added. ratio_EIS ( float ) \u2013 Parameters for the EIS curve. It is the ratio of the current for which a perturbation is added. f_EIS ( tuple ) \u2013 Frequency parameters for the EIS_current density function. It is a tuple containing the power of the initial frequency 'f_power_min_EIS' (f_min_EIS = 10**f_power_min_EIS), the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS', and the number of points calculated per specific period 'nb_points_EIS'. t_EIS ( tuple ) \u2013 Time parameters for the EIS_current density function. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS' in seconds, a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS' in seconds, the final time 'tf_EIS' in seconds, a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS' in seconds, and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS' in seconds. current_density ( function, optional. ) \u2013 Current density function. Source code in configuration/settings.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def current_density_parameters ( type_current = None ): \"\"\"This function is used to set the parameters of the current density which is imposed to the fuel cell system. Parameters ---------- type_current : str Type of current density which is imposed to the fuel cell system. It can be \"step\", \"polarization\" or \"EIS\". Returns ------- step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS : float Parameters for the EIS curve. It is the current for which a perturbation is added. ratio_EIS : float Parameters for the EIS curve. It is the ratio of the current for which a perturbation is added. f_EIS : tuple Frequency parameters for the EIS_current density function. It is a tuple containing the power of the initial frequency 'f_power_min_EIS' (f_min_EIS = 10**f_power_min_EIS), the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS', and the number of points calculated per specific period 'nb_points_EIS'. t_EIS : tuple Time parameters for the EIS_current density function. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS' in seconds, a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS' in seconds, the final time 'tf_EIS' in seconds, a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS' in seconds, and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS' in seconds. current_density : function, optional. Current density function. \"\"\" # Setting the parameters of the step current density function delta_t_ini_step = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_step = 30 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 15 * 60 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 1.5e4 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } # Setting the parameters of the polarization current density function delta_t_ini_pola = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola } # Setting the parameters of the polarization for calibration current density function delta_t_ini_pola_cali = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 10 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } # Setting the parameters of the EIS current density function i_EIS , ratio_EIS = 1.0e4 , 5 / 100 # (A/m\u00b2, ). Parameters for the EIS curve. f_EIS = - 3 , 5 , 90 , 50 # Frequency parameters for the EIS_current density function. t_EIS = EIS_parameters ( f_EIS ) # Time parameters for the EIS_current density function. # Setting the current density function: if type_current == \"step\" : current_density = step_current elif type_current == \"polarization\" : current_density = polarization_current elif type_current == \"polarization_for_cali\" : current_density = polarization_current_for_calibration elif type_current == \"EIS\" : current_density = EIS_current elif type_current is None : current_density = None # No current density function is set. else : raise ValueError ( 'You have to specify a type_current which is on the list.' ) return ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) operating_inputs_function ( pola_current_parameters , type_fuel_cell ) This function is used to set the operating inputs of the fuel cell system. Parameters: pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density function. type_fuel_cell ( str ) \u2013 Type of fuel cell system. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. Source code in configuration/settings.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def operating_inputs_function ( pola_current_parameters , type_fuel_cell ): \"\"\"This function is used to set the operating inputs of the fuel cell system. Parameters ---------- pola_current_parameters : dict Parameters for the polarization current density function. type_fuel_cell : str Type of fuel cell system. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. \"\"\" if type_fuel_cell == \"manual_setup\" : # Setup which are not stored in \"stored_operating_inputs\". T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 3.0e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell is None : T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , i_max_pola = None , None , None , None , None , None , None , None else : # Stored setup in \"stored_operating_inputs\". T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , i_max_pola = stored_operating_inputs ( type_fuel_cell ) pola_current_parameters [ 'i_max_pola' ] = i_max_pola # Update the maximum current density for the polarization curve. return T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , pola_current_parameters physical_parameters ( type_fuel_cell ) This function is used to set the physical parameters of the fuel cell system. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell system. It can be \"EH-31_1.5\", \"EH-31_2.0\", \"EH-31_2.25\", \"EH-31_2.5\", \"LF\", or \"manual_setup\". Returns: Hacl ( float ) \u2013 Thickness of the anode catalyst layer in meters. Hacl ( float ) \u2013 Thickness of the cathode catalyst layer in meters. epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the catalyst layer. Hmem ( float ) \u2013 Thickness of the membrane in meters. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in meters. epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_c ( float ) \u2013 Compression ratio of the GDL. Hmpl ( float ) \u2013 Thickness of the microporous layer in meters. epsilon_mpl ( float ) \u2013 Porosity of the microporous layer. Hagc ( float ) \u2013 Thickness of the anode gas channel in meters. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in meters. Wagc ( float ) \u2013 Width of the anode gas channel in meters. Wcgc ( float ) \u2013 Width of the cathode gas channel in meters. Lgc ( float ) \u2013 Length of the gas channel in meters. Aact ( float ) \u2013 Active area of the catalyst layer in meters squared. e ( float ) \u2013 Capillary exponent. i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode in A.m-2. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c ( float ) \u2013 Overpotential correction exponent. a_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of slim function. b_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the intercept of slim function. a_switch ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl ( float ) \u2013 Volumetric double layer capacitance in F.m-3. Source code in configuration/settings.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def physical_parameters ( type_fuel_cell ): \"\"\"This function is used to set the physical parameters of the fuel cell system. Parameters ---------- type_fuel_cell : str Type of fuel cell system. It can be \"EH-31_1.5\", \"EH-31_2.0\", \"EH-31_2.25\", \"EH-31_2.5\", \"LF\", or \"manual_setup\". Returns ------- Hacl : float Thickness of the anode catalyst layer in meters. Hacl : float Thickness of the cathode catalyst layer in meters. epsilon_mc : float Volume fraction of ionomer in the catalyst layer. Hmem : float Thickness of the membrane in meters. Hgdl : float Thickness of the gas diffusion layer in meters. epsilon_gdl : float Anode/cathode GDL porosity. epsilon_c : float Compression ratio of the GDL. Hmpl : float Thickness of the microporous layer in meters. epsilon_mpl : float Porosity of the microporous layer. Hagc : float Thickness of the anode gas channel in meters. Hcgc : float Thickness of the cathode gas channel in meters. Wagc : float Width of the anode gas channel in meters. Wcgc : float Width of the cathode gas channel in meters. Lgc : float Length of the gas channel in meters. Aact : float Active area of the catalyst layer in meters squared. e : float Capillary exponent. i0_c_ref : float Reference exchange current density at the cathode in A.m-2. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c : float Overpotential correction exponent. a_slim : float One of the limit liquid saturation coefficients: the slop of slim function. b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function. a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl : float Volumetric double layer capacitance in F.m-3. \"\"\" if type_fuel_cell == \"manual_setup\" : # Setup which are not stored in \"stored_physical_parameters\". # Fuel cell physical parameters: \ud835\udf14 (which are not controllable by the system) # Catalyst layer Aact = 8.5e-3 # m\u00b2. It is the active area of the catalyst layer. Hacl = 8.089e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_mc = 0.3949198274842546 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 2e-5 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 2e-4 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.7011156494971454 # It is the anode/cathode GDL porosity. epsilon_c = 0.27052745219052654 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 3e-5 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. # Gas channel Hagc = 5e-4 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Wagc = 4.5e-4 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 9.67 # m. It is the length of the gas channel. # Interaction parameters between water and PEMFC structure e = 5.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 2.787917581303015 # A.m-2. It is the reference exchange current density at the cathode. kappa_co = 29.793535549174077 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.6136446641573106 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.0555312850726664 , 0.10514269908118055 , 0.6365424991141914 # It is the limit # liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. else : # Stored setup in \"stored_physical_parameters\". ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , Aact , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl ) = stored_physical_parameters ( type_fuel_cell ) return ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , Aact , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl )","title":"Settings"},{"location":"functions/configuration/settings/#settings","text":"This file is used to set the parameters of the fuel cell system.","title":"Settings"},{"location":"functions/configuration/settings/#configuration.settings.computing_parameters","text":"This function is used to set the computing parameters of the fuel cell system. Parameters: step_current_parameters ( dict ) \u2013 Parameters for the step current density function. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in meters. Hacl ( float ) \u2013 Thickness of the anode catalyst layer in meters. Returns: n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. t_purge ( tuple ) \u2013 Time parameters for purging the system. It is a tuple containing the purge time 'purge_time' in seconds, and the time between two purges 'delta_purge' in seconds. delta_t_dyn_step : float step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. Source code in configuration/settings.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def computing_parameters ( step_current_parameters , Hgdl , Hacl ): \"\"\"This function is used to set the computing parameters of the fuel cell system. Parameters ---------- step_current_parameters : dict Parameters for the step current density function. Hgdl : float Thickness of the gas diffusion layer in meters. Hacl : float Thickness of the anode catalyst layer in meters. Returns ------- n_gdl : int Number of model nodes placed inside each GDL. t_purge : tuple Time parameters for purging the system. It is a tuple containing the purge time 'purge_time' in seconds, and the time between two purges 'delta_purge' in seconds. delta_t_dyn_step : float step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. \"\"\" n_gdl = max ( 1 , int ( Hgdl / Hacl / 4 )) # It is the number of model points placed inside each GDL. # A good compromise is int(Hgdl/Hacl/4). t_purge = 0.6 , 15 # (s, s). It is the time parameters for purging the system. delta_t_dyn_step = 5 * 60 # (s). Time for dynamic display of the step current density function. step_current_parameters [ 'delta_t_dyn_step' ] = delta_t_dyn_step # Update the step current parameters. return n_gdl , t_purge , step_current_parameters","title":"computing_parameters"},{"location":"functions/configuration/settings/#configuration.settings.current_density_parameters","text":"This function is used to set the parameters of the current density which is imposed to the fuel cell system. Parameters: type_current ( str , default: None ) \u2013 Type of current density which is imposed to the fuel cell system. It can be \"step\", \"polarization\" or \"EIS\". Returns: step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters ( dict ) \u2013 Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS ( float ) \u2013 Parameters for the EIS curve. It is the current for which a perturbation is added. ratio_EIS ( float ) \u2013 Parameters for the EIS curve. It is the ratio of the current for which a perturbation is added. f_EIS ( tuple ) \u2013 Frequency parameters for the EIS_current density function. It is a tuple containing the power of the initial frequency 'f_power_min_EIS' (f_min_EIS = 10**f_power_min_EIS), the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS', and the number of points calculated per specific period 'nb_points_EIS'. t_EIS ( tuple ) \u2013 Time parameters for the EIS_current density function. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS' in seconds, a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS' in seconds, the final time 'tf_EIS' in seconds, a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS' in seconds, and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS' in seconds. current_density ( function, optional. ) \u2013 Current density function. Source code in configuration/settings.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def current_density_parameters ( type_current = None ): \"\"\"This function is used to set the parameters of the current density which is imposed to the fuel cell system. Parameters ---------- type_current : str Type of current density which is imposed to the fuel cell system. It can be \"step\", \"polarization\" or \"EIS\". Returns ------- step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS : float Parameters for the EIS curve. It is the current for which a perturbation is added. ratio_EIS : float Parameters for the EIS curve. It is the ratio of the current for which a perturbation is added. f_EIS : tuple Frequency parameters for the EIS_current density function. It is a tuple containing the power of the initial frequency 'f_power_min_EIS' (f_min_EIS = 10**f_power_min_EIS), the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS', and the number of points calculated per specific period 'nb_points_EIS'. t_EIS : tuple Time parameters for the EIS_current density function. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS' in seconds, a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS' in seconds, the final time 'tf_EIS' in seconds, a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS' in seconds, and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS' in seconds. current_density : function, optional. Current density function. \"\"\" # Setting the parameters of the step current density function delta_t_ini_step = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_step = 30 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 15 * 60 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 1.5e4 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } # Setting the parameters of the polarization current density function delta_t_ini_pola = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola } # Setting the parameters of the polarization for calibration current density function delta_t_ini_pola_cali = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 10 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } # Setting the parameters of the EIS current density function i_EIS , ratio_EIS = 1.0e4 , 5 / 100 # (A/m\u00b2, ). Parameters for the EIS curve. f_EIS = - 3 , 5 , 90 , 50 # Frequency parameters for the EIS_current density function. t_EIS = EIS_parameters ( f_EIS ) # Time parameters for the EIS_current density function. # Setting the current density function: if type_current == \"step\" : current_density = step_current elif type_current == \"polarization\" : current_density = polarization_current elif type_current == \"polarization_for_cali\" : current_density = polarization_current_for_calibration elif type_current == \"EIS\" : current_density = EIS_current elif type_current is None : current_density = None # No current density function is set. else : raise ValueError ( 'You have to specify a type_current which is on the list.' ) return ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density )","title":"current_density_parameters"},{"location":"functions/configuration/settings/#configuration.settings.operating_inputs_function","text":"This function is used to set the operating inputs of the fuel cell system. Parameters: pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density function. type_fuel_cell ( str ) \u2013 Type of fuel cell system. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. Source code in configuration/settings.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def operating_inputs_function ( pola_current_parameters , type_fuel_cell ): \"\"\"This function is used to set the operating inputs of the fuel cell system. Parameters ---------- pola_current_parameters : dict Parameters for the polarization current density function. type_fuel_cell : str Type of fuel cell system. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. \"\"\" if type_fuel_cell == \"manual_setup\" : # Setup which are not stored in \"stored_operating_inputs\". T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 3.0e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell is None : T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , i_max_pola = None , None , None , None , None , None , None , None else : # Stored setup in \"stored_operating_inputs\". T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , i_max_pola = stored_operating_inputs ( type_fuel_cell ) pola_current_parameters [ 'i_max_pola' ] = i_max_pola # Update the maximum current density for the polarization curve. return T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , pola_current_parameters","title":"operating_inputs_function"},{"location":"functions/configuration/settings/#configuration.settings.physical_parameters","text":"This function is used to set the physical parameters of the fuel cell system. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell system. It can be \"EH-31_1.5\", \"EH-31_2.0\", \"EH-31_2.25\", \"EH-31_2.5\", \"LF\", or \"manual_setup\". Returns: Hacl ( float ) \u2013 Thickness of the anode catalyst layer in meters. Hacl ( float ) \u2013 Thickness of the cathode catalyst layer in meters. epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the catalyst layer. Hmem ( float ) \u2013 Thickness of the membrane in meters. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in meters. epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_c ( float ) \u2013 Compression ratio of the GDL. Hmpl ( float ) \u2013 Thickness of the microporous layer in meters. epsilon_mpl ( float ) \u2013 Porosity of the microporous layer. Hagc ( float ) \u2013 Thickness of the anode gas channel in meters. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in meters. Wagc ( float ) \u2013 Width of the anode gas channel in meters. Wcgc ( float ) \u2013 Width of the cathode gas channel in meters. Lgc ( float ) \u2013 Length of the gas channel in meters. Aact ( float ) \u2013 Active area of the catalyst layer in meters squared. e ( float ) \u2013 Capillary exponent. i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode in A.m-2. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c ( float ) \u2013 Overpotential correction exponent. a_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of slim function. b_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the intercept of slim function. a_switch ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl ( float ) \u2013 Volumetric double layer capacitance in F.m-3. Source code in configuration/settings.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def physical_parameters ( type_fuel_cell ): \"\"\"This function is used to set the physical parameters of the fuel cell system. Parameters ---------- type_fuel_cell : str Type of fuel cell system. It can be \"EH-31_1.5\", \"EH-31_2.0\", \"EH-31_2.25\", \"EH-31_2.5\", \"LF\", or \"manual_setup\". Returns ------- Hacl : float Thickness of the anode catalyst layer in meters. Hacl : float Thickness of the cathode catalyst layer in meters. epsilon_mc : float Volume fraction of ionomer in the catalyst layer. Hmem : float Thickness of the membrane in meters. Hgdl : float Thickness of the gas diffusion layer in meters. epsilon_gdl : float Anode/cathode GDL porosity. epsilon_c : float Compression ratio of the GDL. Hmpl : float Thickness of the microporous layer in meters. epsilon_mpl : float Porosity of the microporous layer. Hagc : float Thickness of the anode gas channel in meters. Hcgc : float Thickness of the cathode gas channel in meters. Wagc : float Width of the anode gas channel in meters. Wcgc : float Width of the cathode gas channel in meters. Lgc : float Length of the gas channel in meters. Aact : float Active area of the catalyst layer in meters squared. e : float Capillary exponent. i0_c_ref : float Reference exchange current density at the cathode in A.m-2. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c : float Overpotential correction exponent. a_slim : float One of the limit liquid saturation coefficients: the slop of slim function. b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function. a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl : float Volumetric double layer capacitance in F.m-3. \"\"\" if type_fuel_cell == \"manual_setup\" : # Setup which are not stored in \"stored_physical_parameters\". # Fuel cell physical parameters: \ud835\udf14 (which are not controllable by the system) # Catalyst layer Aact = 8.5e-3 # m\u00b2. It is the active area of the catalyst layer. Hacl = 8.089e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_mc = 0.3949198274842546 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 2e-5 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 2e-4 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.7011156494971454 # It is the anode/cathode GDL porosity. epsilon_c = 0.27052745219052654 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 3e-5 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. # Gas channel Hagc = 5e-4 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Wagc = 4.5e-4 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 9.67 # m. It is the length of the gas channel. # Interaction parameters between water and PEMFC structure e = 5.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 2.787917581303015 # A.m-2. It is the reference exchange current density at the cathode. kappa_co = 29.793535549174077 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.6136446641573106 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.0555312850726664 , 0.10514269908118055 , 0.6365424991141914 # It is the limit # liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. else : # Stored setup in \"stored_physical_parameters\". ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , Aact , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl ) = stored_physical_parameters ( type_fuel_cell ) return ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , Aact , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl )","title":"physical_parameters"},{"location":"functions/model/AlphaPEM/","text":"AlphaPEM Objectives: Create an open-source software package to simulate the PEM fuel cell for control system applications. Authors: Rapha\u00ebl GASS, Zhongliang LI, Rachid OUTBIB, Samir JEMEI and Daniel HISSEL. This file describes the AlphaPEM class, which is a PEM fuel cell system simulator. The model is one-dimensional, dynamic, biphasic, and isothermal. It has been published in the following articles: - Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a - Gass et al 2024 SSRN http://dx.doi.org/10.2139/ssrn.4812343 AlphaPEM Source code in model/AlphaPEM.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 class AlphaPEM : def __init__ ( self , operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ): \"\"\"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values : list, optional Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval : list, optional Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. \"\"\" # Initialize the operating inputs and parameters dictionaries. self . operating_inputs = operating_inputs self . current_parameters = current_parameters self . accessible_physical_parameters = accessible_physical_parameters self . undetermined_physical_parameters = undetermined_physical_parameters self . computing_parameters = computing_parameters self . parameters = { ** self . current_parameters , ** self . accessible_physical_parameters , ** self . undetermined_physical_parameters , ** self . computing_parameters } if self . operating_inputs [ 'Pa_des' ] < Pext or self . operating_inputs [ 'Pc_des' ] < Pext : raise ValueError ( 'The desired pressure is too low. It cannot be lower than the pressure outside the stack.' ) # Initialize the variables' dictionary. self . solver_variable_names = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_acl' , 'C_v_ccl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_acl' , 's_ccl' , 's_cmpl' , 's_cgdl' , 'lambda_acl' , 'lambda_mem' , 'lambda_ccl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_H2_acl' , 'C_O2_ccl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_acl' , 'T_mem' , 'T_ccl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' , 'eta_c' , 'Pasm' , 'Paem' , 'Pcsm' , 'Pcem' , 'Phi_asm' , 'Phi_aem' , 'Phi_csm' , 'Phi_cem' , 'Wcp' , 'Wa_inj' , 'Wc_inj' , 'Abp_a' , 'Abp_c' ] self . solver_variable_names_extension () # Several points are considered in each GDL and must be inserted into # the solver_variable_names. self . all_variable_names = self . solver_variable_names + [ 't' , 'Ucell' , 'S_abs_acl' , 'S_abs_ccl' ] + \\ [ 'J_lambda_acl_mem' , 'J_lambda_mem_ccl' , 'Pagc' , 'Pcgc' , 'Phi_a_des' , 'Phi_c_des' ] self . variables = { key : [] for key in self . all_variable_names } # Initialize the control_variables dictionary. self . control_variables = { 't_control_Phi' : 0 , 'Phi_a_des' : self . operating_inputs [ 'Phi_a_des' ], 'Phi_c_des' : self . operating_inputs [ 'Phi_c_des' ]} # Create the dynamic evolution. # Create time intervals if time_interval is not None : # Initial time interval may be given to the Simulator. self . time_interval = time_interval else : # If not, it is automatically generated. self . time_interval = self . _create_time_interval () # Create the initial variable values if initial_variable_values is not None : # Initial variable values may be given to the Simulator. self . initial_variable_values = initial_variable_values else : # If not, they are generated considering an equilibrium at the operating inputs without current. self . initial_variable_values = self . _create_initial_variable_values () # Resolution of the system of differential equations. event_negative . terminal = True # Integration is stopped if one of the crucial variables becomes negative. self . sol = solve_ivp ( dydt , self . time_interval , self . initial_variable_values , method = 'BDF' , rtol = 1e-5 , atol = 1e-8 , events = event_negative , args = ( self . operating_inputs , self . parameters , self . solver_variable_names , self . control_variables )) # Recover the variable values calculated by the solver into the dictionary. self . _recovery () # Calculate the cell voltage after computing the internal states of the cell. self . variables [ \"Ucell\" ] . extend ( calculate_cell_voltage ( self . variables , self . operating_inputs , self . parameters )) def solver_variable_names_extension ( self ): \"\"\"Several points are considered in each GDL and must be inserted into the solver_variable_names. \"\"\" new_points_location = [ 'C_v_agdl' , 'C_v_cgdl' , 's_agdl' , 's_cgdl' , 'C_H2_agdl' , 'C_O2_cgdl' , 'T_agdl' , 'T_cgdl' ] for variable in new_points_location : index = self . solver_variable_names . index ( variable ) # Delete the previous points self . solver_variable_names . pop ( index ) # Increase the number of points self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'n_gdl' ] + 1 )] def _create_time_interval ( self ): \"\"\"Calculate the time intervals for numerical resolution, according to the current chosen, if it is not provided. Returns ------- list Time interval for numerical resolution. It is used when initial_variable_values == None. \"\"\" # Extraction of the parameters step_current_parameters = self . parameters [ 'step_current_parameters' ] pola_current_parameters = self . parameters [ 'pola_current_parameters' ] pola_current_for_cali_parameters = self . parameters [ 'pola_current_for_cali_parameters' ] type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] # Recovery of the good time interval if type_current == \"step\" : t0_interval = 0 # s. tf_interval = step_current_parameters [ 'delta_t_ini_step' ] + step_current_parameters [ 'delta_t_load_step' ] + \\ step_current_parameters [ 'delta_t_break_step' ] # s. elif type_current == \"polarization\" : # Extraction of the parameters delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] # (s). delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] # (s). delta_i_pola = pola_current_parameters [ 'delta_i_pola' ] # (A.m-2). i_max_pola = pola_current_parameters [ 'i_max_pola' ] # (A.m-2). # Calculation t0_interval = 0 # s. tf_interval = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * ( delta_t_load_pola + delta_t_break_pola ) elif type_current == \"polarization_for_cali\" : # Extraction of the parameters delta_t_ini_pola_cali = pola_current_for_cali_parameters [ 'delta_t_ini_pola_cali' ] # (s). delta_t_load_pola_cali = pola_current_for_cali_parameters [ 'delta_t_load_pola_cali' ] # (s). delta_t_break_pola_cali = pola_current_for_cali_parameters [ 'delta_t_break_pola_cali' ] # (s). i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell ) # (A.m-2, V). # Calculation delta_t_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. t0_interval = 0 tf_interval = delta_t_ini_pola_cali + len ( i_exp_cali_t ) * delta_t_cali # s. else : # EIS time_interval is calculated in the main.py file. raise ValueError ( \"Please enter a recognized type_current option for calculating the time interval.\" ) # To be reviewed self . control_variables [ 't_control_Phi' ] = t0_interval return [ t0_interval , tf_interval ] def _create_initial_variable_values ( self ): \"\"\"Create the initial values of the solver variables if it is not provided. It is generated considering an equilibrium at the operating inputs without current. Returns ------- list Initial values of the solver variables. It is used when initial_variable_values == None. \"\"\" # Extraction of the operating inputs and parameters current_density , T_des = self . operating_inputs [ 'current_density' ], self . operating_inputs [ 'T_des' ] Pa_des , Pc_des = self . operating_inputs [ 'Pa_des' ], self . operating_inputs [ 'Pc_des' ] Phi_a_des , Phi_c_des = self . operating_inputs [ 'Phi_a_des' ], self . operating_inputs [ 'Phi_c_des' ] Hmem , kappa_co , i0_c_ref , = self . parameters [ 'Hmem' ], self . parameters [ 'kappa_co' ], self . parameters [ 'i0_c_ref' ] kappa_c = self . parameters [ 'kappa_c' ] a_slim , b_slim , a_switch = self . parameters [ 'a_slim' ], self . parameters [ 'b_slim' ], self . parameters [ 'a_switch' ] n_gdl = self . parameters [ 'n_gdl' ] # Mean value of the operating inputs Phi_des_moy = ( Phi_a_des + Phi_c_des ) / 2 P_des_moy = ( Pa_des + Pc_des ) / 2 # Initial fuel cell states # Intermediate values T_ini = T_des # K. It is the initial temperature in the fuel cell. Psat_ini = 101325 * 10 ** ( - 2.1794 + 0.02953 * ( T_ini - 273.15 ) - 9.1837e-5 * ( T_ini - 273.15 ) ** 2 + 1.4454e-7 * ( T_ini - 273.15 ) ** 3 ) slim = a_slim * ( Pc_des / 1e5 ) + b_slim s_switch = a_switch * slim # Initial fuel cell states C_v_ini = Phi_des_moy * Psat_ini / ( R * T_ini ) # mol.m-3. It is the initial vapor concentration. C_H2_ini = ( P_des_moy - Phi_des_moy * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial H2 concentration # in the fuel cell. C_O2_ini = yO2_ext * ( P_des_moy - Phi_des_moy * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial O2 # concentration in the fuel cell. C_N2_ini = ( 1 - yO2_ext ) * ( P_des_moy - Phi_des_moy * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial N2 # concentration in the fuel cell. s_ini = 0 # It is the initial liquid water saturation in the fuel cell. lambda_mem_ini = lambda_eq ( C_v_ini , s_ini , T_ini ) # It is the initial water content in the fuel cell. i_fc_ini = current_density ( self . time_interval [ 0 ], self . parameters ) i_n_ini = 2 * F * R * T_ini / Hmem * C_H2_ini * k_H2 ( lambda_mem_ini , T_ini , kappa_co ) + \\ 4 * F * R * T_ini / Hmem * C_O2_ini * k_O2 ( lambda_mem_ini , T_ini , kappa_co ) f_drop_ini = 0.5 * ( 1.0 - math . tanh (( 4 * s_ini - 2 * slim - 2 * s_switch ) / ( slim - s_switch ))) eta_c_ini = 1 / f_drop_ini * R * T_ini / ( alpha_c * F ) * \\ math . log (( i_fc_ini + i_n_ini ) / i0_c_ref * ( C_O2ref / C_O2_ini ) ** kappa_c ) # It is the initial # cathode overpotential in the fuel cell. # Initial auxiliary system state Pasm_ini , Paem_ini = Pa_des , P_des_moy # Pa. It is the supply/exhaust manifold pressure at the anode side. Pcsm_ini , Pcem_ini = Pc_des , P_des_moy # Pa. It is the supply/exhaust manifold pressure at the cathode side. Phi_asm_ini , Phi_aem_ini = Phi_a_des , Phi_des_moy # It is the supply/exhaust manifold relative humidity # at the anode side. Phi_csm_ini , Phi_cem_ini = Phi_c_des , Phi_des_moy # It is the supply/exhaust manifold relative humidity # at the cathode side. Wcp_ini = 0 # kg.s-1. It is the flow rate of the air compressor. Wa_inj_ini = 0 # kg.s-1. It is the flow rate of the air compressor at the anode side. Wc_inj_ini = 0 # kg.s-1. It is the flow rate of the air compressor at the cathode side. Abp_a_ini = 0 # It is the throttle area of the back pressure valve at the anode. Abp_c_ini = 0 # It is the throttle area of the back pressure valve at the cathode. # Main variable initialization C_v_agc , C_v_agdl , C_v_ampl , C_v_acl , C_v_ccl , C_v_cmpl , C_v_cgdl , C_v_cgc = [ C_v_ini ] * 8 s_agdl , s_ampl , s_acl , s_ccl , s_cmpl , s_cgdl = [ s_ini ] * 6 s_boundary = 0 # Dirichlet boundary condition lambda_acl , lambda_mem , lambda_ccl = [ lambda_mem_ini ] * 3 C_H2_agc , C_H2_agdl , C_H2_ampl , C_H2_acl = [ C_H2_ini ] * 4 C_O2_ccl , C_O2_cmpl , C_O2_cgdl , C_O2_cgc = [ C_O2_ini ] * 4 C_N2 = C_N2_ini T_agc , T_agdl , T_ampl , T_acl , T_mem , T_ccl , T_cmpl , T_cgdl , T_cgc = [ T_ini ] * 9 eta_c = eta_c_ini Pasm , Paem , Pcsm , Pcem = Pasm_ini , Paem_ini , Pcsm_ini , Pcem_ini Phi_asm , Phi_aem , Phi_csm , Phi_cem = Phi_asm_ini , Phi_aem_ini , Phi_csm_ini , Phi_cem_ini Wcp , Wa_inj , Wc_inj , Abp_a , Abp_c = Wcp_ini , Wa_inj_ini , Wc_inj_ini , Abp_a_ini , Abp_c_ini # Gathering of the variables initial value into one list initial_variable_values = ([ C_v_agc ] + [ C_v_agdl ] * n_gdl + [ C_v_ampl , C_v_acl , C_v_ccl , C_v_cmpl ] + [ C_v_cgdl ] * n_gdl + [ C_v_cgc ] + [ s_boundary ] + [ s_agdl ] * ( n_gdl - 1 ) + [ s_ampl , s_acl , s_ccl , s_cmpl ] + [ s_cgdl ] * ( n_gdl - 1 ) + [ s_boundary ] + [ lambda_acl , lambda_mem , lambda_ccl ] + [ C_H2_agc ] + [ C_H2_agdl ] * n_gdl + [ C_H2_ampl , C_H2_acl , C_O2_ccl , C_O2_cmpl ] + [ C_O2_cgdl ] * n_gdl + [ C_O2_cgc , C_N2 ] + [ T_agc ] + [ T_agdl ] * n_gdl + [ T_ampl , T_acl , T_mem , T_ccl , T_cmpl ] + [ T_cgdl ] * n_gdl + [ T_cgc ] + [ eta_c ] + [ Pasm , Paem , Pcsm , Pcem , Phi_asm , Phi_aem , Phi_csm , Phi_cem ] + [ Wcp , Wa_inj , Wc_inj , Abp_a , Abp_c ]) return initial_variable_values def _recovery ( self ): \"\"\"Recover the values which have been calculated by the solver and add them into the variables' dictionary. However, the numerical resolution method does not, by design, recover all the internal states of the stack, even though they are calculated during this process. They therefore have to be recovered manually. \"\"\" # Recovery of the time span self . variables [ 't' ] . extend ( list ( self . sol . t )) # Recovery of the main variables dynamic evolution for index , key in enumerate ( self . solver_variable_names ): self . variables [ key ] . extend ( list ( self . sol . y [ index ])) # Recovery of more variables # The control variables should be reinitialized. To be reviewed. if self . parameters [ 'type_current' ] == \"step\" : self . control_variables [ 't_control_Phi' ] = 0 else : self . control_variables [ 't_control_Phi' ] = 0 self . control_variables [ 'Phi_a_des' ] = self . operating_inputs [ 'Phi_a_des' ] self . control_variables [ 'Phi_c_des' ] = self . operating_inputs [ 'Phi_c_des' ] for j in range ( len ( self . sol . t )): # For each time... # ... recovery of i_fc. i_fc = self . operating_inputs [ \"current_density\" ]( self . variables [ 't' ][ j ], self . parameters ) # ... recovery of S_abs_acl, S_abs_ccl, Jmem_acl, Jmem_ccl, Pagc, Pcgc. last_solver_variables = { key : self . variables [ key ][ j ] for key in self . solver_variable_names } flows_recovery = calculate_flows ( self . variables [ 't' ][ j ], last_solver_variables , self . control_variables , i_fc , self . operating_inputs , self . parameters ) for key in [ 'S_abs_acl' , 'S_abs_ccl' , 'J_lambda_acl_mem' , 'J_lambda_mem_ccl' , 'Pagc' , 'Pcgc' ]: self . variables [ key ] . append ( flows_recovery [ key ]) # ... recovery of Phi_a_des and Phi_c_des. if self . parameters [ \"type_control\" ] == \"Phi_des\" : sv = { 'lambda_mem' : self . variables [ 'lambda_mem' ][ j ], 's_ccl' : self . variables [ 's_ccl' ][ j ]} control_operating_conditions ( self . variables [ 't' ][ j ], sv , self . operating_inputs , self . parameters , self . control_variables ) for key in [ 'Phi_a_des' , 'Phi_c_des' ]: self . variables [ key ] . append ( self . control_variables [ key ]) def Display ( self , ax1 = None , ax2 = None , ax3 = None ): \"\"\"Display the plots of the program. Parameters ---------- ax1 : matplotlib.axes.Axes, optional Axes for the first set of plots. The default is None. ax2 : matplotlib.axes.Axes, optional Axes for the second set of plots. The default is None. ax3 : matplotlib.axes.Axes, optional Axes for the third set of plots. The default is None. \"\"\" # Extraction of the operating inputs and parameters n_gdl , type_fuel_cell = self . parameters [ 'n_gdl' ], self . parameters [ 'type_fuel_cell' ] type_current , type_display = self . parameters [ 'type_current' ], self . parameters [ 'type_display' ] # Parameters' preparation n = len ( self . variables [ 't' ]) subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 \\ else type_fuel_cell # Display if type_current == \"step\" : if type_display == \"multiple\" : figs , axes = zip ( * [ plt . subplots ( figsize = ( 8 , 8 )) for _ in range ( 13 )]) plot_ifc ( self . variables , self . operating_inputs , self . parameters , axes [ 0 ]) plot_J ( self . variables , self . parameters , axes [ 1 ]) plot_C_v ( self . variables , self . parameters , axes [ 2 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , axes [ 3 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , axes [ 4 ]) plot_C_O2 ( self . variables , self . parameters , axes [ 5 ]) plot_C_H2 ( self . variables , self . parameters , axes [ 6 ]) plot_C_N2 ( self . variables , self . parameters , axes [ 7 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , axes [ 8 ]) plot_Ucell ( self . variables , self . parameters , axes [ 9 ]) plot_P ( self . variables , self . parameters , axes [ 10 ]) plot_Phi_a ( self . variables , self . operating_inputs , self . parameters , axes [ 11 ]) plot_Phi_c ( self . variables , self . operating_inputs , self . parameters , axes [ 12 ]) # Considering the number of plots, the saving instructions are made here and not in the main.py file. self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_ifc_1.pdf\" , figs [ 0 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_J_1.pdf\" , figs [ 1 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Cv_1.pdf\" , figs [ 2 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_lambda_1.pdf\" , figs [ 3 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_s_1.pdf\" , figs [ 4 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_O2_1.pdf\" , figs [ 5 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_H2_1.pdf\" , figs [ 6 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_N2_1.pdf\" , figs [ 7 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_T_1.pdf\" , figs [ 8 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Ucell_1.pdf\" , figs [ 9 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_P_1.pdf\" , figs [ 10 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_a_1.pdf\" , figs [ 11 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_c_1.pdf\" , figs [ 12 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_ifc ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 0 ]) plot_Ucell ( self . variables , self . parameters , ax1 [ 0 , 1 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 2 ]) plot_C_v ( self . variables , self . parameters , ax1 [ 1 , 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 1 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 2 ]) plot_C_H2 ( self . variables , self . parameters , ax1 [ 2 , 0 ]) plot_C_O2 ( self . variables , self . parameters , ax1 [ 2 , 1 ]) plot_P ( self . variables , self . parameters , ax1 [ 2 , 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"polarization\" : if type_display == \"multiple\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_power_density_curve ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 1 ]) plot_cell_efficiency ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 2 ]) plot_Phi_des ( self . variables , self . operating_inputs , self . parameters , ax2 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax2 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax2 [ 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"no_display\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 , show = False ) elif type_current == \"polarization_for_cali\" : if type_display == \"multiple\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"EIS\" : if type_display == \"multiple\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 ) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax2 ) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax3 ) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 [ 0 ]) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax1 [ 1 ]) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax1 [ 2 ]) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode def Save_plot ( self , fig1 = None , fig2 = None , fig3 = None ): \"\"\"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters ---------- fig1 : matplotlib.figure.Figure, optional Figure for the first plot. The default is None. fig2 : matplotlib.figure.Figure, optional Figure for the second plot. The default is None. fig3 : matplotlib.figure.Figure, optional Figure for the third plot. The default is None. \"\"\" # Extraction of the operating inputs and parameters type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] type_display = self . parameters [ 'type_display' ] # Folder name subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 else type_fuel_cell # For the step current if type_current == \"step\" : if type_display == \"multiple\" : pass # saving instruction is directly implemented within AlphaPEM.Display for this situation. if type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"global_indicators_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_syn_1.pdf\" , fig2 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_1.pdf\" , fig1 ) # For the EIS curve elif type_current == \"EIS\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_amplitude_curve_1.pdf\" , fig2 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_angle_curve_1.pdf\" , fig3 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"impact_cali_on_internal_state_1.pdf\" , fig1 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_cali_1.pdf\" , fig1 ) def Saving_instructions ( self , root_folder , subfolder_name , filename , fig ): \"\"\"Gives the saving instructions for the figures. Parameters ---------- root_folder : str The root folder for the saving. subfolder_name : str The subfolder name for the saving. filename : str The filename for the saving. fig : matplotlib.figure.Figure The figure to be saved. \"\"\" # Create the folder if necessary folder_name = os . path . join ( root_folder , subfolder_name ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the filename without erasing the previous ones counter = 1 while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 if filename [ - 6 ] == \"_\" : # for the numbers between 1 and 9 filename = filename [: - 5 ] + str ( counter ) + \".pdf\" elif filename [ - 7 ] == \"_\" : # for the numbers between 10 and 99. filename = filename [: - 6 ] + str ( counter ) + \".pdf\" else : # for the numbers between 100 and 999. The bigger numbers are not considered. filename = filename [: - 7 ] + str ( counter ) + \".pdf\" # Save the figure file_path = os . path . join ( folder_name , filename ) fig . savefig ( file_path , dpi = 900 , transparent = False , bbox_inches = 'tight' ) Display ( ax1 = None , ax2 = None , ax3 = None ) Display the plots of the program. Parameters: ax1 ( Axes , default: None ) \u2013 Axes for the first set of plots. The default is None. ax2 ( Axes , default: None ) \u2013 Axes for the second set of plots. The default is None. ax3 ( Axes , default: None ) \u2013 Axes for the third set of plots. The default is None. Source code in model/AlphaPEM.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def Display ( self , ax1 = None , ax2 = None , ax3 = None ): \"\"\"Display the plots of the program. Parameters ---------- ax1 : matplotlib.axes.Axes, optional Axes for the first set of plots. The default is None. ax2 : matplotlib.axes.Axes, optional Axes for the second set of plots. The default is None. ax3 : matplotlib.axes.Axes, optional Axes for the third set of plots. The default is None. \"\"\" # Extraction of the operating inputs and parameters n_gdl , type_fuel_cell = self . parameters [ 'n_gdl' ], self . parameters [ 'type_fuel_cell' ] type_current , type_display = self . parameters [ 'type_current' ], self . parameters [ 'type_display' ] # Parameters' preparation n = len ( self . variables [ 't' ]) subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 \\ else type_fuel_cell # Display if type_current == \"step\" : if type_display == \"multiple\" : figs , axes = zip ( * [ plt . subplots ( figsize = ( 8 , 8 )) for _ in range ( 13 )]) plot_ifc ( self . variables , self . operating_inputs , self . parameters , axes [ 0 ]) plot_J ( self . variables , self . parameters , axes [ 1 ]) plot_C_v ( self . variables , self . parameters , axes [ 2 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , axes [ 3 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , axes [ 4 ]) plot_C_O2 ( self . variables , self . parameters , axes [ 5 ]) plot_C_H2 ( self . variables , self . parameters , axes [ 6 ]) plot_C_N2 ( self . variables , self . parameters , axes [ 7 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , axes [ 8 ]) plot_Ucell ( self . variables , self . parameters , axes [ 9 ]) plot_P ( self . variables , self . parameters , axes [ 10 ]) plot_Phi_a ( self . variables , self . operating_inputs , self . parameters , axes [ 11 ]) plot_Phi_c ( self . variables , self . operating_inputs , self . parameters , axes [ 12 ]) # Considering the number of plots, the saving instructions are made here and not in the main.py file. self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_ifc_1.pdf\" , figs [ 0 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_J_1.pdf\" , figs [ 1 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Cv_1.pdf\" , figs [ 2 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_lambda_1.pdf\" , figs [ 3 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_s_1.pdf\" , figs [ 4 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_O2_1.pdf\" , figs [ 5 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_H2_1.pdf\" , figs [ 6 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_N2_1.pdf\" , figs [ 7 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_T_1.pdf\" , figs [ 8 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Ucell_1.pdf\" , figs [ 9 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_P_1.pdf\" , figs [ 10 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_a_1.pdf\" , figs [ 11 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_c_1.pdf\" , figs [ 12 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_ifc ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 0 ]) plot_Ucell ( self . variables , self . parameters , ax1 [ 0 , 1 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 2 ]) plot_C_v ( self . variables , self . parameters , ax1 [ 1 , 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 1 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 2 ]) plot_C_H2 ( self . variables , self . parameters , ax1 [ 2 , 0 ]) plot_C_O2 ( self . variables , self . parameters , ax1 [ 2 , 1 ]) plot_P ( self . variables , self . parameters , ax1 [ 2 , 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"polarization\" : if type_display == \"multiple\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_power_density_curve ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 1 ]) plot_cell_efficiency ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 2 ]) plot_Phi_des ( self . variables , self . operating_inputs , self . parameters , ax2 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax2 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax2 [ 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"no_display\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 , show = False ) elif type_current == \"polarization_for_cali\" : if type_display == \"multiple\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"EIS\" : if type_display == \"multiple\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 ) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax2 ) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax3 ) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 [ 0 ]) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax1 [ 1 ]) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax1 [ 2 ]) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode Save_plot ( fig1 = None , fig2 = None , fig3 = None ) Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters: fig1 ( Figure , default: None ) \u2013 Figure for the first plot. The default is None. fig2 ( Figure , default: None ) \u2013 Figure for the second plot. The default is None. fig3 ( Figure , default: None ) \u2013 Figure for the third plot. The default is None. Source code in model/AlphaPEM.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 def Save_plot ( self , fig1 = None , fig2 = None , fig3 = None ): \"\"\"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters ---------- fig1 : matplotlib.figure.Figure, optional Figure for the first plot. The default is None. fig2 : matplotlib.figure.Figure, optional Figure for the second plot. The default is None. fig3 : matplotlib.figure.Figure, optional Figure for the third plot. The default is None. \"\"\" # Extraction of the operating inputs and parameters type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] type_display = self . parameters [ 'type_display' ] # Folder name subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 else type_fuel_cell # For the step current if type_current == \"step\" : if type_display == \"multiple\" : pass # saving instruction is directly implemented within AlphaPEM.Display for this situation. if type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"global_indicators_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_syn_1.pdf\" , fig2 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_1.pdf\" , fig1 ) # For the EIS curve elif type_current == \"EIS\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_amplitude_curve_1.pdf\" , fig2 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_angle_curve_1.pdf\" , fig3 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"impact_cali_on_internal_state_1.pdf\" , fig1 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_cali_1.pdf\" , fig1 ) Saving_instructions ( root_folder , subfolder_name , filename , fig ) Gives the saving instructions for the figures. Parameters: root_folder ( str ) \u2013 The root folder for the saving. subfolder_name ( str ) \u2013 The subfolder name for the saving. filename ( str ) \u2013 The filename for the saving. fig ( Figure ) \u2013 The figure to be saved. Source code in model/AlphaPEM.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def Saving_instructions ( self , root_folder , subfolder_name , filename , fig ): \"\"\"Gives the saving instructions for the figures. Parameters ---------- root_folder : str The root folder for the saving. subfolder_name : str The subfolder name for the saving. filename : str The filename for the saving. fig : matplotlib.figure.Figure The figure to be saved. \"\"\" # Create the folder if necessary folder_name = os . path . join ( root_folder , subfolder_name ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the filename without erasing the previous ones counter = 1 while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 if filename [ - 6 ] == \"_\" : # for the numbers between 1 and 9 filename = filename [: - 5 ] + str ( counter ) + \".pdf\" elif filename [ - 7 ] == \"_\" : # for the numbers between 10 and 99. filename = filename [: - 6 ] + str ( counter ) + \".pdf\" else : # for the numbers between 100 and 999. The bigger numbers are not considered. filename = filename [: - 7 ] + str ( counter ) + \".pdf\" # Save the figure file_path = os . path . join ( folder_name , filename ) fig . savefig ( file_path , dpi = 900 , transparent = False , bbox_inches = 'tight' ) __init__ ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ) Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values ( list , default: None ) \u2013 Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval ( list , default: None ) \u2013 Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. Source code in model/AlphaPEM.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def __init__ ( self , operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ): \"\"\"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values : list, optional Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval : list, optional Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. \"\"\" # Initialize the operating inputs and parameters dictionaries. self . operating_inputs = operating_inputs self . current_parameters = current_parameters self . accessible_physical_parameters = accessible_physical_parameters self . undetermined_physical_parameters = undetermined_physical_parameters self . computing_parameters = computing_parameters self . parameters = { ** self . current_parameters , ** self . accessible_physical_parameters , ** self . undetermined_physical_parameters , ** self . computing_parameters } if self . operating_inputs [ 'Pa_des' ] < Pext or self . operating_inputs [ 'Pc_des' ] < Pext : raise ValueError ( 'The desired pressure is too low. It cannot be lower than the pressure outside the stack.' ) # Initialize the variables' dictionary. self . solver_variable_names = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_acl' , 'C_v_ccl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_acl' , 's_ccl' , 's_cmpl' , 's_cgdl' , 'lambda_acl' , 'lambda_mem' , 'lambda_ccl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_H2_acl' , 'C_O2_ccl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_acl' , 'T_mem' , 'T_ccl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' , 'eta_c' , 'Pasm' , 'Paem' , 'Pcsm' , 'Pcem' , 'Phi_asm' , 'Phi_aem' , 'Phi_csm' , 'Phi_cem' , 'Wcp' , 'Wa_inj' , 'Wc_inj' , 'Abp_a' , 'Abp_c' ] self . solver_variable_names_extension () # Several points are considered in each GDL and must be inserted into # the solver_variable_names. self . all_variable_names = self . solver_variable_names + [ 't' , 'Ucell' , 'S_abs_acl' , 'S_abs_ccl' ] + \\ [ 'J_lambda_acl_mem' , 'J_lambda_mem_ccl' , 'Pagc' , 'Pcgc' , 'Phi_a_des' , 'Phi_c_des' ] self . variables = { key : [] for key in self . all_variable_names } # Initialize the control_variables dictionary. self . control_variables = { 't_control_Phi' : 0 , 'Phi_a_des' : self . operating_inputs [ 'Phi_a_des' ], 'Phi_c_des' : self . operating_inputs [ 'Phi_c_des' ]} # Create the dynamic evolution. # Create time intervals if time_interval is not None : # Initial time interval may be given to the Simulator. self . time_interval = time_interval else : # If not, it is automatically generated. self . time_interval = self . _create_time_interval () # Create the initial variable values if initial_variable_values is not None : # Initial variable values may be given to the Simulator. self . initial_variable_values = initial_variable_values else : # If not, they are generated considering an equilibrium at the operating inputs without current. self . initial_variable_values = self . _create_initial_variable_values () # Resolution of the system of differential equations. event_negative . terminal = True # Integration is stopped if one of the crucial variables becomes negative. self . sol = solve_ivp ( dydt , self . time_interval , self . initial_variable_values , method = 'BDF' , rtol = 1e-5 , atol = 1e-8 , events = event_negative , args = ( self . operating_inputs , self . parameters , self . solver_variable_names , self . control_variables )) # Recover the variable values calculated by the solver into the dictionary. self . _recovery () # Calculate the cell voltage after computing the internal states of the cell. self . variables [ \"Ucell\" ] . extend ( calculate_cell_voltage ( self . variables , self . operating_inputs , self . parameters )) solver_variable_names_extension () Several points are considered in each GDL and must be inserted into the solver_variable_names. Source code in model/AlphaPEM.py 246 247 248 249 250 251 252 253 254 255 256 257 def solver_variable_names_extension ( self ): \"\"\"Several points are considered in each GDL and must be inserted into the solver_variable_names. \"\"\" new_points_location = [ 'C_v_agdl' , 'C_v_cgdl' , 's_agdl' , 's_cgdl' , 'C_H2_agdl' , 'C_O2_cgdl' , 'T_agdl' , 'T_cgdl' ] for variable in new_points_location : index = self . solver_variable_names . index ( variable ) # Delete the previous points self . solver_variable_names . pop ( index ) # Increase the number of points self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'n_gdl' ] + 1 )]","title":"AlphaPEM"},{"location":"functions/model/AlphaPEM/#alphapem","text":"Objectives: Create an open-source software package to simulate the PEM fuel cell for control system applications. Authors: Rapha\u00ebl GASS, Zhongliang LI, Rachid OUTBIB, Samir JEMEI and Daniel HISSEL. This file describes the AlphaPEM class, which is a PEM fuel cell system simulator. The model is one-dimensional, dynamic, biphasic, and isothermal. It has been published in the following articles: - Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a - Gass et al 2024 SSRN http://dx.doi.org/10.2139/ssrn.4812343","title":"AlphaPEM"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM","text":"Source code in model/AlphaPEM.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 class AlphaPEM : def __init__ ( self , operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ): \"\"\"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values : list, optional Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval : list, optional Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. \"\"\" # Initialize the operating inputs and parameters dictionaries. self . operating_inputs = operating_inputs self . current_parameters = current_parameters self . accessible_physical_parameters = accessible_physical_parameters self . undetermined_physical_parameters = undetermined_physical_parameters self . computing_parameters = computing_parameters self . parameters = { ** self . current_parameters , ** self . accessible_physical_parameters , ** self . undetermined_physical_parameters , ** self . computing_parameters } if self . operating_inputs [ 'Pa_des' ] < Pext or self . operating_inputs [ 'Pc_des' ] < Pext : raise ValueError ( 'The desired pressure is too low. It cannot be lower than the pressure outside the stack.' ) # Initialize the variables' dictionary. self . solver_variable_names = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_acl' , 'C_v_ccl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_acl' , 's_ccl' , 's_cmpl' , 's_cgdl' , 'lambda_acl' , 'lambda_mem' , 'lambda_ccl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_H2_acl' , 'C_O2_ccl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_acl' , 'T_mem' , 'T_ccl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' , 'eta_c' , 'Pasm' , 'Paem' , 'Pcsm' , 'Pcem' , 'Phi_asm' , 'Phi_aem' , 'Phi_csm' , 'Phi_cem' , 'Wcp' , 'Wa_inj' , 'Wc_inj' , 'Abp_a' , 'Abp_c' ] self . solver_variable_names_extension () # Several points are considered in each GDL and must be inserted into # the solver_variable_names. self . all_variable_names = self . solver_variable_names + [ 't' , 'Ucell' , 'S_abs_acl' , 'S_abs_ccl' ] + \\ [ 'J_lambda_acl_mem' , 'J_lambda_mem_ccl' , 'Pagc' , 'Pcgc' , 'Phi_a_des' , 'Phi_c_des' ] self . variables = { key : [] for key in self . all_variable_names } # Initialize the control_variables dictionary. self . control_variables = { 't_control_Phi' : 0 , 'Phi_a_des' : self . operating_inputs [ 'Phi_a_des' ], 'Phi_c_des' : self . operating_inputs [ 'Phi_c_des' ]} # Create the dynamic evolution. # Create time intervals if time_interval is not None : # Initial time interval may be given to the Simulator. self . time_interval = time_interval else : # If not, it is automatically generated. self . time_interval = self . _create_time_interval () # Create the initial variable values if initial_variable_values is not None : # Initial variable values may be given to the Simulator. self . initial_variable_values = initial_variable_values else : # If not, they are generated considering an equilibrium at the operating inputs without current. self . initial_variable_values = self . _create_initial_variable_values () # Resolution of the system of differential equations. event_negative . terminal = True # Integration is stopped if one of the crucial variables becomes negative. self . sol = solve_ivp ( dydt , self . time_interval , self . initial_variable_values , method = 'BDF' , rtol = 1e-5 , atol = 1e-8 , events = event_negative , args = ( self . operating_inputs , self . parameters , self . solver_variable_names , self . control_variables )) # Recover the variable values calculated by the solver into the dictionary. self . _recovery () # Calculate the cell voltage after computing the internal states of the cell. self . variables [ \"Ucell\" ] . extend ( calculate_cell_voltage ( self . variables , self . operating_inputs , self . parameters )) def solver_variable_names_extension ( self ): \"\"\"Several points are considered in each GDL and must be inserted into the solver_variable_names. \"\"\" new_points_location = [ 'C_v_agdl' , 'C_v_cgdl' , 's_agdl' , 's_cgdl' , 'C_H2_agdl' , 'C_O2_cgdl' , 'T_agdl' , 'T_cgdl' ] for variable in new_points_location : index = self . solver_variable_names . index ( variable ) # Delete the previous points self . solver_variable_names . pop ( index ) # Increase the number of points self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'n_gdl' ] + 1 )] def _create_time_interval ( self ): \"\"\"Calculate the time intervals for numerical resolution, according to the current chosen, if it is not provided. Returns ------- list Time interval for numerical resolution. It is used when initial_variable_values == None. \"\"\" # Extraction of the parameters step_current_parameters = self . parameters [ 'step_current_parameters' ] pola_current_parameters = self . parameters [ 'pola_current_parameters' ] pola_current_for_cali_parameters = self . parameters [ 'pola_current_for_cali_parameters' ] type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] # Recovery of the good time interval if type_current == \"step\" : t0_interval = 0 # s. tf_interval = step_current_parameters [ 'delta_t_ini_step' ] + step_current_parameters [ 'delta_t_load_step' ] + \\ step_current_parameters [ 'delta_t_break_step' ] # s. elif type_current == \"polarization\" : # Extraction of the parameters delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] # (s). delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] # (s). delta_i_pola = pola_current_parameters [ 'delta_i_pola' ] # (A.m-2). i_max_pola = pola_current_parameters [ 'i_max_pola' ] # (A.m-2). # Calculation t0_interval = 0 # s. tf_interval = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * ( delta_t_load_pola + delta_t_break_pola ) elif type_current == \"polarization_for_cali\" : # Extraction of the parameters delta_t_ini_pola_cali = pola_current_for_cali_parameters [ 'delta_t_ini_pola_cali' ] # (s). delta_t_load_pola_cali = pola_current_for_cali_parameters [ 'delta_t_load_pola_cali' ] # (s). delta_t_break_pola_cali = pola_current_for_cali_parameters [ 'delta_t_break_pola_cali' ] # (s). i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell ) # (A.m-2, V). # Calculation delta_t_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. t0_interval = 0 tf_interval = delta_t_ini_pola_cali + len ( i_exp_cali_t ) * delta_t_cali # s. else : # EIS time_interval is calculated in the main.py file. raise ValueError ( \"Please enter a recognized type_current option for calculating the time interval.\" ) # To be reviewed self . control_variables [ 't_control_Phi' ] = t0_interval return [ t0_interval , tf_interval ] def _create_initial_variable_values ( self ): \"\"\"Create the initial values of the solver variables if it is not provided. It is generated considering an equilibrium at the operating inputs without current. Returns ------- list Initial values of the solver variables. It is used when initial_variable_values == None. \"\"\" # Extraction of the operating inputs and parameters current_density , T_des = self . operating_inputs [ 'current_density' ], self . operating_inputs [ 'T_des' ] Pa_des , Pc_des = self . operating_inputs [ 'Pa_des' ], self . operating_inputs [ 'Pc_des' ] Phi_a_des , Phi_c_des = self . operating_inputs [ 'Phi_a_des' ], self . operating_inputs [ 'Phi_c_des' ] Hmem , kappa_co , i0_c_ref , = self . parameters [ 'Hmem' ], self . parameters [ 'kappa_co' ], self . parameters [ 'i0_c_ref' ] kappa_c = self . parameters [ 'kappa_c' ] a_slim , b_slim , a_switch = self . parameters [ 'a_slim' ], self . parameters [ 'b_slim' ], self . parameters [ 'a_switch' ] n_gdl = self . parameters [ 'n_gdl' ] # Mean value of the operating inputs Phi_des_moy = ( Phi_a_des + Phi_c_des ) / 2 P_des_moy = ( Pa_des + Pc_des ) / 2 # Initial fuel cell states # Intermediate values T_ini = T_des # K. It is the initial temperature in the fuel cell. Psat_ini = 101325 * 10 ** ( - 2.1794 + 0.02953 * ( T_ini - 273.15 ) - 9.1837e-5 * ( T_ini - 273.15 ) ** 2 + 1.4454e-7 * ( T_ini - 273.15 ) ** 3 ) slim = a_slim * ( Pc_des / 1e5 ) + b_slim s_switch = a_switch * slim # Initial fuel cell states C_v_ini = Phi_des_moy * Psat_ini / ( R * T_ini ) # mol.m-3. It is the initial vapor concentration. C_H2_ini = ( P_des_moy - Phi_des_moy * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial H2 concentration # in the fuel cell. C_O2_ini = yO2_ext * ( P_des_moy - Phi_des_moy * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial O2 # concentration in the fuel cell. C_N2_ini = ( 1 - yO2_ext ) * ( P_des_moy - Phi_des_moy * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial N2 # concentration in the fuel cell. s_ini = 0 # It is the initial liquid water saturation in the fuel cell. lambda_mem_ini = lambda_eq ( C_v_ini , s_ini , T_ini ) # It is the initial water content in the fuel cell. i_fc_ini = current_density ( self . time_interval [ 0 ], self . parameters ) i_n_ini = 2 * F * R * T_ini / Hmem * C_H2_ini * k_H2 ( lambda_mem_ini , T_ini , kappa_co ) + \\ 4 * F * R * T_ini / Hmem * C_O2_ini * k_O2 ( lambda_mem_ini , T_ini , kappa_co ) f_drop_ini = 0.5 * ( 1.0 - math . tanh (( 4 * s_ini - 2 * slim - 2 * s_switch ) / ( slim - s_switch ))) eta_c_ini = 1 / f_drop_ini * R * T_ini / ( alpha_c * F ) * \\ math . log (( i_fc_ini + i_n_ini ) / i0_c_ref * ( C_O2ref / C_O2_ini ) ** kappa_c ) # It is the initial # cathode overpotential in the fuel cell. # Initial auxiliary system state Pasm_ini , Paem_ini = Pa_des , P_des_moy # Pa. It is the supply/exhaust manifold pressure at the anode side. Pcsm_ini , Pcem_ini = Pc_des , P_des_moy # Pa. It is the supply/exhaust manifold pressure at the cathode side. Phi_asm_ini , Phi_aem_ini = Phi_a_des , Phi_des_moy # It is the supply/exhaust manifold relative humidity # at the anode side. Phi_csm_ini , Phi_cem_ini = Phi_c_des , Phi_des_moy # It is the supply/exhaust manifold relative humidity # at the cathode side. Wcp_ini = 0 # kg.s-1. It is the flow rate of the air compressor. Wa_inj_ini = 0 # kg.s-1. It is the flow rate of the air compressor at the anode side. Wc_inj_ini = 0 # kg.s-1. It is the flow rate of the air compressor at the cathode side. Abp_a_ini = 0 # It is the throttle area of the back pressure valve at the anode. Abp_c_ini = 0 # It is the throttle area of the back pressure valve at the cathode. # Main variable initialization C_v_agc , C_v_agdl , C_v_ampl , C_v_acl , C_v_ccl , C_v_cmpl , C_v_cgdl , C_v_cgc = [ C_v_ini ] * 8 s_agdl , s_ampl , s_acl , s_ccl , s_cmpl , s_cgdl = [ s_ini ] * 6 s_boundary = 0 # Dirichlet boundary condition lambda_acl , lambda_mem , lambda_ccl = [ lambda_mem_ini ] * 3 C_H2_agc , C_H2_agdl , C_H2_ampl , C_H2_acl = [ C_H2_ini ] * 4 C_O2_ccl , C_O2_cmpl , C_O2_cgdl , C_O2_cgc = [ C_O2_ini ] * 4 C_N2 = C_N2_ini T_agc , T_agdl , T_ampl , T_acl , T_mem , T_ccl , T_cmpl , T_cgdl , T_cgc = [ T_ini ] * 9 eta_c = eta_c_ini Pasm , Paem , Pcsm , Pcem = Pasm_ini , Paem_ini , Pcsm_ini , Pcem_ini Phi_asm , Phi_aem , Phi_csm , Phi_cem = Phi_asm_ini , Phi_aem_ini , Phi_csm_ini , Phi_cem_ini Wcp , Wa_inj , Wc_inj , Abp_a , Abp_c = Wcp_ini , Wa_inj_ini , Wc_inj_ini , Abp_a_ini , Abp_c_ini # Gathering of the variables initial value into one list initial_variable_values = ([ C_v_agc ] + [ C_v_agdl ] * n_gdl + [ C_v_ampl , C_v_acl , C_v_ccl , C_v_cmpl ] + [ C_v_cgdl ] * n_gdl + [ C_v_cgc ] + [ s_boundary ] + [ s_agdl ] * ( n_gdl - 1 ) + [ s_ampl , s_acl , s_ccl , s_cmpl ] + [ s_cgdl ] * ( n_gdl - 1 ) + [ s_boundary ] + [ lambda_acl , lambda_mem , lambda_ccl ] + [ C_H2_agc ] + [ C_H2_agdl ] * n_gdl + [ C_H2_ampl , C_H2_acl , C_O2_ccl , C_O2_cmpl ] + [ C_O2_cgdl ] * n_gdl + [ C_O2_cgc , C_N2 ] + [ T_agc ] + [ T_agdl ] * n_gdl + [ T_ampl , T_acl , T_mem , T_ccl , T_cmpl ] + [ T_cgdl ] * n_gdl + [ T_cgc ] + [ eta_c ] + [ Pasm , Paem , Pcsm , Pcem , Phi_asm , Phi_aem , Phi_csm , Phi_cem ] + [ Wcp , Wa_inj , Wc_inj , Abp_a , Abp_c ]) return initial_variable_values def _recovery ( self ): \"\"\"Recover the values which have been calculated by the solver and add them into the variables' dictionary. However, the numerical resolution method does not, by design, recover all the internal states of the stack, even though they are calculated during this process. They therefore have to be recovered manually. \"\"\" # Recovery of the time span self . variables [ 't' ] . extend ( list ( self . sol . t )) # Recovery of the main variables dynamic evolution for index , key in enumerate ( self . solver_variable_names ): self . variables [ key ] . extend ( list ( self . sol . y [ index ])) # Recovery of more variables # The control variables should be reinitialized. To be reviewed. if self . parameters [ 'type_current' ] == \"step\" : self . control_variables [ 't_control_Phi' ] = 0 else : self . control_variables [ 't_control_Phi' ] = 0 self . control_variables [ 'Phi_a_des' ] = self . operating_inputs [ 'Phi_a_des' ] self . control_variables [ 'Phi_c_des' ] = self . operating_inputs [ 'Phi_c_des' ] for j in range ( len ( self . sol . t )): # For each time... # ... recovery of i_fc. i_fc = self . operating_inputs [ \"current_density\" ]( self . variables [ 't' ][ j ], self . parameters ) # ... recovery of S_abs_acl, S_abs_ccl, Jmem_acl, Jmem_ccl, Pagc, Pcgc. last_solver_variables = { key : self . variables [ key ][ j ] for key in self . solver_variable_names } flows_recovery = calculate_flows ( self . variables [ 't' ][ j ], last_solver_variables , self . control_variables , i_fc , self . operating_inputs , self . parameters ) for key in [ 'S_abs_acl' , 'S_abs_ccl' , 'J_lambda_acl_mem' , 'J_lambda_mem_ccl' , 'Pagc' , 'Pcgc' ]: self . variables [ key ] . append ( flows_recovery [ key ]) # ... recovery of Phi_a_des and Phi_c_des. if self . parameters [ \"type_control\" ] == \"Phi_des\" : sv = { 'lambda_mem' : self . variables [ 'lambda_mem' ][ j ], 's_ccl' : self . variables [ 's_ccl' ][ j ]} control_operating_conditions ( self . variables [ 't' ][ j ], sv , self . operating_inputs , self . parameters , self . control_variables ) for key in [ 'Phi_a_des' , 'Phi_c_des' ]: self . variables [ key ] . append ( self . control_variables [ key ]) def Display ( self , ax1 = None , ax2 = None , ax3 = None ): \"\"\"Display the plots of the program. Parameters ---------- ax1 : matplotlib.axes.Axes, optional Axes for the first set of plots. The default is None. ax2 : matplotlib.axes.Axes, optional Axes for the second set of plots. The default is None. ax3 : matplotlib.axes.Axes, optional Axes for the third set of plots. The default is None. \"\"\" # Extraction of the operating inputs and parameters n_gdl , type_fuel_cell = self . parameters [ 'n_gdl' ], self . parameters [ 'type_fuel_cell' ] type_current , type_display = self . parameters [ 'type_current' ], self . parameters [ 'type_display' ] # Parameters' preparation n = len ( self . variables [ 't' ]) subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 \\ else type_fuel_cell # Display if type_current == \"step\" : if type_display == \"multiple\" : figs , axes = zip ( * [ plt . subplots ( figsize = ( 8 , 8 )) for _ in range ( 13 )]) plot_ifc ( self . variables , self . operating_inputs , self . parameters , axes [ 0 ]) plot_J ( self . variables , self . parameters , axes [ 1 ]) plot_C_v ( self . variables , self . parameters , axes [ 2 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , axes [ 3 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , axes [ 4 ]) plot_C_O2 ( self . variables , self . parameters , axes [ 5 ]) plot_C_H2 ( self . variables , self . parameters , axes [ 6 ]) plot_C_N2 ( self . variables , self . parameters , axes [ 7 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , axes [ 8 ]) plot_Ucell ( self . variables , self . parameters , axes [ 9 ]) plot_P ( self . variables , self . parameters , axes [ 10 ]) plot_Phi_a ( self . variables , self . operating_inputs , self . parameters , axes [ 11 ]) plot_Phi_c ( self . variables , self . operating_inputs , self . parameters , axes [ 12 ]) # Considering the number of plots, the saving instructions are made here and not in the main.py file. self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_ifc_1.pdf\" , figs [ 0 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_J_1.pdf\" , figs [ 1 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Cv_1.pdf\" , figs [ 2 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_lambda_1.pdf\" , figs [ 3 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_s_1.pdf\" , figs [ 4 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_O2_1.pdf\" , figs [ 5 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_H2_1.pdf\" , figs [ 6 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_N2_1.pdf\" , figs [ 7 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_T_1.pdf\" , figs [ 8 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Ucell_1.pdf\" , figs [ 9 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_P_1.pdf\" , figs [ 10 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_a_1.pdf\" , figs [ 11 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_c_1.pdf\" , figs [ 12 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_ifc ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 0 ]) plot_Ucell ( self . variables , self . parameters , ax1 [ 0 , 1 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 2 ]) plot_C_v ( self . variables , self . parameters , ax1 [ 1 , 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 1 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 2 ]) plot_C_H2 ( self . variables , self . parameters , ax1 [ 2 , 0 ]) plot_C_O2 ( self . variables , self . parameters , ax1 [ 2 , 1 ]) plot_P ( self . variables , self . parameters , ax1 [ 2 , 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"polarization\" : if type_display == \"multiple\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_power_density_curve ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 1 ]) plot_cell_efficiency ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 2 ]) plot_Phi_des ( self . variables , self . operating_inputs , self . parameters , ax2 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax2 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax2 [ 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"no_display\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 , show = False ) elif type_current == \"polarization_for_cali\" : if type_display == \"multiple\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"EIS\" : if type_display == \"multiple\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 ) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax2 ) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax3 ) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 [ 0 ]) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax1 [ 1 ]) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax1 [ 2 ]) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode def Save_plot ( self , fig1 = None , fig2 = None , fig3 = None ): \"\"\"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters ---------- fig1 : matplotlib.figure.Figure, optional Figure for the first plot. The default is None. fig2 : matplotlib.figure.Figure, optional Figure for the second plot. The default is None. fig3 : matplotlib.figure.Figure, optional Figure for the third plot. The default is None. \"\"\" # Extraction of the operating inputs and parameters type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] type_display = self . parameters [ 'type_display' ] # Folder name subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 else type_fuel_cell # For the step current if type_current == \"step\" : if type_display == \"multiple\" : pass # saving instruction is directly implemented within AlphaPEM.Display for this situation. if type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"global_indicators_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_syn_1.pdf\" , fig2 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_1.pdf\" , fig1 ) # For the EIS curve elif type_current == \"EIS\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_amplitude_curve_1.pdf\" , fig2 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_angle_curve_1.pdf\" , fig3 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"impact_cali_on_internal_state_1.pdf\" , fig1 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_cali_1.pdf\" , fig1 ) def Saving_instructions ( self , root_folder , subfolder_name , filename , fig ): \"\"\"Gives the saving instructions for the figures. Parameters ---------- root_folder : str The root folder for the saving. subfolder_name : str The subfolder name for the saving. filename : str The filename for the saving. fig : matplotlib.figure.Figure The figure to be saved. \"\"\" # Create the folder if necessary folder_name = os . path . join ( root_folder , subfolder_name ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the filename without erasing the previous ones counter = 1 while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 if filename [ - 6 ] == \"_\" : # for the numbers between 1 and 9 filename = filename [: - 5 ] + str ( counter ) + \".pdf\" elif filename [ - 7 ] == \"_\" : # for the numbers between 10 and 99. filename = filename [: - 6 ] + str ( counter ) + \".pdf\" else : # for the numbers between 100 and 999. The bigger numbers are not considered. filename = filename [: - 7 ] + str ( counter ) + \".pdf\" # Save the figure file_path = os . path . join ( folder_name , filename ) fig . savefig ( file_path , dpi = 900 , transparent = False , bbox_inches = 'tight' )","title":"AlphaPEM"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.Display","text":"Display the plots of the program. Parameters: ax1 ( Axes , default: None ) \u2013 Axes for the first set of plots. The default is None. ax2 ( Axes , default: None ) \u2013 Axes for the second set of plots. The default is None. ax3 ( Axes , default: None ) \u2013 Axes for the third set of plots. The default is None. Source code in model/AlphaPEM.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def Display ( self , ax1 = None , ax2 = None , ax3 = None ): \"\"\"Display the plots of the program. Parameters ---------- ax1 : matplotlib.axes.Axes, optional Axes for the first set of plots. The default is None. ax2 : matplotlib.axes.Axes, optional Axes for the second set of plots. The default is None. ax3 : matplotlib.axes.Axes, optional Axes for the third set of plots. The default is None. \"\"\" # Extraction of the operating inputs and parameters n_gdl , type_fuel_cell = self . parameters [ 'n_gdl' ], self . parameters [ 'type_fuel_cell' ] type_current , type_display = self . parameters [ 'type_current' ], self . parameters [ 'type_display' ] # Parameters' preparation n = len ( self . variables [ 't' ]) subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 \\ else type_fuel_cell # Display if type_current == \"step\" : if type_display == \"multiple\" : figs , axes = zip ( * [ plt . subplots ( figsize = ( 8 , 8 )) for _ in range ( 13 )]) plot_ifc ( self . variables , self . operating_inputs , self . parameters , axes [ 0 ]) plot_J ( self . variables , self . parameters , axes [ 1 ]) plot_C_v ( self . variables , self . parameters , axes [ 2 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , axes [ 3 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , axes [ 4 ]) plot_C_O2 ( self . variables , self . parameters , axes [ 5 ]) plot_C_H2 ( self . variables , self . parameters , axes [ 6 ]) plot_C_N2 ( self . variables , self . parameters , axes [ 7 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , axes [ 8 ]) plot_Ucell ( self . variables , self . parameters , axes [ 9 ]) plot_P ( self . variables , self . parameters , axes [ 10 ]) plot_Phi_a ( self . variables , self . operating_inputs , self . parameters , axes [ 11 ]) plot_Phi_c ( self . variables , self . operating_inputs , self . parameters , axes [ 12 ]) # Considering the number of plots, the saving instructions are made here and not in the main.py file. self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_ifc_1.pdf\" , figs [ 0 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_J_1.pdf\" , figs [ 1 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Cv_1.pdf\" , figs [ 2 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_lambda_1.pdf\" , figs [ 3 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_s_1.pdf\" , figs [ 4 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_O2_1.pdf\" , figs [ 5 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_H2_1.pdf\" , figs [ 6 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_N2_1.pdf\" , figs [ 7 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_T_1.pdf\" , figs [ 8 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Ucell_1.pdf\" , figs [ 9 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_P_1.pdf\" , figs [ 10 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_a_1.pdf\" , figs [ 11 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_c_1.pdf\" , figs [ 12 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_ifc ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 0 ]) plot_Ucell ( self . variables , self . parameters , ax1 [ 0 , 1 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 2 ]) plot_C_v ( self . variables , self . parameters , ax1 [ 1 , 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 1 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 2 ]) plot_C_H2 ( self . variables , self . parameters , ax1 [ 2 , 0 ]) plot_C_O2 ( self . variables , self . parameters , ax1 [ 2 , 1 ]) plot_P ( self . variables , self . parameters , ax1 [ 2 , 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"polarization\" : if type_display == \"multiple\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_power_density_curve ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 1 ]) plot_cell_efficiency ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 2 ]) plot_Phi_des ( self . variables , self . operating_inputs , self . parameters , ax2 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax2 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax2 [ 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"no_display\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 , show = False ) elif type_current == \"polarization_for_cali\" : if type_display == \"multiple\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 ]) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"EIS\" : if type_display == \"multiple\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 ) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax2 ) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax3 ) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 [ 0 ]) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax1 [ 1 ]) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax1 [ 2 ]) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode","title":"Display"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.Save_plot","text":"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters: fig1 ( Figure , default: None ) \u2013 Figure for the first plot. The default is None. fig2 ( Figure , default: None ) \u2013 Figure for the second plot. The default is None. fig3 ( Figure , default: None ) \u2013 Figure for the third plot. The default is None. Source code in model/AlphaPEM.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 def Save_plot ( self , fig1 = None , fig2 = None , fig3 = None ): \"\"\"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters ---------- fig1 : matplotlib.figure.Figure, optional Figure for the first plot. The default is None. fig2 : matplotlib.figure.Figure, optional Figure for the second plot. The default is None. fig3 : matplotlib.figure.Figure, optional Figure for the third plot. The default is None. \"\"\" # Extraction of the operating inputs and parameters type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] type_display = self . parameters [ 'type_display' ] # Folder name subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 else type_fuel_cell # For the step current if type_current == \"step\" : if type_display == \"multiple\" : pass # saving instruction is directly implemented within AlphaPEM.Display for this situation. if type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"global_indicators_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_syn_1.pdf\" , fig2 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_1.pdf\" , fig1 ) # For the EIS curve elif type_current == \"EIS\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_amplitude_curve_1.pdf\" , fig2 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_angle_curve_1.pdf\" , fig3 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"impact_cali_on_internal_state_1.pdf\" , fig1 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_cali_1.pdf\" , fig1 )","title":"Save_plot"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.Saving_instructions","text":"Gives the saving instructions for the figures. Parameters: root_folder ( str ) \u2013 The root folder for the saving. subfolder_name ( str ) \u2013 The subfolder name for the saving. filename ( str ) \u2013 The filename for the saving. fig ( Figure ) \u2013 The figure to be saved. Source code in model/AlphaPEM.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def Saving_instructions ( self , root_folder , subfolder_name , filename , fig ): \"\"\"Gives the saving instructions for the figures. Parameters ---------- root_folder : str The root folder for the saving. subfolder_name : str The subfolder name for the saving. filename : str The filename for the saving. fig : matplotlib.figure.Figure The figure to be saved. \"\"\" # Create the folder if necessary folder_name = os . path . join ( root_folder , subfolder_name ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the filename without erasing the previous ones counter = 1 while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 if filename [ - 6 ] == \"_\" : # for the numbers between 1 and 9 filename = filename [: - 5 ] + str ( counter ) + \".pdf\" elif filename [ - 7 ] == \"_\" : # for the numbers between 10 and 99. filename = filename [: - 6 ] + str ( counter ) + \".pdf\" else : # for the numbers between 100 and 999. The bigger numbers are not considered. filename = filename [: - 7 ] + str ( counter ) + \".pdf\" # Save the figure file_path = os . path . join ( folder_name , filename ) fig . savefig ( file_path , dpi = 900 , transparent = False , bbox_inches = 'tight' )","title":"Saving_instructions"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.__init__","text":"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values ( list , default: None ) \u2013 Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval ( list , default: None ) \u2013 Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. Source code in model/AlphaPEM.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def __init__ ( self , operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ): \"\"\"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values : list, optional Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval : list, optional Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. \"\"\" # Initialize the operating inputs and parameters dictionaries. self . operating_inputs = operating_inputs self . current_parameters = current_parameters self . accessible_physical_parameters = accessible_physical_parameters self . undetermined_physical_parameters = undetermined_physical_parameters self . computing_parameters = computing_parameters self . parameters = { ** self . current_parameters , ** self . accessible_physical_parameters , ** self . undetermined_physical_parameters , ** self . computing_parameters } if self . operating_inputs [ 'Pa_des' ] < Pext or self . operating_inputs [ 'Pc_des' ] < Pext : raise ValueError ( 'The desired pressure is too low. It cannot be lower than the pressure outside the stack.' ) # Initialize the variables' dictionary. self . solver_variable_names = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_acl' , 'C_v_ccl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_acl' , 's_ccl' , 's_cmpl' , 's_cgdl' , 'lambda_acl' , 'lambda_mem' , 'lambda_ccl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_H2_acl' , 'C_O2_ccl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_acl' , 'T_mem' , 'T_ccl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' , 'eta_c' , 'Pasm' , 'Paem' , 'Pcsm' , 'Pcem' , 'Phi_asm' , 'Phi_aem' , 'Phi_csm' , 'Phi_cem' , 'Wcp' , 'Wa_inj' , 'Wc_inj' , 'Abp_a' , 'Abp_c' ] self . solver_variable_names_extension () # Several points are considered in each GDL and must be inserted into # the solver_variable_names. self . all_variable_names = self . solver_variable_names + [ 't' , 'Ucell' , 'S_abs_acl' , 'S_abs_ccl' ] + \\ [ 'J_lambda_acl_mem' , 'J_lambda_mem_ccl' , 'Pagc' , 'Pcgc' , 'Phi_a_des' , 'Phi_c_des' ] self . variables = { key : [] for key in self . all_variable_names } # Initialize the control_variables dictionary. self . control_variables = { 't_control_Phi' : 0 , 'Phi_a_des' : self . operating_inputs [ 'Phi_a_des' ], 'Phi_c_des' : self . operating_inputs [ 'Phi_c_des' ]} # Create the dynamic evolution. # Create time intervals if time_interval is not None : # Initial time interval may be given to the Simulator. self . time_interval = time_interval else : # If not, it is automatically generated. self . time_interval = self . _create_time_interval () # Create the initial variable values if initial_variable_values is not None : # Initial variable values may be given to the Simulator. self . initial_variable_values = initial_variable_values else : # If not, they are generated considering an equilibrium at the operating inputs without current. self . initial_variable_values = self . _create_initial_variable_values () # Resolution of the system of differential equations. event_negative . terminal = True # Integration is stopped if one of the crucial variables becomes negative. self . sol = solve_ivp ( dydt , self . time_interval , self . initial_variable_values , method = 'BDF' , rtol = 1e-5 , atol = 1e-8 , events = event_negative , args = ( self . operating_inputs , self . parameters , self . solver_variable_names , self . control_variables )) # Recover the variable values calculated by the solver into the dictionary. self . _recovery () # Calculate the cell voltage after computing the internal states of the cell. self . variables [ \"Ucell\" ] . extend ( calculate_cell_voltage ( self . variables , self . operating_inputs , self . parameters ))","title":"__init__"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.solver_variable_names_extension","text":"Several points are considered in each GDL and must be inserted into the solver_variable_names. Source code in model/AlphaPEM.py 246 247 248 249 250 251 252 253 254 255 256 257 def solver_variable_names_extension ( self ): \"\"\"Several points are considered in each GDL and must be inserted into the solver_variable_names. \"\"\" new_points_location = [ 'C_v_agdl' , 'C_v_cgdl' , 's_agdl' , 's_cgdl' , 'C_H2_agdl' , 'C_O2_cgdl' , 'T_agdl' , 'T_cgdl' ] for variable in new_points_location : index = self . solver_variable_names . index ( variable ) # Delete the previous points self . solver_variable_names . pop ( index ) # Increase the number of points self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'n_gdl' ] + 1 )]","title":"solver_variable_names_extension"},{"location":"functions/model/auxiliaries/","text":"Auxiliaries This file represents all the flows passing through the auxiliaries. It is a component of the fuel cell model. auxiliaries ( t , solver_variables , control_variables , i_fc , operating_inputs , parameters ) This function calculates the flows passing through the auxiliaries. Parameters: t ( float ) \u2013 Time (s). solver_variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables ( dict ) \u2013 Variables controlled by the user. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Jv_a_in ( float ) \u2013 Vapor flow at the anode gas channel inlet (mol.m-2.s-1). Jv_a_out ( float ) \u2013 Vapor flow at the anode gas channel outlet (mol.m-2.s-1). Jv_c_in ( float ) \u2013 Vapor flow at the cathode gas channel inlet (mol.m-2.s-1). Jv_c_out ( float ) \u2013 Vapor flow at the cathode gas channel outlet (mol.m-2.s-1). J_H2_in ( float ) \u2013 H2 flow at the anode gas channel inlet (mol.m-2.s-1). J_H2_out ( float ) \u2013 H2 flow at the anode gas channel outlet (mol.m-2.s-1). J_O2_in ( float ) \u2013 O2 flow at the cathode gas channel inlet (mol.m-2.s-1). J_O2_out ( float ) \u2013 O2 flow at the cathode gas channel outlet (mol.m-2.s-1). J_N2_in ( float ) \u2013 N2 flow at the cathode gas channel inlet (mol.m-2.s-1). J_N2_out ( float ) \u2013 N2 flow at the cathode gas channel outlet (mol.m-2.s-1). Wasm_in ( float ) \u2013 Anode side supply manifold inlet flow (kg.s-1). Wasm_out ( float ) \u2013 Anode side supply manifold outlet flow (kg.s-1). Waem_in ( float ) \u2013 Anode side external manifold inlet flow (kg.s-1). Waem_out ( float ) \u2013 Anode side external manifold outlet flow (kg.s-1). Wcsm_in ( float ) \u2013 Cathode side supply manifold inlet flow (kg.s-1). Wcsm_out ( float ) \u2013 Cathode side supply manifold outlet flow (kg.s-1). Wcem_in ( float ) \u2013 Cathode side external manifold inlet flow (kg.s-1). Wcem_out ( float ) \u2013 Cathode side external manifold outlet flow (kg.s-1). Ware ( float ) \u2013 Anode side recirculation flow (kg.s-1). Wv_asm_in ( float ) \u2013 Vapor flow at the anode supply manifold inlet (mol.s-1). Wv_aem_out ( float ) \u2013 Vapor flow at the anode external manifold outlet (mol.s-1). Wv_csm_in ( float ) \u2013 Vapor flow at the cathode supply manifold inlet (mol.s-1). Wv_cem_out ( float ) \u2013 Vapor flow at the cathode external manifold outlet (mol.s-1). Source code in model/auxiliaries.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def auxiliaries ( t , solver_variables , control_variables , i_fc , operating_inputs , parameters ): \"\"\"This function calculates the flows passing through the auxiliaries. Parameters ---------- t : float Time (s). solver_variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables : dict Variables controlled by the user. i_fc : float Fuel cell current density at time t (A.m-2). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- Jv_a_in : float Vapor flow at the anode gas channel inlet (mol.m-2.s-1). Jv_a_out : float Vapor flow at the anode gas channel outlet (mol.m-2.s-1). Jv_c_in : float Vapor flow at the cathode gas channel inlet (mol.m-2.s-1). Jv_c_out : float Vapor flow at the cathode gas channel outlet (mol.m-2.s-1). J_H2_in : float H2 flow at the anode gas channel inlet (mol.m-2.s-1). J_H2_out : float H2 flow at the anode gas channel outlet (mol.m-2.s-1). J_O2_in : float O2 flow at the cathode gas channel inlet (mol.m-2.s-1). J_O2_out : float O2 flow at the cathode gas channel outlet (mol.m-2.s-1). J_N2_in : float N2 flow at the cathode gas channel inlet (mol.m-2.s-1). J_N2_out : float N2 flow at the cathode gas channel outlet (mol.m-2.s-1). Wasm_in : float Anode side supply manifold inlet flow (kg.s-1). Wasm_out : float Anode side supply manifold outlet flow (kg.s-1). Waem_in : float Anode side external manifold inlet flow (kg.s-1). Waem_out : float Anode side external manifold outlet flow (kg.s-1). Wcsm_in : float Cathode side supply manifold inlet flow (kg.s-1). Wcsm_out : float Cathode side supply manifold outlet flow (kg.s-1). Wcem_in : float Cathode side external manifold inlet flow (kg.s-1). Wcem_out : float Cathode side external manifold outlet flow (kg.s-1). Ware : float Anode side recirculation flow (kg.s-1). Wv_asm_in : float Vapor flow at the anode supply manifold inlet (mol.s-1). Wv_aem_out : float Vapor flow at the anode external manifold outlet (mol.s-1). Wv_csm_in : float Vapor flow at the cathode supply manifold inlet (mol.s-1). Wv_cem_out : float Vapor flow at the cathode external manifold outlet (mol.s-1). \"\"\" # __________________________________________________Preliminaries___________________________________________________ # Extraction of the variables Pasm , Paem , Pcsm = solver_variables [ 'Pasm' ], solver_variables [ 'Paem' ], solver_variables [ 'Pcsm' ] Pcem , Phi_asm , Phi_aem = solver_variables [ 'Pcem' ], solver_variables [ 'Phi_asm' ], solver_variables [ 'Phi_aem' ] Phi_csm , Phi_cem = solver_variables [ 'Phi_csm' ], solver_variables [ 'Phi_cem' ] Wcp , Wa_inj , Wc_inj = solver_variables [ 'Wcp' ], solver_variables [ 'Wa_inj' ], solver_variables [ 'Wc_inj' ] # Extraction of the operating inputs and the parameters T_des , Pa_des , Pc_des = operating_inputs [ 'T_des' ], operating_inputs [ 'Pa_des' ], operating_inputs [ 'Pc_des' ] Sa , Sc = operating_inputs [ 'Sa' ], operating_inputs [ 'Sc' ] Phi_a_des , Phi_c_des = control_variables [ 'Phi_a_des' ], control_variables [ 'Phi_c_des' ] Aact , Hagc , Hcgc = parameters [ 'Aact' ], parameters [ 'Hagc' ], parameters [ 'Hcgc' ] Wagc , Wcgc , type_auxiliary = parameters [ 'Wagc' ], parameters [ 'Wcgc' ], parameters [ 'type_auxiliary' ] # Intermediate values Mext , Pagc , Pcgc , Phi_agc , Phi_cgc , y_cgc , Magc , Mcgc , Pr_aem , Pr_cem , \\ Maem , Masm , Mcem , Mcsm , k_purge , Abp_a , Abp_c , i_n = \\ auxiliaries_int_values ( t , solver_variables , operating_inputs , parameters ) # _________________________________________Inlet and outlet global flows____________________________________________ \"\"\"Global flows here refer to flows that integrate all the chemical species circulating together. Slight differences are to be noted in the expression of these flows depending on the type of auxiliary selected. \"\"\" # At the anode side if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : # Anode inlet Wasm_in = Ksm_in * ( Pa_des - Pasm ) # kg.s-1 Wasm_out = Ksm_out * ( Pasm - Pagc ) # kg.s-1 Ja_in = Wasm_out / ( Hagc * Wagc * Masm ) # mol.m-2.s-1 # Anode outlet Waem_in = Kem_in * ( Pagc - Paem ) # kg.s-1 Ware = n_cell * Maem * ( Paem / ( Paem - Phi_aem * Psat ( T_des ))) * ( Sa - 1 ) * ( i_fc + i_n ) / ( 2 * F ) * Aact # kg.s-1 Waem_out = k_purge * C_D * A_T * Paem / ( R * T_des ) ** 0.5 * Pr_aem ** ( 1 / gamma_H2 ) * \\ ( Magc * 2 * gamma_H2 / ( gamma_H2 - 1 ) * ( 1 - Pr_aem ** (( gamma_H2 - 1 ) / gamma_H2 ))) ** 0.5 # kg.s-1 Ja_out = Waem_in / ( Hagc * Wagc * Magc ) # mol.m-2.s-1 elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : # Anode inlet Wrd = n_cell * M_H2 * Sa * ( i_fc + i_n ) / ( 2 * F ) * Aact # kg.s-1 Wasm_in = Wrd + Wa_inj # kg.s-1 Wasm_out = Ksm_out * ( Pasm - Pagc ) # kg.s-1 Ja_in = Wasm_out / ( Hagc * Wagc * Masm ) # mol.m-2.s-1 # Anode outlet Waem_in = Kem_in * ( Pagc - Paem ) # kg.s-1 Ware = 0 # kg.s-1 Waem_out = C_D * Abp_a * Paem / ( R * T_des ) ** 0.5 * Pr_aem ** ( 1 / gamma_H2 ) * \\ ( Magc * 2 * gamma_H2 / ( gamma_H2 - 1 ) * ( 1 - Pr_aem ** (( gamma_H2 - 1 ) / gamma_H2 ))) ** 0.5 # kg.s-1 Ja_out = Waem_in / ( Hagc * Wagc * Magc ) # mol.m-2.s-1 else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): # Anode inlet Wasm_in , Wasm_out = 0 , 0 # kg.s-1 Ja_in = ( 1 + Phi_a_des * Psat ( T_des ) / ( Pagc - Phi_a_des * Psat ( T_des ))) * \\ Sa * ( i_fc + i_n ) / ( 2 * F ) * Aact / ( Hagc * Wagc ) # mol.m-2.s-1 # Anode outlet Waem_in , Ware , Waem_out = 0 , 0 , 0 # kg.s-1 Ja_out = Kem_in * ( Pagc - Pa_des ) / ( Hagc * Wagc * Magc ) # mol.m-2.s-1 # At the cathode side if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : # Cathode inlet Wcsm_in = Wcp + Wc_inj # kg.s-1 Wcsm_out = Ksm_out * ( Pcsm - Pcgc ) # kg.s-1 Jc_in = Wcsm_out / ( Hcgc * Wcgc * Mcsm ) # mol.m-2.s-1 # Cathode outlet Wcem_in = Kem_in * ( Pcgc - Pcem ) # kg.s-1 Wcem_out = C_D * Abp_c * Pcem / ( R * T_des ) ** 0.5 * Pr_cem ** ( 1 / gamma ) * \\ ( Mcgc * 2 * gamma / ( gamma - 1 ) * ( 1 - Pr_cem ** (( gamma - 1 ) / gamma ))) ** 0.5 # kg.s-1 Jc_out = Wcem_in / ( Hcgc * Wcgc * Mcgc ) # mol.m-2.s-1 else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): # Cathode inlet Wcsm_in , Wcsm_out = 0 , 0 # kg.s-1 Jc_in = ( 1 + Phi_c_des * Psat ( T_des ) / ( Pcgc - Phi_c_des * Psat ( T_des ))) * \\ 1 / yO2_ext * Sc * ( i_fc + i_n ) / ( 4 * F ) * Aact / ( Hcgc * Wcgc ) # mol.m-2.s-1 # Cathode outlet Wcem_in , Wcem_out = 0 , 0 # kg.s-1 Jc_out = Kem_in * ( Pcgc - Pc_des ) / ( Hcgc * Wcgc * Mcgc ) # mol.m-2.s-1 # ________________________________________Inlet and outlet specific flows___________________________________________ \"\"\"Specific flows here refer to flows that integrate only a single chemical species within the ensemble of species circulating together. For example, only the water vapor flow within the ensemble of hydrogen and water vapor. \"\"\" # Vapor flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : Jv_a_in = Phi_asm * Psat ( T_des ) / Pasm * Ja_in Jv_c_in = Phi_csm * Psat ( T_des ) / Pcsm * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": Jv_a_in = Phi_a_des * Psat ( T_des ) / Pagc * Ja_in Jv_c_in = Phi_c_des * Psat ( T_des ) / Pcgc * Jc_in Jv_a_out = Phi_agc * Psat ( T_des ) / Pagc * Ja_out Jv_c_out = Phi_cgc * Psat ( T_des ) / Pcgc * Jc_out # H2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : J_H2_in = ( 1 - Phi_asm * Psat ( T_des ) / Pasm ) * Ja_in else : # elif type_auxiliary == \"no_auxiliary\": J_H2_in = ( 1 - Phi_a_des * Psat ( T_des ) / Pagc ) * Ja_in J_H2_out = ( 1 - Phi_agc * Psat ( T_des ) / Pagc ) * Ja_out # O2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : J_O2_in = yO2_ext * ( 1 - Phi_csm * Psat ( T_des ) / Pcsm ) * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": J_O2_in = yO2_ext * ( 1 - Phi_c_des * Psat ( T_des ) / Pcgc ) * Jc_in J_O2_out = y_cgc * ( 1 - Phi_cgc * Psat ( T_des ) / Pcgc ) * Jc_out # N2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : J_N2_in = ( 1 - yO2_ext ) * ( 1 - Phi_csm * Psat ( T_des ) / Pcsm ) * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": J_N2_in = ( 1 - yO2_ext ) * ( 1 - Phi_c_des * Psat ( T_des ) / Pcgc ) * Jc_in J_N2_out = ( 1 - y_cgc ) * ( 1 - Phi_cgc * Psat ( T_des ) / Pcgc ) * Jc_out # Vapor flows at the manifold (mol.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : Wv_asm_in = Phi_aem * Psat ( T_des ) / Paem * ( Ware / Maem ) Wv_aem_out = Phi_aem * Psat ( T_des ) / Paem * ( Waem_out / Maem ) Wv_csm_in = Phi_ext * Psat ( Text ) / Pext * ( Wcp / Mext ) + Wc_inj / M_H2O Wv_cem_out = Phi_cem * Psat ( T_des ) / Pcem * ( Wcem_out / Mcem ) elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : Wv_asm_in = Wa_inj / M_H2O Wv_aem_out = Phi_aem * Psat ( T_des ) / Paem * ( Waem_out / Maem ) Wv_csm_in = Phi_ext * Psat ( Text ) / Pext * ( Wcp / Mext ) + Wc_inj / M_H2O Wv_cem_out = Phi_cem * Psat ( T_des ) / Pcem * ( Wcem_out / Mcem ) else : # elif type_auxiliary == \"no_auxiliary\": Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out = [ 0 ] * 4 return Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , \\ J_H2_in , J_H2_out , J_O2_in , J_O2_out , J_N2_in , J_N2_out , \\ Wasm_in , Wasm_out , Waem_in , Waem_out , Wcsm_in , Wcsm_out , Wcem_in , Wcem_out , Ware , \\ Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out","title":"Auxiliaries"},{"location":"functions/model/auxiliaries/#auxiliaries","text":"This file represents all the flows passing through the auxiliaries. It is a component of the fuel cell model.","title":"Auxiliaries"},{"location":"functions/model/auxiliaries/#model.auxiliaries.auxiliaries","text":"This function calculates the flows passing through the auxiliaries. Parameters: t ( float ) \u2013 Time (s). solver_variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables ( dict ) \u2013 Variables controlled by the user. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Jv_a_in ( float ) \u2013 Vapor flow at the anode gas channel inlet (mol.m-2.s-1). Jv_a_out ( float ) \u2013 Vapor flow at the anode gas channel outlet (mol.m-2.s-1). Jv_c_in ( float ) \u2013 Vapor flow at the cathode gas channel inlet (mol.m-2.s-1). Jv_c_out ( float ) \u2013 Vapor flow at the cathode gas channel outlet (mol.m-2.s-1). J_H2_in ( float ) \u2013 H2 flow at the anode gas channel inlet (mol.m-2.s-1). J_H2_out ( float ) \u2013 H2 flow at the anode gas channel outlet (mol.m-2.s-1). J_O2_in ( float ) \u2013 O2 flow at the cathode gas channel inlet (mol.m-2.s-1). J_O2_out ( float ) \u2013 O2 flow at the cathode gas channel outlet (mol.m-2.s-1). J_N2_in ( float ) \u2013 N2 flow at the cathode gas channel inlet (mol.m-2.s-1). J_N2_out ( float ) \u2013 N2 flow at the cathode gas channel outlet (mol.m-2.s-1). Wasm_in ( float ) \u2013 Anode side supply manifold inlet flow (kg.s-1). Wasm_out ( float ) \u2013 Anode side supply manifold outlet flow (kg.s-1). Waem_in ( float ) \u2013 Anode side external manifold inlet flow (kg.s-1). Waem_out ( float ) \u2013 Anode side external manifold outlet flow (kg.s-1). Wcsm_in ( float ) \u2013 Cathode side supply manifold inlet flow (kg.s-1). Wcsm_out ( float ) \u2013 Cathode side supply manifold outlet flow (kg.s-1). Wcem_in ( float ) \u2013 Cathode side external manifold inlet flow (kg.s-1). Wcem_out ( float ) \u2013 Cathode side external manifold outlet flow (kg.s-1). Ware ( float ) \u2013 Anode side recirculation flow (kg.s-1). Wv_asm_in ( float ) \u2013 Vapor flow at the anode supply manifold inlet (mol.s-1). Wv_aem_out ( float ) \u2013 Vapor flow at the anode external manifold outlet (mol.s-1). Wv_csm_in ( float ) \u2013 Vapor flow at the cathode supply manifold inlet (mol.s-1). Wv_cem_out ( float ) \u2013 Vapor flow at the cathode external manifold outlet (mol.s-1). Source code in model/auxiliaries.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def auxiliaries ( t , solver_variables , control_variables , i_fc , operating_inputs , parameters ): \"\"\"This function calculates the flows passing through the auxiliaries. Parameters ---------- t : float Time (s). solver_variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables : dict Variables controlled by the user. i_fc : float Fuel cell current density at time t (A.m-2). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- Jv_a_in : float Vapor flow at the anode gas channel inlet (mol.m-2.s-1). Jv_a_out : float Vapor flow at the anode gas channel outlet (mol.m-2.s-1). Jv_c_in : float Vapor flow at the cathode gas channel inlet (mol.m-2.s-1). Jv_c_out : float Vapor flow at the cathode gas channel outlet (mol.m-2.s-1). J_H2_in : float H2 flow at the anode gas channel inlet (mol.m-2.s-1). J_H2_out : float H2 flow at the anode gas channel outlet (mol.m-2.s-1). J_O2_in : float O2 flow at the cathode gas channel inlet (mol.m-2.s-1). J_O2_out : float O2 flow at the cathode gas channel outlet (mol.m-2.s-1). J_N2_in : float N2 flow at the cathode gas channel inlet (mol.m-2.s-1). J_N2_out : float N2 flow at the cathode gas channel outlet (mol.m-2.s-1). Wasm_in : float Anode side supply manifold inlet flow (kg.s-1). Wasm_out : float Anode side supply manifold outlet flow (kg.s-1). Waem_in : float Anode side external manifold inlet flow (kg.s-1). Waem_out : float Anode side external manifold outlet flow (kg.s-1). Wcsm_in : float Cathode side supply manifold inlet flow (kg.s-1). Wcsm_out : float Cathode side supply manifold outlet flow (kg.s-1). Wcem_in : float Cathode side external manifold inlet flow (kg.s-1). Wcem_out : float Cathode side external manifold outlet flow (kg.s-1). Ware : float Anode side recirculation flow (kg.s-1). Wv_asm_in : float Vapor flow at the anode supply manifold inlet (mol.s-1). Wv_aem_out : float Vapor flow at the anode external manifold outlet (mol.s-1). Wv_csm_in : float Vapor flow at the cathode supply manifold inlet (mol.s-1). Wv_cem_out : float Vapor flow at the cathode external manifold outlet (mol.s-1). \"\"\" # __________________________________________________Preliminaries___________________________________________________ # Extraction of the variables Pasm , Paem , Pcsm = solver_variables [ 'Pasm' ], solver_variables [ 'Paem' ], solver_variables [ 'Pcsm' ] Pcem , Phi_asm , Phi_aem = solver_variables [ 'Pcem' ], solver_variables [ 'Phi_asm' ], solver_variables [ 'Phi_aem' ] Phi_csm , Phi_cem = solver_variables [ 'Phi_csm' ], solver_variables [ 'Phi_cem' ] Wcp , Wa_inj , Wc_inj = solver_variables [ 'Wcp' ], solver_variables [ 'Wa_inj' ], solver_variables [ 'Wc_inj' ] # Extraction of the operating inputs and the parameters T_des , Pa_des , Pc_des = operating_inputs [ 'T_des' ], operating_inputs [ 'Pa_des' ], operating_inputs [ 'Pc_des' ] Sa , Sc = operating_inputs [ 'Sa' ], operating_inputs [ 'Sc' ] Phi_a_des , Phi_c_des = control_variables [ 'Phi_a_des' ], control_variables [ 'Phi_c_des' ] Aact , Hagc , Hcgc = parameters [ 'Aact' ], parameters [ 'Hagc' ], parameters [ 'Hcgc' ] Wagc , Wcgc , type_auxiliary = parameters [ 'Wagc' ], parameters [ 'Wcgc' ], parameters [ 'type_auxiliary' ] # Intermediate values Mext , Pagc , Pcgc , Phi_agc , Phi_cgc , y_cgc , Magc , Mcgc , Pr_aem , Pr_cem , \\ Maem , Masm , Mcem , Mcsm , k_purge , Abp_a , Abp_c , i_n = \\ auxiliaries_int_values ( t , solver_variables , operating_inputs , parameters ) # _________________________________________Inlet and outlet global flows____________________________________________ \"\"\"Global flows here refer to flows that integrate all the chemical species circulating together. Slight differences are to be noted in the expression of these flows depending on the type of auxiliary selected. \"\"\" # At the anode side if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : # Anode inlet Wasm_in = Ksm_in * ( Pa_des - Pasm ) # kg.s-1 Wasm_out = Ksm_out * ( Pasm - Pagc ) # kg.s-1 Ja_in = Wasm_out / ( Hagc * Wagc * Masm ) # mol.m-2.s-1 # Anode outlet Waem_in = Kem_in * ( Pagc - Paem ) # kg.s-1 Ware = n_cell * Maem * ( Paem / ( Paem - Phi_aem * Psat ( T_des ))) * ( Sa - 1 ) * ( i_fc + i_n ) / ( 2 * F ) * Aact # kg.s-1 Waem_out = k_purge * C_D * A_T * Paem / ( R * T_des ) ** 0.5 * Pr_aem ** ( 1 / gamma_H2 ) * \\ ( Magc * 2 * gamma_H2 / ( gamma_H2 - 1 ) * ( 1 - Pr_aem ** (( gamma_H2 - 1 ) / gamma_H2 ))) ** 0.5 # kg.s-1 Ja_out = Waem_in / ( Hagc * Wagc * Magc ) # mol.m-2.s-1 elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : # Anode inlet Wrd = n_cell * M_H2 * Sa * ( i_fc + i_n ) / ( 2 * F ) * Aact # kg.s-1 Wasm_in = Wrd + Wa_inj # kg.s-1 Wasm_out = Ksm_out * ( Pasm - Pagc ) # kg.s-1 Ja_in = Wasm_out / ( Hagc * Wagc * Masm ) # mol.m-2.s-1 # Anode outlet Waem_in = Kem_in * ( Pagc - Paem ) # kg.s-1 Ware = 0 # kg.s-1 Waem_out = C_D * Abp_a * Paem / ( R * T_des ) ** 0.5 * Pr_aem ** ( 1 / gamma_H2 ) * \\ ( Magc * 2 * gamma_H2 / ( gamma_H2 - 1 ) * ( 1 - Pr_aem ** (( gamma_H2 - 1 ) / gamma_H2 ))) ** 0.5 # kg.s-1 Ja_out = Waem_in / ( Hagc * Wagc * Magc ) # mol.m-2.s-1 else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): # Anode inlet Wasm_in , Wasm_out = 0 , 0 # kg.s-1 Ja_in = ( 1 + Phi_a_des * Psat ( T_des ) / ( Pagc - Phi_a_des * Psat ( T_des ))) * \\ Sa * ( i_fc + i_n ) / ( 2 * F ) * Aact / ( Hagc * Wagc ) # mol.m-2.s-1 # Anode outlet Waem_in , Ware , Waem_out = 0 , 0 , 0 # kg.s-1 Ja_out = Kem_in * ( Pagc - Pa_des ) / ( Hagc * Wagc * Magc ) # mol.m-2.s-1 # At the cathode side if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : # Cathode inlet Wcsm_in = Wcp + Wc_inj # kg.s-1 Wcsm_out = Ksm_out * ( Pcsm - Pcgc ) # kg.s-1 Jc_in = Wcsm_out / ( Hcgc * Wcgc * Mcsm ) # mol.m-2.s-1 # Cathode outlet Wcem_in = Kem_in * ( Pcgc - Pcem ) # kg.s-1 Wcem_out = C_D * Abp_c * Pcem / ( R * T_des ) ** 0.5 * Pr_cem ** ( 1 / gamma ) * \\ ( Mcgc * 2 * gamma / ( gamma - 1 ) * ( 1 - Pr_cem ** (( gamma - 1 ) / gamma ))) ** 0.5 # kg.s-1 Jc_out = Wcem_in / ( Hcgc * Wcgc * Mcgc ) # mol.m-2.s-1 else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): # Cathode inlet Wcsm_in , Wcsm_out = 0 , 0 # kg.s-1 Jc_in = ( 1 + Phi_c_des * Psat ( T_des ) / ( Pcgc - Phi_c_des * Psat ( T_des ))) * \\ 1 / yO2_ext * Sc * ( i_fc + i_n ) / ( 4 * F ) * Aact / ( Hcgc * Wcgc ) # mol.m-2.s-1 # Cathode outlet Wcem_in , Wcem_out = 0 , 0 # kg.s-1 Jc_out = Kem_in * ( Pcgc - Pc_des ) / ( Hcgc * Wcgc * Mcgc ) # mol.m-2.s-1 # ________________________________________Inlet and outlet specific flows___________________________________________ \"\"\"Specific flows here refer to flows that integrate only a single chemical species within the ensemble of species circulating together. For example, only the water vapor flow within the ensemble of hydrogen and water vapor. \"\"\" # Vapor flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : Jv_a_in = Phi_asm * Psat ( T_des ) / Pasm * Ja_in Jv_c_in = Phi_csm * Psat ( T_des ) / Pcsm * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": Jv_a_in = Phi_a_des * Psat ( T_des ) / Pagc * Ja_in Jv_c_in = Phi_c_des * Psat ( T_des ) / Pcgc * Jc_in Jv_a_out = Phi_agc * Psat ( T_des ) / Pagc * Ja_out Jv_c_out = Phi_cgc * Psat ( T_des ) / Pcgc * Jc_out # H2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : J_H2_in = ( 1 - Phi_asm * Psat ( T_des ) / Pasm ) * Ja_in else : # elif type_auxiliary == \"no_auxiliary\": J_H2_in = ( 1 - Phi_a_des * Psat ( T_des ) / Pagc ) * Ja_in J_H2_out = ( 1 - Phi_agc * Psat ( T_des ) / Pagc ) * Ja_out # O2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : J_O2_in = yO2_ext * ( 1 - Phi_csm * Psat ( T_des ) / Pcsm ) * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": J_O2_in = yO2_ext * ( 1 - Phi_c_des * Psat ( T_des ) / Pcgc ) * Jc_in J_O2_out = y_cgc * ( 1 - Phi_cgc * Psat ( T_des ) / Pcgc ) * Jc_out # N2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : J_N2_in = ( 1 - yO2_ext ) * ( 1 - Phi_csm * Psat ( T_des ) / Pcsm ) * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": J_N2_in = ( 1 - yO2_ext ) * ( 1 - Phi_c_des * Psat ( T_des ) / Pcgc ) * Jc_in J_N2_out = ( 1 - y_cgc ) * ( 1 - Phi_cgc * Psat ( T_des ) / Pcgc ) * Jc_out # Vapor flows at the manifold (mol.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : Wv_asm_in = Phi_aem * Psat ( T_des ) / Paem * ( Ware / Maem ) Wv_aem_out = Phi_aem * Psat ( T_des ) / Paem * ( Waem_out / Maem ) Wv_csm_in = Phi_ext * Psat ( Text ) / Pext * ( Wcp / Mext ) + Wc_inj / M_H2O Wv_cem_out = Phi_cem * Psat ( T_des ) / Pcem * ( Wcem_out / Mcem ) elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : Wv_asm_in = Wa_inj / M_H2O Wv_aem_out = Phi_aem * Psat ( T_des ) / Paem * ( Waem_out / Maem ) Wv_csm_in = Phi_ext * Psat ( Text ) / Pext * ( Wcp / Mext ) + Wc_inj / M_H2O Wv_cem_out = Phi_cem * Psat ( T_des ) / Pcem * ( Wcem_out / Mcem ) else : # elif type_auxiliary == \"no_auxiliary\": Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out = [ 0 ] * 4 return Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , \\ J_H2_in , J_H2_out , J_O2_in , J_O2_out , J_N2_in , J_N2_out , \\ Wasm_in , Wasm_out , Waem_in , Waem_out , Wcsm_in , Wcsm_out , Wcem_in , Wcem_out , Ware , \\ Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out","title":"auxiliaries"},{"location":"functions/model/cell_voltage/","text":"Cell voltage This file represents the equations for calculating the cell voltage. It is a component of the fuel cell model. calculate_cell_voltage ( variables , operating_inputs , parameters ) This function calculates the cell voltage at each time step. Parameters: variables ( dict ) \u2013 The dictionary containing the variables calculated by the solver. operating_inputs ( dict ) \u2013 The dictionary containing the operating inputs. parameters ( dict ) \u2013 The dictionary containing the parameters. Returns: Ucell_t ( list ) \u2013 The cell voltage at each time step. Source code in model/cell_voltage.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def calculate_cell_voltage ( variables , operating_inputs , parameters ): \"\"\"This function calculates the cell voltage at each time step. Parameters ---------- variables : dict The dictionary containing the variables calculated by the solver. operating_inputs : dict The dictionary containing the operating inputs. parameters : dict The dictionary containing the parameters. Returns ------- Ucell_t : list The cell voltage at each time step. \"\"\" # Extraction of the variables t , lambda_mem_t , lambda_ccl_t = variables [ 't' ], variables [ 'lambda_mem' ], variables [ 'lambda_ccl' ] C_H2_acl_t , C_O2_ccl_t , eta_c_t = variables [ 'C_H2_acl' ], variables [ 'C_O2_ccl' ], variables [ 'eta_c' ] T_acl_t , T_mem_t , T_ccl_t = variables [ 'T_acl' ], variables [ 'T_mem' ], variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_mc , kappa_co = parameters [ 'epsilon_mc' ], parameters [ 'kappa_co' ] # Initialisation n = len ( t ) Ucell_t = [ 0 ] * n # Loop for having Ucell_t at each time step for i in range ( n ): # Recovery of the already calculated variable values at each time step lambda_mem , lambda_ccl = lambda_mem_t [ i ], lambda_ccl_t [ i ] C_H2_acl , C_O2_ccl = C_H2_acl_t [ i ], C_O2_ccl_t [ i ] T_acl , T_mem , T_ccl = T_acl_t [ i ], T_mem_t [ i ], T_ccl_t [ i ] eta_c = eta_c_t [ i ] # Current density value at this time step i_fc = operating_inputs [ 'current_density' ]( t [ i ], parameters ) # The equilibrium potential Ueq = E0 - 8.5e-4 * ( T_ccl - 298.15 ) + R * T_ccl / ( 2 * F ) * ( math . log ( R * T_acl * C_H2_acl / Pref ) + 0.5 * math . log ( R * T_ccl * C_O2_ccl / Pref )) # The crossover current density T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # The proton resistance # The proton resistance at the membrane : Rmem Rmem = Hmem / sigma_p_eff ( 'mem' , lambda_mem , T_mem ) # The proton resistance at the cathode catalyst layer : Rccl Rccl = Hccl / sigma_p_eff ( 'ccl' , lambda_ccl , T_ccl , epsilon_mc ) # The total proton resistance Rp = Rmem + Rccl # its value is around [4-7]e-6 ohm.m\u00b2. # The cell voltage Ucell_t [ i ] = Ueq - eta_c - ( i_fc + i_n ) * ( Rp + Re ) return Ucell_t calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ) This function calculates the intermediate values needed for the calculation of the cathode overpotential dynamic evolution. Parameters: solver_variables ( dict ) \u2013 The dictionary containing the variables calculated by the solver. operating_inputs ( dict ) \u2013 The dictionary containing the operating inputs. parameters ( dict ) \u2013 The dictionary containing the parameters. Returns: dict \u2013 The dictionary containing the crossover current density i_n at time t, and the liquid water induced voltage drop function f_drop at time t. Source code in model/cell_voltage.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ): \"\"\"This function calculates the intermediate values needed for the calculation of the cathode overpotential dynamic evolution. Parameters ---------- solver_variables : dict The dictionary containing the variables calculated by the solver. operating_inputs : dict The dictionary containing the operating inputs. parameters : dict The dictionary containing the parameters. Returns ------- dict The dictionary containing the crossover current density i_n at time t, and the liquid water induced voltage drop function f_drop at time t. \"\"\" # Extraction of the variables s_ccl , lambda_mem = solver_variables [ 's_ccl' ], solver_variables [ 'lambda_mem' ] C_H2_acl , C_O2_ccl = solver_variables [ 'C_H2_acl' ], solver_variables [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = solver_variables [ 'T_acl' ], solver_variables [ 'T_mem' ], solver_variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters Pc_des = operating_inputs [ 'Pc_des' ] Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] i0_c_ref , kappa_co , kappa_c = parameters [ 'i0_c_ref' ], parameters [ 'kappa_co' ], parameters [ 'kappa_c' ] a_slim , b_slim , a_switch = parameters [ 'a_slim' ], parameters [ 'b_slim' ], parameters [ 'a_switch' ] # The crossover current density i_n T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # The liquid water induced voltage drop function f_drop slim = a_slim * ( Pc_des / 1e5 ) + b_slim s_switch = a_switch * slim f_drop = 0.5 * ( 1.0 - math . tanh (( 4 * s_ccl - 2 * slim - 2 * s_switch ) / ( slim - s_switch ))) return { 'i_n' : i_n , 'f_drop' : f_drop }","title":"Cell voltage"},{"location":"functions/model/cell_voltage/#cell-voltage","text":"This file represents the equations for calculating the cell voltage. It is a component of the fuel cell model.","title":"Cell voltage"},{"location":"functions/model/cell_voltage/#model.cell_voltage.calculate_cell_voltage","text":"This function calculates the cell voltage at each time step. Parameters: variables ( dict ) \u2013 The dictionary containing the variables calculated by the solver. operating_inputs ( dict ) \u2013 The dictionary containing the operating inputs. parameters ( dict ) \u2013 The dictionary containing the parameters. Returns: Ucell_t ( list ) \u2013 The cell voltage at each time step. Source code in model/cell_voltage.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def calculate_cell_voltage ( variables , operating_inputs , parameters ): \"\"\"This function calculates the cell voltage at each time step. Parameters ---------- variables : dict The dictionary containing the variables calculated by the solver. operating_inputs : dict The dictionary containing the operating inputs. parameters : dict The dictionary containing the parameters. Returns ------- Ucell_t : list The cell voltage at each time step. \"\"\" # Extraction of the variables t , lambda_mem_t , lambda_ccl_t = variables [ 't' ], variables [ 'lambda_mem' ], variables [ 'lambda_ccl' ] C_H2_acl_t , C_O2_ccl_t , eta_c_t = variables [ 'C_H2_acl' ], variables [ 'C_O2_ccl' ], variables [ 'eta_c' ] T_acl_t , T_mem_t , T_ccl_t = variables [ 'T_acl' ], variables [ 'T_mem' ], variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_mc , kappa_co = parameters [ 'epsilon_mc' ], parameters [ 'kappa_co' ] # Initialisation n = len ( t ) Ucell_t = [ 0 ] * n # Loop for having Ucell_t at each time step for i in range ( n ): # Recovery of the already calculated variable values at each time step lambda_mem , lambda_ccl = lambda_mem_t [ i ], lambda_ccl_t [ i ] C_H2_acl , C_O2_ccl = C_H2_acl_t [ i ], C_O2_ccl_t [ i ] T_acl , T_mem , T_ccl = T_acl_t [ i ], T_mem_t [ i ], T_ccl_t [ i ] eta_c = eta_c_t [ i ] # Current density value at this time step i_fc = operating_inputs [ 'current_density' ]( t [ i ], parameters ) # The equilibrium potential Ueq = E0 - 8.5e-4 * ( T_ccl - 298.15 ) + R * T_ccl / ( 2 * F ) * ( math . log ( R * T_acl * C_H2_acl / Pref ) + 0.5 * math . log ( R * T_ccl * C_O2_ccl / Pref )) # The crossover current density T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # The proton resistance # The proton resistance at the membrane : Rmem Rmem = Hmem / sigma_p_eff ( 'mem' , lambda_mem , T_mem ) # The proton resistance at the cathode catalyst layer : Rccl Rccl = Hccl / sigma_p_eff ( 'ccl' , lambda_ccl , T_ccl , epsilon_mc ) # The total proton resistance Rp = Rmem + Rccl # its value is around [4-7]e-6 ohm.m\u00b2. # The cell voltage Ucell_t [ i ] = Ueq - eta_c - ( i_fc + i_n ) * ( Rp + Re ) return Ucell_t","title":"calculate_cell_voltage"},{"location":"functions/model/cell_voltage/#model.cell_voltage.calculate_eta_c_intermediate_values","text":"This function calculates the intermediate values needed for the calculation of the cathode overpotential dynamic evolution. Parameters: solver_variables ( dict ) \u2013 The dictionary containing the variables calculated by the solver. operating_inputs ( dict ) \u2013 The dictionary containing the operating inputs. parameters ( dict ) \u2013 The dictionary containing the parameters. Returns: dict \u2013 The dictionary containing the crossover current density i_n at time t, and the liquid water induced voltage drop function f_drop at time t. Source code in model/cell_voltage.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ): \"\"\"This function calculates the intermediate values needed for the calculation of the cathode overpotential dynamic evolution. Parameters ---------- solver_variables : dict The dictionary containing the variables calculated by the solver. operating_inputs : dict The dictionary containing the operating inputs. parameters : dict The dictionary containing the parameters. Returns ------- dict The dictionary containing the crossover current density i_n at time t, and the liquid water induced voltage drop function f_drop at time t. \"\"\" # Extraction of the variables s_ccl , lambda_mem = solver_variables [ 's_ccl' ], solver_variables [ 'lambda_mem' ] C_H2_acl , C_O2_ccl = solver_variables [ 'C_H2_acl' ], solver_variables [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = solver_variables [ 'T_acl' ], solver_variables [ 'T_mem' ], solver_variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters Pc_des = operating_inputs [ 'Pc_des' ] Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] i0_c_ref , kappa_co , kappa_c = parameters [ 'i0_c_ref' ], parameters [ 'kappa_co' ], parameters [ 'kappa_c' ] a_slim , b_slim , a_switch = parameters [ 'a_slim' ], parameters [ 'b_slim' ], parameters [ 'a_switch' ] # The crossover current density i_n T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # The liquid water induced voltage drop function f_drop slim = a_slim * ( Pc_des / 1e5 ) + b_slim s_switch = a_switch * slim f_drop = 0.5 * ( 1.0 - math . tanh (( 4 * s_ccl - 2 * slim - 2 * s_switch ) / ( slim - s_switch ))) return { 'i_n' : i_n , 'f_drop' : f_drop }","title":"calculate_eta_c_intermediate_values"},{"location":"functions/model/control/","text":"Control This module contains the function that control the operating conditions of the MEA system. control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ) This function controls the operating conditions of the MEA system, if required. This is an elementary rule-based control, serving as a demonstrator. It will need to be improved in the future. Parameters: t ( float ) \u2013 Time (s). solver_variables ( dict ) \u2013 Dictionary containing the solver variables. operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs. parameters ( dict ) \u2013 Dictionary containing the parameters. control_variables ( dict ) \u2013 Dictionary containing the control variables. Source code in model/control.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ): \"\"\"This function controls the operating conditions of the MEA system, if required. This is an elementary rule-based control, serving as a demonstrator. It will need to be improved in the future. Parameters ---------- t : float Time (s). solver_variables : dict Dictionary containing the solver variables. operating_inputs : dict Dictionary containing the operating inputs. parameters : dict Dictionary containing the parameters. control_variables : dict Dictionary containing the control variables. \"\"\" if parameters [ \"type_control\" ] != \"Phi_des\" : raise ValueError ( 'You have to specify a type_control which is accepted.' ) elif parameters [ \"type_control\" ] == \"Phi_des\" : # Initialisation delta_t_control_Phi = 20 # s. Every delta_t_control_Phi second the cell humidity is controlled. delta_Phi_des = 0.01 # Arbitrary value for the step change of Phi_des. slim = parameters [ 'a_slim' ] * ( operating_inputs [ 'Pc_des' ] / 1e5 ) + parameters [ 'b_slim' ] s_ccl_max = 0.55 * slim # An arbitrary margin for s_ccl is established to ensure the CCL is not too flooded. # I may take s_switch instead of 0.55 ? lambda_mem_min = 8 # An arbitrary margin for lambda_mem is established to ensure the membrane is not too dry. # Control on Phi_des # Every delta_t_control_Phi second, Phi_a_des is monitored for controlling the cell humidity. if t > ( control_variables [ 't_control_Phi' ] + delta_t_control_Phi ): # s. control_variables [ 't_control_Phi' ] = control_variables [ 't_control_Phi' ] + delta_t_control_Phi # Flooding is likely. if solver_variables [ 's_ccl' ] > s_ccl_max and solver_variables [ 'lambda_mem' ] > lambda_mem_min : if control_variables [ 'Phi_a_des' ] - delta_Phi_des >= 0 : control_variables [ 'Phi_a_des' ] = control_variables [ 'Phi_a_des' ] - delta_Phi_des if control_variables [ 'Phi_c_des' ] - delta_Phi_des >= 0 : control_variables [ 'Phi_c_des' ] = control_variables [ 'Phi_c_des' ] - delta_Phi_des # Drying out is likely. elif solver_variables [ 'lambda_mem' ] < lambda_mem_min and solver_variables [ 's_ccl' ] < s_ccl_max : if control_variables [ 'Phi_a_des' ] + delta_Phi_des <= 1 : control_variables [ 'Phi_a_des' ] = control_variables [ 'Phi_a_des' ] + delta_Phi_des if control_variables [ 'Phi_c_des' ] + delta_Phi_des <= 1 : control_variables [ 'Phi_c_des' ] = control_variables [ 'Phi_c_des' ] + delta_Phi_des # Both flooding and drying out are likely. Nothing can be done. elif solver_variables [ 's_ccl' ] > s_ccl_max and solver_variables [ 'lambda_mem' ] < lambda_mem_min : pass # Both flooding and drying out are unlikely. It is the desired situation. else : # elif solver_variables['s_ccl'] < s_ccl_max and solver_variables['lambda_mem'] > lambda_mem_min: pass","title":"Control"},{"location":"functions/model/control/#control","text":"This module contains the function that control the operating conditions of the MEA system.","title":"Control"},{"location":"functions/model/control/#model.control.control_operating_conditions","text":"This function controls the operating conditions of the MEA system, if required. This is an elementary rule-based control, serving as a demonstrator. It will need to be improved in the future. Parameters: t ( float ) \u2013 Time (s). solver_variables ( dict ) \u2013 Dictionary containing the solver variables. operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs. parameters ( dict ) \u2013 Dictionary containing the parameters. control_variables ( dict ) \u2013 Dictionary containing the control variables. Source code in model/control.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ): \"\"\"This function controls the operating conditions of the MEA system, if required. This is an elementary rule-based control, serving as a demonstrator. It will need to be improved in the future. Parameters ---------- t : float Time (s). solver_variables : dict Dictionary containing the solver variables. operating_inputs : dict Dictionary containing the operating inputs. parameters : dict Dictionary containing the parameters. control_variables : dict Dictionary containing the control variables. \"\"\" if parameters [ \"type_control\" ] != \"Phi_des\" : raise ValueError ( 'You have to specify a type_control which is accepted.' ) elif parameters [ \"type_control\" ] == \"Phi_des\" : # Initialisation delta_t_control_Phi = 20 # s. Every delta_t_control_Phi second the cell humidity is controlled. delta_Phi_des = 0.01 # Arbitrary value for the step change of Phi_des. slim = parameters [ 'a_slim' ] * ( operating_inputs [ 'Pc_des' ] / 1e5 ) + parameters [ 'b_slim' ] s_ccl_max = 0.55 * slim # An arbitrary margin for s_ccl is established to ensure the CCL is not too flooded. # I may take s_switch instead of 0.55 ? lambda_mem_min = 8 # An arbitrary margin for lambda_mem is established to ensure the membrane is not too dry. # Control on Phi_des # Every delta_t_control_Phi second, Phi_a_des is monitored for controlling the cell humidity. if t > ( control_variables [ 't_control_Phi' ] + delta_t_control_Phi ): # s. control_variables [ 't_control_Phi' ] = control_variables [ 't_control_Phi' ] + delta_t_control_Phi # Flooding is likely. if solver_variables [ 's_ccl' ] > s_ccl_max and solver_variables [ 'lambda_mem' ] > lambda_mem_min : if control_variables [ 'Phi_a_des' ] - delta_Phi_des >= 0 : control_variables [ 'Phi_a_des' ] = control_variables [ 'Phi_a_des' ] - delta_Phi_des if control_variables [ 'Phi_c_des' ] - delta_Phi_des >= 0 : control_variables [ 'Phi_c_des' ] = control_variables [ 'Phi_c_des' ] - delta_Phi_des # Drying out is likely. elif solver_variables [ 'lambda_mem' ] < lambda_mem_min and solver_variables [ 's_ccl' ] < s_ccl_max : if control_variables [ 'Phi_a_des' ] + delta_Phi_des <= 1 : control_variables [ 'Phi_a_des' ] = control_variables [ 'Phi_a_des' ] + delta_Phi_des if control_variables [ 'Phi_c_des' ] + delta_Phi_des <= 1 : control_variables [ 'Phi_c_des' ] = control_variables [ 'Phi_c_des' ] + delta_Phi_des # Both flooding and drying out are likely. Nothing can be done. elif solver_variables [ 's_ccl' ] > s_ccl_max and solver_variables [ 'lambda_mem' ] < lambda_mem_min : pass # Both flooding and drying out are unlikely. It is the desired situation. else : # elif solver_variables['s_ccl'] < s_ccl_max and solver_variables['lambda_mem'] > lambda_mem_min: pass","title":"control_operating_conditions"},{"location":"functions/model/dif_eq/","text":"Differential equations This file represents all the differential equations used for the fuel cell model. calculate_dyn_H2_O2_N2_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , Hagc , Hcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , J_H2_in , J_H2_out , J_O2_in , J_O2_out , J_N2_in , J_N2_out , J_H2_agc_agdl , J_H2_agdl_agdl , J_H2_agdl_ampl , J_H2_ampl_acl , J_O2_ccl_cmpl , J_O2_cmpl_cgdl , J_O2_cgdl_cgdl , J_O2_cgdl_cgc , S_H2_acl , S_O2_ccl , ** kwargs ) This function calculates the dynamic evolution of the hydrogen, oxygen and nitrogen in the gas channels, the gas diffusion layers and the catalyst layers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer (m). Hmpl ( float ) \u2013 Thickness of the microporous layer (m). Hacl ( float ) \u2013 Thickness of the anode catalyst layer (m). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). Hagc ( float ) \u2013 Thickness of the anode gas channel (m). Hcgc ( float ) \u2013 Thickness of the cathode gas channel (m). Lgc ( float ) \u2013 Length of the gas channel (m). epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_cl ( float ) \u2013 Anode/cathode CL porosity. epsilon_mpl ( float ) \u2013 Anode/cathode MPL porosity. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. J_H2_in ( float ) \u2013 Hydrogen flow at the anode inlet (mol.m-2.s-1). J_H2_out ( float ) \u2013 Hydrogen flow at the anode outlet (mol.m-2.s-1). J_O2_in ( float ) \u2013 Oxygen flow at the cathode inlet (mol.m-2.s-1). J_O2_out ( float ) \u2013 Oxygen flow at the cathode outlet (mol.m-2.s-1). J_N2_in ( float ) \u2013 Nitrogen flow at the cathode inlet (mol.m-2.s-1). J_N2_out ( float ) \u2013 Nitrogen flow at the cathode outlet (mol.m-2.s-1). J_H2_agc_agdl ( float ) \u2013 Hydrogen flow between the anode gas channel and the anode GDL (mol.m-2.s-1). J_H2_agdl_agdl ( list ) \u2013 Hydrogen flow between two nodes of the anode GDL (mol.m-2.s-1). J_H2_agdl_ampl ( float ) \u2013 Hydrogen flow between the last node of the anode GDL and the anode microporous layer (mol.m-2.s-1). J_H2_ampl_acl ( float ) \u2013 Hydrogen flow between the anode microporous layer and the anode catalyst layer (mol.m-2.s-1). J_O2_ccl_cmpl ( float ) \u2013 Oxygen flow between the cathode catalyst layer and the cathode microporous layer (mol.m-2.s-1). J_O2_cmpl_cgdl ( float ) \u2013 Oxygen flow between the cathode microporous layer and the first node of the cathode GDL (mol.m-2.s-1). J_O2_cgdl_cgdl ( list ) \u2013 Oxygen flow between two nodes of the cathode GDL (mol.m-2.s-1). J_O2_cgdl_cgc ( float ) \u2013 Oxygen flow between the cathode GDL and the cathode gas channel (mol.m-2.s-1). S_H2_acl ( float ) \u2013 Hydrogen consumed in the anode CL (mol.m-3.s-1). S_O2_ccl ( float ) \u2013 Oxygen consumed in the cathode CL (mol.m-3.s-1). Source code in model/dif_eq.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def calculate_dyn_H2_O2_N2_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , Hagc , Hcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , J_H2_in , J_H2_out , J_O2_in , J_O2_out , J_N2_in , J_N2_out , J_H2_agc_agdl , J_H2_agdl_agdl , J_H2_agdl_ampl , J_H2_ampl_acl , J_O2_ccl_cmpl , J_O2_cmpl_cgdl , J_O2_cgdl_cgdl , J_O2_cgdl_cgc , S_H2_acl , S_O2_ccl , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the hydrogen, oxygen and nitrogen in the gas channels, the gas diffusion layers and the catalyst layers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl : float Thickness of the gas diffusion layer (m). Hmpl : float Thickness of the microporous layer (m). Hacl : float Thickness of the anode catalyst layer (m). Hccl : float Thickness of the cathode catalyst layer (m). Hagc : float Thickness of the anode gas channel (m). Hcgc : float Thickness of the cathode gas channel (m). Lgc : float Length of the gas channel (m). epsilon_gdl : float Anode/cathode GDL porosity. epsilon_cl : float Anode/cathode CL porosity. epsilon_mpl : float Anode/cathode MPL porosity. n_gdl : int Number of model nodes placed inside each GDL. J_H2_in : float Hydrogen flow at the anode inlet (mol.m-2.s-1). J_H2_out : float Hydrogen flow at the anode outlet (mol.m-2.s-1). J_O2_in : float Oxygen flow at the cathode inlet (mol.m-2.s-1). J_O2_out : float Oxygen flow at the cathode outlet (mol.m-2.s-1). J_N2_in : float Nitrogen flow at the cathode inlet (mol.m-2.s-1). J_N2_out : float Nitrogen flow at the cathode outlet (mol.m-2.s-1). J_H2_agc_agdl : float Hydrogen flow between the anode gas channel and the anode GDL (mol.m-2.s-1). J_H2_agdl_agdl : list Hydrogen flow between two nodes of the anode GDL (mol.m-2.s-1). J_H2_agdl_ampl : float Hydrogen flow between the last node of the anode GDL and the anode microporous layer (mol.m-2.s-1). J_H2_ampl_acl : float Hydrogen flow between the anode microporous layer and the anode catalyst layer (mol.m-2.s-1). J_O2_ccl_cmpl : float Oxygen flow between the cathode catalyst layer and the cathode microporous layer (mol.m-2.s-1). J_O2_cmpl_cgdl : float Oxygen flow between the cathode microporous layer and the first node of the cathode GDL (mol.m-2.s-1). J_O2_cgdl_cgdl : list Oxygen flow between two nodes of the cathode GDL (mol.m-2.s-1). J_O2_cgdl_cgc : float Oxygen flow between the cathode GDL and the cathode gas channel (mol.m-2.s-1). S_H2_acl : float Hydrogen consumed in the anode CL (mol.m-3.s-1). S_O2_ccl : float Oxygen consumed in the cathode CL (mol.m-3.s-1). \"\"\" # At the anode side # Inside the AGC dif_eq [ 'dC_H2_agc / dt' ] = ( J_H2_in - J_H2_out ) / Lgc - J_H2_agc_agdl / Hagc # Inside the AGDL dif_eq [ 'dC_H2_agdl_1 / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ 's_agdl_1' ])) * \\ ( J_H2_agc_agdl - J_H2_agdl_agdl [ 1 ]) / ( Hgdl / n_gdl ) for i in range ( 2 , n_gdl ): dif_eq [ f 'dC_H2_agdl_ { i } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_agdl_ { i } ' ])) * \\ ( J_H2_agdl_agdl [ i - 1 ] - J_H2_agdl_agdl [ i ]) / ( Hgdl / n_gdl ) dif_eq [ f 'dC_H2_agdl_ { n_gdl } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_agdl_ { n_gdl } ' ])) * \\ ( J_H2_agdl_agdl [ n_gdl - 1 ] - J_H2_agdl_ampl ) / ( Hgdl / n_gdl ) # Inside the AMPL dif_eq [ 'dC_H2_ampl / dt' ] = 1 / ( epsilon_mpl * ( 1 - sv [ 's_ampl' ])) * ( J_H2_agdl_ampl - J_H2_ampl_acl ) / Hmpl # Inside the ACL dif_eq [ 'dC_H2_acl / dt' ] = 1 / ( epsilon_cl * ( 1 - sv [ 's_acl' ])) * ( J_H2_ampl_acl / Hacl + S_H2_acl ) # At the cathode side # Inside the CCL dif_eq [ 'dC_O2_ccl / dt' ] = 1 / ( epsilon_cl * ( 1 - sv [ 's_ccl' ])) * ( - J_O2_ccl_cmpl / Hccl + S_O2_ccl ) # Inside the CMPL dif_eq [ 'dC_O2_cmpl / dt' ] = 1 / ( epsilon_mpl * ( 1 - sv [ 's_cmpl' ])) * ( J_O2_ccl_cmpl - J_O2_cmpl_cgdl ) / Hmpl # Inside the CGDL dif_eq [ 'dC_O2_cgdl_1 / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ 's_cgdl_1' ])) * \\ ( J_O2_cmpl_cgdl - J_O2_cgdl_cgdl [ 1 ]) / ( Hgdl / n_gdl ) for i in range ( 2 , n_gdl ): dif_eq [ f 'dC_O2_cgdl_ { i } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_cgdl_ { i } ' ])) * \\ ( J_O2_cgdl_cgdl [ i - 1 ] - J_O2_cgdl_cgdl [ i ]) / ( Hgdl / n_gdl ) dif_eq [ f 'dC_O2_cgdl_ { n_gdl } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_cgdl_ { n_gdl } ' ])) * \\ ( J_O2_cgdl_cgdl [ n_gdl - 1 ] - J_O2_cgdl_cgc ) / ( Hgdl / n_gdl ) # Inside the CGC dif_eq [ 'dC_O2_cgc / dt' ] = ( J_O2_in - J_O2_out ) / Lgc + J_O2_cgdl_cgc / Hcgc # Inside the whole cell dif_eq [ 'dC_N2 / dt' ] = ( J_N2_in - J_N2_out ) / Lgc calculate_dyn_air_compressor_and_humidifier_evolution ( dif_eq , Wcp_des , Wa_inj_des , Wc_inj_des , type_auxiliary , Wcp , Wa_inj , Wc_inj , ** kwargs ) This function calculates the dynamic evolution of the air compressor and the humidifiers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. Wcp_des ( float ) \u2013 Desired air compressor flow rate (kg.s-1). Wa_inj_des ( float ) \u2013 Desired anode humidifier flow rate (kg.s-1). Wc_inj_des ( float ) \u2013 Desired cathode humidifier flow rate (kg.s-1). type_auxiliary ( str ) \u2013 Type of auxiliary components used in the fuel cell model. Wcp ( float ) \u2013 Air compressor flow rate (kg.s-1). Wa_inj ( float ) \u2013 Anode humidifier flow rate (kg.s-1). Wc_inj ( float ) \u2013 Cathode humidifier flow rate (kg.s-1). Source code in model/dif_eq.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 def calculate_dyn_air_compressor_and_humidifier_evolution ( dif_eq , Wcp_des , Wa_inj_des , Wc_inj_des , type_auxiliary , Wcp , Wa_inj , Wc_inj , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the air compressor and the humidifiers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. Wcp_des : float Desired air compressor flow rate (kg.s-1). Wa_inj_des : float Desired anode humidifier flow rate (kg.s-1). Wc_inj_des : float Desired cathode humidifier flow rate (kg.s-1). type_auxiliary : str Type of auxiliary components used in the fuel cell model. Wcp : float Air compressor flow rate (kg.s-1). Wa_inj : float Anode humidifier flow rate (kg.s-1). Wc_inj : float Cathode humidifier flow rate (kg.s-1). \"\"\" # Air compressor evolution if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : dif_eq [ 'dWcp / dt' ] = ( Wcp_des - Wcp ) / tau_cp # Estimation at the first order. elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dWcp / dt' ] = ( Wcp_des - Wcp ) / tau_cp # Estimation at the first order. else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dWcp / dt' ] = 0 # Anode and cathode humidifiers evolution if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : dif_eq [ 'dWa_inj / dt' ] = 0 dif_eq [ 'dWc_inj / dt' ] = ( Wc_inj_des - Wc_inj ) / tau_hum # Estimation at the first order. elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dWa_inj / dt' ] = ( Wa_inj_des - Wa_inj ) / tau_hum # Estimation at the first order. dif_eq [ 'dWc_inj / dt' ] = ( Wc_inj_des - Wc_inj ) / tau_hum # Estimation at the first order. else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dWa_inj / dt' ], dif_eq [ 'dWc_inj / dt' ] = 0 , 0 calculate_dyn_dissoved_water_evolution ( dif_eq , Hmem , Hacl , Hccl , epsilon_mc , S_abs_acl , S_abs_ccl , J_lambda_acl_mem , J_lambda_mem_ccl , Sp_acl , Sp_ccl , ** kwargs ) This function calculates the dynamic evolution of the dissolved water in the membrane and the catalyst layers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. Hmem ( float ) \u2013 Thickness of the membrane (m). Hacl ( float ) \u2013 Thickness of the anode catalyst layer (m). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the catalyst layer. S_abs_acl ( float ) \u2013 Water absorption in the anode catalyst layer (mol.m-3.s-1) S_abs_ccl ( float ) \u2013 Water absorption in the cathode catalyst layer (mol.m-3.s-1) J_lambda_acl_mem ( float ) \u2013 Dissolved water flow between the anode catalyst layer and the membrane (mol.m-2.s-1) J_lambda_mem_ccl ( float ) \u2013 Dissolved water flow between the membrane and the cathode catalyst layer (mol.m-2.s-1) Sp_acl ( float ) \u2013 Water produced in the membrane at the ACL through the chemical reaction and crossover (mol.m-3.s-1) Sp_ccl ( float ) \u2013 Water produced in the membrane at the CCL through the chemical reaction and crossover (mol.m-3.s-1) Source code in model/dif_eq.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def calculate_dyn_dissoved_water_evolution ( dif_eq , Hmem , Hacl , Hccl , epsilon_mc , S_abs_acl , S_abs_ccl , J_lambda_acl_mem , J_lambda_mem_ccl , Sp_acl , Sp_ccl , ** kwargs ): \"\"\" This function calculates the dynamic evolution of the dissolved water in the membrane and the catalyst layers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. Hmem : float Thickness of the membrane (m). Hacl : float Thickness of the anode catalyst layer (m). Hccl : float Thickness of the cathode catalyst layer (m). epsilon_mc : float Volume fraction of ionomer in the catalyst layer. S_abs_acl : float Water absorption in the anode catalyst layer (mol.m-3.s-1) S_abs_ccl : float Water absorption in the cathode catalyst layer (mol.m-3.s-1) J_lambda_acl_mem : float Dissolved water flow between the anode catalyst layer and the membrane (mol.m-2.s-1) J_lambda_mem_ccl : float Dissolved water flow between the membrane and the cathode catalyst layer (mol.m-2.s-1) Sp_acl : float Water produced in the membrane at the ACL through the chemical reaction and crossover (mol.m-3.s-1) Sp_ccl : float Water produced in the membrane at the CCL through the chemical reaction and crossover (mol.m-3.s-1) \"\"\" dif_eq [ 'dlambda_acl / dt' ] = M_eq / ( rho_mem * epsilon_mc ) * ( - J_lambda_acl_mem / Hacl + S_abs_acl + Sp_acl ) dif_eq [ 'dlambda_mem / dt' ] = M_eq / rho_mem * ( J_lambda_acl_mem - J_lambda_mem_ccl ) / Hmem dif_eq [ 'dlambda_ccl / dt' ] = M_eq / ( rho_mem * epsilon_mc ) * ( J_lambda_mem_ccl / Hccl + S_abs_ccl + Sp_ccl ) calculate_dyn_liquid_water_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , Jl_agc_agdl , Jl_agdl_agdl , Jl_agdl_ampl , Jl_ampl_acl , Jl_ccl_cmpl , Jl_cmpl_cgdl , Jl_cgdl_cgdl , Jl_cgdl_cgc , Sl_agdl , Sl_ampl , Sl_acl , Sl_ccl , Sl_cmpl , Sl_cgdl , ** kwargs ) This function calculates the dynamic evolution of the liquid water in the gas diffusion and catalyst layers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer (m). Hmpl ( float ) \u2013 Thickness of the microporous layer (m). Hacl ( float ) \u2013 Thickness of the anode catalyst layer (m). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_cl ( float ) \u2013 Anode/cathode CL porosity. epsilon_mpl ( float ) \u2013 Anode/cathode MPL porosity. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. Jl_agc_agdl ( float ) \u2013 Liquid water flow between the anode gas channel border and the anode GDL (kg.m-2.s-1). Jl_agdl_agdl ( list ) \u2013 Liquid water flow between two nodes of the anode GDL (kg.m-2.s-1). Jl_agdl_ampl ( float ) \u2013 Liquid water flow between the last node of the anode GDL and the anode microporous layer (kg.m-2.s-1). Jl_ampl_acl ( float ) \u2013 Liquid water flow between the anode microporous layer and the anode catalyst layer (kg.m-2.s-1). Jl_ccl_cmpl ( list ) \u2013 Liquid water flow between the cathode catalyst layer and the cathode microporous layer (kg.m-2.s-1). Jl_cmpl_cgdl ( float ) \u2013 Liquid water flow between the cathode microporous layer and the first node of the cathode GDL (kg.m-2.s-1). Jl_cgdl_cgdl ( list ) \u2013 Liquid water flow between two nodes of the cathode GDL (kg.m-2.s-1). Jl_cgdl_cgc ( float ) \u2013 Liquid water flow between the cathode GDL and the cathode gas channel border (kg.m-2.s-1). Sl_agdl ( list ) \u2013 Liquid water produced in the anode GDL (kg.m-3.s-1). Sl_acl ( float ) \u2013 Liquid water produced in the anode CL (kg.m-3.s-1). Sl_ccl ( float ) \u2013 Liquid water produced in the cathode CL (kg.m-3.s-1). Sl_cgdl ( list ) \u2013 Liquid water produced in the cathode GDL (kg.m-3.s-1). Source code in model/dif_eq.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def calculate_dyn_liquid_water_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , Jl_agc_agdl , Jl_agdl_agdl , Jl_agdl_ampl , Jl_ampl_acl , Jl_ccl_cmpl , Jl_cmpl_cgdl , Jl_cgdl_cgdl , Jl_cgdl_cgc , Sl_agdl , Sl_ampl , Sl_acl , Sl_ccl , Sl_cmpl , Sl_cgdl , ** kwargs ): \"\"\" This function calculates the dynamic evolution of the liquid water in the gas diffusion and catalyst layers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl : float Thickness of the gas diffusion layer (m). Hmpl : float Thickness of the microporous layer (m). Hacl : float Thickness of the anode catalyst layer (m). Hccl : float Thickness of the cathode catalyst layer (m). epsilon_gdl : float Anode/cathode GDL porosity. epsilon_cl : float Anode/cathode CL porosity. epsilon_mpl : float Anode/cathode MPL porosity. n_gdl : int Number of model nodes placed inside each GDL. Jl_agc_agdl : float Liquid water flow between the anode gas channel border and the anode GDL (kg.m-2.s-1). Jl_agdl_agdl : list Liquid water flow between two nodes of the anode GDL (kg.m-2.s-1). Jl_agdl_ampl : float Liquid water flow between the last node of the anode GDL and the anode microporous layer (kg.m-2.s-1). Jl_ampl_acl : float Liquid water flow between the anode microporous layer and the anode catalyst layer (kg.m-2.s-1). Jl_ccl_cmpl : list Liquid water flow between the cathode catalyst layer and the cathode microporous layer (kg.m-2.s-1). Jl_cmpl_cgdl : float Liquid water flow between the cathode microporous layer and the first node of the cathode GDL (kg.m-2.s-1). Jl_cgdl_cgdl : list Liquid water flow between two nodes of the cathode GDL (kg.m-2.s-1). Jl_cgdl_cgc : float Liquid water flow between the cathode GDL and the cathode gas channel border (kg.m-2.s-1). Sl_agdl : list Liquid water produced in the anode GDL (kg.m-3.s-1). Sl_acl : float Liquid water produced in the anode CL (kg.m-3.s-1). Sl_ccl : float Liquid water produced in the cathode CL (kg.m-3.s-1). Sl_cgdl : list Liquid water produced in the cathode GDL (kg.m-3.s-1). \"\"\" # At the anode side # Inside the AGDL dif_eq [ 'ds_agdl_1 / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_agdl_1' ]) * epsilon_gdl ) * \\ (( Jl_agc_agdl - Jl_agdl_agdl [ 1 ]) / ( Hgdl / n_gdl ) + M_H2O * Sl_agdl [ 1 ]) for i in range ( 2 , n_gdl ): dif_eq [ f 'ds_agdl_ { i } / dt' ] = 1 / ( rho_H2O_l ( sv [ f 'T_agdl_ { i } ' ]) * epsilon_gdl ) * \\ (( Jl_agdl_agdl [ i - 1 ] - Jl_agdl_agdl [ i ]) / ( Hgdl / n_gdl ) + M_H2O * Sl_agdl [ i ]) dif_eq [ f 'ds_agdl_ { n_gdl } / dt' ] = 1 / ( rho_H2O_l ( sv [ f 'T_agdl_ { n_gdl } ' ]) * epsilon_gdl ) * \\ (( Jl_agdl_agdl [ n_gdl - 1 ] - Jl_agdl_ampl ) / ( Hgdl / n_gdl ) + M_H2O * Sl_agdl [ n_gdl ]) # Inside the AMPL dif_eq [ 'ds_ampl / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_ampl' ]) * epsilon_mpl ) * (( Jl_agdl_ampl - Jl_ampl_acl ) / Hmpl + M_H2O * Sl_ampl ) # Inside the ACL dif_eq [ 'ds_acl / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_acl' ]) * epsilon_cl ) * ( Jl_ampl_acl / Hacl + M_H2O * Sl_acl ) # At the cathode side # Inside the CCL dif_eq [ 'ds_ccl / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_ccl' ]) * epsilon_cl ) * ( - Jl_ccl_cmpl / Hccl + M_H2O * Sl_ccl ) # Inside the CMPL dif_eq [ 'ds_cmpl / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_cmpl' ]) * epsilon_mpl ) * (( Jl_ccl_cmpl - Jl_cmpl_cgdl ) / Hmpl + M_H2O * Sl_cmpl ) # Inside the CGDL dif_eq [ 'ds_cgdl_1 / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_cgdl_1' ]) * epsilon_gdl ) * \\ (( Jl_cmpl_cgdl - Jl_cgdl_cgdl [ 1 ]) / ( Hgdl / n_gdl ) + M_H2O * Sl_cgdl [ 1 ]) for i in range ( 2 , n_gdl ): dif_eq [ f 'ds_cgdl_ { i } / dt' ] = 1 / ( rho_H2O_l ( sv [ f 'T_cgdl_ { i } ' ]) * epsilon_gdl ) * \\ (( Jl_cgdl_cgdl [ i - 1 ] - Jl_cgdl_cgdl [ i ]) / ( Hgdl / n_gdl ) + M_H2O * Sl_cgdl [ i ]) dif_eq [ f 'ds_cgdl_ { n_gdl } / dt' ] = 1 / ( rho_H2O_l ( sv [ f 'T_cgdl_ { n_gdl } ' ]) * epsilon_gdl ) * \\ (( Jl_cgdl_cgdl [ n_gdl - 1 ] - Jl_cgdl_cgc ) / ( Hgdl / n_gdl ) + M_H2O * Sl_cgdl [ n_gdl ]) calculate_dyn_manifold_pressure_and_humidity_evolution ( dif_eq , Masm , Maem , Mcsm , Mcem , T_des , Hagc , Hcgc , Wagc , Wcgc , type_auxiliary , Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , Wasm_in , Wasm_out , Waem_in , Waem_out , Wcsm_in , Wcsm_out , Wcem_in , Wcem_out , Ware , Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out , ** kwargs ) This function calculates the dynamic evolution of the pressure and humidity inside the manifolds. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. Masm ( float ) \u2013 Molar mass of all the gaseous species inside the anode supply manifold (kg.mol-1). Maem ( float ) \u2013 Molar mass of all the gaseous species inside the anode exhaust manifold (kg.mol-1). Mcsm ( float ) \u2013 Molar mass of all the gaseous species inside the cathode supply manifold (kg.mol-1). Mcem ( float ) \u2013 Molar mass of all the gaseous species inside the cathode exhaust manifold (kg.mol-1). T_des ( float ) \u2013 Fuel cell temperature (K). Hagc ( float ) \u2013 Thickness of the anode gas channel (m). Hcgc ( float ) \u2013 Thickness of the cathode gas channel (m). Wagc ( float ) \u2013 Width of the anode gas channel (m). Wcgc ( float ) \u2013 Width of the cathode gas channel (m). type_auxiliary ( str ) \u2013 Type of auxiliary components used in the fuel cell model. Jv_a_in ( float ) \u2013 Water vapor flow at the anode inlet (mol.m-2.s-1). Jv_a_out ( float ) \u2013 Water vapor flow at the anode outlet (mol.m-2.s-1). Jv_c_in ( float ) \u2013 Water vapor flow at the cathode inlet (mol.m-2.s-1). Jv_c_out ( float ) \u2013 Water vapor flow at the cathode outlet (mol.m-2.s-1). Wasm_in ( float ) \u2013 Flow at the anode supply manifold inlet (kg.s-1). Wasm_out ( float ) \u2013 Flow at the anode supply manifold outlet (kg.s-1). Waem_in ( float ) \u2013 Flow at the anode exhaust manifold inlet (kg.s-1). Waem_out ( float ) \u2013 Flow at the anode exhaust manifold outlet (kg.s-1). Wcsm_in ( float ) \u2013 Flow at the cathode supply manifold inlet (kg.s-1). Wcsm_out ( float ) \u2013 Flow at the cathode supply manifold outlet (kg.s-1). Wcem_in ( float ) \u2013 Flow at the cathode exhaust manifold inlet (kg.s-1). Wcem_out ( float ) \u2013 Flow at the cathode exhaust manifold outlet (kg.s-1). Ware ( float ) \u2013 Anode side recirculation flow (kg.s-1). Wv_asm_in ( float ) \u2013 Vapor flow at the anode supply manifold inlet (mol.s-1). Wv_aem_out ( float ) \u2013 Vapor flow at the anode external manifold outlet (mol.s-1). Wv_csm_in ( float ) \u2013 Vapor flow at the cathode supply manifold inlet (mol.s-1). Wv_cem_out ( float ) \u2013 Vapor flow at the cathode external manifold outlet (mol.s-1). Source code in model/dif_eq.py 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 def calculate_dyn_manifold_pressure_and_humidity_evolution ( dif_eq , Masm , Maem , Mcsm , Mcem , T_des , Hagc , Hcgc , Wagc , Wcgc , type_auxiliary , Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , Wasm_in , Wasm_out , Waem_in , Waem_out , Wcsm_in , Wcsm_out , Wcem_in , Wcem_out , Ware , Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the pressure and humidity inside the manifolds. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. Masm : float Molar mass of all the gaseous species inside the anode supply manifold (kg.mol-1). Maem : float Molar mass of all the gaseous species inside the anode exhaust manifold (kg.mol-1). Mcsm : float Molar mass of all the gaseous species inside the cathode supply manifold (kg.mol-1). Mcem : float Molar mass of all the gaseous species inside the cathode exhaust manifold (kg.mol-1). T_des : float Fuel cell temperature (K). Hagc : float Thickness of the anode gas channel (m). Hcgc : float Thickness of the cathode gas channel (m). Wagc : float Width of the anode gas channel (m). Wcgc : float Width of the cathode gas channel (m). type_auxiliary : str Type of auxiliary components used in the fuel cell model. Jv_a_in : float Water vapor flow at the anode inlet (mol.m-2.s-1). Jv_a_out : float Water vapor flow at the anode outlet (mol.m-2.s-1). Jv_c_in : float Water vapor flow at the cathode inlet (mol.m-2.s-1). Jv_c_out : float Water vapor flow at the cathode outlet (mol.m-2.s-1). Wasm_in : float Flow at the anode supply manifold inlet (kg.s-1). Wasm_out : float Flow at the anode supply manifold outlet (kg.s-1). Waem_in : float Flow at the anode exhaust manifold inlet (kg.s-1). Waem_out : float Flow at the anode exhaust manifold outlet (kg.s-1). Wcsm_in : float Flow at the cathode supply manifold inlet (kg.s-1). Wcsm_out : float Flow at the cathode supply manifold outlet (kg.s-1). Wcem_in : float Flow at the cathode exhaust manifold inlet (kg.s-1). Wcem_out : float Flow at the cathode exhaust manifold outlet (kg.s-1). Ware : float Anode side recirculation flow (kg.s-1). Wv_asm_in : float Vapor flow at the anode supply manifold inlet (mol.s-1). Wv_aem_out : float Vapor flow at the anode external manifold outlet (mol.s-1). Wv_csm_in : float Vapor flow at the cathode supply manifold inlet (mol.s-1). Wv_cem_out : float Vapor flow at the cathode external manifold outlet (mol.s-1). \"\"\" # Pressure evolution inside the manifolds if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : dif_eq [ 'dPasm / dt' ] = ( Wasm_in + Ware - n_cell * Wasm_out ) / ( Vsm * Masm ) * R * T_des dif_eq [ 'dPaem / dt' ] = ( n_cell * Waem_in - Ware - Waem_out ) / ( Vem * Maem ) * R * T_des dif_eq [ 'dPcsm / dt' ] = ( Wcsm_in - n_cell * Wcsm_out ) / ( Vsm * Mcsm ) * R * T_des dif_eq [ 'dPcem / dt' ] = ( n_cell * Wcem_in - Wcem_out ) / ( Vem * Mcem ) * R * T_des elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dPasm / dt' ] = ( Wasm_in - n_cell * Wasm_out ) / ( Vsm * Masm ) * R * T_des dif_eq [ 'dPaem / dt' ] = ( n_cell * Waem_in - Waem_out ) / ( Vem * Maem ) * R * T_des dif_eq [ 'dPcsm / dt' ] = ( Wcsm_in - n_cell * Wcsm_out ) / ( Vsm * Mcsm ) * R * T_des dif_eq [ 'dPcem / dt' ] = ( n_cell * Wcem_in - Wcem_out ) / ( Vem * Mcem ) * R * T_des else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dPasm / dt' ], dif_eq [ 'dPaem / dt' ], dif_eq [ 'dPcsm / dt' ], dif_eq [ 'dPcem / dt' ] = 0 , 0 , 0 , 0 # Humidity evolution inside the manifolds if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : dif_eq [ 'dPhi_asm / dt' ] = ( Wv_asm_in - Jv_a_in * Hagc * Wagc * n_cell ) / Vsm * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_aem / dt' ] = ( Jv_a_out * Hagc * Wagc * n_cell - Wv_asm_in - Wv_aem_out ) / Vem * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_csm / dt' ] = ( Wv_csm_in - Jv_c_in * Hcgc * Wcgc * n_cell ) / Vsm * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_cem / dt' ] = ( Jv_c_out * Hcgc * Wcgc * n_cell - Wv_cem_out ) / Vem * R * T_des / Psat ( T_des ) elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dPhi_asm / dt' ] = ( Wv_asm_in - Jv_a_in * Hagc * Wagc * n_cell ) / Vsm * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_aem / dt' ] = ( Jv_a_out * Hagc * Wagc * n_cell - Wv_aem_out ) / Vem * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_csm / dt' ] = ( Wv_csm_in - Jv_c_in * Hcgc * Wcgc * n_cell ) / Vsm * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_cem / dt' ] = ( Jv_c_out * Hcgc * Wcgc * n_cell - Wv_cem_out ) / Vem * R * T_des / Psat ( T_des ) else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dPhi_asm / dt' ], dif_eq [ 'dPhi_aem / dt' ], dif_eq [ 'dPhi_csm / dt' ], dif_eq [ 'dPhi_cem / dt' ] = 0 , 0 , 0 , 0 calculate_dyn_temperature_evolution ( dif_eq , rho_Cp0 , Hgdl , Hmpl , Hacl , Hccl , Hmem , n_gdl , Jt , Q_r , Q_sorp , Q_liq , Q_p , Q_e , ** kwargs ) This function calculates the dynamic evolution of the temperature in the fuel cell. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. rho_Cp0 ( dict ) \u2013 Volumetric heat capacity of the different components of the fuel cell system, in J.m-3.K-1. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer, in m. Hmpl ( float ) \u2013 Thickness of the microporous layer, in m. Hacl ( float ) \u2013 Thickness of the anode catalyst layer, in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer, in m. Hmem ( float ) \u2013 Thickness of the membrane, in m. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. Jt ( dict ) \u2013 Heat flows occuring inside the fuel cell system, J.m-2.s-1. Q_r ( dict ) \u2013 Heat dissipated by the electrochemical reaction 2 H2 + O2 -> 2 H2O, in J.m-3.s-1. Q_sorp ( dict ) \u2013 Heat dissipated by the absorption of water from the CL to the membrane, in J.m-3.s-1. Q_liq ( dict ) \u2013 Heat dissipated by the evaporation of liquid water, in J.m-3.s-1. Q_p ( dict ) \u2013 Heat dissipated by the ionic currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_e ( dict ) \u2013 Heat dissipated by the electric currents (Joule heating + Ohm's law), in J.m-3.s-1. Source code in model/dif_eq.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 def calculate_dyn_temperature_evolution ( dif_eq , rho_Cp0 , Hgdl , Hmpl , Hacl , Hccl , Hmem , n_gdl , Jt , Q_r , Q_sorp , Q_liq , Q_p , Q_e , ** kwargs ): \"\"\" This function calculates the dynamic evolution of the temperature in the fuel cell. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. rho_Cp0 : dict Volumetric heat capacity of the different components of the fuel cell system, in J.m-3.K-1. Hgdl : float Thickness of the gas diffusion layer, in m. Hmpl : float Thickness of the microporous layer, in m. Hacl : float Thickness of the anode catalyst layer, in m. Hccl : float Thickness of the cathode catalyst layer, in m. Hmem : float Thickness of the membrane, in m. n_gdl : int Number of model nodes placed inside each GDL. Jt : dict Heat flows occuring inside the fuel cell system, J.m-2.s-1. Q_r : dict Heat dissipated by the electrochemical reaction 2*H2 + O2 -> 2*H2O, in J.m-3.s-1. Q_sorp : dict Heat dissipated by the absorption of water from the CL to the membrane, in J.m-3.s-1. Q_liq : dict Heat dissipated by the evaporation of liquid water, in J.m-3.s-1. Q_p : dict Heat dissipated by the ionic currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_e : dict Heat dissipated by the electric currents (Joule heating + Ohm's law), in J.m-3.s-1. \"\"\" # At the anode side # Inside the AGC dif_eq [ 'dT_agc / dt' ] = 0 # Dirichlet boundary condition. T_agc is initialized to T_fc and remains constant. # Inside the AGDL dif_eq [ 'dT_agdl_1 / dt' ] = ( 1 / rho_Cp0 [ 'agdl_1' ]) * \\ ( ( Jt [ 'agc_agdl' ] - Jt [ 'agdl_agdl_1' ]) / ( Hgdl / n_gdl ) + Q_liq [ 'agdl_1' ] + Q_e [ 'agdl_1' ] ) for i in range ( 2 , n_gdl ): dif_eq [ f 'dT_agdl_ { i } / dt' ] = ( 1 / rho_Cp0 [ f 'agdl_ { i } ' ]) * \\ ( ( Jt [ f 'agdl_agdl_ { i - 1 } ' ] - Jt [ f 'agdl_agdl_ { i } ' ]) / ( Hgdl / n_gdl ) + Q_liq [ f 'agdl_ { i } ' ] + Q_e [ f 'agdl_ { i } ' ] ) dif_eq [ f 'dT_agdl_ { n_gdl } / dt' ] = ( 1 / rho_Cp0 [ f 'agdl_ { n_gdl } ' ]) * \\ ( ( Jt [ f 'agdl_agdl_ { n_gdl - 1 } ' ] - Jt [ 'agdl_ampl' ]) / ( Hgdl / n_gdl ) + Q_liq [ f 'agdl_ { n_gdl } ' ] + Q_e [ f 'agdl_ { n_gdl } ' ] ) # Inside the AMPL dif_eq [ 'dT_ampl / dt' ] = ( 1 / rho_Cp0 [ 'ampl' ]) * ( ( Jt [ 'agdl_ampl' ] - Jt [ 'ampl_acl' ]) / Hmpl + Q_liq [ 'ampl' ] + Q_e [ 'ampl' ] ) # Inside the ACL dif_eq [ 'dT_acl / dt' ] = ( 1 / rho_Cp0 [ 'acl' ]) * \\ ( ( Jt [ 'ampl_acl' ] - Jt [ 'acl_mem' ]) / Hacl + Q_r [ 'acl' ] + Q_sorp [ 'acl' ] + Q_liq [ 'acl' ] + Q_e [ 'acl' ] ) # Inside the membrane dif_eq [ 'dT_mem / dt' ] = ( 1 / rho_Cp0 [ 'mem' ]) * \\ ( ( Jt [ 'acl_mem' ] - Jt [ 'mem_ccl' ]) / Hmem + Q_p [ 'mem' ] ) # At the cathode side # Inside the CCL dif_eq [ 'dT_ccl / dt' ] = ( 1 / rho_Cp0 [ 'ccl' ]) * \\ ( ( Jt [ 'mem_ccl' ] - Jt [ 'ccl_cmpl' ]) / Hccl + Q_r [ 'ccl' ] + Q_sorp [ 'acl' ] + Q_liq [ 'ccl' ] + Q_p [ 'ccl' ] + Q_e [ 'ccl' ] ) # Inside the CMPL dif_eq [ 'dT_cmpl / dt' ] = ( 1 / rho_Cp0 [ 'cmpl' ]) * (( Jt [ 'ccl_cmpl' ] - Jt [ 'cmpl_cgdl' ]) / Hmpl + Q_liq [ 'cmpl' ] + Q_e [ 'cmpl' ]) # Inside the CGDL dif_eq [ 'dT_cgdl_1 / dt' ] = ( 1 / rho_Cp0 [ 'cgdl_1' ]) * \\ ( ( Jt [ 'cmpl_cgdl' ] - Jt [ 'cgdl_cgdl_1' ]) / ( Hgdl / n_gdl ) + Q_liq [ 'cgdl_1' ] + Q_e [ 'cgdl_1' ] ) for i in range ( 2 , n_gdl ): dif_eq [ f 'dT_cgdl_ { i } / dt' ] = ( 1 / rho_Cp0 [ f 'cgdl_ { i } ' ]) * \\ ( ( Jt [ f 'cgdl_cgdl_ { i - 1 } ' ] - Jt [ f 'cgdl_cgdl_ { i } ' ]) / ( Hgdl / n_gdl ) + Q_liq [ f 'cgdl_ { i } ' ] + Q_e [ f 'cgdl_ { i } ' ] ) dif_eq [ f 'dT_cgdl_ { n_gdl } / dt' ] = ( 1 / rho_Cp0 [ f 'cgdl_ { n_gdl } ' ]) * \\ ( ( Jt [ f 'cgdl_cgdl_ { n_gdl - 1 } ' ] - Jt [ 'cgdl_cgc' ]) / ( Hgdl / n_gdl ) + Q_liq [ f 'cgdl_ { n_gdl } ' ] + Q_e [ f 'cgdl_ { n_gdl } ' ] ) # Inside the CCG dif_eq [ 'dT_cgc / dt' ] = 0 # Dirichlet boundary condition. T_cgc is initialized to T_fc and remains constant. calculate_dyn_throttle_area_evolution ( dif_eq , Pagc , Pcgc , T_agc , T_cgc , Abp_a , Abp_c , Pa_des , Pc_des , type_auxiliary , ** kwargs ) This function calculates the dynamic evolution of the throttle area inside the anode and cathode auxiliaries. This function has to be executed after 'calculate_dyn_vapor_evolution' and 'calculate_dyn_H2_O2_N2_evolution'. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. Pagc ( float ) \u2013 Pressure inside the anode gas channel (Pa). Pcgc ( float ) \u2013 Pressure inside the cathode gas channel (Pa). T_agc ( float ) \u2013 Fuel cell temperature in the anode gas channel (K). T_cgc ( float ) \u2013 Fuel cell temperature in the cathode gas channel (K). Abp_a ( float ) \u2013 Throttle area inside the anode auxiliaries (m2). Abp_c ( float ) \u2013 Throttle area inside the cathode auxiliaries (m2). Pa_des ( float ) \u2013 Desired pressure inside the anode gas channel (Pa). Pc_des ( float ) \u2013 Desired pressure inside the cathode gas channel (Pa). type_auxiliary ( str ) \u2013 Type of auxiliary components used in the fuel cell model. Source code in model/dif_eq.py 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 def calculate_dyn_throttle_area_evolution ( dif_eq , Pagc , Pcgc , T_agc , T_cgc , Abp_a , Abp_c , Pa_des , Pc_des , type_auxiliary , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the throttle area inside the anode and cathode auxiliaries. This function has to be executed after 'calculate_dyn_vapor_evolution' and 'calculate_dyn_H2_O2_N2_evolution'. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. Pagc : float Pressure inside the anode gas channel (Pa). Pcgc : float Pressure inside the cathode gas channel (Pa). T_agc : float Fuel cell temperature in the anode gas channel (K). T_cgc : float Fuel cell temperature in the cathode gas channel (K). Abp_a : float Throttle area inside the anode auxiliaries (m2). Abp_c : float Throttle area inside the cathode auxiliaries (m2). Pa_des : float Desired pressure inside the anode gas channel (Pa). Pc_des : float Desired pressure inside the cathode gas channel (Pa). type_auxiliary : str Type of auxiliary components used in the fuel cell model. \"\"\" # Calculation of the pressure derivative inside the gas channels dPagcdt = ( dif_eq [ 'dC_v_agc / dt' ] + dif_eq [ 'dC_H2_agc / dt' ]) * R * T_agc dPcgcdt = ( dif_eq [ 'dC_v_cgc / dt' ] + dif_eq [ 'dC_O2_cgc / dt' ] + dif_eq [ 'dC_N2 / dt' ]) * R * T_cgc # Throttle area evolution inside the anode auxiliaries if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dAbp_a / dt' ] = - Kp * ( Pa_des - Pagc ) + Kd * dPagcdt # PD controller if Abp_a > A_T and dif_eq [ 'dAbp_a / dt' ] > 0 : # The throttle area cannot be higher than the maximum value dif_eq [ 'dAbp_a / dt' ] = 0 elif Abp_a < 0 and dif_eq [ 'dAbp_a / dt' ] < 0 : # The throttle area cannot be lower than 0 dif_eq [ 'dAbp_a / dt' ] = 0 else : # elif type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ # type_auxiliary == \"no_auxiliary\": dif_eq [ 'dAbp_a / dt' ] = 0 # The throttle area is not considered # Throttle area evolution inside the cathode auxiliaries if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dAbp_c / dt' ] = - Kp * ( Pc_des - Pcgc ) + Kd * dPcgcdt # PD controller if Abp_c > A_T and dif_eq [ 'dAbp_c / dt' ] > 0 : # The throttle area cannot be higher than the maximum value dif_eq [ 'dAbp_c / dt' ] = 0 elif Abp_c < 0 and dif_eq [ 'dAbp_c / dt' ] < 0 : # The throttle area cannot be lower than 0 dif_eq [ 'dAbp_c / dt' ] = 0 else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dAbp_a / dt' ] = 0 # The throttle area is not considered calculate_dyn_vapor_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , Hagc , Hcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , Jv_agc_agdl , Jv_agdl_agdl , Jv_agdl_ampl , Jv_ampl_acl , S_abs_acl , S_abs_ccl , Jv_ccl_cmpl , Jv_cmpl_cgdl , Jv_cgdl_cgdl , Jv_cgdl_cgc , Sv_agdl , Sv_ampl , Sv_acl , Sv_ccl , Sv_cmpl , Sv_cgdl , ** kwargs ) This function calculates the dynamic evolution of the vapor in the gas channels, the gas diffusion layers and the catalyst layers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer (m). Hmpl ( float ) \u2013 Thickness of the microporous layer (m). Hacl ( float ) \u2013 Thickness of the anode catalyst layer (m). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). Hagc ( float ) \u2013 Thickness of the anode gas channel (m). Hcgc ( float ) \u2013 Thickness of the cathode gas channel (m). Lgc ( float ) \u2013 Length of the gas channel (m). epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_cl ( float ) \u2013 Anode/cathode CL porosity. epsilon_mpl ( float ) \u2013 Anode/cathode MPL porosity. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. Jv_a_in ( float ) \u2013 Water vapor flow at the anode inlet (mol.m-2.s-1). Jv_a_out ( float ) \u2013 Water vapor flow at the anode outlet (mol.m-2.s-1). Jv_c_in ( float ) \u2013 Water vapor flow at the cathode inlet (mol.m-2.s-1). Jv_c_out ( float ) \u2013 Water vapor flow at the cathode outlet (mol.m-2.s-1). Jv_agc_agdl ( float ) \u2013 Water vapor flow between the anode gas channel and the anode GDL (mol.m-2.s-1). Jv_agdl_agdl ( float ) \u2013 Water vapor flow between two nodes of the anode GDL (mol.m-2.s-1). Jv_agdl_ampl ( float ) \u2013 Water vapor flow between the last node of the anode GDL and the anode microporous layer (mol.m-2.s-1). Jv_ampl_acl ( list ) \u2013 Water vapor flow between the anode microporous layer and the anode catalyst layer (mol.m-2.s-1). S_abs_acl \u2013 Water vapor absorption in the anode CL (mol.m-3.s-1). S_abs_ccl \u2013 Water vapor absorption in the cathode CL (mol.m-3.s-1). Jv_ccl_cmpl ( list ) \u2013 Water vapor flow between the cathode catalyst layer and the cathode microporous layer (mol.m-2.s-1). Jv_cmpl_cgdl ( float ) \u2013 Water vapor flow between the cathode microporous layer and the first node of the cathode GDL (mol.m-2.s-1). Jv_cgdl_cgdl ( list ) \u2013 Water vapor flow between two nodes of the cathode GDL (mol.m-2.s-1). Jv_cgdl_cgc ( float ) \u2013 Water vapor flow between the cathode GDL and the cathode gas channel (mol.m-2.s-1). Sv_agdl ( list ) \u2013 Water vapor produced in the anode GDL (mol.m-3.s-1). Sv_ampl ( float ) \u2013 Water vapor produced in the anode microporous layer (mol.m-3.s-1). Sv_acl ( float ) \u2013 Water vapor produced in the anode CL (mol.m-3.s-1). Sv_ccl ( float ) \u2013 Water vapor produced in the cathode CL (mol.m-3.s-1). Sv_cmpl ( float ) \u2013 Water vapor produced in the cathode microporous layer (mol.m-3.s-1). Sv_cgdl ( list ) \u2013 Water vapor produced in the cathode GDL (mol.m-3.s-1). Source code in model/dif_eq.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def calculate_dyn_vapor_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , Hagc , Hcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , Jv_agc_agdl , Jv_agdl_agdl , Jv_agdl_ampl , Jv_ampl_acl , S_abs_acl , S_abs_ccl , Jv_ccl_cmpl , Jv_cmpl_cgdl , Jv_cgdl_cgdl , Jv_cgdl_cgc , Sv_agdl , Sv_ampl , Sv_acl , Sv_ccl , Sv_cmpl , Sv_cgdl , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the vapor in the gas channels, the gas diffusion layers and the catalyst layers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl : float Thickness of the gas diffusion layer (m). Hmpl : float Thickness of the microporous layer (m). Hacl : float Thickness of the anode catalyst layer (m). Hccl : float Thickness of the cathode catalyst layer (m). Hagc : float Thickness of the anode gas channel (m). Hcgc : float Thickness of the cathode gas channel (m). Lgc : float Length of the gas channel (m). epsilon_gdl : float Anode/cathode GDL porosity. epsilon_cl : float Anode/cathode CL porosity. epsilon_mpl : float Anode/cathode MPL porosity. n_gdl : int Number of model nodes placed inside each GDL. Jv_a_in : float Water vapor flow at the anode inlet (mol.m-2.s-1). Jv_a_out : float Water vapor flow at the anode outlet (mol.m-2.s-1). Jv_c_in : float Water vapor flow at the cathode inlet (mol.m-2.s-1). Jv_c_out : float Water vapor flow at the cathode outlet (mol.m-2.s-1). Jv_agc_agdl : float Water vapor flow between the anode gas channel and the anode GDL (mol.m-2.s-1). Jv_agdl_agdl : float Water vapor flow between two nodes of the anode GDL (mol.m-2.s-1). Jv_agdl_ampl : float Water vapor flow between the last node of the anode GDL and the anode microporous layer (mol.m-2.s-1). Jv_ampl_acl : list Water vapor flow between the anode microporous layer and the anode catalyst layer (mol.m-2.s-1). S_abs_acl: float Water vapor absorption in the anode CL (mol.m-3.s-1). S_abs_ccl: float Water vapor absorption in the cathode CL (mol.m-3.s-1). Jv_ccl_cmpl : list Water vapor flow between the cathode catalyst layer and the cathode microporous layer (mol.m-2.s-1). Jv_cmpl_cgdl : float Water vapor flow between the cathode microporous layer and the first node of the cathode GDL (mol.m-2.s-1). Jv_cgdl_cgdl : list Water vapor flow between two nodes of the cathode GDL (mol.m-2.s-1). Jv_cgdl_cgc : float Water vapor flow between the cathode GDL and the cathode gas channel (mol.m-2.s-1). Sv_agdl : list Water vapor produced in the anode GDL (mol.m-3.s-1). Sv_ampl : float Water vapor produced in the anode microporous layer (mol.m-3.s-1). Sv_acl : float Water vapor produced in the anode CL (mol.m-3.s-1). Sv_ccl : float Water vapor produced in the cathode CL (mol.m-3.s-1). Sv_cmpl : float Water vapor produced in the cathode microporous layer (mol.m-3.s-1). Sv_cgdl : list Water vapor produced in the cathode GDL (mol.m-3.s-1). \"\"\" # At the anode side # Inside the AGC dif_eq [ 'dC_v_agc / dt' ] = ( Jv_a_in - Jv_a_out ) / Lgc - Jv_agc_agdl / Hagc # Inside the AGDL dif_eq [ 'dC_v_agdl_1 / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ 's_agdl_1' ])) * \\ (( Jv_agc_agdl - Jv_agdl_agdl [ 1 ]) / ( Hgdl / n_gdl ) + Sv_agdl [ 1 ]) for i in range ( 2 , n_gdl ): dif_eq [ f 'dC_v_agdl_ { i } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_agdl_ { i } ' ])) * \\ (( Jv_agdl_agdl [ i - 1 ] - Jv_agdl_agdl [ i ]) / ( Hgdl / n_gdl ) + Sv_agdl [ i ]) dif_eq [ f 'dC_v_agdl_ { n_gdl } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_agdl_ { n_gdl } ' ])) * \\ (( Jv_agdl_agdl [ n_gdl - 1 ] - Jv_agdl_ampl ) / ( Hgdl / n_gdl ) + Sv_agdl [ n_gdl ]) # Inside the AMPL dif_eq [ 'dC_v_ampl / dt' ] = 1 / ( epsilon_mpl * ( 1 - sv [ 's_ampl' ])) * (( Jv_agdl_ampl - Jv_ampl_acl ) / Hmpl + Sv_ampl ) # Inside the ACL dif_eq [ 'dC_v_acl / dt' ] = 1 / ( epsilon_cl * ( 1 - sv [ 's_acl' ])) * ( Jv_ampl_acl / Hacl - S_abs_acl + Sv_acl ) # At the cathode side # Inside the CCL dif_eq [ 'dC_v_ccl / dt' ] = 1 / ( epsilon_cl * ( 1 - sv [ 's_ccl' ])) * ( - Jv_ccl_cmpl / Hccl - S_abs_ccl + Sv_ccl ) # Inside the CMPL dif_eq [ 'dC_v_cmpl / dt' ] = 1 / ( epsilon_mpl * ( 1 - sv [ 's_cmpl' ])) * (( Jv_ccl_cmpl - Jv_cmpl_cgdl ) / Hmpl + Sv_cmpl ) # Inside the CGDL dif_eq [ 'dC_v_cgdl_1 / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ 's_cgdl_1' ])) * \\ (( Jv_cmpl_cgdl - Jv_cgdl_cgdl [ 1 ]) / ( Hgdl / n_gdl ) + Sv_cgdl [ 1 ]) for i in range ( 2 , n_gdl ): dif_eq [ f 'dC_v_cgdl_ { i } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_cgdl_ { i } ' ])) * \\ (( Jv_cgdl_cgdl [ i - 1 ] - Jv_cgdl_cgdl [ i ]) / ( Hgdl / n_gdl ) + Sv_cgdl [ i ]) dif_eq [ f 'dC_v_cgdl_ { n_gdl } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_cgdl_ { n_gdl } ' ])) * \\ (( Jv_cgdl_cgdl [ n_gdl - 1 ] - Jv_cgdl_cgc ) / ( Hgdl / n_gdl ) + Sv_cgdl [ n_gdl ]) # Inside the CGC dif_eq [ 'dC_v_cgc / dt' ] = ( Jv_c_in - Jv_c_out ) / Lgc + Jv_cgdl_cgc / Hcgc calculate_dyn_voltage_evolution ( dif_eq , i_fc , C_O2_ccl , T_ccl , eta_c , Hccl , i0_c_ref , kappa_c , C_scl , i_n , f_drop , ** kwargs ) This function calculates the dynamic evolution of the cell overpotential eta_c. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. i_fc ( float ) \u2013 Fuel cell current density (A.m-2). C_O2_ccl ( float ) \u2013 Oxygen concentration in the cathode catalyst layer (mol.m-3). T_ccl ( float ) \u2013 Fuel cell temperature in the cathode catalyst layer (K). eta_c ( float ) \u2013 Cell overpotential (V). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode (A.m-2). kappa_c ( float ) \u2013 Overpotential correction exponent. C_scl ( float ) \u2013 Volumetric space-charge layer capacitance (F.m-3). i_n ( float ) \u2013 Crossover current density (A.m-2). f_drop ( float ) \u2013 Liquid water induced voltage drop function. Source code in model/dif_eq.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 def calculate_dyn_voltage_evolution ( dif_eq , i_fc , C_O2_ccl , T_ccl , eta_c , Hccl , i0_c_ref , kappa_c , C_scl , i_n , f_drop , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the cell overpotential eta_c. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. i_fc : float Fuel cell current density (A.m-2). C_O2_ccl : float Oxygen concentration in the cathode catalyst layer (mol.m-3). T_ccl : float Fuel cell temperature in the cathode catalyst layer (K). eta_c : float Cell overpotential (V). Hccl : float Thickness of the cathode catalyst layer (m). i0_c_ref : float Reference exchange current density at the cathode (A.m-2). kappa_c : float Overpotential correction exponent. C_scl : float Volumetric space-charge layer capacitance (F.m-3). i_n : float Crossover current density (A.m-2). f_drop : float Liquid water induced voltage drop function. \"\"\" dif_eq [ 'deta_c / dt' ] = 1 / ( C_scl * Hccl ) * (( i_fc + i_n ) - i0_c_ref * ( C_O2_ccl / C_O2ref ) ** kappa_c * math . exp ( f_drop * alpha_c * F / ( R * T_ccl ) * eta_c )) dydt ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ) This function gives the system of differential equations to solve. Parameters: t ( float ) \u2013 Time (s). y ( ndarray ) \u2013 Numpy list of the solver variables. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. solver_variable_names ( list ) \u2013 Names of the solver variables. control_variables ( dict ) \u2013 Variables controlled by the user. Returns: dydt ( list ) \u2013 List containing the derivative of the solver variables. Source code in model/dif_eq.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def dydt ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ): \"\"\"This function gives the system of differential equations to solve. Parameters ---------- t : float Time (s). y : numpy.ndarray Numpy list of the solver variables. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. solver_variable_names : list Names of the solver variables. control_variables : dict Variables controlled by the user. Returns ------- dydt : list List containing the derivative of the solver variables. \"\"\" # Creation of the dif_eq dictionary. It is an intermediate calculation to simplify the writing of the code. dif_eq = {( 'd' + key + ' / dt' ): 0 for key in solver_variable_names } # Creation of the solver_variables dict. It is an intermediate calculation to simplify the writing of the code. solver_variables = {} for index , key in enumerate ( solver_variable_names ): solver_variables [ key ] = y [ index ] # Modifications of the operating conditions in real time, if required. if parameters [ \"type_control\" ] != \"no_control\" : control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ) # Intermediate values i_fc = operating_inputs [ 'current_density' ]( t , parameters ) Mext , Pagc , Pcgc , i_n , Masm , Maem , Mcsm , Mcem , rho_Cp0 = dif_eq_int_values ( solver_variables , operating_inputs , control_variables , parameters ) Wcp_des , Wa_inj_des , Wc_inj_des = desired_flows ( solver_variables , control_variables , i_n , i_fc , operating_inputs , parameters , Mext ) eta_c_intermediate_values = calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ) # Calculation of the flows matter_flows_dico = calculate_flows ( t , solver_variables , control_variables , i_fc , operating_inputs , parameters ) heat_flows_dico = calculate_heat_transfers ( solver_variables , i_fc , parameters , ** matter_flows_dico ) # Calculation of the dynamic evolutions # Inside the cell calculate_dyn_dissoved_water_evolution ( dif_eq , ** parameters , ** matter_flows_dico ) calculate_dyn_liquid_water_evolution ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_vapor_evolution ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_H2_O2_N2_evolution ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_voltage_evolution ( dif_eq , i_fc , ** solver_variables , ** operating_inputs , ** parameters , ** eta_c_intermediate_values ) calculate_dyn_temperature_evolution ( dif_eq , rho_Cp0 , ** parameters , ** heat_flows_dico ) # Inside the auxiliary components calculate_dyn_manifold_pressure_and_humidity_evolution ( dif_eq , Masm , Maem , Mcsm , Mcem , ** solver_variables , ** operating_inputs , ** parameters , ** matter_flows_dico ) calculate_dyn_air_compressor_and_humidifier_evolution ( dif_eq , Wcp_des , Wa_inj_des , Wc_inj_des , ** solver_variables , ** parameters ) calculate_dyn_throttle_area_evolution ( dif_eq , Pagc , Pcgc , ** solver_variables , ** operating_inputs , ** parameters ) # dif_eq is converted to dydt because the solver requires an ordered list to work dydt = [] for key in solver_variable_names : dydt . append ( dif_eq [ 'd' + key + ' / dt' ]) return dydt","title":"Differentiel equations"},{"location":"functions/model/dif_eq/#differential-equations","text":"This file represents all the differential equations used for the fuel cell model.","title":"Differential equations"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_H2_O2_N2_evolution","text":"This function calculates the dynamic evolution of the hydrogen, oxygen and nitrogen in the gas channels, the gas diffusion layers and the catalyst layers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer (m). Hmpl ( float ) \u2013 Thickness of the microporous layer (m). Hacl ( float ) \u2013 Thickness of the anode catalyst layer (m). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). Hagc ( float ) \u2013 Thickness of the anode gas channel (m). Hcgc ( float ) \u2013 Thickness of the cathode gas channel (m). Lgc ( float ) \u2013 Length of the gas channel (m). epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_cl ( float ) \u2013 Anode/cathode CL porosity. epsilon_mpl ( float ) \u2013 Anode/cathode MPL porosity. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. J_H2_in ( float ) \u2013 Hydrogen flow at the anode inlet (mol.m-2.s-1). J_H2_out ( float ) \u2013 Hydrogen flow at the anode outlet (mol.m-2.s-1). J_O2_in ( float ) \u2013 Oxygen flow at the cathode inlet (mol.m-2.s-1). J_O2_out ( float ) \u2013 Oxygen flow at the cathode outlet (mol.m-2.s-1). J_N2_in ( float ) \u2013 Nitrogen flow at the cathode inlet (mol.m-2.s-1). J_N2_out ( float ) \u2013 Nitrogen flow at the cathode outlet (mol.m-2.s-1). J_H2_agc_agdl ( float ) \u2013 Hydrogen flow between the anode gas channel and the anode GDL (mol.m-2.s-1). J_H2_agdl_agdl ( list ) \u2013 Hydrogen flow between two nodes of the anode GDL (mol.m-2.s-1). J_H2_agdl_ampl ( float ) \u2013 Hydrogen flow between the last node of the anode GDL and the anode microporous layer (mol.m-2.s-1). J_H2_ampl_acl ( float ) \u2013 Hydrogen flow between the anode microporous layer and the anode catalyst layer (mol.m-2.s-1). J_O2_ccl_cmpl ( float ) \u2013 Oxygen flow between the cathode catalyst layer and the cathode microporous layer (mol.m-2.s-1). J_O2_cmpl_cgdl ( float ) \u2013 Oxygen flow between the cathode microporous layer and the first node of the cathode GDL (mol.m-2.s-1). J_O2_cgdl_cgdl ( list ) \u2013 Oxygen flow between two nodes of the cathode GDL (mol.m-2.s-1). J_O2_cgdl_cgc ( float ) \u2013 Oxygen flow between the cathode GDL and the cathode gas channel (mol.m-2.s-1). S_H2_acl ( float ) \u2013 Hydrogen consumed in the anode CL (mol.m-3.s-1). S_O2_ccl ( float ) \u2013 Oxygen consumed in the cathode CL (mol.m-3.s-1). Source code in model/dif_eq.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def calculate_dyn_H2_O2_N2_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , Hagc , Hcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , J_H2_in , J_H2_out , J_O2_in , J_O2_out , J_N2_in , J_N2_out , J_H2_agc_agdl , J_H2_agdl_agdl , J_H2_agdl_ampl , J_H2_ampl_acl , J_O2_ccl_cmpl , J_O2_cmpl_cgdl , J_O2_cgdl_cgdl , J_O2_cgdl_cgc , S_H2_acl , S_O2_ccl , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the hydrogen, oxygen and nitrogen in the gas channels, the gas diffusion layers and the catalyst layers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl : float Thickness of the gas diffusion layer (m). Hmpl : float Thickness of the microporous layer (m). Hacl : float Thickness of the anode catalyst layer (m). Hccl : float Thickness of the cathode catalyst layer (m). Hagc : float Thickness of the anode gas channel (m). Hcgc : float Thickness of the cathode gas channel (m). Lgc : float Length of the gas channel (m). epsilon_gdl : float Anode/cathode GDL porosity. epsilon_cl : float Anode/cathode CL porosity. epsilon_mpl : float Anode/cathode MPL porosity. n_gdl : int Number of model nodes placed inside each GDL. J_H2_in : float Hydrogen flow at the anode inlet (mol.m-2.s-1). J_H2_out : float Hydrogen flow at the anode outlet (mol.m-2.s-1). J_O2_in : float Oxygen flow at the cathode inlet (mol.m-2.s-1). J_O2_out : float Oxygen flow at the cathode outlet (mol.m-2.s-1). J_N2_in : float Nitrogen flow at the cathode inlet (mol.m-2.s-1). J_N2_out : float Nitrogen flow at the cathode outlet (mol.m-2.s-1). J_H2_agc_agdl : float Hydrogen flow between the anode gas channel and the anode GDL (mol.m-2.s-1). J_H2_agdl_agdl : list Hydrogen flow between two nodes of the anode GDL (mol.m-2.s-1). J_H2_agdl_ampl : float Hydrogen flow between the last node of the anode GDL and the anode microporous layer (mol.m-2.s-1). J_H2_ampl_acl : float Hydrogen flow between the anode microporous layer and the anode catalyst layer (mol.m-2.s-1). J_O2_ccl_cmpl : float Oxygen flow between the cathode catalyst layer and the cathode microporous layer (mol.m-2.s-1). J_O2_cmpl_cgdl : float Oxygen flow between the cathode microporous layer and the first node of the cathode GDL (mol.m-2.s-1). J_O2_cgdl_cgdl : list Oxygen flow between two nodes of the cathode GDL (mol.m-2.s-1). J_O2_cgdl_cgc : float Oxygen flow between the cathode GDL and the cathode gas channel (mol.m-2.s-1). S_H2_acl : float Hydrogen consumed in the anode CL (mol.m-3.s-1). S_O2_ccl : float Oxygen consumed in the cathode CL (mol.m-3.s-1). \"\"\" # At the anode side # Inside the AGC dif_eq [ 'dC_H2_agc / dt' ] = ( J_H2_in - J_H2_out ) / Lgc - J_H2_agc_agdl / Hagc # Inside the AGDL dif_eq [ 'dC_H2_agdl_1 / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ 's_agdl_1' ])) * \\ ( J_H2_agc_agdl - J_H2_agdl_agdl [ 1 ]) / ( Hgdl / n_gdl ) for i in range ( 2 , n_gdl ): dif_eq [ f 'dC_H2_agdl_ { i } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_agdl_ { i } ' ])) * \\ ( J_H2_agdl_agdl [ i - 1 ] - J_H2_agdl_agdl [ i ]) / ( Hgdl / n_gdl ) dif_eq [ f 'dC_H2_agdl_ { n_gdl } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_agdl_ { n_gdl } ' ])) * \\ ( J_H2_agdl_agdl [ n_gdl - 1 ] - J_H2_agdl_ampl ) / ( Hgdl / n_gdl ) # Inside the AMPL dif_eq [ 'dC_H2_ampl / dt' ] = 1 / ( epsilon_mpl * ( 1 - sv [ 's_ampl' ])) * ( J_H2_agdl_ampl - J_H2_ampl_acl ) / Hmpl # Inside the ACL dif_eq [ 'dC_H2_acl / dt' ] = 1 / ( epsilon_cl * ( 1 - sv [ 's_acl' ])) * ( J_H2_ampl_acl / Hacl + S_H2_acl ) # At the cathode side # Inside the CCL dif_eq [ 'dC_O2_ccl / dt' ] = 1 / ( epsilon_cl * ( 1 - sv [ 's_ccl' ])) * ( - J_O2_ccl_cmpl / Hccl + S_O2_ccl ) # Inside the CMPL dif_eq [ 'dC_O2_cmpl / dt' ] = 1 / ( epsilon_mpl * ( 1 - sv [ 's_cmpl' ])) * ( J_O2_ccl_cmpl - J_O2_cmpl_cgdl ) / Hmpl # Inside the CGDL dif_eq [ 'dC_O2_cgdl_1 / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ 's_cgdl_1' ])) * \\ ( J_O2_cmpl_cgdl - J_O2_cgdl_cgdl [ 1 ]) / ( Hgdl / n_gdl ) for i in range ( 2 , n_gdl ): dif_eq [ f 'dC_O2_cgdl_ { i } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_cgdl_ { i } ' ])) * \\ ( J_O2_cgdl_cgdl [ i - 1 ] - J_O2_cgdl_cgdl [ i ]) / ( Hgdl / n_gdl ) dif_eq [ f 'dC_O2_cgdl_ { n_gdl } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_cgdl_ { n_gdl } ' ])) * \\ ( J_O2_cgdl_cgdl [ n_gdl - 1 ] - J_O2_cgdl_cgc ) / ( Hgdl / n_gdl ) # Inside the CGC dif_eq [ 'dC_O2_cgc / dt' ] = ( J_O2_in - J_O2_out ) / Lgc + J_O2_cgdl_cgc / Hcgc # Inside the whole cell dif_eq [ 'dC_N2 / dt' ] = ( J_N2_in - J_N2_out ) / Lgc","title":"calculate_dyn_H2_O2_N2_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_air_compressor_and_humidifier_evolution","text":"This function calculates the dynamic evolution of the air compressor and the humidifiers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. Wcp_des ( float ) \u2013 Desired air compressor flow rate (kg.s-1). Wa_inj_des ( float ) \u2013 Desired anode humidifier flow rate (kg.s-1). Wc_inj_des ( float ) \u2013 Desired cathode humidifier flow rate (kg.s-1). type_auxiliary ( str ) \u2013 Type of auxiliary components used in the fuel cell model. Wcp ( float ) \u2013 Air compressor flow rate (kg.s-1). Wa_inj ( float ) \u2013 Anode humidifier flow rate (kg.s-1). Wc_inj ( float ) \u2013 Cathode humidifier flow rate (kg.s-1). Source code in model/dif_eq.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 def calculate_dyn_air_compressor_and_humidifier_evolution ( dif_eq , Wcp_des , Wa_inj_des , Wc_inj_des , type_auxiliary , Wcp , Wa_inj , Wc_inj , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the air compressor and the humidifiers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. Wcp_des : float Desired air compressor flow rate (kg.s-1). Wa_inj_des : float Desired anode humidifier flow rate (kg.s-1). Wc_inj_des : float Desired cathode humidifier flow rate (kg.s-1). type_auxiliary : str Type of auxiliary components used in the fuel cell model. Wcp : float Air compressor flow rate (kg.s-1). Wa_inj : float Anode humidifier flow rate (kg.s-1). Wc_inj : float Cathode humidifier flow rate (kg.s-1). \"\"\" # Air compressor evolution if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : dif_eq [ 'dWcp / dt' ] = ( Wcp_des - Wcp ) / tau_cp # Estimation at the first order. elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dWcp / dt' ] = ( Wcp_des - Wcp ) / tau_cp # Estimation at the first order. else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dWcp / dt' ] = 0 # Anode and cathode humidifiers evolution if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : dif_eq [ 'dWa_inj / dt' ] = 0 dif_eq [ 'dWc_inj / dt' ] = ( Wc_inj_des - Wc_inj ) / tau_hum # Estimation at the first order. elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dWa_inj / dt' ] = ( Wa_inj_des - Wa_inj ) / tau_hum # Estimation at the first order. dif_eq [ 'dWc_inj / dt' ] = ( Wc_inj_des - Wc_inj ) / tau_hum # Estimation at the first order. else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dWa_inj / dt' ], dif_eq [ 'dWc_inj / dt' ] = 0 , 0","title":"calculate_dyn_air_compressor_and_humidifier_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_dissoved_water_evolution","text":"This function calculates the dynamic evolution of the dissolved water in the membrane and the catalyst layers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. Hmem ( float ) \u2013 Thickness of the membrane (m). Hacl ( float ) \u2013 Thickness of the anode catalyst layer (m). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the catalyst layer. S_abs_acl ( float ) \u2013 Water absorption in the anode catalyst layer (mol.m-3.s-1) S_abs_ccl ( float ) \u2013 Water absorption in the cathode catalyst layer (mol.m-3.s-1) J_lambda_acl_mem ( float ) \u2013 Dissolved water flow between the anode catalyst layer and the membrane (mol.m-2.s-1) J_lambda_mem_ccl ( float ) \u2013 Dissolved water flow between the membrane and the cathode catalyst layer (mol.m-2.s-1) Sp_acl ( float ) \u2013 Water produced in the membrane at the ACL through the chemical reaction and crossover (mol.m-3.s-1) Sp_ccl ( float ) \u2013 Water produced in the membrane at the CCL through the chemical reaction and crossover (mol.m-3.s-1) Source code in model/dif_eq.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def calculate_dyn_dissoved_water_evolution ( dif_eq , Hmem , Hacl , Hccl , epsilon_mc , S_abs_acl , S_abs_ccl , J_lambda_acl_mem , J_lambda_mem_ccl , Sp_acl , Sp_ccl , ** kwargs ): \"\"\" This function calculates the dynamic evolution of the dissolved water in the membrane and the catalyst layers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. Hmem : float Thickness of the membrane (m). Hacl : float Thickness of the anode catalyst layer (m). Hccl : float Thickness of the cathode catalyst layer (m). epsilon_mc : float Volume fraction of ionomer in the catalyst layer. S_abs_acl : float Water absorption in the anode catalyst layer (mol.m-3.s-1) S_abs_ccl : float Water absorption in the cathode catalyst layer (mol.m-3.s-1) J_lambda_acl_mem : float Dissolved water flow between the anode catalyst layer and the membrane (mol.m-2.s-1) J_lambda_mem_ccl : float Dissolved water flow between the membrane and the cathode catalyst layer (mol.m-2.s-1) Sp_acl : float Water produced in the membrane at the ACL through the chemical reaction and crossover (mol.m-3.s-1) Sp_ccl : float Water produced in the membrane at the CCL through the chemical reaction and crossover (mol.m-3.s-1) \"\"\" dif_eq [ 'dlambda_acl / dt' ] = M_eq / ( rho_mem * epsilon_mc ) * ( - J_lambda_acl_mem / Hacl + S_abs_acl + Sp_acl ) dif_eq [ 'dlambda_mem / dt' ] = M_eq / rho_mem * ( J_lambda_acl_mem - J_lambda_mem_ccl ) / Hmem dif_eq [ 'dlambda_ccl / dt' ] = M_eq / ( rho_mem * epsilon_mc ) * ( J_lambda_mem_ccl / Hccl + S_abs_ccl + Sp_ccl )","title":"calculate_dyn_dissoved_water_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_liquid_water_evolution","text":"This function calculates the dynamic evolution of the liquid water in the gas diffusion and catalyst layers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer (m). Hmpl ( float ) \u2013 Thickness of the microporous layer (m). Hacl ( float ) \u2013 Thickness of the anode catalyst layer (m). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_cl ( float ) \u2013 Anode/cathode CL porosity. epsilon_mpl ( float ) \u2013 Anode/cathode MPL porosity. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. Jl_agc_agdl ( float ) \u2013 Liquid water flow between the anode gas channel border and the anode GDL (kg.m-2.s-1). Jl_agdl_agdl ( list ) \u2013 Liquid water flow between two nodes of the anode GDL (kg.m-2.s-1). Jl_agdl_ampl ( float ) \u2013 Liquid water flow between the last node of the anode GDL and the anode microporous layer (kg.m-2.s-1). Jl_ampl_acl ( float ) \u2013 Liquid water flow between the anode microporous layer and the anode catalyst layer (kg.m-2.s-1). Jl_ccl_cmpl ( list ) \u2013 Liquid water flow between the cathode catalyst layer and the cathode microporous layer (kg.m-2.s-1). Jl_cmpl_cgdl ( float ) \u2013 Liquid water flow between the cathode microporous layer and the first node of the cathode GDL (kg.m-2.s-1). Jl_cgdl_cgdl ( list ) \u2013 Liquid water flow between two nodes of the cathode GDL (kg.m-2.s-1). Jl_cgdl_cgc ( float ) \u2013 Liquid water flow between the cathode GDL and the cathode gas channel border (kg.m-2.s-1). Sl_agdl ( list ) \u2013 Liquid water produced in the anode GDL (kg.m-3.s-1). Sl_acl ( float ) \u2013 Liquid water produced in the anode CL (kg.m-3.s-1). Sl_ccl ( float ) \u2013 Liquid water produced in the cathode CL (kg.m-3.s-1). Sl_cgdl ( list ) \u2013 Liquid water produced in the cathode GDL (kg.m-3.s-1). Source code in model/dif_eq.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def calculate_dyn_liquid_water_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , Jl_agc_agdl , Jl_agdl_agdl , Jl_agdl_ampl , Jl_ampl_acl , Jl_ccl_cmpl , Jl_cmpl_cgdl , Jl_cgdl_cgdl , Jl_cgdl_cgc , Sl_agdl , Sl_ampl , Sl_acl , Sl_ccl , Sl_cmpl , Sl_cgdl , ** kwargs ): \"\"\" This function calculates the dynamic evolution of the liquid water in the gas diffusion and catalyst layers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl : float Thickness of the gas diffusion layer (m). Hmpl : float Thickness of the microporous layer (m). Hacl : float Thickness of the anode catalyst layer (m). Hccl : float Thickness of the cathode catalyst layer (m). epsilon_gdl : float Anode/cathode GDL porosity. epsilon_cl : float Anode/cathode CL porosity. epsilon_mpl : float Anode/cathode MPL porosity. n_gdl : int Number of model nodes placed inside each GDL. Jl_agc_agdl : float Liquid water flow between the anode gas channel border and the anode GDL (kg.m-2.s-1). Jl_agdl_agdl : list Liquid water flow between two nodes of the anode GDL (kg.m-2.s-1). Jl_agdl_ampl : float Liquid water flow between the last node of the anode GDL and the anode microporous layer (kg.m-2.s-1). Jl_ampl_acl : float Liquid water flow between the anode microporous layer and the anode catalyst layer (kg.m-2.s-1). Jl_ccl_cmpl : list Liquid water flow between the cathode catalyst layer and the cathode microporous layer (kg.m-2.s-1). Jl_cmpl_cgdl : float Liquid water flow between the cathode microporous layer and the first node of the cathode GDL (kg.m-2.s-1). Jl_cgdl_cgdl : list Liquid water flow between two nodes of the cathode GDL (kg.m-2.s-1). Jl_cgdl_cgc : float Liquid water flow between the cathode GDL and the cathode gas channel border (kg.m-2.s-1). Sl_agdl : list Liquid water produced in the anode GDL (kg.m-3.s-1). Sl_acl : float Liquid water produced in the anode CL (kg.m-3.s-1). Sl_ccl : float Liquid water produced in the cathode CL (kg.m-3.s-1). Sl_cgdl : list Liquid water produced in the cathode GDL (kg.m-3.s-1). \"\"\" # At the anode side # Inside the AGDL dif_eq [ 'ds_agdl_1 / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_agdl_1' ]) * epsilon_gdl ) * \\ (( Jl_agc_agdl - Jl_agdl_agdl [ 1 ]) / ( Hgdl / n_gdl ) + M_H2O * Sl_agdl [ 1 ]) for i in range ( 2 , n_gdl ): dif_eq [ f 'ds_agdl_ { i } / dt' ] = 1 / ( rho_H2O_l ( sv [ f 'T_agdl_ { i } ' ]) * epsilon_gdl ) * \\ (( Jl_agdl_agdl [ i - 1 ] - Jl_agdl_agdl [ i ]) / ( Hgdl / n_gdl ) + M_H2O * Sl_agdl [ i ]) dif_eq [ f 'ds_agdl_ { n_gdl } / dt' ] = 1 / ( rho_H2O_l ( sv [ f 'T_agdl_ { n_gdl } ' ]) * epsilon_gdl ) * \\ (( Jl_agdl_agdl [ n_gdl - 1 ] - Jl_agdl_ampl ) / ( Hgdl / n_gdl ) + M_H2O * Sl_agdl [ n_gdl ]) # Inside the AMPL dif_eq [ 'ds_ampl / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_ampl' ]) * epsilon_mpl ) * (( Jl_agdl_ampl - Jl_ampl_acl ) / Hmpl + M_H2O * Sl_ampl ) # Inside the ACL dif_eq [ 'ds_acl / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_acl' ]) * epsilon_cl ) * ( Jl_ampl_acl / Hacl + M_H2O * Sl_acl ) # At the cathode side # Inside the CCL dif_eq [ 'ds_ccl / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_ccl' ]) * epsilon_cl ) * ( - Jl_ccl_cmpl / Hccl + M_H2O * Sl_ccl ) # Inside the CMPL dif_eq [ 'ds_cmpl / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_cmpl' ]) * epsilon_mpl ) * (( Jl_ccl_cmpl - Jl_cmpl_cgdl ) / Hmpl + M_H2O * Sl_cmpl ) # Inside the CGDL dif_eq [ 'ds_cgdl_1 / dt' ] = 1 / ( rho_H2O_l ( sv [ 'T_cgdl_1' ]) * epsilon_gdl ) * \\ (( Jl_cmpl_cgdl - Jl_cgdl_cgdl [ 1 ]) / ( Hgdl / n_gdl ) + M_H2O * Sl_cgdl [ 1 ]) for i in range ( 2 , n_gdl ): dif_eq [ f 'ds_cgdl_ { i } / dt' ] = 1 / ( rho_H2O_l ( sv [ f 'T_cgdl_ { i } ' ]) * epsilon_gdl ) * \\ (( Jl_cgdl_cgdl [ i - 1 ] - Jl_cgdl_cgdl [ i ]) / ( Hgdl / n_gdl ) + M_H2O * Sl_cgdl [ i ]) dif_eq [ f 'ds_cgdl_ { n_gdl } / dt' ] = 1 / ( rho_H2O_l ( sv [ f 'T_cgdl_ { n_gdl } ' ]) * epsilon_gdl ) * \\ (( Jl_cgdl_cgdl [ n_gdl - 1 ] - Jl_cgdl_cgc ) / ( Hgdl / n_gdl ) + M_H2O * Sl_cgdl [ n_gdl ])","title":"calculate_dyn_liquid_water_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_manifold_pressure_and_humidity_evolution","text":"This function calculates the dynamic evolution of the pressure and humidity inside the manifolds. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. Masm ( float ) \u2013 Molar mass of all the gaseous species inside the anode supply manifold (kg.mol-1). Maem ( float ) \u2013 Molar mass of all the gaseous species inside the anode exhaust manifold (kg.mol-1). Mcsm ( float ) \u2013 Molar mass of all the gaseous species inside the cathode supply manifold (kg.mol-1). Mcem ( float ) \u2013 Molar mass of all the gaseous species inside the cathode exhaust manifold (kg.mol-1). T_des ( float ) \u2013 Fuel cell temperature (K). Hagc ( float ) \u2013 Thickness of the anode gas channel (m). Hcgc ( float ) \u2013 Thickness of the cathode gas channel (m). Wagc ( float ) \u2013 Width of the anode gas channel (m). Wcgc ( float ) \u2013 Width of the cathode gas channel (m). type_auxiliary ( str ) \u2013 Type of auxiliary components used in the fuel cell model. Jv_a_in ( float ) \u2013 Water vapor flow at the anode inlet (mol.m-2.s-1). Jv_a_out ( float ) \u2013 Water vapor flow at the anode outlet (mol.m-2.s-1). Jv_c_in ( float ) \u2013 Water vapor flow at the cathode inlet (mol.m-2.s-1). Jv_c_out ( float ) \u2013 Water vapor flow at the cathode outlet (mol.m-2.s-1). Wasm_in ( float ) \u2013 Flow at the anode supply manifold inlet (kg.s-1). Wasm_out ( float ) \u2013 Flow at the anode supply manifold outlet (kg.s-1). Waem_in ( float ) \u2013 Flow at the anode exhaust manifold inlet (kg.s-1). Waem_out ( float ) \u2013 Flow at the anode exhaust manifold outlet (kg.s-1). Wcsm_in ( float ) \u2013 Flow at the cathode supply manifold inlet (kg.s-1). Wcsm_out ( float ) \u2013 Flow at the cathode supply manifold outlet (kg.s-1). Wcem_in ( float ) \u2013 Flow at the cathode exhaust manifold inlet (kg.s-1). Wcem_out ( float ) \u2013 Flow at the cathode exhaust manifold outlet (kg.s-1). Ware ( float ) \u2013 Anode side recirculation flow (kg.s-1). Wv_asm_in ( float ) \u2013 Vapor flow at the anode supply manifold inlet (mol.s-1). Wv_aem_out ( float ) \u2013 Vapor flow at the anode external manifold outlet (mol.s-1). Wv_csm_in ( float ) \u2013 Vapor flow at the cathode supply manifold inlet (mol.s-1). Wv_cem_out ( float ) \u2013 Vapor flow at the cathode external manifold outlet (mol.s-1). Source code in model/dif_eq.py 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 def calculate_dyn_manifold_pressure_and_humidity_evolution ( dif_eq , Masm , Maem , Mcsm , Mcem , T_des , Hagc , Hcgc , Wagc , Wcgc , type_auxiliary , Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , Wasm_in , Wasm_out , Waem_in , Waem_out , Wcsm_in , Wcsm_out , Wcem_in , Wcem_out , Ware , Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the pressure and humidity inside the manifolds. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. Masm : float Molar mass of all the gaseous species inside the anode supply manifold (kg.mol-1). Maem : float Molar mass of all the gaseous species inside the anode exhaust manifold (kg.mol-1). Mcsm : float Molar mass of all the gaseous species inside the cathode supply manifold (kg.mol-1). Mcem : float Molar mass of all the gaseous species inside the cathode exhaust manifold (kg.mol-1). T_des : float Fuel cell temperature (K). Hagc : float Thickness of the anode gas channel (m). Hcgc : float Thickness of the cathode gas channel (m). Wagc : float Width of the anode gas channel (m). Wcgc : float Width of the cathode gas channel (m). type_auxiliary : str Type of auxiliary components used in the fuel cell model. Jv_a_in : float Water vapor flow at the anode inlet (mol.m-2.s-1). Jv_a_out : float Water vapor flow at the anode outlet (mol.m-2.s-1). Jv_c_in : float Water vapor flow at the cathode inlet (mol.m-2.s-1). Jv_c_out : float Water vapor flow at the cathode outlet (mol.m-2.s-1). Wasm_in : float Flow at the anode supply manifold inlet (kg.s-1). Wasm_out : float Flow at the anode supply manifold outlet (kg.s-1). Waem_in : float Flow at the anode exhaust manifold inlet (kg.s-1). Waem_out : float Flow at the anode exhaust manifold outlet (kg.s-1). Wcsm_in : float Flow at the cathode supply manifold inlet (kg.s-1). Wcsm_out : float Flow at the cathode supply manifold outlet (kg.s-1). Wcem_in : float Flow at the cathode exhaust manifold inlet (kg.s-1). Wcem_out : float Flow at the cathode exhaust manifold outlet (kg.s-1). Ware : float Anode side recirculation flow (kg.s-1). Wv_asm_in : float Vapor flow at the anode supply manifold inlet (mol.s-1). Wv_aem_out : float Vapor flow at the anode external manifold outlet (mol.s-1). Wv_csm_in : float Vapor flow at the cathode supply manifold inlet (mol.s-1). Wv_cem_out : float Vapor flow at the cathode external manifold outlet (mol.s-1). \"\"\" # Pressure evolution inside the manifolds if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : dif_eq [ 'dPasm / dt' ] = ( Wasm_in + Ware - n_cell * Wasm_out ) / ( Vsm * Masm ) * R * T_des dif_eq [ 'dPaem / dt' ] = ( n_cell * Waem_in - Ware - Waem_out ) / ( Vem * Maem ) * R * T_des dif_eq [ 'dPcsm / dt' ] = ( Wcsm_in - n_cell * Wcsm_out ) / ( Vsm * Mcsm ) * R * T_des dif_eq [ 'dPcem / dt' ] = ( n_cell * Wcem_in - Wcem_out ) / ( Vem * Mcem ) * R * T_des elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dPasm / dt' ] = ( Wasm_in - n_cell * Wasm_out ) / ( Vsm * Masm ) * R * T_des dif_eq [ 'dPaem / dt' ] = ( n_cell * Waem_in - Waem_out ) / ( Vem * Maem ) * R * T_des dif_eq [ 'dPcsm / dt' ] = ( Wcsm_in - n_cell * Wcsm_out ) / ( Vsm * Mcsm ) * R * T_des dif_eq [ 'dPcem / dt' ] = ( n_cell * Wcem_in - Wcem_out ) / ( Vem * Mcem ) * R * T_des else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dPasm / dt' ], dif_eq [ 'dPaem / dt' ], dif_eq [ 'dPcsm / dt' ], dif_eq [ 'dPcem / dt' ] = 0 , 0 , 0 , 0 # Humidity evolution inside the manifolds if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : dif_eq [ 'dPhi_asm / dt' ] = ( Wv_asm_in - Jv_a_in * Hagc * Wagc * n_cell ) / Vsm * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_aem / dt' ] = ( Jv_a_out * Hagc * Wagc * n_cell - Wv_asm_in - Wv_aem_out ) / Vem * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_csm / dt' ] = ( Wv_csm_in - Jv_c_in * Hcgc * Wcgc * n_cell ) / Vsm * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_cem / dt' ] = ( Jv_c_out * Hcgc * Wcgc * n_cell - Wv_cem_out ) / Vem * R * T_des / Psat ( T_des ) elif type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dPhi_asm / dt' ] = ( Wv_asm_in - Jv_a_in * Hagc * Wagc * n_cell ) / Vsm * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_aem / dt' ] = ( Jv_a_out * Hagc * Wagc * n_cell - Wv_aem_out ) / Vem * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_csm / dt' ] = ( Wv_csm_in - Jv_c_in * Hcgc * Wcgc * n_cell ) / Vsm * R * T_des / Psat ( T_des ) dif_eq [ 'dPhi_cem / dt' ] = ( Jv_c_out * Hcgc * Wcgc * n_cell - Wv_cem_out ) / Vem * R * T_des / Psat ( T_des ) else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dPhi_asm / dt' ], dif_eq [ 'dPhi_aem / dt' ], dif_eq [ 'dPhi_csm / dt' ], dif_eq [ 'dPhi_cem / dt' ] = 0 , 0 , 0 , 0","title":"calculate_dyn_manifold_pressure_and_humidity_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_temperature_evolution","text":"This function calculates the dynamic evolution of the temperature in the fuel cell. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. rho_Cp0 ( dict ) \u2013 Volumetric heat capacity of the different components of the fuel cell system, in J.m-3.K-1. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer, in m. Hmpl ( float ) \u2013 Thickness of the microporous layer, in m. Hacl ( float ) \u2013 Thickness of the anode catalyst layer, in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer, in m. Hmem ( float ) \u2013 Thickness of the membrane, in m. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. Jt ( dict ) \u2013 Heat flows occuring inside the fuel cell system, J.m-2.s-1. Q_r ( dict ) \u2013 Heat dissipated by the electrochemical reaction 2 H2 + O2 -> 2 H2O, in J.m-3.s-1. Q_sorp ( dict ) \u2013 Heat dissipated by the absorption of water from the CL to the membrane, in J.m-3.s-1. Q_liq ( dict ) \u2013 Heat dissipated by the evaporation of liquid water, in J.m-3.s-1. Q_p ( dict ) \u2013 Heat dissipated by the ionic currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_e ( dict ) \u2013 Heat dissipated by the electric currents (Joule heating + Ohm's law), in J.m-3.s-1. Source code in model/dif_eq.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 def calculate_dyn_temperature_evolution ( dif_eq , rho_Cp0 , Hgdl , Hmpl , Hacl , Hccl , Hmem , n_gdl , Jt , Q_r , Q_sorp , Q_liq , Q_p , Q_e , ** kwargs ): \"\"\" This function calculates the dynamic evolution of the temperature in the fuel cell. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. rho_Cp0 : dict Volumetric heat capacity of the different components of the fuel cell system, in J.m-3.K-1. Hgdl : float Thickness of the gas diffusion layer, in m. Hmpl : float Thickness of the microporous layer, in m. Hacl : float Thickness of the anode catalyst layer, in m. Hccl : float Thickness of the cathode catalyst layer, in m. Hmem : float Thickness of the membrane, in m. n_gdl : int Number of model nodes placed inside each GDL. Jt : dict Heat flows occuring inside the fuel cell system, J.m-2.s-1. Q_r : dict Heat dissipated by the electrochemical reaction 2*H2 + O2 -> 2*H2O, in J.m-3.s-1. Q_sorp : dict Heat dissipated by the absorption of water from the CL to the membrane, in J.m-3.s-1. Q_liq : dict Heat dissipated by the evaporation of liquid water, in J.m-3.s-1. Q_p : dict Heat dissipated by the ionic currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_e : dict Heat dissipated by the electric currents (Joule heating + Ohm's law), in J.m-3.s-1. \"\"\" # At the anode side # Inside the AGC dif_eq [ 'dT_agc / dt' ] = 0 # Dirichlet boundary condition. T_agc is initialized to T_fc and remains constant. # Inside the AGDL dif_eq [ 'dT_agdl_1 / dt' ] = ( 1 / rho_Cp0 [ 'agdl_1' ]) * \\ ( ( Jt [ 'agc_agdl' ] - Jt [ 'agdl_agdl_1' ]) / ( Hgdl / n_gdl ) + Q_liq [ 'agdl_1' ] + Q_e [ 'agdl_1' ] ) for i in range ( 2 , n_gdl ): dif_eq [ f 'dT_agdl_ { i } / dt' ] = ( 1 / rho_Cp0 [ f 'agdl_ { i } ' ]) * \\ ( ( Jt [ f 'agdl_agdl_ { i - 1 } ' ] - Jt [ f 'agdl_agdl_ { i } ' ]) / ( Hgdl / n_gdl ) + Q_liq [ f 'agdl_ { i } ' ] + Q_e [ f 'agdl_ { i } ' ] ) dif_eq [ f 'dT_agdl_ { n_gdl } / dt' ] = ( 1 / rho_Cp0 [ f 'agdl_ { n_gdl } ' ]) * \\ ( ( Jt [ f 'agdl_agdl_ { n_gdl - 1 } ' ] - Jt [ 'agdl_ampl' ]) / ( Hgdl / n_gdl ) + Q_liq [ f 'agdl_ { n_gdl } ' ] + Q_e [ f 'agdl_ { n_gdl } ' ] ) # Inside the AMPL dif_eq [ 'dT_ampl / dt' ] = ( 1 / rho_Cp0 [ 'ampl' ]) * ( ( Jt [ 'agdl_ampl' ] - Jt [ 'ampl_acl' ]) / Hmpl + Q_liq [ 'ampl' ] + Q_e [ 'ampl' ] ) # Inside the ACL dif_eq [ 'dT_acl / dt' ] = ( 1 / rho_Cp0 [ 'acl' ]) * \\ ( ( Jt [ 'ampl_acl' ] - Jt [ 'acl_mem' ]) / Hacl + Q_r [ 'acl' ] + Q_sorp [ 'acl' ] + Q_liq [ 'acl' ] + Q_e [ 'acl' ] ) # Inside the membrane dif_eq [ 'dT_mem / dt' ] = ( 1 / rho_Cp0 [ 'mem' ]) * \\ ( ( Jt [ 'acl_mem' ] - Jt [ 'mem_ccl' ]) / Hmem + Q_p [ 'mem' ] ) # At the cathode side # Inside the CCL dif_eq [ 'dT_ccl / dt' ] = ( 1 / rho_Cp0 [ 'ccl' ]) * \\ ( ( Jt [ 'mem_ccl' ] - Jt [ 'ccl_cmpl' ]) / Hccl + Q_r [ 'ccl' ] + Q_sorp [ 'acl' ] + Q_liq [ 'ccl' ] + Q_p [ 'ccl' ] + Q_e [ 'ccl' ] ) # Inside the CMPL dif_eq [ 'dT_cmpl / dt' ] = ( 1 / rho_Cp0 [ 'cmpl' ]) * (( Jt [ 'ccl_cmpl' ] - Jt [ 'cmpl_cgdl' ]) / Hmpl + Q_liq [ 'cmpl' ] + Q_e [ 'cmpl' ]) # Inside the CGDL dif_eq [ 'dT_cgdl_1 / dt' ] = ( 1 / rho_Cp0 [ 'cgdl_1' ]) * \\ ( ( Jt [ 'cmpl_cgdl' ] - Jt [ 'cgdl_cgdl_1' ]) / ( Hgdl / n_gdl ) + Q_liq [ 'cgdl_1' ] + Q_e [ 'cgdl_1' ] ) for i in range ( 2 , n_gdl ): dif_eq [ f 'dT_cgdl_ { i } / dt' ] = ( 1 / rho_Cp0 [ f 'cgdl_ { i } ' ]) * \\ ( ( Jt [ f 'cgdl_cgdl_ { i - 1 } ' ] - Jt [ f 'cgdl_cgdl_ { i } ' ]) / ( Hgdl / n_gdl ) + Q_liq [ f 'cgdl_ { i } ' ] + Q_e [ f 'cgdl_ { i } ' ] ) dif_eq [ f 'dT_cgdl_ { n_gdl } / dt' ] = ( 1 / rho_Cp0 [ f 'cgdl_ { n_gdl } ' ]) * \\ ( ( Jt [ f 'cgdl_cgdl_ { n_gdl - 1 } ' ] - Jt [ 'cgdl_cgc' ]) / ( Hgdl / n_gdl ) + Q_liq [ f 'cgdl_ { n_gdl } ' ] + Q_e [ f 'cgdl_ { n_gdl } ' ] ) # Inside the CCG dif_eq [ 'dT_cgc / dt' ] = 0 # Dirichlet boundary condition. T_cgc is initialized to T_fc and remains constant.","title":"calculate_dyn_temperature_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_throttle_area_evolution","text":"This function calculates the dynamic evolution of the throttle area inside the anode and cathode auxiliaries. This function has to be executed after 'calculate_dyn_vapor_evolution' and 'calculate_dyn_H2_O2_N2_evolution'. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. Pagc ( float ) \u2013 Pressure inside the anode gas channel (Pa). Pcgc ( float ) \u2013 Pressure inside the cathode gas channel (Pa). T_agc ( float ) \u2013 Fuel cell temperature in the anode gas channel (K). T_cgc ( float ) \u2013 Fuel cell temperature in the cathode gas channel (K). Abp_a ( float ) \u2013 Throttle area inside the anode auxiliaries (m2). Abp_c ( float ) \u2013 Throttle area inside the cathode auxiliaries (m2). Pa_des ( float ) \u2013 Desired pressure inside the anode gas channel (Pa). Pc_des ( float ) \u2013 Desired pressure inside the cathode gas channel (Pa). type_auxiliary ( str ) \u2013 Type of auxiliary components used in the fuel cell model. Source code in model/dif_eq.py 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 def calculate_dyn_throttle_area_evolution ( dif_eq , Pagc , Pcgc , T_agc , T_cgc , Abp_a , Abp_c , Pa_des , Pc_des , type_auxiliary , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the throttle area inside the anode and cathode auxiliaries. This function has to be executed after 'calculate_dyn_vapor_evolution' and 'calculate_dyn_H2_O2_N2_evolution'. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. Pagc : float Pressure inside the anode gas channel (Pa). Pcgc : float Pressure inside the cathode gas channel (Pa). T_agc : float Fuel cell temperature in the anode gas channel (K). T_cgc : float Fuel cell temperature in the cathode gas channel (K). Abp_a : float Throttle area inside the anode auxiliaries (m2). Abp_c : float Throttle area inside the cathode auxiliaries (m2). Pa_des : float Desired pressure inside the anode gas channel (Pa). Pc_des : float Desired pressure inside the cathode gas channel (Pa). type_auxiliary : str Type of auxiliary components used in the fuel cell model. \"\"\" # Calculation of the pressure derivative inside the gas channels dPagcdt = ( dif_eq [ 'dC_v_agc / dt' ] + dif_eq [ 'dC_H2_agc / dt' ]) * R * T_agc dPcgcdt = ( dif_eq [ 'dC_v_cgc / dt' ] + dif_eq [ 'dC_O2_cgc / dt' ] + dif_eq [ 'dC_N2 / dt' ]) * R * T_cgc # Throttle area evolution inside the anode auxiliaries if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dAbp_a / dt' ] = - Kp * ( Pa_des - Pagc ) + Kd * dPagcdt # PD controller if Abp_a > A_T and dif_eq [ 'dAbp_a / dt' ] > 0 : # The throttle area cannot be higher than the maximum value dif_eq [ 'dAbp_a / dt' ] = 0 elif Abp_a < 0 and dif_eq [ 'dAbp_a / dt' ] < 0 : # The throttle area cannot be lower than 0 dif_eq [ 'dAbp_a / dt' ] = 0 else : # elif type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ # type_auxiliary == \"no_auxiliary\": dif_eq [ 'dAbp_a / dt' ] = 0 # The throttle area is not considered # Throttle area evolution inside the cathode auxiliaries if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : dif_eq [ 'dAbp_c / dt' ] = - Kp * ( Pc_des - Pcgc ) + Kd * dPcgcdt # PD controller if Abp_c > A_T and dif_eq [ 'dAbp_c / dt' ] > 0 : # The throttle area cannot be higher than the maximum value dif_eq [ 'dAbp_c / dt' ] = 0 elif Abp_c < 0 and dif_eq [ 'dAbp_c / dt' ] < 0 : # The throttle area cannot be lower than 0 dif_eq [ 'dAbp_c / dt' ] = 0 else : # elif type_auxiliary == \"no_auxiliary\": dif_eq [ 'dAbp_a / dt' ] = 0 # The throttle area is not considered","title":"calculate_dyn_throttle_area_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_vapor_evolution","text":"This function calculates the dynamic evolution of the vapor in the gas channels, the gas diffusion layers and the catalyst layers. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer (m). Hmpl ( float ) \u2013 Thickness of the microporous layer (m). Hacl ( float ) \u2013 Thickness of the anode catalyst layer (m). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). Hagc ( float ) \u2013 Thickness of the anode gas channel (m). Hcgc ( float ) \u2013 Thickness of the cathode gas channel (m). Lgc ( float ) \u2013 Length of the gas channel (m). epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_cl ( float ) \u2013 Anode/cathode CL porosity. epsilon_mpl ( float ) \u2013 Anode/cathode MPL porosity. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. Jv_a_in ( float ) \u2013 Water vapor flow at the anode inlet (mol.m-2.s-1). Jv_a_out ( float ) \u2013 Water vapor flow at the anode outlet (mol.m-2.s-1). Jv_c_in ( float ) \u2013 Water vapor flow at the cathode inlet (mol.m-2.s-1). Jv_c_out ( float ) \u2013 Water vapor flow at the cathode outlet (mol.m-2.s-1). Jv_agc_agdl ( float ) \u2013 Water vapor flow between the anode gas channel and the anode GDL (mol.m-2.s-1). Jv_agdl_agdl ( float ) \u2013 Water vapor flow between two nodes of the anode GDL (mol.m-2.s-1). Jv_agdl_ampl ( float ) \u2013 Water vapor flow between the last node of the anode GDL and the anode microporous layer (mol.m-2.s-1). Jv_ampl_acl ( list ) \u2013 Water vapor flow between the anode microporous layer and the anode catalyst layer (mol.m-2.s-1). S_abs_acl \u2013 Water vapor absorption in the anode CL (mol.m-3.s-1). S_abs_ccl \u2013 Water vapor absorption in the cathode CL (mol.m-3.s-1). Jv_ccl_cmpl ( list ) \u2013 Water vapor flow between the cathode catalyst layer and the cathode microporous layer (mol.m-2.s-1). Jv_cmpl_cgdl ( float ) \u2013 Water vapor flow between the cathode microporous layer and the first node of the cathode GDL (mol.m-2.s-1). Jv_cgdl_cgdl ( list ) \u2013 Water vapor flow between two nodes of the cathode GDL (mol.m-2.s-1). Jv_cgdl_cgc ( float ) \u2013 Water vapor flow between the cathode GDL and the cathode gas channel (mol.m-2.s-1). Sv_agdl ( list ) \u2013 Water vapor produced in the anode GDL (mol.m-3.s-1). Sv_ampl ( float ) \u2013 Water vapor produced in the anode microporous layer (mol.m-3.s-1). Sv_acl ( float ) \u2013 Water vapor produced in the anode CL (mol.m-3.s-1). Sv_ccl ( float ) \u2013 Water vapor produced in the cathode CL (mol.m-3.s-1). Sv_cmpl ( float ) \u2013 Water vapor produced in the cathode microporous layer (mol.m-3.s-1). Sv_cgdl ( list ) \u2013 Water vapor produced in the cathode GDL (mol.m-3.s-1). Source code in model/dif_eq.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def calculate_dyn_vapor_evolution ( dif_eq , sv , Hgdl , Hmpl , Hacl , Hccl , Hagc , Hcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , n_gdl , Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , Jv_agc_agdl , Jv_agdl_agdl , Jv_agdl_ampl , Jv_ampl_acl , S_abs_acl , S_abs_ccl , Jv_ccl_cmpl , Jv_cmpl_cgdl , Jv_cgdl_cgdl , Jv_cgdl_cgc , Sv_agdl , Sv_ampl , Sv_acl , Sv_ccl , Sv_cmpl , Sv_cgdl , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the vapor in the gas channels, the gas diffusion layers and the catalyst layers. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. Hgdl : float Thickness of the gas diffusion layer (m). Hmpl : float Thickness of the microporous layer (m). Hacl : float Thickness of the anode catalyst layer (m). Hccl : float Thickness of the cathode catalyst layer (m). Hagc : float Thickness of the anode gas channel (m). Hcgc : float Thickness of the cathode gas channel (m). Lgc : float Length of the gas channel (m). epsilon_gdl : float Anode/cathode GDL porosity. epsilon_cl : float Anode/cathode CL porosity. epsilon_mpl : float Anode/cathode MPL porosity. n_gdl : int Number of model nodes placed inside each GDL. Jv_a_in : float Water vapor flow at the anode inlet (mol.m-2.s-1). Jv_a_out : float Water vapor flow at the anode outlet (mol.m-2.s-1). Jv_c_in : float Water vapor flow at the cathode inlet (mol.m-2.s-1). Jv_c_out : float Water vapor flow at the cathode outlet (mol.m-2.s-1). Jv_agc_agdl : float Water vapor flow between the anode gas channel and the anode GDL (mol.m-2.s-1). Jv_agdl_agdl : float Water vapor flow between two nodes of the anode GDL (mol.m-2.s-1). Jv_agdl_ampl : float Water vapor flow between the last node of the anode GDL and the anode microporous layer (mol.m-2.s-1). Jv_ampl_acl : list Water vapor flow between the anode microporous layer and the anode catalyst layer (mol.m-2.s-1). S_abs_acl: float Water vapor absorption in the anode CL (mol.m-3.s-1). S_abs_ccl: float Water vapor absorption in the cathode CL (mol.m-3.s-1). Jv_ccl_cmpl : list Water vapor flow between the cathode catalyst layer and the cathode microporous layer (mol.m-2.s-1). Jv_cmpl_cgdl : float Water vapor flow between the cathode microporous layer and the first node of the cathode GDL (mol.m-2.s-1). Jv_cgdl_cgdl : list Water vapor flow between two nodes of the cathode GDL (mol.m-2.s-1). Jv_cgdl_cgc : float Water vapor flow between the cathode GDL and the cathode gas channel (mol.m-2.s-1). Sv_agdl : list Water vapor produced in the anode GDL (mol.m-3.s-1). Sv_ampl : float Water vapor produced in the anode microporous layer (mol.m-3.s-1). Sv_acl : float Water vapor produced in the anode CL (mol.m-3.s-1). Sv_ccl : float Water vapor produced in the cathode CL (mol.m-3.s-1). Sv_cmpl : float Water vapor produced in the cathode microporous layer (mol.m-3.s-1). Sv_cgdl : list Water vapor produced in the cathode GDL (mol.m-3.s-1). \"\"\" # At the anode side # Inside the AGC dif_eq [ 'dC_v_agc / dt' ] = ( Jv_a_in - Jv_a_out ) / Lgc - Jv_agc_agdl / Hagc # Inside the AGDL dif_eq [ 'dC_v_agdl_1 / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ 's_agdl_1' ])) * \\ (( Jv_agc_agdl - Jv_agdl_agdl [ 1 ]) / ( Hgdl / n_gdl ) + Sv_agdl [ 1 ]) for i in range ( 2 , n_gdl ): dif_eq [ f 'dC_v_agdl_ { i } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_agdl_ { i } ' ])) * \\ (( Jv_agdl_agdl [ i - 1 ] - Jv_agdl_agdl [ i ]) / ( Hgdl / n_gdl ) + Sv_agdl [ i ]) dif_eq [ f 'dC_v_agdl_ { n_gdl } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_agdl_ { n_gdl } ' ])) * \\ (( Jv_agdl_agdl [ n_gdl - 1 ] - Jv_agdl_ampl ) / ( Hgdl / n_gdl ) + Sv_agdl [ n_gdl ]) # Inside the AMPL dif_eq [ 'dC_v_ampl / dt' ] = 1 / ( epsilon_mpl * ( 1 - sv [ 's_ampl' ])) * (( Jv_agdl_ampl - Jv_ampl_acl ) / Hmpl + Sv_ampl ) # Inside the ACL dif_eq [ 'dC_v_acl / dt' ] = 1 / ( epsilon_cl * ( 1 - sv [ 's_acl' ])) * ( Jv_ampl_acl / Hacl - S_abs_acl + Sv_acl ) # At the cathode side # Inside the CCL dif_eq [ 'dC_v_ccl / dt' ] = 1 / ( epsilon_cl * ( 1 - sv [ 's_ccl' ])) * ( - Jv_ccl_cmpl / Hccl - S_abs_ccl + Sv_ccl ) # Inside the CMPL dif_eq [ 'dC_v_cmpl / dt' ] = 1 / ( epsilon_mpl * ( 1 - sv [ 's_cmpl' ])) * (( Jv_ccl_cmpl - Jv_cmpl_cgdl ) / Hmpl + Sv_cmpl ) # Inside the CGDL dif_eq [ 'dC_v_cgdl_1 / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ 's_cgdl_1' ])) * \\ (( Jv_cmpl_cgdl - Jv_cgdl_cgdl [ 1 ]) / ( Hgdl / n_gdl ) + Sv_cgdl [ 1 ]) for i in range ( 2 , n_gdl ): dif_eq [ f 'dC_v_cgdl_ { i } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_cgdl_ { i } ' ])) * \\ (( Jv_cgdl_cgdl [ i - 1 ] - Jv_cgdl_cgdl [ i ]) / ( Hgdl / n_gdl ) + Sv_cgdl [ i ]) dif_eq [ f 'dC_v_cgdl_ { n_gdl } / dt' ] = 1 / ( epsilon_gdl * ( 1 - sv [ f 's_cgdl_ { n_gdl } ' ])) * \\ (( Jv_cgdl_cgdl [ n_gdl - 1 ] - Jv_cgdl_cgc ) / ( Hgdl / n_gdl ) + Sv_cgdl [ n_gdl ]) # Inside the CGC dif_eq [ 'dC_v_cgc / dt' ] = ( Jv_c_in - Jv_c_out ) / Lgc + Jv_cgdl_cgc / Hcgc","title":"calculate_dyn_vapor_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.calculate_dyn_voltage_evolution","text":"This function calculates the dynamic evolution of the cell overpotential eta_c. Parameters: dif_eq ( dict ) \u2013 Dictionary used for saving the differential equations. i_fc ( float ) \u2013 Fuel cell current density (A.m-2). C_O2_ccl ( float ) \u2013 Oxygen concentration in the cathode catalyst layer (mol.m-3). T_ccl ( float ) \u2013 Fuel cell temperature in the cathode catalyst layer (K). eta_c ( float ) \u2013 Cell overpotential (V). Hccl ( float ) \u2013 Thickness of the cathode catalyst layer (m). i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode (A.m-2). kappa_c ( float ) \u2013 Overpotential correction exponent. C_scl ( float ) \u2013 Volumetric space-charge layer capacitance (F.m-3). i_n ( float ) \u2013 Crossover current density (A.m-2). f_drop ( float ) \u2013 Liquid water induced voltage drop function. Source code in model/dif_eq.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 def calculate_dyn_voltage_evolution ( dif_eq , i_fc , C_O2_ccl , T_ccl , eta_c , Hccl , i0_c_ref , kappa_c , C_scl , i_n , f_drop , ** kwargs ): \"\"\"This function calculates the dynamic evolution of the cell overpotential eta_c. Parameters ---------- dif_eq : dict Dictionary used for saving the differential equations. i_fc : float Fuel cell current density (A.m-2). C_O2_ccl : float Oxygen concentration in the cathode catalyst layer (mol.m-3). T_ccl : float Fuel cell temperature in the cathode catalyst layer (K). eta_c : float Cell overpotential (V). Hccl : float Thickness of the cathode catalyst layer (m). i0_c_ref : float Reference exchange current density at the cathode (A.m-2). kappa_c : float Overpotential correction exponent. C_scl : float Volumetric space-charge layer capacitance (F.m-3). i_n : float Crossover current density (A.m-2). f_drop : float Liquid water induced voltage drop function. \"\"\" dif_eq [ 'deta_c / dt' ] = 1 / ( C_scl * Hccl ) * (( i_fc + i_n ) - i0_c_ref * ( C_O2_ccl / C_O2ref ) ** kappa_c * math . exp ( f_drop * alpha_c * F / ( R * T_ccl ) * eta_c ))","title":"calculate_dyn_voltage_evolution"},{"location":"functions/model/dif_eq/#model.dif_eq.dydt","text":"This function gives the system of differential equations to solve. Parameters: t ( float ) \u2013 Time (s). y ( ndarray ) \u2013 Numpy list of the solver variables. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. solver_variable_names ( list ) \u2013 Names of the solver variables. control_variables ( dict ) \u2013 Variables controlled by the user. Returns: dydt ( list ) \u2013 List containing the derivative of the solver variables. Source code in model/dif_eq.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def dydt ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ): \"\"\"This function gives the system of differential equations to solve. Parameters ---------- t : float Time (s). y : numpy.ndarray Numpy list of the solver variables. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. solver_variable_names : list Names of the solver variables. control_variables : dict Variables controlled by the user. Returns ------- dydt : list List containing the derivative of the solver variables. \"\"\" # Creation of the dif_eq dictionary. It is an intermediate calculation to simplify the writing of the code. dif_eq = {( 'd' + key + ' / dt' ): 0 for key in solver_variable_names } # Creation of the solver_variables dict. It is an intermediate calculation to simplify the writing of the code. solver_variables = {} for index , key in enumerate ( solver_variable_names ): solver_variables [ key ] = y [ index ] # Modifications of the operating conditions in real time, if required. if parameters [ \"type_control\" ] != \"no_control\" : control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ) # Intermediate values i_fc = operating_inputs [ 'current_density' ]( t , parameters ) Mext , Pagc , Pcgc , i_n , Masm , Maem , Mcsm , Mcem , rho_Cp0 = dif_eq_int_values ( solver_variables , operating_inputs , control_variables , parameters ) Wcp_des , Wa_inj_des , Wc_inj_des = desired_flows ( solver_variables , control_variables , i_n , i_fc , operating_inputs , parameters , Mext ) eta_c_intermediate_values = calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ) # Calculation of the flows matter_flows_dico = calculate_flows ( t , solver_variables , control_variables , i_fc , operating_inputs , parameters ) heat_flows_dico = calculate_heat_transfers ( solver_variables , i_fc , parameters , ** matter_flows_dico ) # Calculation of the dynamic evolutions # Inside the cell calculate_dyn_dissoved_water_evolution ( dif_eq , ** parameters , ** matter_flows_dico ) calculate_dyn_liquid_water_evolution ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_vapor_evolution ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_H2_O2_N2_evolution ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_voltage_evolution ( dif_eq , i_fc , ** solver_variables , ** operating_inputs , ** parameters , ** eta_c_intermediate_values ) calculate_dyn_temperature_evolution ( dif_eq , rho_Cp0 , ** parameters , ** heat_flows_dico ) # Inside the auxiliary components calculate_dyn_manifold_pressure_and_humidity_evolution ( dif_eq , Masm , Maem , Mcsm , Mcem , ** solver_variables , ** operating_inputs , ** parameters , ** matter_flows_dico ) calculate_dyn_air_compressor_and_humidifier_evolution ( dif_eq , Wcp_des , Wa_inj_des , Wc_inj_des , ** solver_variables , ** parameters ) calculate_dyn_throttle_area_evolution ( dif_eq , Pagc , Pcgc , ** solver_variables , ** operating_inputs , ** parameters ) # dif_eq is converted to dydt because the solver requires an ordered list to work dydt = [] for key in solver_variable_names : dydt . append ( dif_eq [ 'd' + key + ' / dt' ]) return dydt","title":"dydt"},{"location":"functions/model/flows/","text":"Flows This file represents all the matter flows inside the fuel cell system. It is a component of the fuel cell model. calculate_flows ( t , sv , control_variables , i_fc , operating_inputs , parameters ) This function calculates the flows inside the fuel cell system. Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables ( dict ) \u2013 Variables controlled by the user. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: dict \u2013 Flows inside the fuel cell system. Source code in model/flows.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def calculate_flows ( t , sv , control_variables , i_fc , operating_inputs , parameters ): \"\"\"This function calculates the flows inside the fuel cell system. Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables : dict Variables controlled by the user. i_fc : float Fuel cell current density at time t (A.m-2). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- dict Flows inside the fuel cell system. \"\"\" # ___________________________________________________Preliminaries__________________________________________________ # Extraction of the variables C_v_agc , C_v_ampl , C_v_acl = sv [ 'C_v_agc' ], sv [ 'C_v_ampl' ], sv [ 'C_v_acl' ] C_v_ccl , C_v_cmpl , C_v_cgc = sv [ 'C_v_ccl' ], sv [ 'C_v_cmpl' ], sv [ 'C_v_cgc' ] s_ampl , s_acl , s_ccl , s_cmpl = sv [ 's_ampl' ], sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 's_cmpl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_agc , C_H2_ampl , C_H2_acl = sv [ 'C_H2_agc' ], sv [ 'C_H2_ampl' ], sv [ 'C_H2_acl' ] C_O2_ccl , C_O2_cmpl , C_O2_cgc = sv [ 'C_O2_ccl' ], sv [ 'C_O2_cmpl' ], sv [ 'C_O2_cgc' ] C_N2 = sv [ 'C_N2' ] T_ampl , T_acl , T_mem , T_ccl , T_cmpl = sv [ 'T_ampl' ], sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ], sv [ 'T_cmpl' ] # Extraction of the operating inputs and parameters Hgdl , Hmpl , Hmem = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Hmem' ] Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] e , kappa_co , n_gdl = parameters [ 'e' ], parameters [ 'kappa_co' ], parameters [ 'n_gdl' ] # Intermediate values ( H_gdl_node , Pagc , Pcgc , lambda_acl_mem , lambda_mem_ccl , D_acl_mem , D_mem_ccl , D_cap_agdl_agdl , D_cap_agdl_ampl , D_cap_ampl_acl , D_cap_cgdl_cgdl , D_cap_cmpl_cgdl , D_cap_ccl_cmpl , ha_Da_eff_agc_agdl , hc_Dc_eff_cgdl_cgc , Da_eff_agdl_agdl , Da_eff_agdl_ampl , Da_eff_ampl_acl , Dc_eff_cgdl_cgdl , Dc_eff_cmpl_cgdl , Dc_eff_ccl_cmpl , T_acl_mem_ccl ) = flows_int_values ( sv , operating_inputs , parameters ) # Inlet and outlet flows ( Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , J_H2_in , J_H2_out , J_O2_in , J_O2_out , J_N2_in , J_N2_out , Wasm_in , Wasm_out , Waem_in , Waem_out , Wcsm_in , Wcsm_out , Wcem_in , Wcem_out , Ware , Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out ) = \\ auxiliaries ( t , sv , control_variables , i_fc , operating_inputs , parameters ) # ________________________________________Dissolved water flows (mol.m-2.s-1)_______________________________________ # Anode side J_lambda_acl_mem = 2.5 / 22 * i_fc / F * lambda_acl_mem - \\ 2 * rho_mem / M_eq * D_acl_mem * ( lambda_mem - lambda_acl ) / ( Hmem + Hacl ) # Cathode side J_lambda_mem_ccl = 2.5 / 22 * i_fc / F * lambda_mem_ccl - \\ 2 * rho_mem / M_eq * D_mem_ccl * ( lambda_ccl - lambda_mem ) / ( Hmem + Hccl ) # _________________________________________Liquid water flows (kg.m-2.s-1)__________________________________________ # Anode side s_agc = 0 # Dirichlet boundary condition (taken at the agc/agdl border). Jl_agc_agdl = - 2 * Dcap ( 'gdl' , sv [ 's_agdl_1' ], sv [ 'T_agdl_1' ], epsilon_gdl , e , epsilon_c = epsilon_c ) * \\ ( sv [ 's_agdl_1' ] - s_agc ) / H_gdl_node Jl_agdl_agdl = [ None ] + [ - D_cap_agdl_agdl [ i ] * ( sv [ f 's_agdl_ { i + 1 } ' ] - sv [ f 's_agdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] Jl_agdl_ampl = - 2 * D_cap_agdl_ampl * ( s_ampl - sv [ f 's_agdl_ { n_gdl } ' ]) / ( H_gdl_node + Hmpl ) Jl_ampl_acl = - 2 * D_cap_ampl_acl * ( s_acl - s_ampl ) / ( Hmpl + Hacl ) # Cathode side s_cgc = 0 # Dirichlet boundary condition (taken at the cgc/cgdl border). Jl_ccl_cmpl = - 2 * D_cap_ccl_cmpl * ( s_cmpl - s_ccl ) / ( Hmpl + Hccl ) Jl_cmpl_cgdl = - 2 * D_cap_cmpl_cgdl * ( sv [ 's_cgdl_1' ] - s_cmpl ) / ( H_gdl_node + Hmpl ) Jl_cgdl_cgdl = [ None ] + [ - D_cap_cgdl_cgdl [ i ] * ( sv [ f 's_cgdl_ { i + 1 } ' ] - sv [ f 's_cgdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] Jl_cgdl_cgc = - 2 * Dcap ( 'gdl' , sv [ f 's_cgdl_ { n_gdl } ' ], sv [ f 'T_cgdl_ { n_gdl } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ) * \\ ( s_cgc - sv [ f 's_cgdl_ { n_gdl } ' ]) / H_gdl_node # _____________________________________________Vapor flows (mol.m-2.s-1)____________________________________________ # Convective vapor flows # Anode side Jv_agc_agdl = - 2 * ha_Da_eff_agc_agdl * ( sv [ 'C_v_agdl_1' ] - C_v_agc ) / ( H_gdl_node + Hacl ) # Cathode side Jv_cgdl_cgc = - 2 * hc_Dc_eff_cgdl_cgc * ( C_v_cgc - sv [ f 'C_v_cgdl_ { n_gdl } ' ]) / ( H_gdl_node + Hccl ) # Conductive vapor flows # Anode side Jv_agdl_agdl = [ None ] + [ - Da_eff_agdl_agdl [ i ] * ( sv [ f 'C_v_agdl_ { i + 1 } ' ] - sv [ f 'C_v_agdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] Jv_agdl_ampl = - 2 * Da_eff_agdl_ampl * ( C_v_ampl - sv [ f 'C_v_agdl_ { n_gdl } ' ]) / ( H_gdl_node + Hmpl ) Jv_ampl_acl = - 2 * Da_eff_ampl_acl * ( C_v_acl - C_v_ampl ) / ( Hmpl + Hacl ) # Cathode side Jv_ccl_cmpl = - 2 * Dc_eff_ccl_cmpl * ( C_v_cmpl - C_v_ccl ) / ( Hccl + Hmpl ) Jv_cmpl_cgdl = - 2 * Dc_eff_cmpl_cgdl * ( sv [ 'C_v_cgdl_1' ] - C_v_cmpl ) / ( H_gdl_node + Hmpl ) Jv_cgdl_cgdl = [ None ] + [ - Dc_eff_cgdl_cgdl [ i ] * ( sv [ f 'C_v_cgdl_ { i + 1 } ' ] - sv [ f 'C_v_cgdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] # __________________________________________H2 and O2 flows (mol.m-2.s-1)___________________________________________ # Hydrogen and oxygen consumption # Anode side S_H2_acl = - i_fc / ( 2 * F * Hacl ) - \\ R * T_acl_mem_ccl / ( Hmem * Hacl ) * ( k_H2 ( lambda_mem , T_mem , kappa_co ) * C_H2_acl + 2 * k_O2 ( lambda_mem , T_mem , kappa_co ) * C_O2_ccl ) # Cathode side S_O2_ccl = - i_fc / ( 4 * F * Hccl ) - \\ R * T_acl_mem_ccl / ( Hmem * Hccl ) * ( k_O2 ( lambda_mem , T_mem , kappa_co ) * C_O2_ccl + 1 / 2 * k_H2 ( lambda_mem , T_mem , kappa_co ) * C_H2_acl ) # Conductive-convective H2 and O2 flows # Anode side J_H2_agc_agdl = - 2 * ha_Da_eff_agc_agdl * ( sv [ 'C_H2_agdl_1' ] - C_H2_agc ) / ( H_gdl_node + Hacl ) # Cathode side J_O2_cgdl_cgc = - 2 * hc_Dc_eff_cgdl_cgc * ( C_O2_cgc - sv [ f 'C_O2_cgdl_ { n_gdl } ' ]) / ( H_gdl_node + Hccl ) # Conductive H2 and O2 flows # Anode side J_H2_agdl_agdl = [ None ] + [ - Da_eff_agdl_agdl [ i ] * ( sv [ f 'C_H2_agdl_ { i + 1 } ' ] - sv [ f 'C_H2_agdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] J_H2_agdl_ampl = - 2 * Da_eff_agdl_ampl * ( C_H2_ampl - sv [ f 'C_H2_agdl_ { n_gdl } ' ]) / ( H_gdl_node + Hmpl ) J_H2_ampl_acl = - 2 * Da_eff_ampl_acl * ( C_H2_acl - C_H2_ampl ) / ( Hmpl + Hacl ) # Cathode side J_O2_ccl_cmpl = - 2 * Dc_eff_ccl_cmpl * ( C_O2_cmpl - C_O2_ccl ) / ( Hmpl + Hccl ) J_O2_cmpl_cgdl = - 2 * Dc_eff_cmpl_cgdl * ( sv [ 'C_O2_cgdl_1' ] - C_O2_cmpl ) / ( Hmpl + H_gdl_node ) J_O2_cgdl_cgdl = [ None ] + [ - Dc_eff_cgdl_cgdl [ i ] * ( sv [ f 'C_O2_cgdl_ { i + 1 } ' ] - sv [ f 'C_O2_cgdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] # __________________________________________Water generated (mol.m-3.s-1)___________________________________________ # Water produced in the membrane at the CL through the chemical reaction and crossover # Anode side Sp_acl = 2 * k_O2 ( lambda_mem , T_mem , kappa_co ) * R * T_acl_mem_ccl / ( Hmem * Hacl ) * C_O2_ccl # Cathode side Sp_ccl = i_fc / ( 2 * F * Hccl ) + k_H2 ( lambda_mem , T_mem , kappa_co ) * R * T_acl_mem_ccl / ( Hmem * Hccl ) * C_H2_acl # Water absorption in the CL: # Anode side S_abs_acl = gamma_sorp ( C_v_acl , s_acl , lambda_acl , T_acl , Hacl ) * rho_mem / M_eq * \\ ( lambda_eq ( C_v_acl , s_acl , T_acl ) - lambda_acl ) # Cathode side S_abs_ccl = gamma_sorp ( C_v_ccl , s_ccl , lambda_ccl , T_ccl , Hccl ) * rho_mem / M_eq * \\ ( lambda_eq ( C_v_ccl , s_ccl , T_ccl ) - lambda_ccl ) # Liquid water generated through vapor condensation or degenerated through evaporation # Anode side Sl_agdl = [ None ] + [ Svl ( sv [ f 's_agdl_ { i } ' ], sv [ f 'C_v_agdl_ { i } ' ], sv [ f 'C_v_agdl_ { i } ' ] + sv [ f 'C_H2_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], epsilon_gdl , gamma_cond , gamma_evap ) for i in range ( 1 , n_gdl + 1 )] Sl_ampl = Svl ( s_ampl , C_v_ampl , C_v_ampl + C_H2_ampl , T_ampl , epsilon_mpl , gamma_cond , gamma_evap ) Sl_acl = Svl ( s_acl , C_v_acl , C_v_acl + C_H2_acl , T_acl , epsilon_cl , gamma_cond , gamma_evap ) # Cathode side Sl_ccl = Svl ( s_ccl , C_v_ccl , C_v_ccl + C_O2_ccl + C_N2 , T_ccl , epsilon_cl , gamma_cond , gamma_evap ) Sl_cmpl = Svl ( s_cmpl , C_v_cmpl , C_v_cmpl + C_O2_cmpl + C_N2 , T_cmpl , epsilon_mpl , gamma_cond , gamma_evap ) Sl_cgdl = [ None ] + [ Svl ( sv [ f 's_cgdl_ { i } ' ], sv [ f 'C_v_cgdl_ { i } ' ], sv [ f 'C_v_cgdl_ { i } ' ] + sv [ f 'C_O2_cgdl_ { i } ' ] + C_N2 , sv [ f 'T_cgdl_ { i } ' ], epsilon_gdl , gamma_cond , gamma_evap ) for i in range ( 1 , n_gdl + 1 )] # Vapor generated through liquid water evaporation or degenerated through condensation # Anode side Sv_agdl = [ None ] + [ - x for x in Sl_agdl [ 1 :]] Sv_ampl = - Sl_ampl Sv_acl = - Sl_acl # Cathode side Sv_ccl = - Sl_ccl Sv_cmpl = - Sl_cmpl Sv_cgdl = [ None ] + [ - x for x in Sl_cgdl [ 1 :]] return { 'Jv_a_in' : Jv_a_in , 'Jv_a_out' : Jv_a_out , 'Jv_c_in' : Jv_c_in , 'Jv_c_out' : Jv_c_out , 'J_H2_in' : J_H2_in , 'J_H2_out' : J_H2_out , 'J_O2_in' : J_O2_in , 'J_O2_out' : J_O2_out , 'J_N2_in' : J_N2_in , 'J_N2_out' : J_N2_out , 'Jv_agc_agdl' : Jv_agc_agdl , 'Jv_agdl_agdl' : Jv_agdl_agdl , 'Jv_agdl_ampl' : Jv_agdl_ampl , 'Jv_ampl_acl' : Jv_ampl_acl , 'S_abs_acl' : S_abs_acl , 'S_abs_ccl' : S_abs_ccl , 'Jv_ccl_cmpl' : Jv_ccl_cmpl , 'Jv_cmpl_cgdl' : Jv_cmpl_cgdl , 'Jv_cgdl_cgdl' : Jv_cgdl_cgdl , 'Jv_cgdl_cgc' : Jv_cgdl_cgc , 'Jl_agc_agdl' : Jl_agc_agdl , 'Jl_agdl_agdl' : Jl_agdl_agdl , 'Jl_agdl_ampl' : Jl_agdl_ampl , 'Jl_ampl_acl' : Jl_ampl_acl , 'J_lambda_acl_mem' : J_lambda_acl_mem , 'J_lambda_mem_ccl' : J_lambda_mem_ccl , 'Jl_ccl_cmpl' : Jl_ccl_cmpl , 'Jl_cmpl_cgdl' : Jl_cmpl_cgdl , 'Jl_cgdl_cgdl' : Jl_cgdl_cgdl , 'Jl_cgdl_cgc' : Jl_cgdl_cgc , 'Sp_acl' : Sp_acl , 'Sp_ccl' : Sp_ccl , 'J_H2_agc_agdl' : J_H2_agc_agdl , 'J_H2_agdl_agdl' : J_H2_agdl_agdl , 'J_H2_agdl_ampl' : J_H2_agdl_ampl , 'J_H2_ampl_acl' : J_H2_ampl_acl , 'J_O2_ccl_cmpl' : J_O2_ccl_cmpl , 'J_O2_cmpl_cgdl' : J_O2_cmpl_cgdl , 'J_O2_cgdl_cgdl' : J_O2_cgdl_cgdl , 'J_O2_cgdl_cgc' : J_O2_cgdl_cgc , 'S_H2_acl' : S_H2_acl , 'S_O2_ccl' : S_O2_ccl , 'Sv_agdl' : Sv_agdl , 'Sv_ampl' : Sv_ampl , 'Sv_acl' : Sv_acl , 'Sv_ccl' : Sv_ccl , 'Sv_cmpl' : Sv_cmpl , 'Sv_cgdl' : Sv_cgdl , 'Sl_agdl' : Sl_agdl , 'Sl_ampl' : Sl_ampl , 'Sl_acl' : Sl_acl , 'Sl_ccl' : Sl_ccl , 'Sl_cmpl' : Sl_cmpl , 'Sl_cgdl' : Sl_cgdl , 'Pagc' : Pagc , 'Pcgc' : Pcgc , 'Wasm_in' : Wasm_in , 'Wasm_out' : Wasm_out , 'Waem_in' : Waem_in , 'Waem_out' : Waem_out , 'Wcsm_in' : Wcsm_in , 'Wcsm_out' : Wcsm_out , 'Wcem_in' : Wcem_in , 'Wcem_out' : Wcem_out , 'Ware' : Ware , 'Wv_asm_in' : Wv_asm_in , 'Wv_aem_out' : Wv_aem_out , 'Wv_csm_in' : Wv_csm_in , 'Wv_cem_out' : Wv_cem_out }","title":"Flows"},{"location":"functions/model/flows/#flows","text":"This file represents all the matter flows inside the fuel cell system. It is a component of the fuel cell model.","title":"Flows"},{"location":"functions/model/flows/#model.flows.calculate_flows","text":"This function calculates the flows inside the fuel cell system. Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables ( dict ) \u2013 Variables controlled by the user. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: dict \u2013 Flows inside the fuel cell system. Source code in model/flows.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def calculate_flows ( t , sv , control_variables , i_fc , operating_inputs , parameters ): \"\"\"This function calculates the flows inside the fuel cell system. Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables : dict Variables controlled by the user. i_fc : float Fuel cell current density at time t (A.m-2). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- dict Flows inside the fuel cell system. \"\"\" # ___________________________________________________Preliminaries__________________________________________________ # Extraction of the variables C_v_agc , C_v_ampl , C_v_acl = sv [ 'C_v_agc' ], sv [ 'C_v_ampl' ], sv [ 'C_v_acl' ] C_v_ccl , C_v_cmpl , C_v_cgc = sv [ 'C_v_ccl' ], sv [ 'C_v_cmpl' ], sv [ 'C_v_cgc' ] s_ampl , s_acl , s_ccl , s_cmpl = sv [ 's_ampl' ], sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 's_cmpl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_agc , C_H2_ampl , C_H2_acl = sv [ 'C_H2_agc' ], sv [ 'C_H2_ampl' ], sv [ 'C_H2_acl' ] C_O2_ccl , C_O2_cmpl , C_O2_cgc = sv [ 'C_O2_ccl' ], sv [ 'C_O2_cmpl' ], sv [ 'C_O2_cgc' ] C_N2 = sv [ 'C_N2' ] T_ampl , T_acl , T_mem , T_ccl , T_cmpl = sv [ 'T_ampl' ], sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ], sv [ 'T_cmpl' ] # Extraction of the operating inputs and parameters Hgdl , Hmpl , Hmem = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Hmem' ] Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] e , kappa_co , n_gdl = parameters [ 'e' ], parameters [ 'kappa_co' ], parameters [ 'n_gdl' ] # Intermediate values ( H_gdl_node , Pagc , Pcgc , lambda_acl_mem , lambda_mem_ccl , D_acl_mem , D_mem_ccl , D_cap_agdl_agdl , D_cap_agdl_ampl , D_cap_ampl_acl , D_cap_cgdl_cgdl , D_cap_cmpl_cgdl , D_cap_ccl_cmpl , ha_Da_eff_agc_agdl , hc_Dc_eff_cgdl_cgc , Da_eff_agdl_agdl , Da_eff_agdl_ampl , Da_eff_ampl_acl , Dc_eff_cgdl_cgdl , Dc_eff_cmpl_cgdl , Dc_eff_ccl_cmpl , T_acl_mem_ccl ) = flows_int_values ( sv , operating_inputs , parameters ) # Inlet and outlet flows ( Jv_a_in , Jv_a_out , Jv_c_in , Jv_c_out , J_H2_in , J_H2_out , J_O2_in , J_O2_out , J_N2_in , J_N2_out , Wasm_in , Wasm_out , Waem_in , Waem_out , Wcsm_in , Wcsm_out , Wcem_in , Wcem_out , Ware , Wv_asm_in , Wv_aem_out , Wv_csm_in , Wv_cem_out ) = \\ auxiliaries ( t , sv , control_variables , i_fc , operating_inputs , parameters ) # ________________________________________Dissolved water flows (mol.m-2.s-1)_______________________________________ # Anode side J_lambda_acl_mem = 2.5 / 22 * i_fc / F * lambda_acl_mem - \\ 2 * rho_mem / M_eq * D_acl_mem * ( lambda_mem - lambda_acl ) / ( Hmem + Hacl ) # Cathode side J_lambda_mem_ccl = 2.5 / 22 * i_fc / F * lambda_mem_ccl - \\ 2 * rho_mem / M_eq * D_mem_ccl * ( lambda_ccl - lambda_mem ) / ( Hmem + Hccl ) # _________________________________________Liquid water flows (kg.m-2.s-1)__________________________________________ # Anode side s_agc = 0 # Dirichlet boundary condition (taken at the agc/agdl border). Jl_agc_agdl = - 2 * Dcap ( 'gdl' , sv [ 's_agdl_1' ], sv [ 'T_agdl_1' ], epsilon_gdl , e , epsilon_c = epsilon_c ) * \\ ( sv [ 's_agdl_1' ] - s_agc ) / H_gdl_node Jl_agdl_agdl = [ None ] + [ - D_cap_agdl_agdl [ i ] * ( sv [ f 's_agdl_ { i + 1 } ' ] - sv [ f 's_agdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] Jl_agdl_ampl = - 2 * D_cap_agdl_ampl * ( s_ampl - sv [ f 's_agdl_ { n_gdl } ' ]) / ( H_gdl_node + Hmpl ) Jl_ampl_acl = - 2 * D_cap_ampl_acl * ( s_acl - s_ampl ) / ( Hmpl + Hacl ) # Cathode side s_cgc = 0 # Dirichlet boundary condition (taken at the cgc/cgdl border). Jl_ccl_cmpl = - 2 * D_cap_ccl_cmpl * ( s_cmpl - s_ccl ) / ( Hmpl + Hccl ) Jl_cmpl_cgdl = - 2 * D_cap_cmpl_cgdl * ( sv [ 's_cgdl_1' ] - s_cmpl ) / ( H_gdl_node + Hmpl ) Jl_cgdl_cgdl = [ None ] + [ - D_cap_cgdl_cgdl [ i ] * ( sv [ f 's_cgdl_ { i + 1 } ' ] - sv [ f 's_cgdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] Jl_cgdl_cgc = - 2 * Dcap ( 'gdl' , sv [ f 's_cgdl_ { n_gdl } ' ], sv [ f 'T_cgdl_ { n_gdl } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ) * \\ ( s_cgc - sv [ f 's_cgdl_ { n_gdl } ' ]) / H_gdl_node # _____________________________________________Vapor flows (mol.m-2.s-1)____________________________________________ # Convective vapor flows # Anode side Jv_agc_agdl = - 2 * ha_Da_eff_agc_agdl * ( sv [ 'C_v_agdl_1' ] - C_v_agc ) / ( H_gdl_node + Hacl ) # Cathode side Jv_cgdl_cgc = - 2 * hc_Dc_eff_cgdl_cgc * ( C_v_cgc - sv [ f 'C_v_cgdl_ { n_gdl } ' ]) / ( H_gdl_node + Hccl ) # Conductive vapor flows # Anode side Jv_agdl_agdl = [ None ] + [ - Da_eff_agdl_agdl [ i ] * ( sv [ f 'C_v_agdl_ { i + 1 } ' ] - sv [ f 'C_v_agdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] Jv_agdl_ampl = - 2 * Da_eff_agdl_ampl * ( C_v_ampl - sv [ f 'C_v_agdl_ { n_gdl } ' ]) / ( H_gdl_node + Hmpl ) Jv_ampl_acl = - 2 * Da_eff_ampl_acl * ( C_v_acl - C_v_ampl ) / ( Hmpl + Hacl ) # Cathode side Jv_ccl_cmpl = - 2 * Dc_eff_ccl_cmpl * ( C_v_cmpl - C_v_ccl ) / ( Hccl + Hmpl ) Jv_cmpl_cgdl = - 2 * Dc_eff_cmpl_cgdl * ( sv [ 'C_v_cgdl_1' ] - C_v_cmpl ) / ( H_gdl_node + Hmpl ) Jv_cgdl_cgdl = [ None ] + [ - Dc_eff_cgdl_cgdl [ i ] * ( sv [ f 'C_v_cgdl_ { i + 1 } ' ] - sv [ f 'C_v_cgdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] # __________________________________________H2 and O2 flows (mol.m-2.s-1)___________________________________________ # Hydrogen and oxygen consumption # Anode side S_H2_acl = - i_fc / ( 2 * F * Hacl ) - \\ R * T_acl_mem_ccl / ( Hmem * Hacl ) * ( k_H2 ( lambda_mem , T_mem , kappa_co ) * C_H2_acl + 2 * k_O2 ( lambda_mem , T_mem , kappa_co ) * C_O2_ccl ) # Cathode side S_O2_ccl = - i_fc / ( 4 * F * Hccl ) - \\ R * T_acl_mem_ccl / ( Hmem * Hccl ) * ( k_O2 ( lambda_mem , T_mem , kappa_co ) * C_O2_ccl + 1 / 2 * k_H2 ( lambda_mem , T_mem , kappa_co ) * C_H2_acl ) # Conductive-convective H2 and O2 flows # Anode side J_H2_agc_agdl = - 2 * ha_Da_eff_agc_agdl * ( sv [ 'C_H2_agdl_1' ] - C_H2_agc ) / ( H_gdl_node + Hacl ) # Cathode side J_O2_cgdl_cgc = - 2 * hc_Dc_eff_cgdl_cgc * ( C_O2_cgc - sv [ f 'C_O2_cgdl_ { n_gdl } ' ]) / ( H_gdl_node + Hccl ) # Conductive H2 and O2 flows # Anode side J_H2_agdl_agdl = [ None ] + [ - Da_eff_agdl_agdl [ i ] * ( sv [ f 'C_H2_agdl_ { i + 1 } ' ] - sv [ f 'C_H2_agdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] J_H2_agdl_ampl = - 2 * Da_eff_agdl_ampl * ( C_H2_ampl - sv [ f 'C_H2_agdl_ { n_gdl } ' ]) / ( H_gdl_node + Hmpl ) J_H2_ampl_acl = - 2 * Da_eff_ampl_acl * ( C_H2_acl - C_H2_ampl ) / ( Hmpl + Hacl ) # Cathode side J_O2_ccl_cmpl = - 2 * Dc_eff_ccl_cmpl * ( C_O2_cmpl - C_O2_ccl ) / ( Hmpl + Hccl ) J_O2_cmpl_cgdl = - 2 * Dc_eff_cmpl_cgdl * ( sv [ 'C_O2_cgdl_1' ] - C_O2_cmpl ) / ( Hmpl + H_gdl_node ) J_O2_cgdl_cgdl = [ None ] + [ - Dc_eff_cgdl_cgdl [ i ] * ( sv [ f 'C_O2_cgdl_ { i + 1 } ' ] - sv [ f 'C_O2_cgdl_ { i } ' ]) / H_gdl_node for i in range ( 1 , n_gdl )] # __________________________________________Water generated (mol.m-3.s-1)___________________________________________ # Water produced in the membrane at the CL through the chemical reaction and crossover # Anode side Sp_acl = 2 * k_O2 ( lambda_mem , T_mem , kappa_co ) * R * T_acl_mem_ccl / ( Hmem * Hacl ) * C_O2_ccl # Cathode side Sp_ccl = i_fc / ( 2 * F * Hccl ) + k_H2 ( lambda_mem , T_mem , kappa_co ) * R * T_acl_mem_ccl / ( Hmem * Hccl ) * C_H2_acl # Water absorption in the CL: # Anode side S_abs_acl = gamma_sorp ( C_v_acl , s_acl , lambda_acl , T_acl , Hacl ) * rho_mem / M_eq * \\ ( lambda_eq ( C_v_acl , s_acl , T_acl ) - lambda_acl ) # Cathode side S_abs_ccl = gamma_sorp ( C_v_ccl , s_ccl , lambda_ccl , T_ccl , Hccl ) * rho_mem / M_eq * \\ ( lambda_eq ( C_v_ccl , s_ccl , T_ccl ) - lambda_ccl ) # Liquid water generated through vapor condensation or degenerated through evaporation # Anode side Sl_agdl = [ None ] + [ Svl ( sv [ f 's_agdl_ { i } ' ], sv [ f 'C_v_agdl_ { i } ' ], sv [ f 'C_v_agdl_ { i } ' ] + sv [ f 'C_H2_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], epsilon_gdl , gamma_cond , gamma_evap ) for i in range ( 1 , n_gdl + 1 )] Sl_ampl = Svl ( s_ampl , C_v_ampl , C_v_ampl + C_H2_ampl , T_ampl , epsilon_mpl , gamma_cond , gamma_evap ) Sl_acl = Svl ( s_acl , C_v_acl , C_v_acl + C_H2_acl , T_acl , epsilon_cl , gamma_cond , gamma_evap ) # Cathode side Sl_ccl = Svl ( s_ccl , C_v_ccl , C_v_ccl + C_O2_ccl + C_N2 , T_ccl , epsilon_cl , gamma_cond , gamma_evap ) Sl_cmpl = Svl ( s_cmpl , C_v_cmpl , C_v_cmpl + C_O2_cmpl + C_N2 , T_cmpl , epsilon_mpl , gamma_cond , gamma_evap ) Sl_cgdl = [ None ] + [ Svl ( sv [ f 's_cgdl_ { i } ' ], sv [ f 'C_v_cgdl_ { i } ' ], sv [ f 'C_v_cgdl_ { i } ' ] + sv [ f 'C_O2_cgdl_ { i } ' ] + C_N2 , sv [ f 'T_cgdl_ { i } ' ], epsilon_gdl , gamma_cond , gamma_evap ) for i in range ( 1 , n_gdl + 1 )] # Vapor generated through liquid water evaporation or degenerated through condensation # Anode side Sv_agdl = [ None ] + [ - x for x in Sl_agdl [ 1 :]] Sv_ampl = - Sl_ampl Sv_acl = - Sl_acl # Cathode side Sv_ccl = - Sl_ccl Sv_cmpl = - Sl_cmpl Sv_cgdl = [ None ] + [ - x for x in Sl_cgdl [ 1 :]] return { 'Jv_a_in' : Jv_a_in , 'Jv_a_out' : Jv_a_out , 'Jv_c_in' : Jv_c_in , 'Jv_c_out' : Jv_c_out , 'J_H2_in' : J_H2_in , 'J_H2_out' : J_H2_out , 'J_O2_in' : J_O2_in , 'J_O2_out' : J_O2_out , 'J_N2_in' : J_N2_in , 'J_N2_out' : J_N2_out , 'Jv_agc_agdl' : Jv_agc_agdl , 'Jv_agdl_agdl' : Jv_agdl_agdl , 'Jv_agdl_ampl' : Jv_agdl_ampl , 'Jv_ampl_acl' : Jv_ampl_acl , 'S_abs_acl' : S_abs_acl , 'S_abs_ccl' : S_abs_ccl , 'Jv_ccl_cmpl' : Jv_ccl_cmpl , 'Jv_cmpl_cgdl' : Jv_cmpl_cgdl , 'Jv_cgdl_cgdl' : Jv_cgdl_cgdl , 'Jv_cgdl_cgc' : Jv_cgdl_cgc , 'Jl_agc_agdl' : Jl_agc_agdl , 'Jl_agdl_agdl' : Jl_agdl_agdl , 'Jl_agdl_ampl' : Jl_agdl_ampl , 'Jl_ampl_acl' : Jl_ampl_acl , 'J_lambda_acl_mem' : J_lambda_acl_mem , 'J_lambda_mem_ccl' : J_lambda_mem_ccl , 'Jl_ccl_cmpl' : Jl_ccl_cmpl , 'Jl_cmpl_cgdl' : Jl_cmpl_cgdl , 'Jl_cgdl_cgdl' : Jl_cgdl_cgdl , 'Jl_cgdl_cgc' : Jl_cgdl_cgc , 'Sp_acl' : Sp_acl , 'Sp_ccl' : Sp_ccl , 'J_H2_agc_agdl' : J_H2_agc_agdl , 'J_H2_agdl_agdl' : J_H2_agdl_agdl , 'J_H2_agdl_ampl' : J_H2_agdl_ampl , 'J_H2_ampl_acl' : J_H2_ampl_acl , 'J_O2_ccl_cmpl' : J_O2_ccl_cmpl , 'J_O2_cmpl_cgdl' : J_O2_cmpl_cgdl , 'J_O2_cgdl_cgdl' : J_O2_cgdl_cgdl , 'J_O2_cgdl_cgc' : J_O2_cgdl_cgc , 'S_H2_acl' : S_H2_acl , 'S_O2_ccl' : S_O2_ccl , 'Sv_agdl' : Sv_agdl , 'Sv_ampl' : Sv_ampl , 'Sv_acl' : Sv_acl , 'Sv_ccl' : Sv_ccl , 'Sv_cmpl' : Sv_cmpl , 'Sv_cgdl' : Sv_cgdl , 'Sl_agdl' : Sl_agdl , 'Sl_ampl' : Sl_ampl , 'Sl_acl' : Sl_acl , 'Sl_ccl' : Sl_ccl , 'Sl_cmpl' : Sl_cmpl , 'Sl_cgdl' : Sl_cgdl , 'Pagc' : Pagc , 'Pcgc' : Pcgc , 'Wasm_in' : Wasm_in , 'Wasm_out' : Wasm_out , 'Waem_in' : Waem_in , 'Waem_out' : Waem_out , 'Wcsm_in' : Wcsm_in , 'Wcsm_out' : Wcsm_out , 'Wcem_in' : Wcem_in , 'Wcem_out' : Wcem_out , 'Ware' : Ware , 'Wv_asm_in' : Wv_asm_in , 'Wv_aem_out' : Wv_aem_out , 'Wv_csm_in' : Wv_csm_in , 'Wv_cem_out' : Wv_cem_out }","title":"calculate_flows"},{"location":"functions/model/heat_transfer/","text":"Heat Transfer This file represents all the heat transfers occuring inside the fuel cell system. It is a component of the fuel cell model. calculate_heat_transfers ( sv , i_fc , parameters , S_abs_acl , S_abs_ccl , Sl_agdl , Sl_ampl , Sl_acl , Sl_ccl , Sl_cmpl , Sl_cgdl , ** kwargs ) This function calculates the heat transfers occurring inside the fuel cell system. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). parameters ( dict ) \u2013 Parameters of the fuel cell model. S_abs_acl ( float ) \u2013 Water absorption in the ACL (mol.m-3.s-1). S_abs_ccl ( float ) \u2013 Water absorption in the CCL (mol.m-3.s-1). Sl_agdl ( list ) \u2013 Liquid water generated through vapor water liquefaction in the AGDL (mol.m-3.s-1). Sl_ampl ( list ) \u2013 Liquid water generated through vapor water liquefaction in the AMPL (mol.m-3.s-1). Sl_acl ( float ) \u2013 Liquid water generated through vapor water liquefaction in the ACL (mol.m-3.s-1). Sl_ccl ( float ) \u2013 Liquid water generated through vapor water liquefaction in the CCL (mol.m-3.s-1). Sl_cmpl ( list ) \u2013 Liquid water generated through vapor water liquefaction in the CMPL (mol.m-3.s-1). Sl_cgdl ( list ) \u2013 Liquid water generated through vapor water liquefaction in the CGDL (mol.m-3.s-1). Returns: dict \u2013 Heat transfers occuring inside the fuel cell system. Source code in model/heat_transfer.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def calculate_heat_transfers ( sv , i_fc , parameters , S_abs_acl , S_abs_ccl , Sl_agdl , Sl_ampl , Sl_acl , Sl_ccl , Sl_cmpl , Sl_cgdl , ** kwargs ): \"\"\"This function calculates the heat transfers occurring inside the fuel cell system. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc : float Fuel cell current density at time t (A.m-2). parameters : dict Parameters of the fuel cell model. S_abs_acl : float Water absorption in the ACL (mol.m-3.s-1). S_abs_ccl : float Water absorption in the CCL (mol.m-3.s-1). Sl_agdl : list Liquid water generated through vapor water liquefaction in the AGDL (mol.m-3.s-1). Sl_ampl : list Liquid water generated through vapor water liquefaction in the AMPL (mol.m-3.s-1). Sl_acl : float Liquid water generated through vapor water liquefaction in the ACL (mol.m-3.s-1). Sl_ccl : float Liquid water generated through vapor water liquefaction in the CCL (mol.m-3.s-1). Sl_cmpl : list Liquid water generated through vapor water liquefaction in the CMPL (mol.m-3.s-1). Sl_cgdl : list Liquid water generated through vapor water liquefaction in the CGDL (mol.m-3.s-1). Returns ------- dict Heat transfers occuring inside the fuel cell system. \"\"\" # ___________________________________________________Preliminaries__________________________________________________ # Extraction of the variables T_agc , T_ampl , T_acl , T_mem = sv [ 'T_agc' ], sv [ 'T_ampl' ], sv [ 'T_acl' ], sv [ 'T_mem' ] T_ccl , T_cmpl , T_cgc = sv [ 'T_ccl' ], sv [ 'T_cmpl' ], sv [ 'T_cgc' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] s_acl , s_ccl , eta_c = sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 'eta_c' ] # Extraction of the operating inputs and parameters epsilon_mc , epsilon_gdl , epsilon_cl = parameters [ 'epsilon_mc' ], parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c , n_gdl = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ], parameters [ 'n_gdl' ] Hmem , Hgdl , Hmpl = parameters [ 'Hmem' ], parameters [ 'Hgdl' ], parameters [ 'Hmpl' ] Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] # Intermediate values ( k_th_eff_agc_agdl , k_th_eff_agdl_agdl , k_th_eff_agdl_ampl , k_th_eff_ampl_acl , k_th_eff_acl_mem , k_th_eff_mem_ccl , k_th_eff_ccl_cmpl , k_th_eff_cmpl_cgdl , k_th_eff_cgdl_cgdl , k_th_eff_cgdl_cgc ) \\ = heat_transfer_int_values ( sv , parameters ) # ______________________________________________Heat flows (J.m-2.s-1)______________________________________________ # Anode side Jt_agc_agdl = - 2 * k_th_eff_agc_agdl * ( sv [ 'T_agdl_1' ] - T_agc ) / ( Hgdl / n_gdl ) Jt_agdl_agdl = { f 'agdl_agdl_ { i } ' : - k_th_eff_agdl_agdl [ i ] * ( sv [ f 'T_agdl_ { i + 1 } ' ] - sv [ f 'T_agdl_ { i } ' ]) / ( Hgdl / n_gdl ) for i in range ( 1 , n_gdl )} Jt_agdl_ampl = - 2 * k_th_eff_agdl_ampl * ( T_ampl - sv [ f 'T_agdl_ { n_gdl } ' ]) / ( Hgdl / n_gdl + Hmpl ) Jt_ampl_acl = - 2 * k_th_eff_ampl_acl * ( T_acl - T_ampl ) / ( Hmpl + Hacl ) # Membrane side Jt_acl_mem = - 2 * k_th_eff_acl_mem * ( T_mem - T_acl ) / ( Hacl + Hmem ) Jt_mem_ccl = - 2 * k_th_eff_mem_ccl * ( T_ccl - T_mem ) / ( Hccl + Hmem ) # Cathode side Jt_ccl_cmpl = - 2 * k_th_eff_ccl_cmpl * ( T_cmpl - T_ccl ) / ( Hmpl + Hccl ) Jt_cmpl_cgdl = - 2 * k_th_eff_cmpl_cgdl * ( sv [ 'T_cgdl_1' ] - T_cmpl ) / ( Hgdl / n_gdl + Hmpl ) Jt_cgdl_cgdl = { f 'cgdl_cgdl_ { i } ' : - k_th_eff_cgdl_cgdl [ i ] * ( sv [ f 'T_cgdl_ { i + 1 } ' ] - sv [ f 'T_cgdl_ { i } ' ]) / ( Hgdl / n_gdl ) for i in range ( 1 , n_gdl )} Jt_cgdl_cgc = - 2 * k_th_eff_cgdl_cgc * ( T_cgc - sv [ f 'T_cgdl_ { n_gdl } ' ]) / ( Hgdl / n_gdl ) Jt = { 'agc_agdl' : Jt_agc_agdl , ** Jt_agdl_agdl , 'agdl_ampl' : Jt_agdl_ampl , 'ampl_acl' : Jt_ampl_acl , 'acl_mem' : Jt_acl_mem , 'mem_ccl' : Jt_mem_ccl , 'ccl_cmpl' : Jt_ccl_cmpl , 'cmpl_cgdl' : Jt_cmpl_cgdl , ** Jt_cgdl_cgdl , 'cgdl_cgc' : Jt_cgdl_cgc } # ____________________________________________Heat generated (J.m-3.s-1)____________________________________________ # The heat dissipated by the electrochemical reaction 2*H2 + O2 -> 2*H2O, in J.m-3.s-1. # It is given by the sum of Peltier and activation heats [vetterFreeOpenReference2019]. S_r_acl = i_fc / ( 2 * F * Hacl ) # mol.m-3.s-1. It is the amount of hydrogen consumed at the ACL. S_r_ccl = i_fc / ( 4 * F * Hccl ) # mol.m-3.s-1. It is the amount of oxygen consumed at the CCL. Q_r = { 'acl' : S_r_acl * T_acl * ( - delta_s_HOR ), 'ccl' : S_r_ccl * T_ccl * ( - delta_s_ORR ) + i_fc * eta_c / Hccl } # The heat dissipated by the absorption of water from the CL to the membrane, in J.m-3.s-1. Q_sorp = { 'acl' : S_abs_acl * ( - delta_h_abs ( T_acl )), 'ccl' : S_abs_ccl * ( - delta_h_abs ( T_ccl ))} # The heat dissipated by the liquefaction of vapor water, in J.m-3.s-1. Q_liq = { ** { f 'agdl_ { i } ' : Sl_agdl [ i ] * ( - delta_h_liq ( sv [ f 'T_agdl_ { i } ' ])) for i in range ( 1 , n_gdl + 1 )}, ** { f 'cgdl_ { i } ' : Sl_cgdl [ i ] * ( - delta_h_liq ( sv [ f 'T_cgdl_ { i } ' ])) for i in range ( 1 , n_gdl + 1 )}, 'ampl' : Sl_ampl * ( - delta_h_liq ( T_ampl )), 'cmpl' : Sl_cmpl * ( - delta_h_liq ( T_cmpl )), 'acl' : Sl_acl * ( - delta_h_liq ( T_acl )), 'ccl' : Sl_ccl * ( - delta_h_liq ( T_ccl )) } # The heat dissipated by the ionic currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_p = { 'mem' : i_fc ** 2 / sigma_p_eff ( 'mem' , lambda_mem , T_mem ), 'ccl' : i_fc ** 2 / ( 3 * sigma_p_eff ( 'ccl' , lambda_ccl , T_ccl , epsilon_mc ))} # The heat dissipated by the electric currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_e = { ** { f 'agdl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'gdl' , epsilon_gdl , epsilon_c = epsilon_c ) for i in range ( 1 , n_gdl + 1 )}, 'acl' : i_fc ** 2 / sigma_e_eff ( 'cl' , epsilon_cl , epsilon_mc = epsilon_mc ), 'ampl' : i_fc ** 2 / sigma_e_eff ( 'mpl' , epsilon_mpl ), 'ccl' : i_fc ** 2 / ( 3 * sigma_e_eff ( 'cl' , epsilon_cl , epsilon_mc = epsilon_mc )), 'cmpl' : i_fc ** 2 / ( 3 * sigma_e_eff ( 'mpl' , epsilon_mpl )), ** { f 'cgdl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'gdl' , epsilon_gdl , epsilon_c = epsilon_c ) for i in range ( 1 , n_gdl + 1 )}} return { 'Jt' : Jt , 'Q_r' : Q_r , 'Q_sorp' : Q_sorp , 'Q_liq' : Q_liq , 'Q_p' : Q_p , 'Q_e' : Q_e }","title":"Heat transfer"},{"location":"functions/model/heat_transfer/#heat-transfer","text":"This file represents all the heat transfers occuring inside the fuel cell system. It is a component of the fuel cell model.","title":"Heat Transfer"},{"location":"functions/model/heat_transfer/#model.heat_transfer.calculate_heat_transfers","text":"This function calculates the heat transfers occurring inside the fuel cell system. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). parameters ( dict ) \u2013 Parameters of the fuel cell model. S_abs_acl ( float ) \u2013 Water absorption in the ACL (mol.m-3.s-1). S_abs_ccl ( float ) \u2013 Water absorption in the CCL (mol.m-3.s-1). Sl_agdl ( list ) \u2013 Liquid water generated through vapor water liquefaction in the AGDL (mol.m-3.s-1). Sl_ampl ( list ) \u2013 Liquid water generated through vapor water liquefaction in the AMPL (mol.m-3.s-1). Sl_acl ( float ) \u2013 Liquid water generated through vapor water liquefaction in the ACL (mol.m-3.s-1). Sl_ccl ( float ) \u2013 Liquid water generated through vapor water liquefaction in the CCL (mol.m-3.s-1). Sl_cmpl ( list ) \u2013 Liquid water generated through vapor water liquefaction in the CMPL (mol.m-3.s-1). Sl_cgdl ( list ) \u2013 Liquid water generated through vapor water liquefaction in the CGDL (mol.m-3.s-1). Returns: dict \u2013 Heat transfers occuring inside the fuel cell system. Source code in model/heat_transfer.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def calculate_heat_transfers ( sv , i_fc , parameters , S_abs_acl , S_abs_ccl , Sl_agdl , Sl_ampl , Sl_acl , Sl_ccl , Sl_cmpl , Sl_cgdl , ** kwargs ): \"\"\"This function calculates the heat transfers occurring inside the fuel cell system. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc : float Fuel cell current density at time t (A.m-2). parameters : dict Parameters of the fuel cell model. S_abs_acl : float Water absorption in the ACL (mol.m-3.s-1). S_abs_ccl : float Water absorption in the CCL (mol.m-3.s-1). Sl_agdl : list Liquid water generated through vapor water liquefaction in the AGDL (mol.m-3.s-1). Sl_ampl : list Liquid water generated through vapor water liquefaction in the AMPL (mol.m-3.s-1). Sl_acl : float Liquid water generated through vapor water liquefaction in the ACL (mol.m-3.s-1). Sl_ccl : float Liquid water generated through vapor water liquefaction in the CCL (mol.m-3.s-1). Sl_cmpl : list Liquid water generated through vapor water liquefaction in the CMPL (mol.m-3.s-1). Sl_cgdl : list Liquid water generated through vapor water liquefaction in the CGDL (mol.m-3.s-1). Returns ------- dict Heat transfers occuring inside the fuel cell system. \"\"\" # ___________________________________________________Preliminaries__________________________________________________ # Extraction of the variables T_agc , T_ampl , T_acl , T_mem = sv [ 'T_agc' ], sv [ 'T_ampl' ], sv [ 'T_acl' ], sv [ 'T_mem' ] T_ccl , T_cmpl , T_cgc = sv [ 'T_ccl' ], sv [ 'T_cmpl' ], sv [ 'T_cgc' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] s_acl , s_ccl , eta_c = sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 'eta_c' ] # Extraction of the operating inputs and parameters epsilon_mc , epsilon_gdl , epsilon_cl = parameters [ 'epsilon_mc' ], parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c , n_gdl = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ], parameters [ 'n_gdl' ] Hmem , Hgdl , Hmpl = parameters [ 'Hmem' ], parameters [ 'Hgdl' ], parameters [ 'Hmpl' ] Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] # Intermediate values ( k_th_eff_agc_agdl , k_th_eff_agdl_agdl , k_th_eff_agdl_ampl , k_th_eff_ampl_acl , k_th_eff_acl_mem , k_th_eff_mem_ccl , k_th_eff_ccl_cmpl , k_th_eff_cmpl_cgdl , k_th_eff_cgdl_cgdl , k_th_eff_cgdl_cgc ) \\ = heat_transfer_int_values ( sv , parameters ) # ______________________________________________Heat flows (J.m-2.s-1)______________________________________________ # Anode side Jt_agc_agdl = - 2 * k_th_eff_agc_agdl * ( sv [ 'T_agdl_1' ] - T_agc ) / ( Hgdl / n_gdl ) Jt_agdl_agdl = { f 'agdl_agdl_ { i } ' : - k_th_eff_agdl_agdl [ i ] * ( sv [ f 'T_agdl_ { i + 1 } ' ] - sv [ f 'T_agdl_ { i } ' ]) / ( Hgdl / n_gdl ) for i in range ( 1 , n_gdl )} Jt_agdl_ampl = - 2 * k_th_eff_agdl_ampl * ( T_ampl - sv [ f 'T_agdl_ { n_gdl } ' ]) / ( Hgdl / n_gdl + Hmpl ) Jt_ampl_acl = - 2 * k_th_eff_ampl_acl * ( T_acl - T_ampl ) / ( Hmpl + Hacl ) # Membrane side Jt_acl_mem = - 2 * k_th_eff_acl_mem * ( T_mem - T_acl ) / ( Hacl + Hmem ) Jt_mem_ccl = - 2 * k_th_eff_mem_ccl * ( T_ccl - T_mem ) / ( Hccl + Hmem ) # Cathode side Jt_ccl_cmpl = - 2 * k_th_eff_ccl_cmpl * ( T_cmpl - T_ccl ) / ( Hmpl + Hccl ) Jt_cmpl_cgdl = - 2 * k_th_eff_cmpl_cgdl * ( sv [ 'T_cgdl_1' ] - T_cmpl ) / ( Hgdl / n_gdl + Hmpl ) Jt_cgdl_cgdl = { f 'cgdl_cgdl_ { i } ' : - k_th_eff_cgdl_cgdl [ i ] * ( sv [ f 'T_cgdl_ { i + 1 } ' ] - sv [ f 'T_cgdl_ { i } ' ]) / ( Hgdl / n_gdl ) for i in range ( 1 , n_gdl )} Jt_cgdl_cgc = - 2 * k_th_eff_cgdl_cgc * ( T_cgc - sv [ f 'T_cgdl_ { n_gdl } ' ]) / ( Hgdl / n_gdl ) Jt = { 'agc_agdl' : Jt_agc_agdl , ** Jt_agdl_agdl , 'agdl_ampl' : Jt_agdl_ampl , 'ampl_acl' : Jt_ampl_acl , 'acl_mem' : Jt_acl_mem , 'mem_ccl' : Jt_mem_ccl , 'ccl_cmpl' : Jt_ccl_cmpl , 'cmpl_cgdl' : Jt_cmpl_cgdl , ** Jt_cgdl_cgdl , 'cgdl_cgc' : Jt_cgdl_cgc } # ____________________________________________Heat generated (J.m-3.s-1)____________________________________________ # The heat dissipated by the electrochemical reaction 2*H2 + O2 -> 2*H2O, in J.m-3.s-1. # It is given by the sum of Peltier and activation heats [vetterFreeOpenReference2019]. S_r_acl = i_fc / ( 2 * F * Hacl ) # mol.m-3.s-1. It is the amount of hydrogen consumed at the ACL. S_r_ccl = i_fc / ( 4 * F * Hccl ) # mol.m-3.s-1. It is the amount of oxygen consumed at the CCL. Q_r = { 'acl' : S_r_acl * T_acl * ( - delta_s_HOR ), 'ccl' : S_r_ccl * T_ccl * ( - delta_s_ORR ) + i_fc * eta_c / Hccl } # The heat dissipated by the absorption of water from the CL to the membrane, in J.m-3.s-1. Q_sorp = { 'acl' : S_abs_acl * ( - delta_h_abs ( T_acl )), 'ccl' : S_abs_ccl * ( - delta_h_abs ( T_ccl ))} # The heat dissipated by the liquefaction of vapor water, in J.m-3.s-1. Q_liq = { ** { f 'agdl_ { i } ' : Sl_agdl [ i ] * ( - delta_h_liq ( sv [ f 'T_agdl_ { i } ' ])) for i in range ( 1 , n_gdl + 1 )}, ** { f 'cgdl_ { i } ' : Sl_cgdl [ i ] * ( - delta_h_liq ( sv [ f 'T_cgdl_ { i } ' ])) for i in range ( 1 , n_gdl + 1 )}, 'ampl' : Sl_ampl * ( - delta_h_liq ( T_ampl )), 'cmpl' : Sl_cmpl * ( - delta_h_liq ( T_cmpl )), 'acl' : Sl_acl * ( - delta_h_liq ( T_acl )), 'ccl' : Sl_ccl * ( - delta_h_liq ( T_ccl )) } # The heat dissipated by the ionic currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_p = { 'mem' : i_fc ** 2 / sigma_p_eff ( 'mem' , lambda_mem , T_mem ), 'ccl' : i_fc ** 2 / ( 3 * sigma_p_eff ( 'ccl' , lambda_ccl , T_ccl , epsilon_mc ))} # The heat dissipated by the electric currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_e = { ** { f 'agdl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'gdl' , epsilon_gdl , epsilon_c = epsilon_c ) for i in range ( 1 , n_gdl + 1 )}, 'acl' : i_fc ** 2 / sigma_e_eff ( 'cl' , epsilon_cl , epsilon_mc = epsilon_mc ), 'ampl' : i_fc ** 2 / sigma_e_eff ( 'mpl' , epsilon_mpl ), 'ccl' : i_fc ** 2 / ( 3 * sigma_e_eff ( 'cl' , epsilon_cl , epsilon_mc = epsilon_mc )), 'cmpl' : i_fc ** 2 / ( 3 * sigma_e_eff ( 'mpl' , epsilon_mpl )), ** { f 'cgdl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'gdl' , epsilon_gdl , epsilon_c = epsilon_c ) for i in range ( 1 , n_gdl + 1 )}} return { 'Jt' : Jt , 'Q_r' : Q_r , 'Q_sorp' : Q_sorp , 'Q_liq' : Q_liq , 'Q_p' : Q_p , 'Q_e' : Q_e }","title":"calculate_heat_transfers"},{"location":"functions/modules/GUI_modules/","text":"GUI modules This module contains some of the required functions for the GUI.py file. changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ) This function is called when the user selects a specific option from a dropdown menu for the type of fuel cell. Depending on the selected option, it either hides or displays specific input fields (labels or entry widgets) on the GUI. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choices_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ): \"\"\"This function is called when the user selects a specific option from a dropdown menu for the type of fuel cell. Depending on the selected option, it either hides or displays specific input fields (labels or entry widgets) on the GUI. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choices_buttons : dict A dictionary containing the button information. \"\"\" if choices_buttons [ 'type_fuel_cell' ][ 'value' ] . get () != 'Enter your specifications' : # Recovers the new settings recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ) # Display the labels for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Label ( operating_conditions_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Label ( accessible_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Label ( undetermined_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Label ( current_density_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Label ( computing_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) else : # choices_buttons['type_fuel_cell']['value'].get() == 'Enter your specifications': # Saves and displays the user entries for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Entry ( operating_conditions_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Entry ( accessible_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Entry ( undetermined_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Entry ( current_density_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Entry ( computing_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) This function displays labels on the GUI, representing operating conditions and physical parameters, without their actual values. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. Source code in modules/GUI_modules.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ): \"\"\"This function displays labels on the GUI, representing operating conditions and physical parameters, without their actual values. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. \"\"\" # Display the titles ttk . Label ( operating_conditions_frame , text = 'Operating conditions' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 1 , column = 0 , columnspan = 6 , ipady = 15 ) ttk . Label ( accessible_parameters_frame , text = 'Accessible physical parameters' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 6 , ipady = 15 ) # Display the labels for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Label ( operating_conditions_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Label ( accessible_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Label ( undetermined_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # current density parameters ttk . Label ( current_density_parameters_frame , text = 'Step current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Label ( current_density_parameters_frame , text = 'Polarization current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 2 , column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Label ( current_density_parameters_frame , text = 'EIS current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 5 , column = 0 , columnspan = 2 , sticky = \"w\" ) for k , v in choice_current_density_parameters . items (): ttk . Label ( current_density_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Label ( computing_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) This function displays entry widgets on the GUI. There, the user can enter values for operating conditions and physical parameters. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. Source code in modules/GUI_modules.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ): \"\"\"This function displays entry widgets on the GUI. There, the user can enter values for operating conditions and physical parameters. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. \"\"\" # Display the value for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Entry ( operating_conditions_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Entry ( accessible_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Entry ( undetermined_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Entry ( current_density_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Entry ( computing_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) display_radiobuttons ( model_possibilities_frame , choices_buttons ) This function displays radiobuttons on the GUI, allowing the user to make choices for control, results display, plot style, etc. Parameters: model_possibilities_frame ( Frame ) \u2013 The frame where the graphical elements for the model possibilities and the choice of current density are placed. choices_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def display_radiobuttons ( model_possibilities_frame , choices_buttons ): \"\"\"This function displays radiobuttons on the GUI, allowing the user to make choices for control, results display, plot style, etc. Parameters ---------- model_possibilities_frame : ttk.Frame The frame where the graphical elements for the model possibilities and the choice of current density are placed. choices_buttons : dict A dictionary containing the button information. \"\"\" ttk . Label ( model_possibilities_frame , text = 'Model possibilities' , font = ( 'cmr10' , 12 , 'bold' )) \\ . grid ( row = 0 , column = 0 , columnspan = 6 , ipady = 15 ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Auxiliaries: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 0 , columnspan = 1 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No auxiliaries' , value = 0 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Forced-convective cathode \\n with anodic recirculation' , value = 1 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Forced-convective cathode \\n with flow-through anode' , value = 2 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Control: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No control' , value = 0 , variable = choices_buttons [ 'type_control' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Humidity' , value = 1 , variable = choices_buttons [ 'type_control' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 3 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Purge: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No purge' , value = 0 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Periodic' , value = 1 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Constant' , value = 2 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Display: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No display' , value = 0 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Synthetic' , value = 1 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Multiple' , value = 2 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Plot: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Fixed' , value = 0 , variable = choices_buttons [ 'type_plot' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Dynamic' , value = 1 , variable = choices_buttons [ 'type_plot' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 3 , sticky = \"w\" ) launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 def launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None t0_EIS , t_new_start , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = current_parameters [ 't_EIS' ] f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = current_parameters [ 'f_EIS' ] # These are used for EIS max_step # actualization. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested. n = len ( t_new_start ) # It is the plot update number. time_interval = [ 0 , t0_EIS ] # It is the initial time interval. # A preliminary simulation run is necessary to equilibrate the internal variables of the cell at i_EIS # prior to initiating the EIS. Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization t0_EIS_temp = t0_EIS # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ 0 ] + delta_t_break_EIS [ 0 ] + delta_t_measurement_EIS [ 0 ] # It is the final time for # 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which has been # made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) if computing_parameters [ 'type_display' ] == \"multiple\" : print ( \"A display bug prevents the dynamic updating of the graphs, as it appears that too much data is \" \"involved. However, the data is correctly calculated, and the appropriate plots are saved in the \" \"'results' folder. This display bug does not occur when using a 'synthetic' type_display.\" ) # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_EIS_temp = Simulator . variables [ 't' ][ - 1 ] # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ i + 1 ] + delta_t_break_EIS [ i + 1 ] + delta_t_measurement_EIS [ i + 1 ] # It # is the final time for 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which # has been made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # It is the time interval for 1 EIS point. # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 def launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_load_pola' ] # (s). delta_t_break_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_break_pola' ] # (s). delta_i_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_i_pola' ] # (A.m-2). i_max_pola = current_parameters [ 'pola_current_parameters' ][ 'i_max_pola' ] # (A.m-2). # Calculation delta_t_pola = delta_t_load_pola + delta_t_break_pola # s. It is the time of one load. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * delta_t_pola # s. It is the polarization current duration. n = int ( tf / delta_t_pola ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola + delta_t_pola ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola + ( i + 2 ) * delta_t_pola time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a step current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 def launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a step current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Check if the type_fuel_cell and type_current are valid if computing_parameters [ 'type_current' ] == \"step\" and computing_parameters [ 'type_display' ] == \"multiple\" : raise ValueError ( 'dynamic plot is not thought to be used with step current and multiple display.' + 'There would be too much plots to handle.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters tf_step = ( current_parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_break_step' ]) # (s). delta_t_dyn_step = current_parameters [ 'step_current_parameters' ][ 'delta_t_dyn_step' ] # (s). # Calculation n = int ( tf_step / delta_t_dyn_step ) # It is the plot update number. time_interval = [ 0 , delta_t_dyn_step ] # (s). It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = ( i + 2 ) * delta_t_dyn_step time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ) This function retrieves parameter values for predefined stacks (e.g., \"EH-31 1.5 bar (2021)\", \"Biao Xie 1.0 bar (2015)\", etc.) and converts them to appropriate units for display on the GUI. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ): \"\"\"This function retrieves parameter values for predefined stacks (e.g., \"EH-31 1.5 bar (2021)\", \"Biao Xie 1.0 bar (2015)\", etc.) and converts them to appropriate units for display on the GUI. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. \"\"\" if choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 1.5 bar (2021)\" : type_fuel_cell = \"EH-31_1.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.0 bar (2021)\" : type_fuel_cell = \"EH-31_2.0\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.25 bar (2021)\" : type_fuel_cell = \"EH-31_2.25\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.5 bar (2021)\" : type_fuel_cell = \"EH-31_2.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"Linhao Fan (2010)\" : type_fuel_cell = \"LF\" ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) = current_density_parameters () T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , i_max_pola = stored_operating_inputs ( type_fuel_cell ) ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , Aact , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl ) = stored_physical_parameters ( type_fuel_cell ) n_gdl , t_purge , step_current_parameters = computing_parameters ( step_current_parameters , Hgdl , Hacl ) # operating conditions recovery choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . set ( round ( T_des - 273.15 , 4 )) # \u00b0C choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . set ( round ( Pa_des / 1e5 , 4 )) # bar choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . set ( round ( Pc_des / 1e5 , 4 )) # bar choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . set ( round ( Sa , 4 )) choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . set ( round ( Sc , 4 )) choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . set ( round ( Phi_a_des , 4 )) choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . set ( round ( Phi_c_des , 4 )) # accessible physical parameters recovery choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . set ( round ( Aact * 1e4 , 4 )) # cm\u00b2 choice_accessible_parameters [ 'AGC thickness - Hagc (\u00b5m)' ][ 'value' ] . set ( round ( Hagc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'CGC thickness - Hcgc (\u00b5m)' ][ 'value' ] . set ( round ( Hcgc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'AGC width - Wagc (\u00b5m)' ][ 'value' ] . set ( round ( Wagc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'CGC width - Wcgc (\u00b5m)' ][ 'value' ] . set ( round ( Wcgc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'GC cumulated length - Lgc (m)' ][ 'value' ] . set ( round ( Lgc , 4 )) # \u00b5m # undetermined physical parameters recovery choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m)' ][ 'value' ] . set ( round ( Hgdl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m)' ][ 'value' ] . set ( round ( Hmpl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . set ( round ( Hacl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . set ( round ( Hccl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . set ( round ( Hmem * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . set ( round ( epsilon_gdl , 4 )) choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . set ( round ( epsilon_cl , 4 )) choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . set ( round ( epsilon_mpl , 4 )) choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . set ( round ( epsilon_mc , 4 )) choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . set ( round ( epsilon_c , 4 )) choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . set ( e ) choice_undetermined_parameters [ 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' ][ 'value' ] . set ( round ( i0_c_ref , 4 )) # A.m-2 choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . set ( round ( kappa_co , 4 )) # mol.m-1.s-1.Pa-1 choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . set ( round ( kappa_c , 4 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . set ( round ( a_slim , 7 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . set ( round ( b_slim , 7 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . set ( round ( a_switch , 7 )) choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . set ( round ( C_scl * 1e-6 , 4 )) # F.cm-3 # i_max_pola recovery choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . set ( round ( i_max_pola / 1e4 , 4 )) # A/cm\u00b2 # computing parameters recovery choice_computing_parameters [ 'Number of GDL nodes - n_gdl' ][ 'value' ] . set ( n_gdl ) recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ) This function retrieves and converts the parameter values from the GUI into standard units for further calculations. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ): \"\"\"This function retrieves and converts the parameter values from the GUI into standard units for further calculations. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. \"\"\" # operating conditions T_des = choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . get () + 273.15 # K Pa_des = choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . get () * 1e5 # Pa Pc_des = choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () * 1e5 # Pa Sa = choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () Sc = choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () Phi_a_des = choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () Phi_c_des = choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () # accessible physical parameters Aact = choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . get () * 1e-4 # m\u00b2 Hagc = choice_accessible_parameters [ 'AGC thickness - Hagc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hcgc = choice_accessible_parameters [ 'CGC thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Wagc = choice_accessible_parameters [ 'AGC width - Wagc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Wcgc = choice_accessible_parameters [ 'CGC width - Wcgc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Lgc = choice_accessible_parameters [ 'GC cumulated length - Lgc (m)' ][ 'value' ] . get () # m # undetermined physical parameters Hgdl = choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hmpl = choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hacl = choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hccl = choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hmem = choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m epsilon_gdl = choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () epsilon_cl = choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () epsilon_mpl = choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () epsilon_mc = choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () epsilon_c = choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () e = choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () i0_c_ref = choice_undetermined_parameters [ 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' ][ 'value' ] . get () # A.m-2 kappa_co = choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () # mol.m-1.s-1.Pa-1 kappa_c = choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () a_slim = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () b_slim = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () a_switch = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () C_scl = choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () * 1e6 # F.m-3 # current density parameters delta_t_ini_step = choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_step (min)' ][ 'value' ] . get () * 60 #s delta_t_load_step = choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_step (s)' ][ 'value' ] . get () #s delta_t_break_step = choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_step (min)' ][ 'value' ] . get () * 60 #s i_step = choice_current_density_parameters [ 'Current density step \\n - i_step (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 delta_t_dyn_step = choice_computing_parameters [ 'Time for dynamic \\n display - \u0394t_dyn_step (s)' ][ 'value' ] . get () #s step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step , 'delta_t_dyn_step' : delta_t_dyn_step } delta_t_ini_pola = choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_pola (min)' ][ 'value' ] . get () * 60 #s delta_t_load_pola = choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_pola (s)' ][ 'value' ] . get () #s delta_t_break_pola = choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_pola (min)' ][ 'value' ] . get () * 60 #s delta_i_pola = choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 i_max_pola = choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola , 'i_max_pola' : i_max_pola } pola_current_for_cali_parameters = None # Calibration is not implemented in the GUI. i_EIS = choice_current_density_parameters [ 'Static current \\n - i_EIS (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # (A.m-2) ratio_EIS = choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () / 100 f_EIS = ( choice_current_density_parameters [ 'Power of the \\n initial frequency \\n - f_power_min_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Power of the \\n final frequency \\n - f_power_max_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get ()) t_EIS = EIS_parameters ( f_EIS ) # Time parameters for the EIS_current density function. # computing parameters t_purge = choice_computing_parameters [ 'Purge time - t_purge (s)' ][ 'value' ] . get () # s delta_t_purge = choice_computing_parameters [ 'Time between two purges \\n - \u0394t_purge (s)' ][ 'value' ] . get () # s n_gdl = choice_computing_parameters [ 'Number of GDL nodes - n_gdl' ][ 'value' ] . get () if choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 1.5 bar (2021)\" : type_fuel_cell = \"EH-31_1.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.0 bar (2021)\" : type_fuel_cell = \"EH-31_2.0\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.25 bar (2021)\" : type_fuel_cell = \"EH-31_2.25\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.5 bar (2021)\" : type_fuel_cell = \"EH-31_2.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"Linhao Fan (2010)\" : type_fuel_cell = \"LF\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"Enter your specifications\" : type_fuel_cell = \"manual_setup\" if choice_buttons [ 'type_auxiliary' ][ 'value' ] . get () == 0 : type_auxiliary = \"no_auxiliary\" elif choice_buttons [ 'type_auxiliary' ][ 'value' ] . get () == 1 : type_auxiliary = \"forced-convective_cathode_with_anodic_recirculation\" else : type_auxiliary = \"forced-convective_cathode_with_flow-through_anode\" if choice_buttons [ 'type_control' ][ 'value' ] . get () == 0 : type_control = \"no_control\" else : type_control = \"Phi_des\" if choice_buttons [ 'type_purge' ][ 'value' ] . get () == 0 : type_purge = \"no_purge\" elif choice_buttons [ 'type_purge' ][ 'value' ] . get () == 1 : type_purge = \"periodic_purge\" else : type_purge = \"constant_purge\" if choice_buttons [ 'type_display' ][ 'value' ] . get () == 0 : type_display = \"no_display\" elif choice_buttons [ 'type_display' ][ 'value' ] . get () == 1 : type_display = \"synthetic\" else : type_display = \"multiple\" if choice_buttons [ 'type_plot' ][ 'value' ] . get () == 0 : type_plot = \"fixed\" else : type_plot = \"dynamic\" return ( T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , Aact , Hgdl , Hmpl , Hacl , Hccl , Hmem , Hagc , Hcgc , Wagc , Wcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , epsilon_mc , epsilon_c , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl , step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , t_purge , delta_t_purge , n_gdl , type_fuel_cell , type_auxiliary , type_control , type_purge , type_display , type_plot ) set_equal_width ( frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ) Adjusts the width of the frames to be equal based on their maximum width. Parameters: frame1 ( Frame ) \u2013 The first frame to be resized. frame2 ( Frame ) \u2013 The second frame to be resized. frame3 ( Frame ) \u2013 The third frame to be resized. frame4 ( Frame ) \u2013 The fourth frame to be resized. frame5 ( Frame ) \u2013 The fifth frame to be resized. frame6 ( Frame ) \u2013 The sixth frame to be resized. Source code in modules/GUI_modules.py 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 def set_equal_width ( frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ): \"\"\" Adjusts the width of the frames to be equal based on their maximum width. Parameters ---------- frame1 : ttk.Frame The first frame to be resized. frame2 : ttk.Frame The second frame to be resized. frame3 : ttk.Frame The third frame to be resized. frame4 : ttk.Frame The fourth frame to be resized. frame5 : ttk.Frame The fifth frame to be resized. frame6 : ttk.Frame The sixth frame to be resized. \"\"\" # Initialisation of the list of widths widths = [] for frame in [ frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ]: # Update the frame sizes frame . update_idletasks () # Get the current width of all frames widths . append ( frame . winfo_width ()) # Set all frames to the maximum width for frame in [ frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ]: for i in range ( 6 ): frame . grid_columnconfigure ( i , minsize = max ( widths ) / 5.5 ) # Set minimum width of all column to max_width / 5 value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) This function checks the integrity of the values entered by the user and returns an empty tuple if they are not valid. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in modules/GUI_modules.py 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 def value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function checks the integrity of the values entered by the user and returns an empty tuple if they are not valid. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # The values entered by the user are checked for compliance if choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Temperatures' , message = 'Negative temperatures do not exist in the Kelvin scale.' ) choices . clear () return if choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () > 5.0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () > 5.0 : messagebox . showerror ( title = 'Desired pressures' , message = 'Desired pressure should be positive and bellow 5.0 ' 'bars.' ) choices . clear () return if choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () < 1 or \\ choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () > 5 or \\ choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () < 1 or \\ choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () > 5 : messagebox . showerror ( title = 'Stoichiometric ratios' , message = 'The stoichiometric ratios Sa and Sc should be ' 'between 1 and 5.' ) choices . clear () return if choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () > 1 or \\ choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Desired humidity' , message = 'The desired humidities should be between 0 and 1.' ) choices . clear () return if choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Active area' , message = 'Negative active area is impossible.' ) choices . clear () return if choice_accessible_parameters [ 'AGC thickness - Hagc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'AGC thickness - Hagc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'CGC thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'CGC thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'AGC width - Wagc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'AGC width - Wagc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'CGC width - Wcgc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'CGC width - Wcgc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'GC cumulated length - Lgc (m)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'GC cumulated length - Lgc (m)' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'GC distances' , message = 'GC generally have a thickness and a width between 10\u00b5m and ' '10mm. Also, GC length is generally between 0 and 100m' ) choices . clear () return if choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () > 1000 : messagebox . showerror ( title = 'MEA thickness' , message = 'All MEA components generally have a thickness between ' '1\u00b5m and 1mm.' ) choices . clear () return if choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () < 0.50 or \\ choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () > 0.90 : messagebox . showerror ( title = 'GDL porosity' , message = 'GDL porosity should be between 0.50 and 0.90.' ) choices . clear () return if choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () < 0.12 or \\ choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () > 0.60 : messagebox . showerror ( title = 'GDL porosity' , message = 'CL porosity should be between 0.12 and 0.60.' ) choices . clear () return if choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () < 0.30 or \\ choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () > 0.70 : messagebox . showerror ( title = 'MPL porosity' , message = 'MPL porosity should be between 0.30 and 0.70.' ) choices . clear () return if choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Ionomer volume fraction' , message = 'Ionomer volume fraction should be between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Compression ratio' , message = 'The compression ratio should be between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () < 3 or choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () > 5 : messagebox . showerror ( title = 'Capillary exponent' , message = 'The capillary exponent should be between 3 and 5 and ' 'being an integer.' ) choices . clear () return if choice_undetermined_parameters [ 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' ][ 'value' ] . get () < 0.001 or \\ choice_undetermined_parameters [ 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' ][ 'value' ] . get () > 500 : messagebox . showerror ( title = 'Referenced exchange current density' , message = 'The referenced exchange current ' 'density is generally between 0.001 ' 'and 500 A.m-2.' ) choices . clear () return if choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () < 0.01 or \\ choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Crossover correction coefficient' , message = 'The crossover correction coefficient is' ' generally between 0.01 and 100 ' 'mol.m-1.s-1.Pa-1.' ) choices . clear () return if choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Overpotential correction exponent' , message = 'The overpotential correction exponent ' 'is generally between 0 and 100.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Slop of slim function' , message = 'The slop of slim function is generally between 0 ' 'and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Intercept of slim function' , message = 'The intercept of slim function is generally ' 'between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Slop of switch function' , message = 'The slop of switch function is generally between' ' 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () < 5 or \\ choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Double layer capacitance' , message = 'I have not settled yet a range for C_scl.' ) choices . clear () return if choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_step (min)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_step (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_step (min)' ][ 'value' ] . get () < 0 or \\ choice_computing_parameters [ 'Time for dynamic \\n display - \u0394t_dyn_step (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_pola (min)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_pola (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_pola (min)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Times' , message = 'The times should be positive, t0_step < tf_step and ' 'delta_t_load_step < (tf_step - t0_step).' ) choices . clear () return if choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Static current \\n - i_EIS (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () > \\ choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get (): messagebox . showerror ( title = 'Current densities' , message = 'The current densities should be positive, ' 'delta_i_pola < i_max_pola and ' 'i_ini_step < i_final_step.' ) choices . clear () return if choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () > 20 : messagebox . showerror ( title = 'Ratio EIS' , message = 'Ratio EIS is a percentage of i_EIS and should be between 0 ' 'and 20 for plotting correct EIS.' ) choices . clear () return if choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get () < 0 or \\ type ( choice_current_density_parameters [ 'Power of the \\n initial frequency \\n - f_power_min_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Power of the \\n final frequency \\n - f_power_max_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'f EIS' , message = 'f_EIS parameters should be integer and number of points should ' 'be positive.' ) choices . clear () return if choice_computing_parameters [ 'Purge time - t_purge (s)' ][ 'value' ] . get () < 0 or \\ choice_computing_parameters [ 'Time between two purges \\n - \u0394t_purge (s)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Purge times' , message = 'Negative times does not characterise purges.' ) choices . clear () return if choice_computing_parameters [ 'Number of GDL nodes - n_gdl' ][ 'value' ] . get () < 2 or \\ type ( choice_computing_parameters [ 'Number of GDL nodes - n_gdl' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'n gdl' , message = 'The n_gdl value should be an integer bigger than 2. ' 'A good compromise is 10.' ) choices . clear () return if current_button == 0 and choice_buttons [ 'type_display' ][ 'value' ] . get () == 2 \\ and choice_buttons [ 'type_plot' ][ 'value' ] . get () == 1 : messagebox . showerror ( title = 'n gdl' , message = 'dynamic plot is not thought to be used with step current and ' 'multiple display. There would be too much plots to handle.' ) choices . clear () return","title":"GUI modules"},{"location":"functions/modules/GUI_modules/#gui-modules","text":"This module contains some of the required functions for the GUI.py file.","title":"GUI modules"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.changeValue","text":"This function is called when the user selects a specific option from a dropdown menu for the type of fuel cell. Depending on the selected option, it either hides or displays specific input fields (labels or entry widgets) on the GUI. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choices_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ): \"\"\"This function is called when the user selects a specific option from a dropdown menu for the type of fuel cell. Depending on the selected option, it either hides or displays specific input fields (labels or entry widgets) on the GUI. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choices_buttons : dict A dictionary containing the button information. \"\"\" if choices_buttons [ 'type_fuel_cell' ][ 'value' ] . get () != 'Enter your specifications' : # Recovers the new settings recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ) # Display the labels for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Label ( operating_conditions_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Label ( accessible_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Label ( undetermined_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Label ( current_density_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Label ( computing_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) else : # choices_buttons['type_fuel_cell']['value'].get() == 'Enter your specifications': # Saves and displays the user entries for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Entry ( operating_conditions_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Entry ( accessible_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Entry ( undetermined_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Entry ( current_density_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Entry ( computing_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 )","title":"changeValue"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.display_parameter_labels","text":"This function displays labels on the GUI, representing operating conditions and physical parameters, without their actual values. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. Source code in modules/GUI_modules.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ): \"\"\"This function displays labels on the GUI, representing operating conditions and physical parameters, without their actual values. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. \"\"\" # Display the titles ttk . Label ( operating_conditions_frame , text = 'Operating conditions' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 1 , column = 0 , columnspan = 6 , ipady = 15 ) ttk . Label ( accessible_parameters_frame , text = 'Accessible physical parameters' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 6 , ipady = 15 ) # Display the labels for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Label ( operating_conditions_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Label ( accessible_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Label ( undetermined_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # current density parameters ttk . Label ( current_density_parameters_frame , text = 'Step current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Label ( current_density_parameters_frame , text = 'Polarization current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 2 , column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Label ( current_density_parameters_frame , text = 'EIS current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 5 , column = 0 , columnspan = 2 , sticky = \"w\" ) for k , v in choice_current_density_parameters . items (): ttk . Label ( current_density_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Label ( computing_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" )","title":"display_parameter_labels"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.display_parameters_value","text":"This function displays entry widgets on the GUI. There, the user can enter values for operating conditions and physical parameters. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. Source code in modules/GUI_modules.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ): \"\"\"This function displays entry widgets on the GUI. There, the user can enter values for operating conditions and physical parameters. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. \"\"\" # Display the value for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Entry ( operating_conditions_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Entry ( accessible_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Entry ( undetermined_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Entry ( current_density_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Entry ( computing_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 )","title":"display_parameters_value"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.display_radiobuttons","text":"This function displays radiobuttons on the GUI, allowing the user to make choices for control, results display, plot style, etc. Parameters: model_possibilities_frame ( Frame ) \u2013 The frame where the graphical elements for the model possibilities and the choice of current density are placed. choices_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def display_radiobuttons ( model_possibilities_frame , choices_buttons ): \"\"\"This function displays radiobuttons on the GUI, allowing the user to make choices for control, results display, plot style, etc. Parameters ---------- model_possibilities_frame : ttk.Frame The frame where the graphical elements for the model possibilities and the choice of current density are placed. choices_buttons : dict A dictionary containing the button information. \"\"\" ttk . Label ( model_possibilities_frame , text = 'Model possibilities' , font = ( 'cmr10' , 12 , 'bold' )) \\ . grid ( row = 0 , column = 0 , columnspan = 6 , ipady = 15 ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Auxiliaries: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 0 , columnspan = 1 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No auxiliaries' , value = 0 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Forced-convective cathode \\n with anodic recirculation' , value = 1 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Forced-convective cathode \\n with flow-through anode' , value = 2 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Control: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No control' , value = 0 , variable = choices_buttons [ 'type_control' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Humidity' , value = 1 , variable = choices_buttons [ 'type_control' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 3 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Purge: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No purge' , value = 0 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Periodic' , value = 1 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Constant' , value = 2 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Display: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No display' , value = 0 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Synthetic' , value = 1 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Multiple' , value = 2 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Plot: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Fixed' , value = 0 , variable = choices_buttons [ 'type_plot' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Dynamic' , value = 1 , variable = choices_buttons [ 'type_plot' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 3 , sticky = \"w\" )","title":"display_radiobuttons"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.launch_AlphaPEM_for_EIS_current","text":"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 def launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None t0_EIS , t_new_start , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = current_parameters [ 't_EIS' ] f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = current_parameters [ 'f_EIS' ] # These are used for EIS max_step # actualization. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested. n = len ( t_new_start ) # It is the plot update number. time_interval = [ 0 , t0_EIS ] # It is the initial time interval. # A preliminary simulation run is necessary to equilibrate the internal variables of the cell at i_EIS # prior to initiating the EIS. Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization t0_EIS_temp = t0_EIS # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ 0 ] + delta_t_break_EIS [ 0 ] + delta_t_measurement_EIS [ 0 ] # It is the final time for # 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which has been # made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) if computing_parameters [ 'type_display' ] == \"multiple\" : print ( \"A display bug prevents the dynamic updating of the graphs, as it appears that too much data is \" \"involved. However, the data is correctly calculated, and the appropriate plots are saved in the \" \"'results' folder. This display bug does not occur when using a 'synthetic' type_display.\" ) # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_EIS_temp = Simulator . variables [ 't' ][ - 1 ] # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ i + 1 ] + delta_t_break_EIS [ i + 1 ] + delta_t_measurement_EIS [ i + 1 ] # It # is the final time for 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which # has been made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # It is the time interval for 1 EIS point. # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_EIS_current"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.launch_AlphaPEM_for_polarization_current","text":"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 def launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_load_pola' ] # (s). delta_t_break_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_break_pola' ] # (s). delta_i_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_i_pola' ] # (A.m-2). i_max_pola = current_parameters [ 'pola_current_parameters' ][ 'i_max_pola' ] # (A.m-2). # Calculation delta_t_pola = delta_t_load_pola + delta_t_break_pola # s. It is the time of one load. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * delta_t_pola # s. It is the polarization current duration. n = int ( tf / delta_t_pola ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola + delta_t_pola ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola + ( i + 2 ) * delta_t_pola time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_polarization_current"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.launch_AlphaPEM_for_step_current","text":"Launch the AlphaPEM simulator for a step current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 def launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a step current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - i0_c_ref : float Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - n_gdl : int Number of points considered in the GDL (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Check if the type_fuel_cell and type_current are valid if computing_parameters [ 'type_current' ] == \"step\" and computing_parameters [ 'type_display' ] == \"multiple\" : raise ValueError ( 'dynamic plot is not thought to be used with step current and multiple display.' + 'There would be too much plots to handle.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters tf_step = ( current_parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_break_step' ]) # (s). delta_t_dyn_step = current_parameters [ 'step_current_parameters' ][ 'delta_t_dyn_step' ] # (s). # Calculation n = int ( tf_step / delta_t_dyn_step ) # It is the plot update number. time_interval = [ 0 , delta_t_dyn_step ] # (s). It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = ( i + 2 ) * delta_t_dyn_step time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_step_current"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.recover_for_display_operating_inputs_and_physical_parameters","text":"This function retrieves parameter values for predefined stacks (e.g., \"EH-31 1.5 bar (2021)\", \"Biao Xie 1.0 bar (2015)\", etc.) and converts them to appropriate units for display on the GUI. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ): \"\"\"This function retrieves parameter values for predefined stacks (e.g., \"EH-31 1.5 bar (2021)\", \"Biao Xie 1.0 bar (2015)\", etc.) and converts them to appropriate units for display on the GUI. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. \"\"\" if choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 1.5 bar (2021)\" : type_fuel_cell = \"EH-31_1.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.0 bar (2021)\" : type_fuel_cell = \"EH-31_2.0\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.25 bar (2021)\" : type_fuel_cell = \"EH-31_2.25\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.5 bar (2021)\" : type_fuel_cell = \"EH-31_2.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"Linhao Fan (2010)\" : type_fuel_cell = \"LF\" ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) = current_density_parameters () T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , i_max_pola = stored_operating_inputs ( type_fuel_cell ) ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , Aact , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl ) = stored_physical_parameters ( type_fuel_cell ) n_gdl , t_purge , step_current_parameters = computing_parameters ( step_current_parameters , Hgdl , Hacl ) # operating conditions recovery choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . set ( round ( T_des - 273.15 , 4 )) # \u00b0C choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . set ( round ( Pa_des / 1e5 , 4 )) # bar choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . set ( round ( Pc_des / 1e5 , 4 )) # bar choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . set ( round ( Sa , 4 )) choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . set ( round ( Sc , 4 )) choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . set ( round ( Phi_a_des , 4 )) choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . set ( round ( Phi_c_des , 4 )) # accessible physical parameters recovery choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . set ( round ( Aact * 1e4 , 4 )) # cm\u00b2 choice_accessible_parameters [ 'AGC thickness - Hagc (\u00b5m)' ][ 'value' ] . set ( round ( Hagc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'CGC thickness - Hcgc (\u00b5m)' ][ 'value' ] . set ( round ( Hcgc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'AGC width - Wagc (\u00b5m)' ][ 'value' ] . set ( round ( Wagc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'CGC width - Wcgc (\u00b5m)' ][ 'value' ] . set ( round ( Wcgc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'GC cumulated length - Lgc (m)' ][ 'value' ] . set ( round ( Lgc , 4 )) # \u00b5m # undetermined physical parameters recovery choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m)' ][ 'value' ] . set ( round ( Hgdl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m)' ][ 'value' ] . set ( round ( Hmpl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . set ( round ( Hacl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . set ( round ( Hccl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . set ( round ( Hmem * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . set ( round ( epsilon_gdl , 4 )) choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . set ( round ( epsilon_cl , 4 )) choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . set ( round ( epsilon_mpl , 4 )) choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . set ( round ( epsilon_mc , 4 )) choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . set ( round ( epsilon_c , 4 )) choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . set ( e ) choice_undetermined_parameters [ 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' ][ 'value' ] . set ( round ( i0_c_ref , 4 )) # A.m-2 choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . set ( round ( kappa_co , 4 )) # mol.m-1.s-1.Pa-1 choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . set ( round ( kappa_c , 4 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . set ( round ( a_slim , 7 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . set ( round ( b_slim , 7 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . set ( round ( a_switch , 7 )) choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . set ( round ( C_scl * 1e-6 , 4 )) # F.cm-3 # i_max_pola recovery choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . set ( round ( i_max_pola / 1e4 , 4 )) # A/cm\u00b2 # computing parameters recovery choice_computing_parameters [ 'Number of GDL nodes - n_gdl' ][ 'value' ] . set ( n_gdl )","title":"recover_for_display_operating_inputs_and_physical_parameters"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.recover_for_use_operating_inputs_and_physical_parameters","text":"This function retrieves and converts the parameter values from the GUI into standard units for further calculations. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ): \"\"\"This function retrieves and converts the parameter values from the GUI into standard units for further calculations. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. \"\"\" # operating conditions T_des = choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . get () + 273.15 # K Pa_des = choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . get () * 1e5 # Pa Pc_des = choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () * 1e5 # Pa Sa = choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () Sc = choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () Phi_a_des = choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () Phi_c_des = choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () # accessible physical parameters Aact = choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . get () * 1e-4 # m\u00b2 Hagc = choice_accessible_parameters [ 'AGC thickness - Hagc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hcgc = choice_accessible_parameters [ 'CGC thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Wagc = choice_accessible_parameters [ 'AGC width - Wagc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Wcgc = choice_accessible_parameters [ 'CGC width - Wcgc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Lgc = choice_accessible_parameters [ 'GC cumulated length - Lgc (m)' ][ 'value' ] . get () # m # undetermined physical parameters Hgdl = choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hmpl = choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hacl = choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hccl = choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hmem = choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m epsilon_gdl = choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () epsilon_cl = choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () epsilon_mpl = choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () epsilon_mc = choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () epsilon_c = choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () e = choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () i0_c_ref = choice_undetermined_parameters [ 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' ][ 'value' ] . get () # A.m-2 kappa_co = choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () # mol.m-1.s-1.Pa-1 kappa_c = choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () a_slim = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () b_slim = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () a_switch = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () C_scl = choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () * 1e6 # F.m-3 # current density parameters delta_t_ini_step = choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_step (min)' ][ 'value' ] . get () * 60 #s delta_t_load_step = choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_step (s)' ][ 'value' ] . get () #s delta_t_break_step = choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_step (min)' ][ 'value' ] . get () * 60 #s i_step = choice_current_density_parameters [ 'Current density step \\n - i_step (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 delta_t_dyn_step = choice_computing_parameters [ 'Time for dynamic \\n display - \u0394t_dyn_step (s)' ][ 'value' ] . get () #s step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step , 'delta_t_dyn_step' : delta_t_dyn_step } delta_t_ini_pola = choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_pola (min)' ][ 'value' ] . get () * 60 #s delta_t_load_pola = choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_pola (s)' ][ 'value' ] . get () #s delta_t_break_pola = choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_pola (min)' ][ 'value' ] . get () * 60 #s delta_i_pola = choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 i_max_pola = choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola , 'i_max_pola' : i_max_pola } pola_current_for_cali_parameters = None # Calibration is not implemented in the GUI. i_EIS = choice_current_density_parameters [ 'Static current \\n - i_EIS (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # (A.m-2) ratio_EIS = choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () / 100 f_EIS = ( choice_current_density_parameters [ 'Power of the \\n initial frequency \\n - f_power_min_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Power of the \\n final frequency \\n - f_power_max_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get ()) t_EIS = EIS_parameters ( f_EIS ) # Time parameters for the EIS_current density function. # computing parameters t_purge = choice_computing_parameters [ 'Purge time - t_purge (s)' ][ 'value' ] . get () # s delta_t_purge = choice_computing_parameters [ 'Time between two purges \\n - \u0394t_purge (s)' ][ 'value' ] . get () # s n_gdl = choice_computing_parameters [ 'Number of GDL nodes - n_gdl' ][ 'value' ] . get () if choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 1.5 bar (2021)\" : type_fuel_cell = \"EH-31_1.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.0 bar (2021)\" : type_fuel_cell = \"EH-31_2.0\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.25 bar (2021)\" : type_fuel_cell = \"EH-31_2.25\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.5 bar (2021)\" : type_fuel_cell = \"EH-31_2.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"Linhao Fan (2010)\" : type_fuel_cell = \"LF\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"Enter your specifications\" : type_fuel_cell = \"manual_setup\" if choice_buttons [ 'type_auxiliary' ][ 'value' ] . get () == 0 : type_auxiliary = \"no_auxiliary\" elif choice_buttons [ 'type_auxiliary' ][ 'value' ] . get () == 1 : type_auxiliary = \"forced-convective_cathode_with_anodic_recirculation\" else : type_auxiliary = \"forced-convective_cathode_with_flow-through_anode\" if choice_buttons [ 'type_control' ][ 'value' ] . get () == 0 : type_control = \"no_control\" else : type_control = \"Phi_des\" if choice_buttons [ 'type_purge' ][ 'value' ] . get () == 0 : type_purge = \"no_purge\" elif choice_buttons [ 'type_purge' ][ 'value' ] . get () == 1 : type_purge = \"periodic_purge\" else : type_purge = \"constant_purge\" if choice_buttons [ 'type_display' ][ 'value' ] . get () == 0 : type_display = \"no_display\" elif choice_buttons [ 'type_display' ][ 'value' ] . get () == 1 : type_display = \"synthetic\" else : type_display = \"multiple\" if choice_buttons [ 'type_plot' ][ 'value' ] . get () == 0 : type_plot = \"fixed\" else : type_plot = \"dynamic\" return ( T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , Aact , Hgdl , Hmpl , Hacl , Hccl , Hmem , Hagc , Hcgc , Wagc , Wcgc , Lgc , epsilon_gdl , epsilon_cl , epsilon_mpl , epsilon_mc , epsilon_c , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl , step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , t_purge , delta_t_purge , n_gdl , type_fuel_cell , type_auxiliary , type_control , type_purge , type_display , type_plot )","title":"recover_for_use_operating_inputs_and_physical_parameters"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.set_equal_width","text":"Adjusts the width of the frames to be equal based on their maximum width. Parameters: frame1 ( Frame ) \u2013 The first frame to be resized. frame2 ( Frame ) \u2013 The second frame to be resized. frame3 ( Frame ) \u2013 The third frame to be resized. frame4 ( Frame ) \u2013 The fourth frame to be resized. frame5 ( Frame ) \u2013 The fifth frame to be resized. frame6 ( Frame ) \u2013 The sixth frame to be resized. Source code in modules/GUI_modules.py 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 def set_equal_width ( frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ): \"\"\" Adjusts the width of the frames to be equal based on their maximum width. Parameters ---------- frame1 : ttk.Frame The first frame to be resized. frame2 : ttk.Frame The second frame to be resized. frame3 : ttk.Frame The third frame to be resized. frame4 : ttk.Frame The fourth frame to be resized. frame5 : ttk.Frame The fifth frame to be resized. frame6 : ttk.Frame The sixth frame to be resized. \"\"\" # Initialisation of the list of widths widths = [] for frame in [ frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ]: # Update the frame sizes frame . update_idletasks () # Get the current width of all frames widths . append ( frame . winfo_width ()) # Set all frames to the maximum width for frame in [ frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ]: for i in range ( 6 ): frame . grid_columnconfigure ( i , minsize = max ( widths ) / 5.5 ) # Set minimum width of all column to max_width / 5","title":"set_equal_width"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.value_control","text":"This function checks the integrity of the values entered by the user and returns an empty tuple if they are not valid. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in modules/GUI_modules.py 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 def value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function checks the integrity of the values entered by the user and returns an empty tuple if they are not valid. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # The values entered by the user are checked for compliance if choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Temperatures' , message = 'Negative temperatures do not exist in the Kelvin scale.' ) choices . clear () return if choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () > 5.0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () > 5.0 : messagebox . showerror ( title = 'Desired pressures' , message = 'Desired pressure should be positive and bellow 5.0 ' 'bars.' ) choices . clear () return if choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () < 1 or \\ choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () > 5 or \\ choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () < 1 or \\ choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () > 5 : messagebox . showerror ( title = 'Stoichiometric ratios' , message = 'The stoichiometric ratios Sa and Sc should be ' 'between 1 and 5.' ) choices . clear () return if choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () > 1 or \\ choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Desired humidity' , message = 'The desired humidities should be between 0 and 1.' ) choices . clear () return if choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Active area' , message = 'Negative active area is impossible.' ) choices . clear () return if choice_accessible_parameters [ 'AGC thickness - Hagc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'AGC thickness - Hagc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'CGC thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'CGC thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'AGC width - Wagc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'AGC width - Wagc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'CGC width - Wcgc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'CGC width - Wcgc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'GC cumulated length - Lgc (m)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'GC cumulated length - Lgc (m)' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'GC distances' , message = 'GC generally have a thickness and a width between 10\u00b5m and ' '10mm. Also, GC length is generally between 0 and 100m' ) choices . clear () return if choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () > 1000 : messagebox . showerror ( title = 'MEA thickness' , message = 'All MEA components generally have a thickness between ' '1\u00b5m and 1mm.' ) choices . clear () return if choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () < 0.50 or \\ choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () > 0.90 : messagebox . showerror ( title = 'GDL porosity' , message = 'GDL porosity should be between 0.50 and 0.90.' ) choices . clear () return if choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () < 0.12 or \\ choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () > 0.60 : messagebox . showerror ( title = 'GDL porosity' , message = 'CL porosity should be between 0.12 and 0.60.' ) choices . clear () return if choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () < 0.30 or \\ choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () > 0.70 : messagebox . showerror ( title = 'MPL porosity' , message = 'MPL porosity should be between 0.30 and 0.70.' ) choices . clear () return if choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Ionomer volume fraction' , message = 'Ionomer volume fraction should be between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Compression ratio' , message = 'The compression ratio should be between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () < 3 or choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () > 5 : messagebox . showerror ( title = 'Capillary exponent' , message = 'The capillary exponent should be between 3 and 5 and ' 'being an integer.' ) choices . clear () return if choice_undetermined_parameters [ 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' ][ 'value' ] . get () < 0.001 or \\ choice_undetermined_parameters [ 'Reference exchange current \\n density - i0_c_ref (A/m\u00b2)' ][ 'value' ] . get () > 500 : messagebox . showerror ( title = 'Referenced exchange current density' , message = 'The referenced exchange current ' 'density is generally between 0.001 ' 'and 500 A.m-2.' ) choices . clear () return if choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () < 0.01 or \\ choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Crossover correction coefficient' , message = 'The crossover correction coefficient is' ' generally between 0.01 and 100 ' 'mol.m-1.s-1.Pa-1.' ) choices . clear () return if choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Overpotential correction exponent' , message = 'The overpotential correction exponent ' 'is generally between 0 and 100.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Slop of slim function' , message = 'The slop of slim function is generally between 0 ' 'and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Intercept of slim function' , message = 'The intercept of slim function is generally ' 'between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Slop of switch function' , message = 'The slop of switch function is generally between' ' 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () < 5 or \\ choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Double layer capacitance' , message = 'I have not settled yet a range for C_scl.' ) choices . clear () return if choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_step (min)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_step (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_step (min)' ][ 'value' ] . get () < 0 or \\ choice_computing_parameters [ 'Time for dynamic \\n display - \u0394t_dyn_step (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_pola (min)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_pola (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_pola (min)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Times' , message = 'The times should be positive, t0_step < tf_step and ' 'delta_t_load_step < (tf_step - t0_step).' ) choices . clear () return if choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Static current \\n - i_EIS (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () > \\ choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get (): messagebox . showerror ( title = 'Current densities' , message = 'The current densities should be positive, ' 'delta_i_pola < i_max_pola and ' 'i_ini_step < i_final_step.' ) choices . clear () return if choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () > 20 : messagebox . showerror ( title = 'Ratio EIS' , message = 'Ratio EIS is a percentage of i_EIS and should be between 0 ' 'and 20 for plotting correct EIS.' ) choices . clear () return if choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get () < 0 or \\ type ( choice_current_density_parameters [ 'Power of the \\n initial frequency \\n - f_power_min_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Power of the \\n final frequency \\n - f_power_max_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'f EIS' , message = 'f_EIS parameters should be integer and number of points should ' 'be positive.' ) choices . clear () return if choice_computing_parameters [ 'Purge time - t_purge (s)' ][ 'value' ] . get () < 0 or \\ choice_computing_parameters [ 'Time between two purges \\n - \u0394t_purge (s)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Purge times' , message = 'Negative times does not characterise purges.' ) choices . clear () return if choice_computing_parameters [ 'Number of GDL nodes - n_gdl' ][ 'value' ] . get () < 2 or \\ type ( choice_computing_parameters [ 'Number of GDL nodes - n_gdl' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'n gdl' , message = 'The n_gdl value should be an integer bigger than 2. ' 'A good compromise is 10.' ) choices . clear () return if current_button == 0 and choice_buttons [ 'type_display' ][ 'value' ] . get () == 2 \\ and choice_buttons [ 'type_plot' ][ 'value' ] . get () == 1 : messagebox . showerror ( title = 'n gdl' , message = 'dynamic plot is not thought to be used with step current and ' 'multiple display. There would be too much plots to handle.' ) choices . clear () return","title":"value_control"},{"location":"functions/modules/auxiliaries_modules/","text":"Auxiliaries modules This module is used to calculate intermediate values for the auxiliaries flows calculation. auxiliaries_int_values ( t , solver_variables , operating_inputs , parameters ) This functions calculates intermediate values for the auxiliaries flows calculation. Parameters: t ( float ) \u2013 Time (s). solver_variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell model. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Mext ( float ) \u2013 Molar mass of the ambient air outside the stack (kg/mol). Pagc ( float ) \u2013 Global pressure in the anode gas channel (Pa). Pcgc ( float ) \u2013 Global pressure in the cathode gas channel (Pa). Phi_agc ( float ) \u2013 Relative humidity in the anode gas channel. Phi_cgc ( float ) \u2013 Relative humidity in the cathode gas channel. y_cgc ( float ) \u2013 Oxygen ratio in dry air in the cathode gas channel. Magc ( float ) \u2013 Molar mass of all the gas species in the anode gas channel (kg/mol). Mcgc ( float ) \u2013 Molar mass of all the gas species in the cathode gas channel (kg/mol). Pr_aem ( float ) \u2013 Pressure ratio in the anode external manifold. Pr_cem ( float ) \u2013 Pressure ratio in the cathode external manifold. Maem ( float ) \u2013 Molar mass of all the gas species in the anode external manifold (kg/mol). Masm ( float ) \u2013 Molar mass of all the gas species in the anode supply manifold (kg/mol). Mcem ( float ) \u2013 Molar mass of all the gas species in the cathode external manifold (kg/mol). Mcsm ( float ) \u2013 Molar mass of all the gas species in the cathode supply manifold (kg/mol). k_purge ( float ) \u2013 Purge coefficient. It is equal to 1 if the purge is active and 0 otherwise. Abp_a ( float ) \u2013 Area of the back pressure valve in the anode external manifold (m\u00b2). Abp_c ( float ) \u2013 Area of the back pressure valve in the cathode external manifold (m\u00b2). i_n ( float ) \u2013 Internal current density (A/m\u00b2). Source code in modules/auxiliaries_modules.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def auxiliaries_int_values ( t , solver_variables , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the auxiliaries flows calculation. Parameters ---------- t : float Time (s). solver_variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell model. parameters : dict Parameters of the fuel cell model. Returns ------- Mext : float Molar mass of the ambient air outside the stack (kg/mol). Pagc : float Global pressure in the anode gas channel (Pa). Pcgc : float Global pressure in the cathode gas channel (Pa). Phi_agc : float Relative humidity in the anode gas channel. Phi_cgc : float Relative humidity in the cathode gas channel. y_cgc : float Oxygen ratio in dry air in the cathode gas channel. Magc : float Molar mass of all the gas species in the anode gas channel (kg/mol). Mcgc : float Molar mass of all the gas species in the cathode gas channel (kg/mol). Pr_aem : float Pressure ratio in the anode external manifold. Pr_cem : float Pressure ratio in the cathode external manifold. Maem : float Molar mass of all the gas species in the anode external manifold (kg/mol). Masm : float Molar mass of all the gas species in the anode supply manifold (kg/mol). Mcem : float Molar mass of all the gas species in the cathode external manifold (kg/mol). Mcsm : float Molar mass of all the gas species in the cathode supply manifold (kg/mol). k_purge : float Purge coefficient. It is equal to 1 if the purge is active and 0 otherwise. Abp_a : float Area of the back pressure valve in the anode external manifold (m\u00b2). Abp_c : float Area of the back pressure valve in the cathode external manifold (m\u00b2). i_n : float Internal current density (A/m\u00b2). \"\"\" # Extraction of the variables C_v_agc , C_v_cgc = solver_variables [ 'C_v_agc' ], solver_variables [ 'C_v_cgc' ] lambda_mem = solver_variables [ 'lambda_mem' ] C_H2_agc , C_H2_acl = solver_variables [ 'C_H2_agc' ], solver_variables [ 'C_H2_acl' ] C_N2 , C_O2_ccl , C_O2_cgc = solver_variables [ 'C_N2' ], solver_variables [ 'C_O2_ccl' ], solver_variables [ 'C_O2_cgc' ] T_acl , T_mem , T_ccl = solver_variables [ 'T_acl' ], solver_variables [ 'T_mem' ], solver_variables [ 'T_ccl' ] Pasm , Paem , Pcsm = solver_variables [ 'Pasm' ], solver_variables [ 'Paem' ], solver_variables [ 'Pcsm' ] Pcem , Phi_asm , Phi_aem = solver_variables [ 'Pcem' ], solver_variables [ 'Phi_asm' ], solver_variables [ 'Phi_aem' ] Phi_csm , Phi_cem = solver_variables [ 'Phi_csm' ], solver_variables [ 'Phi_cem' ] Abp_a , Abp_c = solver_variables [ 'Abp_a' ], solver_variables [ 'Abp_c' ] # Extraction of the operating inputs and the parameters T_des = operating_inputs [ 'T_des' ] Hmem , Hacl , Hccl , kappa_co = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'kappa_co' ] t_purge , type_purge = parameters [ 't_purge' ], parameters [ 'type_purge' ] # Molar mass of the ambient air Mext = Phi_ext * Psat ( Text ) / Pext * M_H2O + \\ yO2_ext * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_O2 + \\ ( 1 - yO2_ext ) * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_N2 # Physical quantities inside the stack # Pressures Pagc = ( C_v_agc + C_H2_agc ) * R * T_des Pcgc = ( C_v_cgc + C_O2_cgc + C_N2 ) * R * T_des # Humidities Phi_agc = C_v_agc / C_v_sat ( T_des ) Phi_cgc = C_v_cgc / C_v_sat ( T_des ) # Oxygen ratio in dry air y_cgc = C_O2_cgc / ( C_O2_cgc + C_N2 ) # Molar masses Magc = C_v_agc * R * T_des / Pagc * M_H2O + \\ C_H2_agc * R * T_des / Pagc * M_H2 Mcgc = Phi_cgc * Psat ( T_des ) / Pcgc * M_H2O + \\ y_cgc * ( 1 - Phi_cgc * Psat ( T_des ) / Pcgc ) * M_O2 + \\ ( 1 - y_cgc ) * ( 1 - Phi_cgc * Psat ( T_des ) / Pcgc ) * M_N2 # Internal current density T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # Physical quantities in the auxiliary system if parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_anodic_recirculation\" or \\ parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_flow-through_anode\" : # Pressure ratios Pr_aem = ( Pext / Paem ) Pr_cem = ( Pext / Pcem ) # Oxygen ratio in dry air y_cem = ( Pcem - Phi_cem * Psat ( T_des ) - C_N2 * R * T_des ) / ( Pcem - Phi_cem * Psat ( T_des )) # Molar masses Maem = Phi_aem * Psat ( T_des ) / Paem * M_H2O + \\ ( 1 - Phi_aem * Psat ( T_des ) / Paem ) * M_H2 Masm = Phi_asm * Psat ( T_des ) / Pasm * M_H2O + \\ ( 1 - Phi_asm * Psat ( T_des ) / Pasm ) * M_H2 Mcem = Phi_cem * Psat ( T_des ) / Pcem * M_H2O + \\ y_cem * ( 1 - Phi_cem * Psat ( T_des ) / Pcem ) * M_O2 + \\ ( 1 - y_cem ) * ( 1 - Phi_cem * Psat ( T_des ) / Pcem ) * M_N2 Mcsm = Phi_csm * Psat ( T_des ) / Pcsm * M_H2O + \\ yO2_ext * ( 1 - Phi_csm * Psat ( T_des ) / Pcsm ) * M_O2 + \\ ( 1 - yO2_ext ) * ( 1 - Phi_csm * Psat ( T_des ) / Pcsm ) * M_N2 # Purge if type_purge == \"no_purge\" : k_purge = 0 elif type_purge == \"constant_purge\" : k_purge = 1 elif type_purge == \"periodic_purge\" : purge_time , delta_purge = t_purge if ( t - int ( t / ( purge_time + delta_purge )) * ( purge_time + delta_purge )) <= purge_time : k_purge = 1 else : k_purge = 0 else : raise ValueError ( \"The type_purge variable should be correctly referenced.\" ) # Back pressure valve area if Abp_a > A_T : Abp_a = A_T elif Abp_a < 0 : Abp_a = 0 if Abp_c > A_T : Abp_c = A_T elif Abp_c < 0 : Abp_c = 0 else : # parameters[\"type_auxiliary\"] == \"no_auxiliary\" Pr_aem , Pr_cem , Maem , Masm , Mcem , Mcsm , k_purge , Abp_a , Abp_c = [ 0 ] * 9 return ( Mext , Pagc , Pcgc , Phi_agc , Phi_cgc , y_cgc , Magc , Mcgc , Pr_aem , Pr_cem , Maem , Masm , Mcem , Mcsm , k_purge , Abp_a , Abp_c , i_n )","title":"Auxiliaries modules"},{"location":"functions/modules/auxiliaries_modules/#auxiliaries-modules","text":"This module is used to calculate intermediate values for the auxiliaries flows calculation.","title":"Auxiliaries modules"},{"location":"functions/modules/auxiliaries_modules/#modules.auxiliaries_modules.auxiliaries_int_values","text":"This functions calculates intermediate values for the auxiliaries flows calculation. Parameters: t ( float ) \u2013 Time (s). solver_variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell model. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Mext ( float ) \u2013 Molar mass of the ambient air outside the stack (kg/mol). Pagc ( float ) \u2013 Global pressure in the anode gas channel (Pa). Pcgc ( float ) \u2013 Global pressure in the cathode gas channel (Pa). Phi_agc ( float ) \u2013 Relative humidity in the anode gas channel. Phi_cgc ( float ) \u2013 Relative humidity in the cathode gas channel. y_cgc ( float ) \u2013 Oxygen ratio in dry air in the cathode gas channel. Magc ( float ) \u2013 Molar mass of all the gas species in the anode gas channel (kg/mol). Mcgc ( float ) \u2013 Molar mass of all the gas species in the cathode gas channel (kg/mol). Pr_aem ( float ) \u2013 Pressure ratio in the anode external manifold. Pr_cem ( float ) \u2013 Pressure ratio in the cathode external manifold. Maem ( float ) \u2013 Molar mass of all the gas species in the anode external manifold (kg/mol). Masm ( float ) \u2013 Molar mass of all the gas species in the anode supply manifold (kg/mol). Mcem ( float ) \u2013 Molar mass of all the gas species in the cathode external manifold (kg/mol). Mcsm ( float ) \u2013 Molar mass of all the gas species in the cathode supply manifold (kg/mol). k_purge ( float ) \u2013 Purge coefficient. It is equal to 1 if the purge is active and 0 otherwise. Abp_a ( float ) \u2013 Area of the back pressure valve in the anode external manifold (m\u00b2). Abp_c ( float ) \u2013 Area of the back pressure valve in the cathode external manifold (m\u00b2). i_n ( float ) \u2013 Internal current density (A/m\u00b2). Source code in modules/auxiliaries_modules.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def auxiliaries_int_values ( t , solver_variables , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the auxiliaries flows calculation. Parameters ---------- t : float Time (s). solver_variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell model. parameters : dict Parameters of the fuel cell model. Returns ------- Mext : float Molar mass of the ambient air outside the stack (kg/mol). Pagc : float Global pressure in the anode gas channel (Pa). Pcgc : float Global pressure in the cathode gas channel (Pa). Phi_agc : float Relative humidity in the anode gas channel. Phi_cgc : float Relative humidity in the cathode gas channel. y_cgc : float Oxygen ratio in dry air in the cathode gas channel. Magc : float Molar mass of all the gas species in the anode gas channel (kg/mol). Mcgc : float Molar mass of all the gas species in the cathode gas channel (kg/mol). Pr_aem : float Pressure ratio in the anode external manifold. Pr_cem : float Pressure ratio in the cathode external manifold. Maem : float Molar mass of all the gas species in the anode external manifold (kg/mol). Masm : float Molar mass of all the gas species in the anode supply manifold (kg/mol). Mcem : float Molar mass of all the gas species in the cathode external manifold (kg/mol). Mcsm : float Molar mass of all the gas species in the cathode supply manifold (kg/mol). k_purge : float Purge coefficient. It is equal to 1 if the purge is active and 0 otherwise. Abp_a : float Area of the back pressure valve in the anode external manifold (m\u00b2). Abp_c : float Area of the back pressure valve in the cathode external manifold (m\u00b2). i_n : float Internal current density (A/m\u00b2). \"\"\" # Extraction of the variables C_v_agc , C_v_cgc = solver_variables [ 'C_v_agc' ], solver_variables [ 'C_v_cgc' ] lambda_mem = solver_variables [ 'lambda_mem' ] C_H2_agc , C_H2_acl = solver_variables [ 'C_H2_agc' ], solver_variables [ 'C_H2_acl' ] C_N2 , C_O2_ccl , C_O2_cgc = solver_variables [ 'C_N2' ], solver_variables [ 'C_O2_ccl' ], solver_variables [ 'C_O2_cgc' ] T_acl , T_mem , T_ccl = solver_variables [ 'T_acl' ], solver_variables [ 'T_mem' ], solver_variables [ 'T_ccl' ] Pasm , Paem , Pcsm = solver_variables [ 'Pasm' ], solver_variables [ 'Paem' ], solver_variables [ 'Pcsm' ] Pcem , Phi_asm , Phi_aem = solver_variables [ 'Pcem' ], solver_variables [ 'Phi_asm' ], solver_variables [ 'Phi_aem' ] Phi_csm , Phi_cem = solver_variables [ 'Phi_csm' ], solver_variables [ 'Phi_cem' ] Abp_a , Abp_c = solver_variables [ 'Abp_a' ], solver_variables [ 'Abp_c' ] # Extraction of the operating inputs and the parameters T_des = operating_inputs [ 'T_des' ] Hmem , Hacl , Hccl , kappa_co = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'kappa_co' ] t_purge , type_purge = parameters [ 't_purge' ], parameters [ 'type_purge' ] # Molar mass of the ambient air Mext = Phi_ext * Psat ( Text ) / Pext * M_H2O + \\ yO2_ext * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_O2 + \\ ( 1 - yO2_ext ) * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_N2 # Physical quantities inside the stack # Pressures Pagc = ( C_v_agc + C_H2_agc ) * R * T_des Pcgc = ( C_v_cgc + C_O2_cgc + C_N2 ) * R * T_des # Humidities Phi_agc = C_v_agc / C_v_sat ( T_des ) Phi_cgc = C_v_cgc / C_v_sat ( T_des ) # Oxygen ratio in dry air y_cgc = C_O2_cgc / ( C_O2_cgc + C_N2 ) # Molar masses Magc = C_v_agc * R * T_des / Pagc * M_H2O + \\ C_H2_agc * R * T_des / Pagc * M_H2 Mcgc = Phi_cgc * Psat ( T_des ) / Pcgc * M_H2O + \\ y_cgc * ( 1 - Phi_cgc * Psat ( T_des ) / Pcgc ) * M_O2 + \\ ( 1 - y_cgc ) * ( 1 - Phi_cgc * Psat ( T_des ) / Pcgc ) * M_N2 # Internal current density T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # Physical quantities in the auxiliary system if parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_anodic_recirculation\" or \\ parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_flow-through_anode\" : # Pressure ratios Pr_aem = ( Pext / Paem ) Pr_cem = ( Pext / Pcem ) # Oxygen ratio in dry air y_cem = ( Pcem - Phi_cem * Psat ( T_des ) - C_N2 * R * T_des ) / ( Pcem - Phi_cem * Psat ( T_des )) # Molar masses Maem = Phi_aem * Psat ( T_des ) / Paem * M_H2O + \\ ( 1 - Phi_aem * Psat ( T_des ) / Paem ) * M_H2 Masm = Phi_asm * Psat ( T_des ) / Pasm * M_H2O + \\ ( 1 - Phi_asm * Psat ( T_des ) / Pasm ) * M_H2 Mcem = Phi_cem * Psat ( T_des ) / Pcem * M_H2O + \\ y_cem * ( 1 - Phi_cem * Psat ( T_des ) / Pcem ) * M_O2 + \\ ( 1 - y_cem ) * ( 1 - Phi_cem * Psat ( T_des ) / Pcem ) * M_N2 Mcsm = Phi_csm * Psat ( T_des ) / Pcsm * M_H2O + \\ yO2_ext * ( 1 - Phi_csm * Psat ( T_des ) / Pcsm ) * M_O2 + \\ ( 1 - yO2_ext ) * ( 1 - Phi_csm * Psat ( T_des ) / Pcsm ) * M_N2 # Purge if type_purge == \"no_purge\" : k_purge = 0 elif type_purge == \"constant_purge\" : k_purge = 1 elif type_purge == \"periodic_purge\" : purge_time , delta_purge = t_purge if ( t - int ( t / ( purge_time + delta_purge )) * ( purge_time + delta_purge )) <= purge_time : k_purge = 1 else : k_purge = 0 else : raise ValueError ( \"The type_purge variable should be correctly referenced.\" ) # Back pressure valve area if Abp_a > A_T : Abp_a = A_T elif Abp_a < 0 : Abp_a = 0 if Abp_c > A_T : Abp_c = A_T elif Abp_c < 0 : Abp_c = 0 else : # parameters[\"type_auxiliary\"] == \"no_auxiliary\" Pr_aem , Pr_cem , Maem , Masm , Mcem , Mcsm , k_purge , Abp_a , Abp_c = [ 0 ] * 9 return ( Mext , Pagc , Pcgc , Phi_agc , Phi_cgc , y_cgc , Magc , Mcgc , Pr_aem , Pr_cem , Maem , Masm , Mcem , Mcsm , k_purge , Abp_a , Abp_c , i_n )","title":"auxiliaries_int_values"},{"location":"functions/modules/calibration_modules/","text":"Calibration modules This module contains some of the functions required for the parameter calibration. calculate_simulation_error ( Simulator_1 , U_exp_1 , i_exp_1 , Simulator_2 , U_exp_2 , i_exp_2 ) This function is used to calculate the simulation maximal error between the experimental and the simulated polarization curves. Two simulations on different operating conditions and on the same stack, and so two set of experimental data, are considered as it is the minimum amount of data which is required for the calibration. Parameters: Simulator_1 ( AlphaPEM object ) \u2013 PEM simulator which contains the simulation results for the first simulation. U_exp_1 ( ndarray ) \u2013 Experimental values of the voltage for the first simulation. i_exp_1 ( ndarray ) \u2013 Experimental values of the current density for the first simulation. Simulator_2 ( AlphaPEM object ) \u2013 PEM simulator which contains the simulation results for the second simulation. U_exp_2 ( ndarray ) \u2013 Experimental values of the voltage for the second simulation. i_exp_2 ( ndarray ) \u2013 Experimental values of the current density for the second simulation. Returns: sim_error ( float ) \u2013 Maximum error between the experimental and the simulated polarization curves in percentage. Source code in modules/calibration_modules.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 def calculate_simulation_error ( Simulator_1 , U_exp_1 , i_exp_1 , Simulator_2 , U_exp_2 , i_exp_2 ): \"\"\"This function is used to calculate the simulation maximal error between the experimental and the simulated polarization curves. Two simulations on different operating conditions and on the same stack, and so two set of experimental data, are considered as it is the minimum amount of data which is required for the calibration. Parameters ---------- Simulator_1 : AlphaPEM object PEM simulator which contains the simulation results for the first simulation. U_exp_1 : numpy.ndarray Experimental values of the voltage for the first simulation. i_exp_1 : numpy.ndarray Experimental values of the current density for the first simulation. Simulator_2 : AlphaPEM object PEM simulator which contains the simulation results for the second simulation. U_exp_2 : numpy.ndarray Experimental values of the voltage for the second simulation. i_exp_2 : numpy.ndarray Experimental values of the current density for the second simulation. Returns ------- sim_error : float Maximum error between the experimental and the simulated polarization curves in percentage. \"\"\" # Recovery of ifc_1 t1 = np . array ( Simulator_1 . variables [ 't' ]) n1 = len ( t1 ) ifc_t_1 = np . zeros ( n1 ) for i in range ( n1 ): # Creation of ifc_t ifc_t_1 [ i ] = Simulator_1 . operating_inputs [ 'current_density' ]( t1 [ i ], Simulator_1 . parameters ) # Recovery of ifc_2 t2 = np . array ( Simulator_2 . variables [ 't' ]) n2 = len ( t2 ) ifc_t_2 = np . zeros ( n2 ) for i in range ( n2 ): # Creation of ifc_t ifc_t_2 [ i ] = Simulator_2 . operating_inputs [ 'current_density' ]( t2 [ i ], Simulator_2 . parameters ) # Polarisation curve point recovery after stack stabilisation for Simulator1 # Extraction of the parameters # The initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # The loading time for one step current of the polarisation current density function. delta_t_load_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # The breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). # Calculation nb_loads1 = len ( i_exp_1 ) # Number of load which are made delta_t_cali_1 = delta_t_load_pola_cali_1 + delta_t_break_pola_cali_1 # s. It is the time of one load. ifc_discretized1 = np . zeros ( nb_loads1 ) Ucell_discretized1 = np . zeros ( nb_loads1 ) for i in range ( nb_loads1 ): t_load_1 = delta_t_ini_pola_cali_1 + ( i + 1 ) * delta_t_cali_1 # time for measurement idx1 = ( np . abs ( t1 - t_load_1 )) . argmin () # the corresponding index ifc_discretized1 [ i ] = ifc_t_1 [ idx1 ] # the last value at the end of each load Ucell_discretized1 [ i ] = Simulator_1 . variables [ 'Ucell' ][ idx1 ] # the last value at the end of each load # Polarisation curve point recovery after stack stabilisation for Simulator2 # Extraction of the parameters # The initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # The loading time for one step current of the polarisation current density function. delta_t_load_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # The breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). # Calculation nb_loads2 = len ( i_exp_2 ) # Number of load which are made delta_t_cali_2 = delta_t_load_pola_cali_2 + delta_t_break_pola_cali_2 # s. It is the time of one load. ifc_discretized2 = np . zeros ( nb_loads2 ) Ucell_discretized2 = np . zeros ( nb_loads2 ) for i in range ( nb_loads2 ): t_load_2 = delta_t_ini_pola_cali_2 + ( i + 1 ) * delta_t_cali_2 # time for measurement idx2 = ( np . abs ( t2 - t_load_2 )) . argmin () # the corresponding index ifc_discretized2 [ i ] = ifc_t_2 [ idx2 ] # the last value at the end of each load Ucell_discretized2 [ i ] = Simulator_2 . variables [ 'Ucell' ][ idx2 ] # the last value at the end of each load # Distance between the simulated and the experimental polarization curves. sim_error = ( np . max ( np . abs ( Ucell_discretized1 - U_exp_1 ) / U_exp_1 * 100 ) + np . max ( np . abs ( Ucell_discretized2 - U_exp_2 ) / U_exp_2 * 100 )) / 2 # in %. return sim_error parameter_bounds_for_calibration ( type_fuel_cell ) This function is used to determine the parameter bounds of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters type_fuel_cell : str Type of fuel cell configuration. Returns varbound : list List of the bounds on the parameters to calibrate. Each element is a list containing the minimum and maximum values of the parameter, and the type of the parameter ('real' or 'int'). gene_space : list List of dictionaries used to define the bounds of the undetermined parameters for pygad. Each dictionary contains the 'low' and 'high' values for the parameter, and optionally a 'step' value for integer parameters. Source code in modules/calibration_modules.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def parameter_bounds_for_calibration ( type_fuel_cell ): \"\"\"This function is used to determine the parameter bounds of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- varbound : list List of the bounds on the parameters to calibrate. Each element is a list containing the minimum and maximum values of the parameter, and the type of the parameter ('real' or 'int'). gene_space : list List of dictionaries used to define the bounds of the undetermined parameters for pygad. Each dictionary contains the 'low' and 'high' values for the parameter, and optionally a 'step' value for integer parameters. \"\"\" if type_fuel_cell == \"ZSW-GenStack\" : # Fuel cell physical parameters Hacl_min , Hacl_max = 6e-6 , 1e-5 # m. It is the thickness of the ACL. Hccl_min , Hccl_max = 1e-5 , 2e-5 # m. It is the thickness of the CCL. Hmem_min , Hmem_max = 1e-5 , 2e-5 # m. It is the thickness of the membrane. epsilon_gdl_min , epsilon_gdl_max = 0.696 , 0.880 # It is the anode/cathode GDL porosity, without units. epsilon_mpl_min , epsilon_mpl_max = 0.32 , 0.54 # It is the anode/cathode MPL porosity, without units. epsilon_cl_min , epsilon_cl_max = 0.40 , 0.60 # It is the anode/cathode MPL porosity, without units. epsilon_mc_min , epsilon_mc_max = 0.40 , 0.60 # It is the volume fraction of ionomer in the CL. # Constants based on the interaction between water and the structure e_min , e_max = 3 , 5 # It is the capillary exponent, and should be an int number. # Voltage polarization i0_c_ref_min , i0_c_ref_max = 1e-3 , 80 # A.m-2.It is the reference exchange current density at the cathode. kappa_co_min , kappa_co_max = 0.01 , 40 # A.m-2. It is the crossover correction coefficient. kappa_c_min , kappa_c_max = 0.25 , 4 # It is the overpotential correction exponent. # The bounds on liquid saturation coefficients are constrained to facilitate calibration. a_slim_min , a_slim_max = 0.0 , 0.2 # It is one of the limit liquid saturation coefficients. b_slim_min , b_slim_max = 0.05 , 0.4 # It is one of the limit liquid saturation coefficients. a_switch_min , a_switch_max = 0.5 , 0.95 # It is one of the limit liquid saturation coefficients. # Undetermined parameter which is not considered yet (require the use of EIS curves to be calibrated) C_scl_min , C_sl_max = 2e7 , 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Bounds gathering and type varbound = [[ 'epsilon_gdl' , epsilon_gdl_min , epsilon_gdl_max , 'real' ], [ 'e' , e_min , e_max , 'int' ], [ 'i0_c_ref' , i0_c_ref_min , i0_c_ref_max , 'real' ], [ 'kappa_co' , kappa_co_min , kappa_co_max , 'real' ], [ 'kappa_c' , kappa_c_min , kappa_c_max , 'real' ]] gene_space = [] # List used to define the bounds of the undetermined parameters for pygad. for i in range ( len ( varbound )): name , min_val , max_val , type_val = varbound [ i ] if type_val == 'int' : gene_space . append ({ 'low' : min_val , 'high' : max_val , 'step' : 1 }) else : gene_space . append ({ 'low' : min_val , 'high' : max_val }) elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Fuel cell physical parameters Hacl_min , Hacl_max = 8e-6 , 2e-5 # m. It is the thickness of the ACL. Hmem_min , Hmem_max = 1.5e-5 , 5e-5 # m. It is the thickness of the membrane. epsilon_gdl_min , epsilon_gdl_max = 0.50 , 0.90 # It is the anode/cathode GDL porosity, without units. epsilon_mpl_min , epsilon_mpl_max = 0.30 , 0.60 # It is the anode/cathode MPL porosity, without units. epsilon_cl_min , epsilon_cl_max = 0.12 , 0.50 # It is the anode/cathode MPL porosity, without units. epsilon_mc_min , epsilon_mc_max = 0.15 , 0.40 # It is the volume fraction of ionomer in the CL. epsilon_c_min , epsilon_c_max = 0.15 , 0.30 # It is the compression ratio of the GDL. # Constants based on the interaction between water and the structure e_min , e_max = 3 , 5 # It is the capillary exponent, and should be an int number. # Voltage polarization i0_c_ref_min , i0_c_ref_max = 1e-3 , 80 # A.m-2.It is the reference exchange current density at the cathode. kappa_co_min , kappa_co_max = 0.01 , 40 # A.m-2. It is the crossover correction coefficient. kappa_c_min , kappa_c_max = 0.25 , 4 # It is the overpotential correction exponent. # The bounds on liquid saturation coefficients are constrained to facilitate calibration. a_slim_min , a_slim_max = 0.0 , 0.2 # It is one of the limit liquid saturation coefficients. b_slim_min , b_slim_max = 0.05 , 0.4 # It is one of the limit liquid saturation coefficients. a_switch_min , a_switch_max = 0.5 , 0.95 # It is one of the limit liquid saturation coefficients. # Undetermined parameter which is not considered yet (require the use of EIS curves to be calibrated) C_scl_min , C_sl_max = 2e7 , 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Bounds gathering and type varbound = [[ 'Hacl' , Hacl_min , Hacl_max , 'real' ], [ 'Hmem' , Hmem_min , Hmem_max , 'real' ], [ 'epsilon_gdl' , epsilon_gdl_min , epsilon_gdl_max , 'real' ], [ 'epsilon_mc' , epsilon_mc_min , epsilon_mc_max , 'real' ], [ 'e' , e_min , e_max , 'int' ], [ 'i0_c_ref' , i0_c_ref_min , i0_c_ref_max , 'real' ], [ 'kappa_co' , kappa_co_min , kappa_co_max , 'real' ], [ 'kappa_c' , kappa_c_min , kappa_c_max , 'real' ]] gene_space = [] # List used to define the bounds of the undetermined parameters for pygad. for i in range ( len ( varbound )): name , min_val , max_val , type_val = varbound [ i ] if type_val == 'int' : gene_space . append ({ 'low' : min_val , 'high' : max_val , 'step' : 1 }) else : gene_space . append ({ 'low' : min_val , 'high' : max_val }) else : raise ValueError ( \"A correct type_fuel_cell should be given.\" ) return varbound , gene_space parameters_for_calibration ( type_fuel_cell ) This function is used to determine the parameters of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. i_max_pola ( float ) \u2013 Maximum current density for the polarization curve. Aact ( float ) \u2013 Active area of the cell in m\u00b2. Hmem ( float ) \u2013 Thickness of the membrane in m. Hacl ( float ) \u2013 Thickness of the anode catalyst layer in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer in m. Hagc ( float ) \u2013 Thickness of the anode gas channel in m. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in m. Wagc ( float ) \u2013 Width of the gas anode channel in m. Wcgc ( float ) \u2013 Width of the gas cathode channel in m. Lgc ( float ) \u2013 Length of the gas channel in m. type_auxiliary ( str ) \u2013 Type of auxiliary system. type_control ( str ) \u2013 Type of control system. type_purge ( str ) \u2013 Type of purge system. type_display ( str ) \u2013 Type of display. type_plot ( str ) \u2013 Type of plot. type_current ( str ) \u2013 Type of current density function. current_density ( function ) \u2013 Current density evolution over time. It is a function of time and parameters dictionary. step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters ( dict ) \u2013 Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS ( float ) \u2013 Current for which a ratio_EIS perturbation is added. ratio_EIS ( float ) \u2013 Value of the perturbation on the current density for building the EIS curve. t_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min': f_min = 10**f_power_min, the power of the final frequency 'f_power_max', the number of frequencies tested 'nb_f' and the number of points calculated per specific period 'nb_points'. t_purge ( tuple ) \u2013 Time parameters for purging the system. It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. n_gdl ( int ) \u2013 Number of points considered in the GDL. i_exp ( ndarray ) \u2013 Experimental values of the current density. U_exp ( ndarray ) \u2013 Experimental values of the voltage. Source code in modules/calibration_modules.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def parameters_for_calibration ( type_fuel_cell ): \"\"\"This function is used to determine the parameters of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. i_max_pola : float Maximum current density for the polarization curve. Aact : float Active area of the cell in m\u00b2. Hmem : float Thickness of the membrane in m. Hacl : float Thickness of the anode catalyst layer in m. Hccl : float Thickness of the cathode catalyst layer in m. Hagc : float Thickness of the anode gas channel in m. Hcgc : float Thickness of the cathode gas channel in m. Wagc : float Width of the gas anode channel in m. Wcgc : float Width of the gas cathode channel in m. Lgc : float Length of the gas channel in m. type_auxiliary : str Type of auxiliary system. type_control : str Type of control system. type_purge : str Type of purge system. type_display : str Type of display. type_plot : str Type of plot. type_current : str Type of current density function. current_density : function Current density evolution over time. It is a function of time and parameters dictionary. step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS : float Current for which a ratio_EIS perturbation is added. ratio_EIS : float Value of the perturbation on the current density for building the EIS curve. t_EIS : tuple EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min': f_min = 10**f_power_min, the power of the final frequency 'f_power_max', the number of frequencies tested 'nb_f' and the number of points calculated per specific period 'nb_points'. t_purge : tuple Time parameters for purging the system. It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. n_gdl : int Number of points considered in the GDL. i_exp : numpy.ndarray Experimental values of the current density. U_exp : numpy.ndarray Experimental values of the voltage. \"\"\" if type_fuel_cell == \"ZSW-GenStack\" : # Given values by the author # Operating inputs T_des = 68 + 273.15 # K. It is the temperature of the fuel cell. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 39.8 , 50 # It is the desired relative humidity. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). # Fuel cell physical parameters Aact = 2.7972e-2 # m\u00b2. It is the active area of the catalyst layer. Hagc = 2.3e-4 # m. It is the thickness of the anode gas channel. Hcgc = 3e-4 # m. It is the thickness of the cathode gas channel. Wagc = 4.3e-4 # m. It is the width of the anode gas channel. Wcgc = 5.32e-4 # m. It is the width of the cathode gas channel. Lgc = 23.31 # m. It is the length of the gas channel. # Fuel cell undetermined physical parameters. Hgdl = 1.27e-4 # m. It is the thickness of the gas diffusion layer. Hmpl = 7e-5 # m. It is the thickness of the microporous layer. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Estimated undetermined parameters for the initialisation # Gas diffusion layer epsilon_gdl = 0.788 # It is the anode/cathode GDL porosity. epsilon_mpl = 0.425 # It is the porosity of the microporous layer. # Catalyst layer Hacl = 8e-6 # m. It is the thickness of the anode catalyst layer. Hccl = 1.7e-5 # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.5 # It is the porosity of the microporous layer. epsilon_mc = 0.5 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 1.5e-5 # m. It is the thickness of the membrane. # Interaction parameters between water and PEMFC structure e = 3.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 14.86 # A.m-2.It is the reference exchange current density at the cathode. kappa_co = 1 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.6386 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Algorithm parameters for polarization curve generation type_auxiliary = \"forced-convective_cathode_with_flow-through_anode\" type_control = \"no_control\" type_purge = \"no_purge\" type_display = \"no_display\" type_plot = \"fixed\" type_current = \"polarization_for_cali\" current_density = polarization_current_for_calibration delta_t_ini_step = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_step = 1e-15 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 0 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 0 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } delta_t_ini_pola = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. i_max_pola = 1.7e4 # (A.m-2). It is the maximum current density for the polarization curve. pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola , 'i_max_pola' : i_max_pola } delta_t_ini_pola_cali = 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 10 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } i_EIS , ratio_EIS = np . nan , np . nan # (A/m\u00b2, ). i_EIS is the current for which a ratio_EIS perturbation is added. f_EIS , t_EIS = np . nan , np . nan # It is the EIS parameters. t_purge = 0.6 , 15 # s It is the purge time and the distance between two purges. n_gdl = int ( Hgdl / Hacl / 4 ) # It is the number of model points placed inside each GDL. elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Given values by the author # Operating inputs T_des = 74 + 273.15 # K. It is the temperature of the fuel cell. Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. if type_fuel_cell == \"EH-31_1.5\" : Pa_des , Pc_des = 1.5e5 , 1.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). elif type_fuel_cell == \"EH-31_2.0\" : Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). elif type_fuel_cell == \"EH-31_2.25\" : Pa_des , Pc_des = 2.25e5 , 2.25e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). else : # type_fuel_cell == \"EH-31_2.5\": Pa_des , Pc_des = 2.5e5 , 2.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). # Fuel cell physical parameters Aact = 8.5e-3 # m\u00b2. It is the active area of the catalyst layer. Wagc = 4.5e-4 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 9.67 # m. It is the length of the gas channel. # Extrapolated physical parameters Hgdl = 2e-4 # m. It is the thickness of the gas diffusion layer. Hmpl = 3e-5 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. Hagc = 5e-4 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. # Estimated undetermined parameters for the initialisation # Gas diffusion layer epsilon_gdl = 0.7943 # It is the anode/cathode GDL porosity. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Catalyst layer Hacl = 8.089e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.2111 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 1.5e-5 # m. It is the thickness of the membrane. # Interaction parameters between water and PEMFC structure e = 3.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 14.86 # A.m-2.It is the reference exchange current density at the cathode. kappa_co = 1 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.6386 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Algorithm parameters for polarization curve generation type_auxiliary = \"forced-convective_cathode_with_flow-through_anode\" type_control = \"no_control\" type_purge = \"no_purge\" type_display = \"no_display\" type_plot = \"fixed\" type_current = \"polarization_for_cali\" current_density = polarization_current_for_calibration delta_t_ini_step = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_step = 1e-15 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 0 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 0 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } delta_t_ini_pola = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. i_max_pola = 1.7e4 # (A.m-2). It is the maximum current density for the polarization curve. pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola , 'i_max_pola' : i_max_pola } delta_t_ini_pola_cali = 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 10 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } i_EIS , ratio_EIS = np . nan , np . nan # (A/m\u00b2, ). i_EIS is the current for which a ratio_EIS perturbation is added. f_EIS , t_EIS = np . nan , np . nan # It is the EIS parameters. t_purge = 0.6 , 15 # s It is the purge time and the distance between two purges. n_gdl = int ( Hgdl / Hacl / 4 ) # It is the number of model points placed inside each GDL. else : ValueError ( \"A correct type_fuel_cell should be given.\" ) # Initialize the operating inputs and parameters dictionaries. operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des } current_parameters = { 'step_current_parameters' : step_current_parameters , 'pola_current_parameters' : pola_current_parameters , 'pola_current_for_cali_parameters' : pola_current_for_cali_parameters , 'i_EIS' : i_EIS , 'ratio_EIS' : ratio_EIS , 't_EIS' : t_EIS , 'f_EIS' : f_EIS } accessible_physical_parameters = { 'Aact' : Aact , 'Hagc' : Hagc , 'Hcgc' : Hcgc , 'Wagc' : Wagc , 'Wcgc' : Wcgc , 'Lgc' : Lgc } undetermined_physical_parameters = { 'Hgdl' : Hgdl , 'Hmpl' : Hmpl , 'Hmem' : Hmem , 'Hacl' : Hacl , 'Hccl' : Hccl , 'epsilon_gdl' : epsilon_gdl , 'epsilon_mpl' : epsilon_mpl , 'epsilon_mc' : epsilon_mc , 'epsilon_c' : epsilon_c , 'e' : e , 'kappa_co' : kappa_co , 'i0_c_ref' : i0_c_ref , 'kappa_c' : kappa_c , 'a_slim' : a_slim , 'b_slim' : b_slim , 'a_switch' : a_switch , 'C_scl' : C_scl } computing_parameters = { 'n_gdl' : n_gdl , 't_purge' : t_purge , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } # Characteristic points of the experimental polarization curve i_exp , U_exp = pola_exp_values_calibration ( type_fuel_cell ) return ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , i_exp , U_exp ) print_calibration_results ( convergence , ga_instance , solution , varbound , sim_error ) This function prints the calibration results by associating each optimized value with its parameter name. Parameters: convergence ( dict ) \u2013 Dictionary containing the convergence information of the genetic algorithm. ga_instance ( PyGAD object ) \u2013 Instance of PyGAD used for optimization. solution ( list ) \u2013 List of optimized parameter values. varbound ( list ) \u2013 List of parameter bounds and names. sim_error ( float ) \u2013 Maximum simulation error in percentage. Source code in modules/calibration_modules.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def print_calibration_results ( convergence , ga_instance , solution , varbound , sim_error ): \"\"\" This function prints the calibration results by associating each optimized value with its parameter name. Parameters ---------- convergence : dict Dictionary containing the convergence information of the genetic algorithm. ga_instance : PyGAD object Instance of PyGAD used for optimization. solution : list List of optimized parameter values. varbound : list List of parameter bounds and names. sim_error : float Maximum simulation error in percentage. \"\"\" print ( \"Convergence: \\n \" , convergence ) for idx , val in enumerate ( solution ): param_name = varbound [ idx ][ 0 ] print ( f \"Optimized parameter { param_name } : { val } \" ) print ( Fore . RED + \" \\n Max simulation error: \" , sim_error , \"%\" ) print ( Style . RESET_ALL ) if ga_instance . best_solution_generation != - 1 : print ( f \"Best fitness value reached after { ga_instance . best_solution_generation } generations.\" ) save_calibration_results ( convergence , ga_instance , solution , varbound , sim_error , type_fuel_cell ) This function saves the calibration results in a text file and a PyGAD file. The optimized values are retrieved from the solution list and associated with their names via varbound. Parameters: convergence ( dict ) \u2013 Convergence information from the genetic algorithm. ga_instance ( PyGAD object ) \u2013 Instance of PyGAD used for optimization. solution ( list ) \u2013 List of optimized parameter values. varbound ( list ) \u2013 List of parameter bounds and names. sim_error ( float ) \u2013 Maximum simulation error in percentage. type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: None \u2013 Source code in modules/calibration_modules.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def save_calibration_results ( convergence , ga_instance , solution , varbound , sim_error , type_fuel_cell ): \"\"\" This function saves the calibration results in a text file and a PyGAD file. The optimized values are retrieved from the solution list and associated with their names via varbound. Parameters ---------- convergence : dict Convergence information from the genetic algorithm. ga_instance : PyGAD object Instance of PyGAD used for optimization. solution : list List of optimized parameter values. varbound : list List of parameter bounds and names. sim_error : float Maximum simulation error in percentage. type_fuel_cell : str Type of fuel cell configuration. Returns ------- None \"\"\" root_folder , filename = \"results\" , \"parameter_calibration_1.txt\" subfolder_name = type_fuel_cell [: type_fuel_cell . find ( '_' )] if type_fuel_cell . find ( '_' ) != - 1 else type_fuel_cell counter = 1 folder_name = os . path . join ( root_folder , subfolder_name ) # Create the folder if necessary if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the file without erasing the previous ones while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 filename = \"parameter_calibration_\" + str ( counter ) + \".txt\" file_path = os . path . join ( folder_name , filename ) # Write information with open ( file_path , \"w\" ) as file : file . write ( \"Convergence: \" + str ( convergence )) for idx , val in enumerate ( solution ): param_name = varbound [ idx ][ 0 ] file . write ( f \" \\n Optimized parameter { param_name } : { val } \" ) file . write ( \" \\n Max simulation error: \" + str ( sim_error ) + \"%\" ) file . write ( \" \\n Algorithm works with \" + type_fuel_cell + \".\" ) if ga_instance . best_solution_generation != - 1 : file . write ( f \" \\n Best fitness value reached after { ga_instance . best_solution_generation } generations.\" ) ga_instance . save ( filename = os . path . join ( folder_name , \"parameter_calibration_\" + str ( counter ))) if os . path . isfile ( 'parameter_calibration_ongoing.pkl' ): os . remove ( 'parameter_calibration_ongoing.pkl' ) update_undetermined_parameters ( type_fuel_cell , solution , varbound , undetermined_physical_parameters ) Update the undetermined physical parameters dictionary with values from the solution. Parameters: solution ( list ) \u2013 List of parameter values obtained from the optimization algorithm. varbound ( list ) \u2013 List of parameter bounds and names. Each element contains the parameter name at index 0. undetermined_physical_parameters ( dict ) \u2013 Dictionary of undetermined physical parameters to be updated. Returns: dict \u2013 Updated dictionary of undetermined physical parameters. Source code in modules/calibration_modules.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def update_undetermined_parameters ( type_fuel_cell , solution , varbound , undetermined_physical_parameters ): \"\"\" Update the undetermined physical parameters dictionary with values from the solution. Parameters ---------- solution : list List of parameter values obtained from the optimization algorithm. varbound : list List of parameter bounds and names. Each element contains the parameter name at index 0. undetermined_physical_parameters : dict Dictionary of undetermined physical parameters to be updated. Returns ------- dict Updated dictionary of undetermined physical parameters. \"\"\" for i in range ( len ( solution )): param_name = varbound [ i ][ 0 ] if param_name in undetermined_physical_parameters : undetermined_physical_parameters [ param_name ] = solution [ i ] if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : undetermined_physical_parameters [ 'Hccl' ] = undetermined_physical_parameters [ 'Hacl' ] return undetermined_physical_parameters","title":"Calibration modules"},{"location":"functions/modules/calibration_modules/#calibration-modules","text":"This module contains some of the functions required for the parameter calibration.","title":"Calibration modules"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.calculate_simulation_error","text":"This function is used to calculate the simulation maximal error between the experimental and the simulated polarization curves. Two simulations on different operating conditions and on the same stack, and so two set of experimental data, are considered as it is the minimum amount of data which is required for the calibration. Parameters: Simulator_1 ( AlphaPEM object ) \u2013 PEM simulator which contains the simulation results for the first simulation. U_exp_1 ( ndarray ) \u2013 Experimental values of the voltage for the first simulation. i_exp_1 ( ndarray ) \u2013 Experimental values of the current density for the first simulation. Simulator_2 ( AlphaPEM object ) \u2013 PEM simulator which contains the simulation results for the second simulation. U_exp_2 ( ndarray ) \u2013 Experimental values of the voltage for the second simulation. i_exp_2 ( ndarray ) \u2013 Experimental values of the current density for the second simulation. Returns: sim_error ( float ) \u2013 Maximum error between the experimental and the simulated polarization curves in percentage. Source code in modules/calibration_modules.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 def calculate_simulation_error ( Simulator_1 , U_exp_1 , i_exp_1 , Simulator_2 , U_exp_2 , i_exp_2 ): \"\"\"This function is used to calculate the simulation maximal error between the experimental and the simulated polarization curves. Two simulations on different operating conditions and on the same stack, and so two set of experimental data, are considered as it is the minimum amount of data which is required for the calibration. Parameters ---------- Simulator_1 : AlphaPEM object PEM simulator which contains the simulation results for the first simulation. U_exp_1 : numpy.ndarray Experimental values of the voltage for the first simulation. i_exp_1 : numpy.ndarray Experimental values of the current density for the first simulation. Simulator_2 : AlphaPEM object PEM simulator which contains the simulation results for the second simulation. U_exp_2 : numpy.ndarray Experimental values of the voltage for the second simulation. i_exp_2 : numpy.ndarray Experimental values of the current density for the second simulation. Returns ------- sim_error : float Maximum error between the experimental and the simulated polarization curves in percentage. \"\"\" # Recovery of ifc_1 t1 = np . array ( Simulator_1 . variables [ 't' ]) n1 = len ( t1 ) ifc_t_1 = np . zeros ( n1 ) for i in range ( n1 ): # Creation of ifc_t ifc_t_1 [ i ] = Simulator_1 . operating_inputs [ 'current_density' ]( t1 [ i ], Simulator_1 . parameters ) # Recovery of ifc_2 t2 = np . array ( Simulator_2 . variables [ 't' ]) n2 = len ( t2 ) ifc_t_2 = np . zeros ( n2 ) for i in range ( n2 ): # Creation of ifc_t ifc_t_2 [ i ] = Simulator_2 . operating_inputs [ 'current_density' ]( t2 [ i ], Simulator_2 . parameters ) # Polarisation curve point recovery after stack stabilisation for Simulator1 # Extraction of the parameters # The initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # The loading time for one step current of the polarisation current density function. delta_t_load_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # The breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). # Calculation nb_loads1 = len ( i_exp_1 ) # Number of load which are made delta_t_cali_1 = delta_t_load_pola_cali_1 + delta_t_break_pola_cali_1 # s. It is the time of one load. ifc_discretized1 = np . zeros ( nb_loads1 ) Ucell_discretized1 = np . zeros ( nb_loads1 ) for i in range ( nb_loads1 ): t_load_1 = delta_t_ini_pola_cali_1 + ( i + 1 ) * delta_t_cali_1 # time for measurement idx1 = ( np . abs ( t1 - t_load_1 )) . argmin () # the corresponding index ifc_discretized1 [ i ] = ifc_t_1 [ idx1 ] # the last value at the end of each load Ucell_discretized1 [ i ] = Simulator_1 . variables [ 'Ucell' ][ idx1 ] # the last value at the end of each load # Polarisation curve point recovery after stack stabilisation for Simulator2 # Extraction of the parameters # The initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # The loading time for one step current of the polarisation current density function. delta_t_load_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # The breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). # Calculation nb_loads2 = len ( i_exp_2 ) # Number of load which are made delta_t_cali_2 = delta_t_load_pola_cali_2 + delta_t_break_pola_cali_2 # s. It is the time of one load. ifc_discretized2 = np . zeros ( nb_loads2 ) Ucell_discretized2 = np . zeros ( nb_loads2 ) for i in range ( nb_loads2 ): t_load_2 = delta_t_ini_pola_cali_2 + ( i + 1 ) * delta_t_cali_2 # time for measurement idx2 = ( np . abs ( t2 - t_load_2 )) . argmin () # the corresponding index ifc_discretized2 [ i ] = ifc_t_2 [ idx2 ] # the last value at the end of each load Ucell_discretized2 [ i ] = Simulator_2 . variables [ 'Ucell' ][ idx2 ] # the last value at the end of each load # Distance between the simulated and the experimental polarization curves. sim_error = ( np . max ( np . abs ( Ucell_discretized1 - U_exp_1 ) / U_exp_1 * 100 ) + np . max ( np . abs ( Ucell_discretized2 - U_exp_2 ) / U_exp_2 * 100 )) / 2 # in %. return sim_error","title":"calculate_simulation_error"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.parameter_bounds_for_calibration","text":"This function is used to determine the parameter bounds of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters type_fuel_cell : str Type of fuel cell configuration. Returns varbound : list List of the bounds on the parameters to calibrate. Each element is a list containing the minimum and maximum values of the parameter, and the type of the parameter ('real' or 'int'). gene_space : list List of dictionaries used to define the bounds of the undetermined parameters for pygad. Each dictionary contains the 'low' and 'high' values for the parameter, and optionally a 'step' value for integer parameters. Source code in modules/calibration_modules.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def parameter_bounds_for_calibration ( type_fuel_cell ): \"\"\"This function is used to determine the parameter bounds of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- varbound : list List of the bounds on the parameters to calibrate. Each element is a list containing the minimum and maximum values of the parameter, and the type of the parameter ('real' or 'int'). gene_space : list List of dictionaries used to define the bounds of the undetermined parameters for pygad. Each dictionary contains the 'low' and 'high' values for the parameter, and optionally a 'step' value for integer parameters. \"\"\" if type_fuel_cell == \"ZSW-GenStack\" : # Fuel cell physical parameters Hacl_min , Hacl_max = 6e-6 , 1e-5 # m. It is the thickness of the ACL. Hccl_min , Hccl_max = 1e-5 , 2e-5 # m. It is the thickness of the CCL. Hmem_min , Hmem_max = 1e-5 , 2e-5 # m. It is the thickness of the membrane. epsilon_gdl_min , epsilon_gdl_max = 0.696 , 0.880 # It is the anode/cathode GDL porosity, without units. epsilon_mpl_min , epsilon_mpl_max = 0.32 , 0.54 # It is the anode/cathode MPL porosity, without units. epsilon_cl_min , epsilon_cl_max = 0.40 , 0.60 # It is the anode/cathode MPL porosity, without units. epsilon_mc_min , epsilon_mc_max = 0.40 , 0.60 # It is the volume fraction of ionomer in the CL. # Constants based on the interaction between water and the structure e_min , e_max = 3 , 5 # It is the capillary exponent, and should be an int number. # Voltage polarization i0_c_ref_min , i0_c_ref_max = 1e-3 , 80 # A.m-2.It is the reference exchange current density at the cathode. kappa_co_min , kappa_co_max = 0.01 , 40 # A.m-2. It is the crossover correction coefficient. kappa_c_min , kappa_c_max = 0.25 , 4 # It is the overpotential correction exponent. # The bounds on liquid saturation coefficients are constrained to facilitate calibration. a_slim_min , a_slim_max = 0.0 , 0.2 # It is one of the limit liquid saturation coefficients. b_slim_min , b_slim_max = 0.05 , 0.4 # It is one of the limit liquid saturation coefficients. a_switch_min , a_switch_max = 0.5 , 0.95 # It is one of the limit liquid saturation coefficients. # Undetermined parameter which is not considered yet (require the use of EIS curves to be calibrated) C_scl_min , C_sl_max = 2e7 , 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Bounds gathering and type varbound = [[ 'epsilon_gdl' , epsilon_gdl_min , epsilon_gdl_max , 'real' ], [ 'e' , e_min , e_max , 'int' ], [ 'i0_c_ref' , i0_c_ref_min , i0_c_ref_max , 'real' ], [ 'kappa_co' , kappa_co_min , kappa_co_max , 'real' ], [ 'kappa_c' , kappa_c_min , kappa_c_max , 'real' ]] gene_space = [] # List used to define the bounds of the undetermined parameters for pygad. for i in range ( len ( varbound )): name , min_val , max_val , type_val = varbound [ i ] if type_val == 'int' : gene_space . append ({ 'low' : min_val , 'high' : max_val , 'step' : 1 }) else : gene_space . append ({ 'low' : min_val , 'high' : max_val }) elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Fuel cell physical parameters Hacl_min , Hacl_max = 8e-6 , 2e-5 # m. It is the thickness of the ACL. Hmem_min , Hmem_max = 1.5e-5 , 5e-5 # m. It is the thickness of the membrane. epsilon_gdl_min , epsilon_gdl_max = 0.50 , 0.90 # It is the anode/cathode GDL porosity, without units. epsilon_mpl_min , epsilon_mpl_max = 0.30 , 0.60 # It is the anode/cathode MPL porosity, without units. epsilon_cl_min , epsilon_cl_max = 0.12 , 0.50 # It is the anode/cathode MPL porosity, without units. epsilon_mc_min , epsilon_mc_max = 0.15 , 0.40 # It is the volume fraction of ionomer in the CL. epsilon_c_min , epsilon_c_max = 0.15 , 0.30 # It is the compression ratio of the GDL. # Constants based on the interaction between water and the structure e_min , e_max = 3 , 5 # It is the capillary exponent, and should be an int number. # Voltage polarization i0_c_ref_min , i0_c_ref_max = 1e-3 , 80 # A.m-2.It is the reference exchange current density at the cathode. kappa_co_min , kappa_co_max = 0.01 , 40 # A.m-2. It is the crossover correction coefficient. kappa_c_min , kappa_c_max = 0.25 , 4 # It is the overpotential correction exponent. # The bounds on liquid saturation coefficients are constrained to facilitate calibration. a_slim_min , a_slim_max = 0.0 , 0.2 # It is one of the limit liquid saturation coefficients. b_slim_min , b_slim_max = 0.05 , 0.4 # It is one of the limit liquid saturation coefficients. a_switch_min , a_switch_max = 0.5 , 0.95 # It is one of the limit liquid saturation coefficients. # Undetermined parameter which is not considered yet (require the use of EIS curves to be calibrated) C_scl_min , C_sl_max = 2e7 , 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Bounds gathering and type varbound = [[ 'Hacl' , Hacl_min , Hacl_max , 'real' ], [ 'Hmem' , Hmem_min , Hmem_max , 'real' ], [ 'epsilon_gdl' , epsilon_gdl_min , epsilon_gdl_max , 'real' ], [ 'epsilon_mc' , epsilon_mc_min , epsilon_mc_max , 'real' ], [ 'e' , e_min , e_max , 'int' ], [ 'i0_c_ref' , i0_c_ref_min , i0_c_ref_max , 'real' ], [ 'kappa_co' , kappa_co_min , kappa_co_max , 'real' ], [ 'kappa_c' , kappa_c_min , kappa_c_max , 'real' ]] gene_space = [] # List used to define the bounds of the undetermined parameters for pygad. for i in range ( len ( varbound )): name , min_val , max_val , type_val = varbound [ i ] if type_val == 'int' : gene_space . append ({ 'low' : min_val , 'high' : max_val , 'step' : 1 }) else : gene_space . append ({ 'low' : min_val , 'high' : max_val }) else : raise ValueError ( \"A correct type_fuel_cell should be given.\" ) return varbound , gene_space","title":"parameter_bounds_for_calibration"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.parameters_for_calibration","text":"This function is used to determine the parameters of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. i_max_pola ( float ) \u2013 Maximum current density for the polarization curve. Aact ( float ) \u2013 Active area of the cell in m\u00b2. Hmem ( float ) \u2013 Thickness of the membrane in m. Hacl ( float ) \u2013 Thickness of the anode catalyst layer in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer in m. Hagc ( float ) \u2013 Thickness of the anode gas channel in m. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in m. Wagc ( float ) \u2013 Width of the gas anode channel in m. Wcgc ( float ) \u2013 Width of the gas cathode channel in m. Lgc ( float ) \u2013 Length of the gas channel in m. type_auxiliary ( str ) \u2013 Type of auxiliary system. type_control ( str ) \u2013 Type of control system. type_purge ( str ) \u2013 Type of purge system. type_display ( str ) \u2013 Type of display. type_plot ( str ) \u2013 Type of plot. type_current ( str ) \u2013 Type of current density function. current_density ( function ) \u2013 Current density evolution over time. It is a function of time and parameters dictionary. step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters ( dict ) \u2013 Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS ( float ) \u2013 Current for which a ratio_EIS perturbation is added. ratio_EIS ( float ) \u2013 Value of the perturbation on the current density for building the EIS curve. t_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min': f_min = 10**f_power_min, the power of the final frequency 'f_power_max', the number of frequencies tested 'nb_f' and the number of points calculated per specific period 'nb_points'. t_purge ( tuple ) \u2013 Time parameters for purging the system. It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. n_gdl ( int ) \u2013 Number of points considered in the GDL. i_exp ( ndarray ) \u2013 Experimental values of the current density. U_exp ( ndarray ) \u2013 Experimental values of the voltage. Source code in modules/calibration_modules.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def parameters_for_calibration ( type_fuel_cell ): \"\"\"This function is used to determine the parameters of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. i_max_pola : float Maximum current density for the polarization curve. Aact : float Active area of the cell in m\u00b2. Hmem : float Thickness of the membrane in m. Hacl : float Thickness of the anode catalyst layer in m. Hccl : float Thickness of the cathode catalyst layer in m. Hagc : float Thickness of the anode gas channel in m. Hcgc : float Thickness of the cathode gas channel in m. Wagc : float Width of the gas anode channel in m. Wcgc : float Width of the gas cathode channel in m. Lgc : float Length of the gas channel in m. type_auxiliary : str Type of auxiliary system. type_control : str Type of control system. type_purge : str Type of purge system. type_display : str Type of display. type_plot : str Type of plot. type_current : str Type of current density function. current_density : function Current density evolution over time. It is a function of time and parameters dictionary. step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS : float Current for which a ratio_EIS perturbation is added. ratio_EIS : float Value of the perturbation on the current density for building the EIS curve. t_EIS : tuple EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min': f_min = 10**f_power_min, the power of the final frequency 'f_power_max', the number of frequencies tested 'nb_f' and the number of points calculated per specific period 'nb_points'. t_purge : tuple Time parameters for purging the system. It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. n_gdl : int Number of points considered in the GDL. i_exp : numpy.ndarray Experimental values of the current density. U_exp : numpy.ndarray Experimental values of the voltage. \"\"\" if type_fuel_cell == \"ZSW-GenStack\" : # Given values by the author # Operating inputs T_des = 68 + 273.15 # K. It is the temperature of the fuel cell. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 39.8 , 50 # It is the desired relative humidity. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). # Fuel cell physical parameters Aact = 2.7972e-2 # m\u00b2. It is the active area of the catalyst layer. Hagc = 2.3e-4 # m. It is the thickness of the anode gas channel. Hcgc = 3e-4 # m. It is the thickness of the cathode gas channel. Wagc = 4.3e-4 # m. It is the width of the anode gas channel. Wcgc = 5.32e-4 # m. It is the width of the cathode gas channel. Lgc = 23.31 # m. It is the length of the gas channel. # Fuel cell undetermined physical parameters. Hgdl = 1.27e-4 # m. It is the thickness of the gas diffusion layer. Hmpl = 7e-5 # m. It is the thickness of the microporous layer. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Estimated undetermined parameters for the initialisation # Gas diffusion layer epsilon_gdl = 0.788 # It is the anode/cathode GDL porosity. epsilon_mpl = 0.425 # It is the porosity of the microporous layer. # Catalyst layer Hacl = 8e-6 # m. It is the thickness of the anode catalyst layer. Hccl = 1.7e-5 # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.5 # It is the porosity of the microporous layer. epsilon_mc = 0.5 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 1.5e-5 # m. It is the thickness of the membrane. # Interaction parameters between water and PEMFC structure e = 3.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 14.86 # A.m-2.It is the reference exchange current density at the cathode. kappa_co = 1 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.6386 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Algorithm parameters for polarization curve generation type_auxiliary = \"forced-convective_cathode_with_flow-through_anode\" type_control = \"no_control\" type_purge = \"no_purge\" type_display = \"no_display\" type_plot = \"fixed\" type_current = \"polarization_for_cali\" current_density = polarization_current_for_calibration delta_t_ini_step = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_step = 1e-15 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 0 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 0 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } delta_t_ini_pola = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. i_max_pola = 1.7e4 # (A.m-2). It is the maximum current density for the polarization curve. pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola , 'i_max_pola' : i_max_pola } delta_t_ini_pola_cali = 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 10 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } i_EIS , ratio_EIS = np . nan , np . nan # (A/m\u00b2, ). i_EIS is the current for which a ratio_EIS perturbation is added. f_EIS , t_EIS = np . nan , np . nan # It is the EIS parameters. t_purge = 0.6 , 15 # s It is the purge time and the distance between two purges. n_gdl = int ( Hgdl / Hacl / 4 ) # It is the number of model points placed inside each GDL. elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Given values by the author # Operating inputs T_des = 74 + 273.15 # K. It is the temperature of the fuel cell. Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. if type_fuel_cell == \"EH-31_1.5\" : Pa_des , Pc_des = 1.5e5 , 1.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). elif type_fuel_cell == \"EH-31_2.0\" : Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). elif type_fuel_cell == \"EH-31_2.25\" : Pa_des , Pc_des = 2.25e5 , 2.25e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). else : # type_fuel_cell == \"EH-31_2.5\": Pa_des , Pc_des = 2.5e5 , 2.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). # Fuel cell physical parameters Aact = 8.5e-3 # m\u00b2. It is the active area of the catalyst layer. Wagc = 4.5e-4 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 9.67 # m. It is the length of the gas channel. # Extrapolated physical parameters Hgdl = 2e-4 # m. It is the thickness of the gas diffusion layer. Hmpl = 3e-5 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. Hagc = 5e-4 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. # Estimated undetermined parameters for the initialisation # Gas diffusion layer epsilon_gdl = 0.7943 # It is the anode/cathode GDL porosity. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Catalyst layer Hacl = 8.089e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.2111 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 1.5e-5 # m. It is the thickness of the membrane. # Interaction parameters between water and PEMFC structure e = 3.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 14.86 # A.m-2.It is the reference exchange current density at the cathode. kappa_co = 1 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.6386 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Algorithm parameters for polarization curve generation type_auxiliary = \"forced-convective_cathode_with_flow-through_anode\" type_control = \"no_control\" type_purge = \"no_purge\" type_display = \"no_display\" type_plot = \"fixed\" type_current = \"polarization_for_cali\" current_density = polarization_current_for_calibration delta_t_ini_step = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_step = 1e-15 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 0 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 0 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } delta_t_ini_pola = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. i_max_pola = 1.7e4 # (A.m-2). It is the maximum current density for the polarization curve. pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola , 'i_max_pola' : i_max_pola } delta_t_ini_pola_cali = 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 10 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } i_EIS , ratio_EIS = np . nan , np . nan # (A/m\u00b2, ). i_EIS is the current for which a ratio_EIS perturbation is added. f_EIS , t_EIS = np . nan , np . nan # It is the EIS parameters. t_purge = 0.6 , 15 # s It is the purge time and the distance between two purges. n_gdl = int ( Hgdl / Hacl / 4 ) # It is the number of model points placed inside each GDL. else : ValueError ( \"A correct type_fuel_cell should be given.\" ) # Initialize the operating inputs and parameters dictionaries. operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des } current_parameters = { 'step_current_parameters' : step_current_parameters , 'pola_current_parameters' : pola_current_parameters , 'pola_current_for_cali_parameters' : pola_current_for_cali_parameters , 'i_EIS' : i_EIS , 'ratio_EIS' : ratio_EIS , 't_EIS' : t_EIS , 'f_EIS' : f_EIS } accessible_physical_parameters = { 'Aact' : Aact , 'Hagc' : Hagc , 'Hcgc' : Hcgc , 'Wagc' : Wagc , 'Wcgc' : Wcgc , 'Lgc' : Lgc } undetermined_physical_parameters = { 'Hgdl' : Hgdl , 'Hmpl' : Hmpl , 'Hmem' : Hmem , 'Hacl' : Hacl , 'Hccl' : Hccl , 'epsilon_gdl' : epsilon_gdl , 'epsilon_mpl' : epsilon_mpl , 'epsilon_mc' : epsilon_mc , 'epsilon_c' : epsilon_c , 'e' : e , 'kappa_co' : kappa_co , 'i0_c_ref' : i0_c_ref , 'kappa_c' : kappa_c , 'a_slim' : a_slim , 'b_slim' : b_slim , 'a_switch' : a_switch , 'C_scl' : C_scl } computing_parameters = { 'n_gdl' : n_gdl , 't_purge' : t_purge , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } # Characteristic points of the experimental polarization curve i_exp , U_exp = pola_exp_values_calibration ( type_fuel_cell ) return ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , i_exp , U_exp )","title":"parameters_for_calibration"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.print_calibration_results","text":"This function prints the calibration results by associating each optimized value with its parameter name. Parameters: convergence ( dict ) \u2013 Dictionary containing the convergence information of the genetic algorithm. ga_instance ( PyGAD object ) \u2013 Instance of PyGAD used for optimization. solution ( list ) \u2013 List of optimized parameter values. varbound ( list ) \u2013 List of parameter bounds and names. sim_error ( float ) \u2013 Maximum simulation error in percentage. Source code in modules/calibration_modules.py 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def print_calibration_results ( convergence , ga_instance , solution , varbound , sim_error ): \"\"\" This function prints the calibration results by associating each optimized value with its parameter name. Parameters ---------- convergence : dict Dictionary containing the convergence information of the genetic algorithm. ga_instance : PyGAD object Instance of PyGAD used for optimization. solution : list List of optimized parameter values. varbound : list List of parameter bounds and names. sim_error : float Maximum simulation error in percentage. \"\"\" print ( \"Convergence: \\n \" , convergence ) for idx , val in enumerate ( solution ): param_name = varbound [ idx ][ 0 ] print ( f \"Optimized parameter { param_name } : { val } \" ) print ( Fore . RED + \" \\n Max simulation error: \" , sim_error , \"%\" ) print ( Style . RESET_ALL ) if ga_instance . best_solution_generation != - 1 : print ( f \"Best fitness value reached after { ga_instance . best_solution_generation } generations.\" )","title":"print_calibration_results"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.save_calibration_results","text":"This function saves the calibration results in a text file and a PyGAD file. The optimized values are retrieved from the solution list and associated with their names via varbound. Parameters: convergence ( dict ) \u2013 Convergence information from the genetic algorithm. ga_instance ( PyGAD object ) \u2013 Instance of PyGAD used for optimization. solution ( list ) \u2013 List of optimized parameter values. varbound ( list ) \u2013 List of parameter bounds and names. sim_error ( float ) \u2013 Maximum simulation error in percentage. type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: None \u2013 Source code in modules/calibration_modules.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def save_calibration_results ( convergence , ga_instance , solution , varbound , sim_error , type_fuel_cell ): \"\"\" This function saves the calibration results in a text file and a PyGAD file. The optimized values are retrieved from the solution list and associated with their names via varbound. Parameters ---------- convergence : dict Convergence information from the genetic algorithm. ga_instance : PyGAD object Instance of PyGAD used for optimization. solution : list List of optimized parameter values. varbound : list List of parameter bounds and names. sim_error : float Maximum simulation error in percentage. type_fuel_cell : str Type of fuel cell configuration. Returns ------- None \"\"\" root_folder , filename = \"results\" , \"parameter_calibration_1.txt\" subfolder_name = type_fuel_cell [: type_fuel_cell . find ( '_' )] if type_fuel_cell . find ( '_' ) != - 1 else type_fuel_cell counter = 1 folder_name = os . path . join ( root_folder , subfolder_name ) # Create the folder if necessary if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the file without erasing the previous ones while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 filename = \"parameter_calibration_\" + str ( counter ) + \".txt\" file_path = os . path . join ( folder_name , filename ) # Write information with open ( file_path , \"w\" ) as file : file . write ( \"Convergence: \" + str ( convergence )) for idx , val in enumerate ( solution ): param_name = varbound [ idx ][ 0 ] file . write ( f \" \\n Optimized parameter { param_name } : { val } \" ) file . write ( \" \\n Max simulation error: \" + str ( sim_error ) + \"%\" ) file . write ( \" \\n Algorithm works with \" + type_fuel_cell + \".\" ) if ga_instance . best_solution_generation != - 1 : file . write ( f \" \\n Best fitness value reached after { ga_instance . best_solution_generation } generations.\" ) ga_instance . save ( filename = os . path . join ( folder_name , \"parameter_calibration_\" + str ( counter ))) if os . path . isfile ( 'parameter_calibration_ongoing.pkl' ): os . remove ( 'parameter_calibration_ongoing.pkl' )","title":"save_calibration_results"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.update_undetermined_parameters","text":"Update the undetermined physical parameters dictionary with values from the solution. Parameters: solution ( list ) \u2013 List of parameter values obtained from the optimization algorithm. varbound ( list ) \u2013 List of parameter bounds and names. Each element contains the parameter name at index 0. undetermined_physical_parameters ( dict ) \u2013 Dictionary of undetermined physical parameters to be updated. Returns: dict \u2013 Updated dictionary of undetermined physical parameters. Source code in modules/calibration_modules.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def update_undetermined_parameters ( type_fuel_cell , solution , varbound , undetermined_physical_parameters ): \"\"\" Update the undetermined physical parameters dictionary with values from the solution. Parameters ---------- solution : list List of parameter values obtained from the optimization algorithm. varbound : list List of parameter bounds and names. Each element contains the parameter name at index 0. undetermined_physical_parameters : dict Dictionary of undetermined physical parameters to be updated. Returns ------- dict Updated dictionary of undetermined physical parameters. \"\"\" for i in range ( len ( solution )): param_name = varbound [ i ][ 0 ] if param_name in undetermined_physical_parameters : undetermined_physical_parameters [ param_name ] = solution [ i ] if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : undetermined_physical_parameters [ 'Hccl' ] = undetermined_physical_parameters [ 'Hacl' ] return undetermined_physical_parameters","title":"update_undetermined_parameters"},{"location":"functions/modules/dif_eq_modules/","text":"Differential equations modules This module is used to determine intermediate values for the calculation of the differential equations and to implement integration events. desired_flows ( solver_variables , control_variables , i_n , i_fc , operating_inputs , parameters , Mext ) This function calculates the desired flow for the air compressor and the humidifiers. These desired flow are different from the real ones as the corresponding machines takes time to reach the desired values. Parameters: solver_variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables ( dict ) \u2013 Variables controlled by the user. i_n ( float ) \u2013 Internal current density (A/m\u00b2). i_fc ( float ) \u2013 Fuel cell current density (A/m\u00b2). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Mext ( float ) \u2013 Molar mass of the ambient air outside the stack (kg/mol). Returns: Wcp_des ( float ) \u2013 Desired air compressor flow rate (kg/s). Wa_inj_des ( float ) \u2013 Desired humidifier flow rate at the anode side (kg/s). Wc_inj_des ( float ) \u2013 Desired humidifier flow rate at the cathode side (kg/s). Source code in modules/dif_eq_modules.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def desired_flows ( solver_variables , control_variables , i_n , i_fc , operating_inputs , parameters , Mext ): \"\"\" This function calculates the desired flow for the air compressor and the humidifiers. These desired flow are different from the real ones as the corresponding machines takes time to reach the desired values. Parameters ---------- solver_variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables : dict Variables controlled by the user. i_n : float Internal current density (A/m\u00b2). i_fc : float Fuel cell current density (A/m\u00b2). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Mext : float Molar mass of the ambient air outside the stack (kg/mol). Returns ------- Wcp_des : float Desired air compressor flow rate (kg/s). Wa_inj_des : float Desired humidifier flow rate at the anode side (kg/s). Wc_inj_des : float Desired humidifier flow rate at the cathode side (kg/s). \"\"\" # Extraction of the variables Pasm , Pcsm , Wcp = solver_variables [ 'Pasm' ], solver_variables [ 'Pcsm' ], solver_variables [ 'Wcp' ] # Extraction of the operating inputs and the parameters T_des , Sa , Sc = operating_inputs [ 'T_des' ], operating_inputs [ 'Sa' ], operating_inputs [ 'Sc' ] Phi_a_des , Phi_c_des = control_variables [ 'Phi_a_des' ], control_variables [ 'Phi_c_des' ] Aact , type_auxiliary = parameters [ 'Aact' ], parameters [ 'type_auxiliary' ] if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : # Intermediate values Prd = Pasm Pcp = Pcsm # The desired air compressor flow rate Wcp_des (kg.s-1) Wcp_des = n_cell * Mext * Pext / ( Pext - Phi_ext * Psat ( Text )) * \\ 1 / yO2_ext * Sc * ( i_fc + i_n ) / ( 4 * F ) * Aact # The desired humidifier flow rate at the anode side Wa_v_inj_des (kg.s-1) Wrd = n_cell * M_H2 * Sa * ( i_fc + i_n ) / ( 2 * F ) * Aact Wa_inj_des = ( M_H2O * Phi_a_des * Psat ( T_des ) / ( Prd + Phi_a_des * Psat ( T_des )) / ( 1 - Phi_a_des * Psat ( T_des ) / ( Prd + Phi_a_des * Psat ( T_des ))) * ( Wrd / M_H2 )) # The desired humidifier flow rate at the cathode side Wc_inj_des (kg.s-1) Wv_hum_in = M_H2O * Phi_ext * Psat ( Text ) / Pext * ( Wcp / Mext ) # Vapor flow rate from the outside Wc_v_des = M_H2O * Phi_c_des * Psat ( T_des ) / Pcp * ( Wcp / Mext ) # Desired vapor flow rate Wc_inj_des = Wc_v_des - Wv_hum_in # Desired humidifier flow rate else : # elif type_auxiliary == \"no_auxiliary\": Wcp_des , Wa_inj_des , Wc_inj_des = 0 , 0 , 0 return Wcp_des , Wa_inj_des , Wc_inj_des dif_eq_int_values ( sv , operating_inputs , control_variables , parameters ) This functions calculates intermediate values for the calculation of the differential equations Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. control_variables ( dict ) \u2013 Variables controlled by the user. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Mext ( float ) \u2013 Molar mass of the ambient air outside the stack (kg/mol). Pagc ( float ) \u2013 Global pressure in the anode gas channel (Pa). Pcgc ( float ) \u2013 Global pressure in the cathode gas channel (Pa). i_n ( float ) \u2013 Internal current density (A/m\u00b2). Masm ( float ) \u2013 Molar mass of all the gas species in the anode supply manifold (kg/mol). Maem ( float ) \u2013 Molar mass of all the gas species in the anode external manifold (kg/mol). Mcsm ( float ) \u2013 Molar mass of all the gas species in the cathode supply manifold (kg/mol). Mcem ( float ) \u2013 Molar mass of all the gas species in the cathode external manifold (kg/mol). rho_Cp0 ( dict ) \u2013 Volumetric heat capacity of each component in the stack (J.m-3.K-1). Source code in modules/dif_eq_modules.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def dif_eq_int_values ( sv , operating_inputs , control_variables , parameters ): \"\"\"This functions calculates intermediate values for the calculation of the differential equations Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs : dict Operating inputs of the fuel cell. control_variables : dict Variables controlled by the user. parameters : dict Parameters of the fuel cell model. Returns ------- Mext : float Molar mass of the ambient air outside the stack (kg/mol). Pagc : float Global pressure in the anode gas channel (Pa). Pcgc : float Global pressure in the cathode gas channel (Pa). i_n : float Internal current density (A/m\u00b2). Masm : float Molar mass of all the gas species in the anode supply manifold (kg/mol). Maem : float Molar mass of all the gas species in the anode external manifold (kg/mol). Mcsm : float Molar mass of all the gas species in the cathode supply manifold (kg/mol). Mcem : float Molar mass of all the gas species in the cathode external manifold (kg/mol). rho_Cp0 : dict Volumetric heat capacity of each component in the stack (J.m-3.K-1). \"\"\" # Extraction of the variables C_v_agc , C_v_ampl , C_v_acl = sv [ 'C_v_agc' ], sv [ 'C_v_ampl' ], sv [ 'C_v_acl' ] C_v_ccl , C_v_cmpl , C_v_cgc = sv [ 'C_v_ccl' ], sv [ 'C_v_cmpl' ], sv [ 'C_v_cgc' ] s_ampl , s_acl , s_ccl , s_cmpl = sv [ 's_ampl' ], sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 's_cmpl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_agc , C_H2_ampl , C_H2_acl = sv [ 'C_H2_agc' ], sv [ 'C_H2_ampl' ], sv [ 'C_H2_acl' ] C_O2_ccl , C_O2_cmpl , C_O2_cgc = sv [ 'C_O2_ccl' ], sv [ 'C_O2_cmpl' ], sv [ 'C_O2_cgc' ] C_N2 = sv [ 'C_N2' ] T_agc , T_ampl , T_acl , T_mem = sv [ 'T_agc' ], sv [ 'T_ampl' ], sv [ 'T_acl' ], sv [ 'T_mem' ] T_ccl , T_cmpl , T_cgc = sv [ 'T_ccl' ], sv [ 'T_cmpl' ], sv [ 'T_cgc' ] Pasm , Paem , Pcsm , Pcem = sv [ 'Pasm' ], sv [ 'Paem' ], sv [ 'Pcsm' ], sv [ 'Pcem' ] # Extraction of the operating inputs and the parameters T_des , Phi_c_des = operating_inputs [ 'T_des' ], control_variables [ 'Phi_c_des' ] Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_gdl , epsilon_cl , epsilon_mpl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ], parameters [ 'epsilon_mpl' ] kappa_co , epsilon_mc = parameters [ 'kappa_co' ], parameters [ 'epsilon_mc' ] n_gdl = parameters [ 'n_gdl' ] # Physical quantities outside the stack # Molar masses Mext = Phi_ext * Psat ( Text ) / Pext * M_H2O + \\ yO2_ext * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_O2 + \\ ( 1 - yO2_ext ) * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_N2 # Physical quantities inside the stack # Pressures Pagc = ( C_v_agc + C_H2_agc ) * R * T_agc Pcgc = ( C_v_cgc + C_O2_cgc + C_N2 ) * R * T_cgc # Humidities Phi_agc = C_v_agc / C_v_sat ( T_agc ) Phi_cgc = C_v_cgc / C_v_sat ( T_cgc ) # Oxygen ratio in dry air y_c = C_O2_cgc / ( C_O2_cgc + C_N2 ) # Internal current density T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # Volumetric heat capacity (J.m-3.K-1) rho_Cp0 = { ** { f 'agdl_ { i } ' : calculate_rho_Cp0 ( 'agdl' , sv [ f 'T_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], s = sv [ f 's_agdl_ { i } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i } ' ], epsilon = epsilon_gdl ) for i in range ( 1 , n_gdl + 1 )}, 'ampl' : calculate_rho_Cp0 ( 'ampl' , T_ampl , C_v = C_v_ampl , s = s_ampl , C_H2 = C_H2_ampl , epsilon = epsilon_mpl ), 'acl' : calculate_rho_Cp0 ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), 'mem' : calculate_rho_Cp0 ( 'mem' , T_mem , lambdaa = lambda_mem ), 'ccl' : calculate_rho_Cp0 ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2 , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), 'cmpl' : calculate_rho_Cp0 ( 'cmpl' , T_cmpl , C_v = C_v_cmpl , s = s_cmpl , C_O2 = C_O2_cmpl , C_N2 = C_N2 , epsilon = epsilon_mpl ), ** { f 'cgdl_ { i } ' : calculate_rho_Cp0 ( 'cgdl' , sv [ f 'T_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], s = sv [ f 's_cgdl_ { i } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i } ' ], C_N2 = C_N2 , epsilon = epsilon_gdl ) for i in range ( 1 , n_gdl + 1 )} } # Physical quantities inside the auxiliary system if parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_anodic_recirculation\" or \\ parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_flow-through_anode\" : # Pressure Pp = Pasm # Humidities Phi_aem = Phi_agc * Paem / Pagc Phi_asm = Phi_aem * Pp / Paem Phi_cem = Phi_cgc * Pcem / Pcgc # Molar masses Masm = Phi_asm * Psat ( T_des ) / Pasm * M_H2O + \\ ( 1 - Phi_asm * Psat ( T_des ) / Pasm ) * M_H2 Maem = Phi_aem * Psat ( T_des ) / Paem * M_H2O + \\ ( 1 - Phi_aem * Psat ( T_des ) / Paem ) * M_H2 Mcsm = Phi_c_des * Psat ( T_des ) / Pcsm * M_H2O + \\ yO2_ext * ( 1 - Phi_c_des * Psat ( T_des ) / Pcsm ) * M_O2 + \\ ( 1 - yO2_ext ) * ( 1 - Phi_c_des * Psat ( T_des ) / Pcsm ) * M_N2 Mcem = Phi_cem * Psat ( T_des ) / Pcem * M_H2O + \\ y_c * ( 1 - Phi_cem * Psat ( T_des ) / Pcem ) * M_O2 + \\ ( 1 - y_c ) * ( 1 - Phi_cem * Psat ( T_des ) / Pcem ) * M_N2 else : # parameters[\"type_auxiliary\"] == \"no_auxiliary\" Masm , Maem , Mcsm , Mcem = [ 0 ] * 4 return Mext , Pagc , Pcgc , i_n , Masm , Maem , Mcsm , Mcem , rho_Cp0 event_negative ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ) This function creates an event that will be checked at each step of solve_ivp integration. The integration stops if one of the crucial variables (C_v, lambda, C_O2, C_H2) becomes negative (or smaller than 1e-5). Parameters: t ( float ) \u2013 Time (s). y ( ndarray ) \u2013 Numpy list of the solver variables. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. solver_variable_names ( list ) \u2013 Names of the solver variables. control_variables ( dict ) \u2013 Variables controlled by the user. Returns: The difference between the minimum value of the crucial variables and 1e-5. \u2013 Source code in modules/dif_eq_modules.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def event_negative ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ): \"\"\"This function creates an event that will be checked at each step of solve_ivp integration. The integration stops if one of the crucial variables (C_v, lambda, C_O2, C_H2) becomes negative (or smaller than 1e-5). Parameters ---------- t : float Time (s). y : numpy.ndarray Numpy list of the solver variables. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. solver_variable_names : list Names of the solver variables. control_variables : dict Variables controlled by the user. Returns ------- The difference between the minimum value of the crucial variables and 1e-5. \"\"\" negative_solver_variables = {} # Dictionary to store the crucial variables for index , key in enumerate ( solver_variable_names ): if ( key . startswith ( \"C_v_\" )) or ( key . startswith ( \"lambda_\" )) or \\ ( key . startswith ( \"C_O2_\" )) or ( key . startswith ( \"C_H2_\" )): negative_solver_variables [ key ] = y [ index ] return min ( negative_solver_variables . values ()) - 1e-5 # 1e-5 is a control parameter to stop the program before","title":"Differential equations modules"},{"location":"functions/modules/dif_eq_modules/#differential-equations-modules","text":"This module is used to determine intermediate values for the calculation of the differential equations and to implement integration events.","title":"Differential equations modules"},{"location":"functions/modules/dif_eq_modules/#modules.dif_eq_modules.desired_flows","text":"This function calculates the desired flow for the air compressor and the humidifiers. These desired flow are different from the real ones as the corresponding machines takes time to reach the desired values. Parameters: solver_variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables ( dict ) \u2013 Variables controlled by the user. i_n ( float ) \u2013 Internal current density (A/m\u00b2). i_fc ( float ) \u2013 Fuel cell current density (A/m\u00b2). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Mext ( float ) \u2013 Molar mass of the ambient air outside the stack (kg/mol). Returns: Wcp_des ( float ) \u2013 Desired air compressor flow rate (kg/s). Wa_inj_des ( float ) \u2013 Desired humidifier flow rate at the anode side (kg/s). Wc_inj_des ( float ) \u2013 Desired humidifier flow rate at the cathode side (kg/s). Source code in modules/dif_eq_modules.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def desired_flows ( solver_variables , control_variables , i_n , i_fc , operating_inputs , parameters , Mext ): \"\"\" This function calculates the desired flow for the air compressor and the humidifiers. These desired flow are different from the real ones as the corresponding machines takes time to reach the desired values. Parameters ---------- solver_variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables : dict Variables controlled by the user. i_n : float Internal current density (A/m\u00b2). i_fc : float Fuel cell current density (A/m\u00b2). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Mext : float Molar mass of the ambient air outside the stack (kg/mol). Returns ------- Wcp_des : float Desired air compressor flow rate (kg/s). Wa_inj_des : float Desired humidifier flow rate at the anode side (kg/s). Wc_inj_des : float Desired humidifier flow rate at the cathode side (kg/s). \"\"\" # Extraction of the variables Pasm , Pcsm , Wcp = solver_variables [ 'Pasm' ], solver_variables [ 'Pcsm' ], solver_variables [ 'Wcp' ] # Extraction of the operating inputs and the parameters T_des , Sa , Sc = operating_inputs [ 'T_des' ], operating_inputs [ 'Sa' ], operating_inputs [ 'Sc' ] Phi_a_des , Phi_c_des = control_variables [ 'Phi_a_des' ], control_variables [ 'Phi_c_des' ] Aact , type_auxiliary = parameters [ 'Aact' ], parameters [ 'type_auxiliary' ] if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : # Intermediate values Prd = Pasm Pcp = Pcsm # The desired air compressor flow rate Wcp_des (kg.s-1) Wcp_des = n_cell * Mext * Pext / ( Pext - Phi_ext * Psat ( Text )) * \\ 1 / yO2_ext * Sc * ( i_fc + i_n ) / ( 4 * F ) * Aact # The desired humidifier flow rate at the anode side Wa_v_inj_des (kg.s-1) Wrd = n_cell * M_H2 * Sa * ( i_fc + i_n ) / ( 2 * F ) * Aact Wa_inj_des = ( M_H2O * Phi_a_des * Psat ( T_des ) / ( Prd + Phi_a_des * Psat ( T_des )) / ( 1 - Phi_a_des * Psat ( T_des ) / ( Prd + Phi_a_des * Psat ( T_des ))) * ( Wrd / M_H2 )) # The desired humidifier flow rate at the cathode side Wc_inj_des (kg.s-1) Wv_hum_in = M_H2O * Phi_ext * Psat ( Text ) / Pext * ( Wcp / Mext ) # Vapor flow rate from the outside Wc_v_des = M_H2O * Phi_c_des * Psat ( T_des ) / Pcp * ( Wcp / Mext ) # Desired vapor flow rate Wc_inj_des = Wc_v_des - Wv_hum_in # Desired humidifier flow rate else : # elif type_auxiliary == \"no_auxiliary\": Wcp_des , Wa_inj_des , Wc_inj_des = 0 , 0 , 0 return Wcp_des , Wa_inj_des , Wc_inj_des","title":"desired_flows"},{"location":"functions/modules/dif_eq_modules/#modules.dif_eq_modules.dif_eq_int_values","text":"This functions calculates intermediate values for the calculation of the differential equations Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. control_variables ( dict ) \u2013 Variables controlled by the user. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Mext ( float ) \u2013 Molar mass of the ambient air outside the stack (kg/mol). Pagc ( float ) \u2013 Global pressure in the anode gas channel (Pa). Pcgc ( float ) \u2013 Global pressure in the cathode gas channel (Pa). i_n ( float ) \u2013 Internal current density (A/m\u00b2). Masm ( float ) \u2013 Molar mass of all the gas species in the anode supply manifold (kg/mol). Maem ( float ) \u2013 Molar mass of all the gas species in the anode external manifold (kg/mol). Mcsm ( float ) \u2013 Molar mass of all the gas species in the cathode supply manifold (kg/mol). Mcem ( float ) \u2013 Molar mass of all the gas species in the cathode external manifold (kg/mol). rho_Cp0 ( dict ) \u2013 Volumetric heat capacity of each component in the stack (J.m-3.K-1). Source code in modules/dif_eq_modules.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def dif_eq_int_values ( sv , operating_inputs , control_variables , parameters ): \"\"\"This functions calculates intermediate values for the calculation of the differential equations Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs : dict Operating inputs of the fuel cell. control_variables : dict Variables controlled by the user. parameters : dict Parameters of the fuel cell model. Returns ------- Mext : float Molar mass of the ambient air outside the stack (kg/mol). Pagc : float Global pressure in the anode gas channel (Pa). Pcgc : float Global pressure in the cathode gas channel (Pa). i_n : float Internal current density (A/m\u00b2). Masm : float Molar mass of all the gas species in the anode supply manifold (kg/mol). Maem : float Molar mass of all the gas species in the anode external manifold (kg/mol). Mcsm : float Molar mass of all the gas species in the cathode supply manifold (kg/mol). Mcem : float Molar mass of all the gas species in the cathode external manifold (kg/mol). rho_Cp0 : dict Volumetric heat capacity of each component in the stack (J.m-3.K-1). \"\"\" # Extraction of the variables C_v_agc , C_v_ampl , C_v_acl = sv [ 'C_v_agc' ], sv [ 'C_v_ampl' ], sv [ 'C_v_acl' ] C_v_ccl , C_v_cmpl , C_v_cgc = sv [ 'C_v_ccl' ], sv [ 'C_v_cmpl' ], sv [ 'C_v_cgc' ] s_ampl , s_acl , s_ccl , s_cmpl = sv [ 's_ampl' ], sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 's_cmpl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_agc , C_H2_ampl , C_H2_acl = sv [ 'C_H2_agc' ], sv [ 'C_H2_ampl' ], sv [ 'C_H2_acl' ] C_O2_ccl , C_O2_cmpl , C_O2_cgc = sv [ 'C_O2_ccl' ], sv [ 'C_O2_cmpl' ], sv [ 'C_O2_cgc' ] C_N2 = sv [ 'C_N2' ] T_agc , T_ampl , T_acl , T_mem = sv [ 'T_agc' ], sv [ 'T_ampl' ], sv [ 'T_acl' ], sv [ 'T_mem' ] T_ccl , T_cmpl , T_cgc = sv [ 'T_ccl' ], sv [ 'T_cmpl' ], sv [ 'T_cgc' ] Pasm , Paem , Pcsm , Pcem = sv [ 'Pasm' ], sv [ 'Paem' ], sv [ 'Pcsm' ], sv [ 'Pcem' ] # Extraction of the operating inputs and the parameters T_des , Phi_c_des = operating_inputs [ 'T_des' ], control_variables [ 'Phi_c_des' ] Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_gdl , epsilon_cl , epsilon_mpl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ], parameters [ 'epsilon_mpl' ] kappa_co , epsilon_mc = parameters [ 'kappa_co' ], parameters [ 'epsilon_mc' ] n_gdl = parameters [ 'n_gdl' ] # Physical quantities outside the stack # Molar masses Mext = Phi_ext * Psat ( Text ) / Pext * M_H2O + \\ yO2_ext * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_O2 + \\ ( 1 - yO2_ext ) * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_N2 # Physical quantities inside the stack # Pressures Pagc = ( C_v_agc + C_H2_agc ) * R * T_agc Pcgc = ( C_v_cgc + C_O2_cgc + C_N2 ) * R * T_cgc # Humidities Phi_agc = C_v_agc / C_v_sat ( T_agc ) Phi_cgc = C_v_cgc / C_v_sat ( T_cgc ) # Oxygen ratio in dry air y_c = C_O2_cgc / ( C_O2_cgc + C_N2 ) # Internal current density T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # Volumetric heat capacity (J.m-3.K-1) rho_Cp0 = { ** { f 'agdl_ { i } ' : calculate_rho_Cp0 ( 'agdl' , sv [ f 'T_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], s = sv [ f 's_agdl_ { i } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i } ' ], epsilon = epsilon_gdl ) for i in range ( 1 , n_gdl + 1 )}, 'ampl' : calculate_rho_Cp0 ( 'ampl' , T_ampl , C_v = C_v_ampl , s = s_ampl , C_H2 = C_H2_ampl , epsilon = epsilon_mpl ), 'acl' : calculate_rho_Cp0 ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), 'mem' : calculate_rho_Cp0 ( 'mem' , T_mem , lambdaa = lambda_mem ), 'ccl' : calculate_rho_Cp0 ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2 , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), 'cmpl' : calculate_rho_Cp0 ( 'cmpl' , T_cmpl , C_v = C_v_cmpl , s = s_cmpl , C_O2 = C_O2_cmpl , C_N2 = C_N2 , epsilon = epsilon_mpl ), ** { f 'cgdl_ { i } ' : calculate_rho_Cp0 ( 'cgdl' , sv [ f 'T_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], s = sv [ f 's_cgdl_ { i } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i } ' ], C_N2 = C_N2 , epsilon = epsilon_gdl ) for i in range ( 1 , n_gdl + 1 )} } # Physical quantities inside the auxiliary system if parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_anodic_recirculation\" or \\ parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_flow-through_anode\" : # Pressure Pp = Pasm # Humidities Phi_aem = Phi_agc * Paem / Pagc Phi_asm = Phi_aem * Pp / Paem Phi_cem = Phi_cgc * Pcem / Pcgc # Molar masses Masm = Phi_asm * Psat ( T_des ) / Pasm * M_H2O + \\ ( 1 - Phi_asm * Psat ( T_des ) / Pasm ) * M_H2 Maem = Phi_aem * Psat ( T_des ) / Paem * M_H2O + \\ ( 1 - Phi_aem * Psat ( T_des ) / Paem ) * M_H2 Mcsm = Phi_c_des * Psat ( T_des ) / Pcsm * M_H2O + \\ yO2_ext * ( 1 - Phi_c_des * Psat ( T_des ) / Pcsm ) * M_O2 + \\ ( 1 - yO2_ext ) * ( 1 - Phi_c_des * Psat ( T_des ) / Pcsm ) * M_N2 Mcem = Phi_cem * Psat ( T_des ) / Pcem * M_H2O + \\ y_c * ( 1 - Phi_cem * Psat ( T_des ) / Pcem ) * M_O2 + \\ ( 1 - y_c ) * ( 1 - Phi_cem * Psat ( T_des ) / Pcem ) * M_N2 else : # parameters[\"type_auxiliary\"] == \"no_auxiliary\" Masm , Maem , Mcsm , Mcem = [ 0 ] * 4 return Mext , Pagc , Pcgc , i_n , Masm , Maem , Mcsm , Mcem , rho_Cp0","title":"dif_eq_int_values"},{"location":"functions/modules/dif_eq_modules/#modules.dif_eq_modules.event_negative","text":"This function creates an event that will be checked at each step of solve_ivp integration. The integration stops if one of the crucial variables (C_v, lambda, C_O2, C_H2) becomes negative (or smaller than 1e-5). Parameters: t ( float ) \u2013 Time (s). y ( ndarray ) \u2013 Numpy list of the solver variables. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. solver_variable_names ( list ) \u2013 Names of the solver variables. control_variables ( dict ) \u2013 Variables controlled by the user. Returns: The difference between the minimum value of the crucial variables and 1e-5. \u2013 Source code in modules/dif_eq_modules.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def event_negative ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ): \"\"\"This function creates an event that will be checked at each step of solve_ivp integration. The integration stops if one of the crucial variables (C_v, lambda, C_O2, C_H2) becomes negative (or smaller than 1e-5). Parameters ---------- t : float Time (s). y : numpy.ndarray Numpy list of the solver variables. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. solver_variable_names : list Names of the solver variables. control_variables : dict Variables controlled by the user. Returns ------- The difference between the minimum value of the crucial variables and 1e-5. \"\"\" negative_solver_variables = {} # Dictionary to store the crucial variables for index , key in enumerate ( solver_variable_names ): if ( key . startswith ( \"C_v_\" )) or ( key . startswith ( \"lambda_\" )) or \\ ( key . startswith ( \"C_O2_\" )) or ( key . startswith ( \"C_H2_\" )): negative_solver_variables [ key ] = y [ index ] return min ( negative_solver_variables . values ()) - 1e-5 # 1e-5 is a control parameter to stop the program before","title":"event_negative"},{"location":"functions/modules/display_modules/","text":"Display modules This module is used to accurately plot the figures. calculate_simulation_error ( Ucell , U_exp_t ) This function calculates the simulation error between the simulated cell voltage and the experimental cell voltage. It is calculated as the maximum relative difference between the two voltages (in %). Parameters: Ucell ( ndarray ) \u2013 Simulated cell voltage. U_exp_t ( ndarray ) \u2013 Experimental cell voltage. Returns: float \u2013 Simulation error between the simulated cell voltage and the experimental cell voltage (in %). Source code in modules/display_modules.py 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 def calculate_simulation_error ( Ucell , U_exp_t ): \"\"\"This function calculates the simulation error between the simulated cell voltage and the experimental cell voltage. It is calculated as the maximum relative difference between the two voltages (in %). Parameters ---------- Ucell : numpy.ndarray Simulated cell voltage. U_exp_t : numpy.ndarray Experimental cell voltage. Returns ------- float Simulation error between the simulated cell voltage and the experimental cell voltage (in %). \"\"\" return np . round ( np . max ( np . abs ( Ucell - U_exp_t ) / U_exp_t * 100 ), 2 ) # in %. make_Fourier_transformation ( variables , operating_inputs , parameters ) This function calculates the Fourier transformation of both cell voltage and current density. It will be used to display the Nyquist and Bode diagrams. To generate it at each frequency change, the cell voltage and the current density are recorded. The time for which these points are captured is determined using the following approach: at the beginning of each frequency change, a delta_t_break_EIS time is observed to ensure the dynamic stability of the stack's variables. Subsequently, a delta_t_measurement_EIS time is needed to record the cell voltage and the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: dict \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. Source code in modules/display_modules.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def make_Fourier_transformation ( variables , operating_inputs , parameters ): \"\"\" This function calculates the Fourier transformation of both cell voltage and current density. It will be used to display the Nyquist and Bode diagrams. To generate it at each frequency change, the cell voltage and the current density are recorded. The time for which these points are captured is determined using the following approach: at the beginning of each frequency change, a delta_t_break_EIS time is observed to ensure the dynamic stability of the stack's variables. Subsequently, a delta_t_measurement_EIS time is needed to record the cell voltage and the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] t_EIS = parameters [ 't_EIS' ] # Creation of ifc ifc_t = np . zeros ( len ( t )) for i in range ( len ( t )): ifc_t [ i ] = current_density ( t [ i ], parameters ) # Identify the areas where Ucell and ifc can be measured for the EIS: after equilibrium and at each frequency change t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = t_EIS n_inf = np . where ( t_new_start_EIS <= t [ 0 ])[ 0 ][ - 1 ] # The number of frequency changes which has been mad so far. Ucell_EIS_measured = Ucell_t [ np . where (( t > ( t [ 0 ] + delta_t_break_EIS [ n_inf ])) & ( t < ( t [ 0 ] + delta_t_break_EIS [ n_inf ] + delta_t_measurement_EIS [ n_inf ])))] ifc_EIS_measured = ifc_t [ np . where (( t > ( t [ 0 ] + delta_t_break_EIS [ n_inf ])) & ( t < ( t [ 0 ] + delta_t_break_EIS [ n_inf ] + delta_t_measurement_EIS [ n_inf ])))] # Determination of the Fourier transformation N = Ucell_EIS_measured . size # Number of points used for the Fourier transformation Ucell_Fourier = fft ( Ucell_EIS_measured ) # Ucell Fourier transformation ifc_Fourier = fft ( ifc_EIS_measured ) # ifc Fourier transformation A_period_t = np . concatenate ( ([ np . abs ( Ucell_Fourier )[ 0 ] / N ], np . abs ( Ucell_Fourier [ 1 : N // 2 ]) * 2 / N )) # Recovery of # all amplitude values calculated by fft A = max ( A_period_t [ 1 :]) # Amplitude at the frequency of the perturbation freq_t = fftfreq ( N )[: N // 2 ] # Recovery of all frequency values used by fft f = freq_t [ np . argmax ( A_period_t == A )] # Recovery of the studied frequency return { 'Ucell_Fourier' : Ucell_Fourier , 'ifc_Fourier' : ifc_Fourier , 'A_period_t' : A_period_t , 'A' : A , 'freq_t' : freq_t , 'f' : f , 'N' : N } plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax ) This function adds the instructions for amplitude Bode plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 def plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax ): \"\"\"This function adds the instructions for amplitude Bode plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. ax . set_xscale ( 'log' ) # set logarithmic scale for the x-axis # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( LogLocator ( base = 10.0 , numticks = f_power_max_EIS - f_power_min_EIS + 1 )) ax . xaxis . set_minor_locator ( LogLocator ( base = 10.0 , subs = np . arange ( 2 , 10 ) * .1 , numticks = ( f_power_max_EIS - f_power_min_EIS + 1 ) * len ( np . arange ( 2 , 10 )))) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 30 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 30 / 5 )) ax . set_xlim ([ 10 ** f_power_min_EIS , 10 ** f_power_max_EIS ]) plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax ) This function adds the instructions for phase Bode plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 def plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax ): \"\"\"This function adds the instructions for phase Bode plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. ax . set_xscale ( 'log' ) # set logarithmic scale for the x-axis if not ax . yaxis_inverted (): ax . invert_yaxis () # Invert the y-axis # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( LogLocator ( base = 10.0 , numticks = f_power_max_EIS - f_power_min_EIS + 1 )) ax . xaxis . set_minor_locator ( LogLocator ( base = 10.0 , subs = np . arange ( 2 , 10 ) * .1 , numticks = ( f_power_max_EIS - f_power_min_EIS + 1 ) * len ( np . arange ( 2 , 10 )))) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 5 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 5 / 5 )) ax . set_xlim ([ 10 ** f_power_min_EIS , 10 ** f_power_max_EIS ]) plot_C_H2 ( variables , parameters , ax ) This function plots the hydrogen concentration at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. ax ( Axes ) \u2013 Axes on which the hydrogen concentration will be plotted. Source code in modules/display_modules.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 def plot_C_H2 ( variables , parameters , ax ): \"\"\"This function plots the hydrogen concentration at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl : int Number of model nodes placed inside each GDL. ax : matplotlib.axes.Axes Axes on which the hydrogen concentration will be plotted. \"\"\" # Extraction of the parameters n_gdl , type_current , type_plot = parameters [ 'n_gdl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_H2_agc_t = np . array ( variables [ 'C_H2_agc' ])[ mask ] C_H2_agdl_t = np . array ( variables [ f 'C_H2_agdl_ { n_gdl // 2 } ' ])[ mask ] C_H2_ampl_t = np . array ( variables [ 'C_H2_ampl' ])[ mask ] C_H2_acl_t = np . array ( variables [ 'C_H2_acl' ])[ mask ] # Plot the hydrogen concentration at different spatial localisations: C_H2 ax . plot ( t , C_H2_agc_t , color = colors ( 0 )) ax . plot ( t , C_H2_agdl_t , color = colors ( 1 )) ax . plot ( t , C_H2_ampl_t , color = colors ( 2 )) ax . plot ( t , C_H2_acl_t , color = colors ( 3 )) ax . legend ([ r '$\\mathregular{C_{H_ {2} ,agc}}$' , r '$\\mathregular{C_{H_ {2} ,agdl}}$' , r '$\\mathregular{C_{H_ {2} ,ampl}}$' , r '$\\mathregular{C_{H_ {2} ,acl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Hydrogen} $ $\\mathbf {concentration} $ $\\mathbf{C_{H_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_C_N2 ( variables , parameters , ax ) This function plots the nitrogen concentration as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the nitrogen concentration will be plotted. Source code in modules/display_modules.py 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 def plot_C_N2 ( variables , parameters , ax ): \"\"\"This function plots the nitrogen concentration as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the nitrogen concentration will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_N2_t = np . array ( variables [ 'C_N2' ])[ mask ] # Plot C_N2 ax . plot ( t , C_N2_t , color = colors ( 6 )) ax . legend ([ r '$\\mathregular{C_{N_ {2} }}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Nitrogen} $ $\\mathbf {concentration} $ $\\mathbf{C_{N_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_C_O2 ( variables , parameters , ax ) This function plots the oxygen concentration at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. ax ( Axes ) \u2013 Axes on which the oxygen concentration will be plotted. Source code in modules/display_modules.py 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 def plot_C_O2 ( variables , parameters , ax ): \"\"\"This function plots the oxygen concentration at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl : int Number of model nodes placed inside each GDL. ax : matplotlib.axes.Axes Axes on which the oxygen concentration will be plotted. \"\"\" # Extraction of the parameters n_gdl , type_current , type_plot = parameters [ 'n_gdl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_O2_ccl_t = np . array ( variables [ 'C_O2_ccl' ])[ mask ] C_O2_cmpl_t = np . array ( variables [ 'C_O2_cmpl' ])[ mask ] C_O2_cgdl_t = np . array ( variables [ f 'C_O2_cgdl_ { n_gdl // 2 } ' ])[ mask ] C_O2_cgc_t = np . array ( variables [ 'C_O2_cgc' ])[ mask ] # Plot the oxygen concentration at different spatial localisations: C_O2 ax . plot ( t , C_O2_ccl_t , color = colors ( 5 )) ax . plot ( t , C_O2_cmpl_t , color = colors ( 6 )) ax . plot ( t , C_O2_cgdl_t , color = colors ( 7 )) ax . plot ( t , C_O2_cgc_t , color = colors ( 8 )) ax . legend ([ r '$\\mathregular{C_{O_ {2} ,ccl}}$' , r '$\\mathregular{C_{O_ {2} ,cmpl}}$' , r '$\\mathregular{C_{O_ {2} ,cgdl}}$' , r '$\\mathregular{C_{O_ {2} ,cgc}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Oxygen} $ $\\mathbf {concentration} $ $\\mathbf{C_{O_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_C_v ( variables , parameters , ax ) This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. ax ( Axes ) \u2013 Axes on which the vapor concentration will be plotted. Source code in modules/display_modules.py 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 def plot_C_v ( variables , parameters , ax ): \"\"\"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl : int Number of model nodes placed inside each GDL. ax : matplotlib.axes.Axes Axes on which the vapor concentration will be plotted. \"\"\" # Extraction of the parameter n_gdl , type_current , type_plot = parameters [ 'n_gdl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_agc_t = np . array ( variables [ 'C_v_agc' ])[ mask ] C_v_agdl_t = np . array ( variables [ f 'C_v_agdl_ { n_gdl // 2 } ' ])[ mask ] C_v_ampl_t = np . array ( variables [ 'C_v_ampl' ])[ mask ] C_v_acl_t = np . array ( variables [ 'C_v_acl' ])[ mask ] C_v_ccl_t = np . array ( variables [ 'C_v_ccl' ])[ mask ] C_v_cmpl_t = np . array ( variables [ 'C_v_cmpl' ])[ mask ] C_v_cgdl_t = np . array ( variables [ f 'C_v_cgdl_ { n_gdl // 2 } ' ])[ mask ] C_v_cgc_t = np . array ( variables [ 'C_v_cgc' ])[ mask ] T_ccl = np . array ( variables [ 'T_ccl' ])[ mask ] # Plot the vapor concentrations at different spatial localisations Cv C_v_sat_ccl_t = np . array ([ C_v_sat ( T ) for T in T_ccl ]) ax . plot ( t , C_v_agc_t , color = colors ( 0 )) ax . plot ( t , C_v_agdl_t , color = colors ( 1 )) ax . plot ( t , C_v_ampl_t , color = colors ( 2 )) ax . plot ( t , C_v_acl_t , color = colors ( 3 )) ax . plot ( t , C_v_ccl_t , color = colors ( 5 )) ax . plot ( t , C_v_cmpl_t , color = colors ( 6 )) ax . plot ( t , C_v_cgdl_t , color = colors ( 7 )) ax . plot ( t , C_v_cgc_t , color = colors ( 8 )) ax . plot ( t , C_v_sat_ccl_t , color = 'k' ) ax . legend ([ r '$\\mathregular{C_{v,agc}}$' , r '$\\mathregular{C_{v,agdl}}$' , r '$\\mathregular{C_{v,ampl}}$' , r '$\\mathregular{C_{v,acl}}$' , r '$\\mathregular{C_{v,ccl}}$' , r '$\\mathregular{C_{v,cmpl}}$' , r '$\\mathregular{C_{v,cgdl}}$' , r '$\\mathregular{C_{v,cgc}}$' , r '$\\mathregular{C_{v,sat,ccl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r \"$\\mathbf {Vapor} $ $\\mathbf {concentration} $ $\\mathbf{C_ {v} }$ $\\mathbf{\\left( mol.m^{-3} \\right)}$\" , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , x , y , ax ) This function adds the instructions for EIS plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. f_Fourier ( ndarray ) \u2013 Frequency at which the EIS is simulated. x ( ndarray ) \u2013 x-axis values for plotting the annotation. y ( ndarray ) \u2013 y-axis values for plotting the annotation. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 def plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , x , y , ax ): \"\"\"This function adds the instructions for EIS plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. f_Fourier : numpy.ndarray Frequency at which the EIS is simulated. x : numpy.ndarray x-axis values for plotting the annotation. y : numpy.ndarray y-axis values for plotting the annotation. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions ax . set_aspect ( 'equal' , adjustable = 'box' ) # Set orthonormal axis. # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : # Double charge transfer if ( f_Fourier >= 70 and f_Fourier <= 80 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , - 40 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) # Auxiliary system if ( f_Fourier >= 0.14 and f_Fourier <= 0.16 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 7 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 1.2 and f_Fourier <= 1.4 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 10 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) # Diffusion if ( f_Fourier >= 0.015 and f_Fourier <= 0.020 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 30 , 0 ), ha = 'center' , fontsize = 14 , rotation = 0 , weight = 'bold' ) if ( f_Fourier >= 0.9 and f_Fourier <= 1.1 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 10 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 70 and f_Fourier <= 90 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , - 40 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 10000 and f_Fourier <= 12000 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 35 , 0 ), ha = 'center' , fontsize = 14 , rotation = 0 , weight = 'bold' ) ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 20 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 20 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 10 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 10 / 5 )) ax . set_xlim ( 30 , 200 ) ax . set_ylim ( - 25 , 55 ) plot_EIS_curve_Bode_amplitude ( parameters , Fourier_results , ax ) This function is used to plot the amplitude Bode diagram of the EIS curves. Parameters: parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the amplitude Bode diagram will be plotted. Source code in modules/display_modules.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def plot_EIS_curve_Bode_amplitude ( parameters , Fourier_results , ax ): \"\"\"This function is used to plot the amplitude Bode diagram of the EIS curves. Parameters ---------- parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the amplitude Bode diagram will be plotted. \"\"\" # Extraction of the parameters i_EIS , ratio_EIS , f_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ], parameters [ 'f_EIS' ] type_fuel_cell = parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results A , f = Fourier_results [ 'A' ], Fourier_results [ 'f' ] # Calculation of the impedance of the perturbation Z0 = A / ( ratio_EIS * ( - i_EIS )) * 1e7 # in m\u03a9.cm\u00b2. The sign of i is inverted to comply with the standards of EIS, # which measure a device under load rather than a current source. # Plot the amplitude Bode diagram ax . plot ( f , np . abs ( Z0 ), 'o' , color = colors ( 1 ), label = 'Amplitude Bode diagram' ) ax . set_xlabel ( r '$\\mathbf {Frequency} $ $\\mathbf{(Hz,}$ $\\mathbf {logarithmic} $ $\\mathbf{scale)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Impedance} $ $\\mathbf {amplitude} $ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) # Plot instructions plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax ) plot_EIS_curve_Bode_angle ( parameters , Fourier_results , ax ) This function is used to plot the angle Bode diagram. It only works with an entry signal made with a cosinus (not a sinus). Parameters: Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the angle Bode diagram will be plotted. Source code in modules/display_modules.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def plot_EIS_curve_Bode_angle ( parameters , Fourier_results , ax ): \"\"\"This function is used to plot the angle Bode diagram. It only works with an entry signal made with a cosinus (not a sinus). Parameters ---------- Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the angle Bode diagram will be plotted. \"\"\" # Extraction of the parameters f_EIS , type_fuel_cell = parameters [ 'f_EIS' ], parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] A_period_t , A = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ] f , N = Fourier_results [ 'f' ], Fourier_results [ 'N' ] # Calculation of the dephasing values at the frequency of the perturbation theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) + np . pi # Recovery of all dephasing values calculated by fft. # An angle of pi is added to comply with the standards of EIS, # which measure a device under load rather than a current source. theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation phi_U_i = (( theta_U - theta_i ) * 180 / np . pi ) % 360 # Dephasing between Ucell and ifc with a value between 0 and 360 if phi_U_i > 180 : phi_U_i -= 360 # To have a value between -180 and 180 # Plot the angle Bode diagram ax . plot ( f , phi_U_i , 'o' , color = colors ( 2 ), label = 'Angle Bode diagram' ) ax . set_xlabel ( r '$\\mathbf {Frequency} $ $\\mathbf{(Hz,}$ $\\mathbf {logarithmic} $ $\\mathbf{scale)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Phase} $ $\\mathbf{(^\\circ)}$' , labelpad = 3 ) # Plot instructions plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax ) plot_EIS_curve_Nyquist ( parameters , Fourier_results , ax ) This function is used to plot the Nyquist diagram of the EIS curves. Parameters: parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the Nyquist diagram will be plotted. Source code in modules/display_modules.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def plot_EIS_curve_Nyquist ( parameters , Fourier_results , ax ): \"\"\" This function is used to plot the Nyquist diagram of the EIS curves. Parameters ---------- parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the Nyquist diagram will be plotted. \"\"\" # Extraction of the parameters i_EIS , ratio_EIS , type_fuel_cell = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ], parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] f_Fourier = Fourier_results [ 'f' ] A_period_t , A , N = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ], Fourier_results [ 'N' ] # Calculation of the real and imaginary component of the impedance for each period Z0 = A / ( ratio_EIS * ( - i_EIS )) * 1e7 # Impedance of the perturbation in m\u03a9.cm\u00b2. The sign of i is inverted to # comply with the standards of EIS, which measure a device under load rather than a current source. theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation Z_real = Z0 * np . cos ( theta_U - theta_i ) # Real component of the impedance for each period Z_imag = Z0 * np . sin ( theta_U - theta_i ) # Imaginary component of the impedance for each period # Plot the Nyquist diagram ax . plot ( Z_real , - Z_imag , 'o' , color = colors ( 0 ), label = 'Nyquist diagram' ) ax . set_xlabel ( r '$\\mathbf{Z_ {real} }$ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf{-Z_ {imag} }$ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) # Plot instructions plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , Z_real , - Z_imag , ax ) plot_EIS_curve_tests ( variables , operating_inputs , parameters , Fourier_results ) This function is used to test the accuracy of the EIS results. It compares the reconstructed Ucell_Fourier(t) from the Fourier transformation with the current density ifc(t), and displays Ucell(t) given by the model with the reconstructed Ucell_Fourier(t). Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. Source code in modules/display_modules.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def plot_EIS_curve_tests ( variables , operating_inputs , parameters , Fourier_results ): \"\"\"This function is used to test the accuracy of the EIS results. It compares the reconstructed Ucell_Fourier(t) from the Fourier transformation with the current density ifc(t), and displays Ucell(t) given by the model with the reconstructed Ucell_Fourier(t). Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), variables [ 'Ucell' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] i_EIS , ratio_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ] t_EIS , f_EIS = parameters [ 't_EIS' ], parameters [ 'f_EIS' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] A_period_t , A = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ] f , N = Fourier_results [ 'f' ], Fourier_results [ 'N' ] # Reconstructed Ucell with a cosinus form, and comparison of its form with the current density one. t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = t_EIS f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS n_inf = np . where ( t_new_start_EIS <= t [ 0 ])[ 0 ][ - 1 ] # The number of frequency changes which has been made. f_current = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation print ( \"Ucell:\" , round ( A_period_t [ 0 ], 4 ), ' + ' , round ( A , 6 ), \" * np.cos(2*np.pi*\" , round ( f , 4 ), \"*t + \" , round ( theta_U , 4 ), \"). \" ) print ( \"Current:\" , i_EIS , ' + ' , ratio_EIS * i_EIS , \" * np.cos(2*np.pi*\" , round ( f_current [ n_inf ], 4 ), \"*t + \" , round ( theta_i , 4 ), \"). \\n \" ) # Display ifc(t) plt . figure ( 3 ) plt . subplot ( 2 , 1 , 1 ) # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Conversion in A/cm\u00b2 ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Plot of ifc_t plt . plot ( t , ifc_t , color = 'blue' , label = 'ifc' ) plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Current density (A/cm\u00b2)' ) plt . title ( 'The current density \\n behaviour over time' ) # Display Ucell(t) and compare it with the reconstructed Ucell_Fourier(t) from the Fourier transformation plt . subplot ( 2 , 1 , 2 ) Ucell_Fourier = A_period_t [ 0 ] + A * np . cos ( 2 * np . pi * f * t + theta_U ) plt . plot ( t , Ucell_t , color = 'blue' , label = 'Ucell' ) plt . plot ( t , Ucell_Fourier , color = 'black' , label = 'Ucell_Fourier' ) plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Cell voltage (V)' ) plt . title ( 'The cell voltage \\n behaviour over time' ) plot_J ( variables , parameters , ax ) This function plots the sorption and dissolved water flows as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the flows will be plotted. Source code in modules/display_modules.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def plot_J ( variables , parameters , ax ): \"\"\"This function plots the sorption and dissolved water flows as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the flows will be plotted. \"\"\" # Extraction of the operating inputs and the parameters Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] S_abs_acl_t = np . array ( variables [ 'S_abs_acl' ])[ mask ] S_abs_ccl_t = np . array ( variables [ 'S_abs_ccl' ])[ mask ] J_lambda_acl_mem_t = np . array ( variables [ 'J_lambda_acl_mem' ])[ mask ] J_lambda_mem_ccl_t = np . array ( variables [ 'J_lambda_mem_ccl' ])[ mask ] # Plot the sorption and dissolved water flows: J J_abs_acl , J_abs_ccl = S_abs_acl_t * Hacl , S_abs_ccl_t * Hccl # Conversion in mol.m\u207b\u00b2.s\u207b\u00b9 for comparison ax . plot ( t , J_abs_acl , color = colors ( 2 )) ax . plot ( t , J_lambda_acl_mem_t , color = colors ( 3 )) ax . plot ( t , J_abs_ccl , color = colors ( 4 )) ax . plot ( t , J_lambda_mem_ccl_t , color = colors ( 7 )) ax . legend ([ r '$\\mathregular{J_{abs,acl}}$' , r '$\\mathregular{J_{\\lambda,mem,acl}}$' , r '$\\mathregular{J_{abs,ccl}}$' , r '$\\mathregular{J_{\\lambda,mem,ccl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Flows} $ $\\mathbf {J} $ $\\mathbf{\\left( mol.m^{-2}.s^{-1} \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax ) plot_P ( variables , parameters , ax ) This function plots the pressure at different spatial localisations as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the pressure will be plotted. Source code in modules/display_modules.py 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 def plot_P ( variables , parameters , ax ): \"\"\"This function plots the pressure at different spatial localisations as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the pressure will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] Pagc_t = np . array ( variables [ 'Pagc' ])[ mask ] / 1e5 # Conversion in atm Pcgc_t = np . array ( variables [ 'Pcgc' ])[ mask ] / 1e5 # Conversion in atm Pasm_t = np . array ( variables [ 'Pasm' ])[ mask ] / 1e5 # Conversion in atm Paem_t = np . array ( variables [ 'Paem' ])[ mask ] / 1e5 # Conversion in atm Pcsm_t = np . array ( variables [ 'Pcsm' ])[ mask ] / 1e5 # Conversion in atm Pcem_t = np . array ( variables [ 'Pcem' ])[ mask ] / 1e5 # Conversion in atm # Plot the pressure at different spatial localisations: P ax . plot ( t , Pagc_t , color = colors ( 0 )) ax . plot ( t , Pcgc_t , color = colors ( 6 )) ax . plot ( t , Pasm_t , color = colors ( 7 )) ax . plot ( t , Paem_t , color = colors ( 8 )) ax . plot ( t , Pcsm_t , color = colors ( 9 )) ax . plot ( t , Pcem_t , color = colors ( 3 )) ax . legend ([ r '$\\mathregular{P_ {agc} }$' , r '$\\mathregular{P_ {cgc} }$' , r '$\\mathregular{P_ {asm} }$' , r '$\\mathregular{P_ {aem} }$' , r '$\\mathregular{P_ {csm} }$' , r '$\\mathregular{P_ {cem} }$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Pressure} $ $\\mathbf {P} $ $\\mathbf{\\left( bar \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax ) plot_Phi_a ( variables , operating_inputs , parameters , ax ) This function plots the humidity at the anode side, at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. ax ( Axes ) \u2013 Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 def plot_Phi_a ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the humidity at the anode side, at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and parameters Phi_a_des = operating_inputs [ 'Phi_a_des' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_agc_t = np . array ( variables [ 'C_v_agc' ])[ mask ] T_agc_t = np . array ( variables [ 'T_agc' ])[ mask ] Phi_asm_t = np . array ( variables [ 'Phi_asm' ])[ mask ] Phi_aem_t = np . array ( variables [ 'Phi_aem' ])[ mask ] # Calculate the humidity Phi Phi_agc_t = C_v_agc_t * R * T_agc_t / Psat ( T_agc_t ) # Plot the humidity at different spatial localisations: Phi ax . plot ( t , Phi_agc_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_ {agc} }$' ) ax . plot ( t , Phi_asm_t , color = colors ( 1 ), label = r '$\\mathregular{\\Phi_ {asm} }$' ) ax . plot ( t , Phi_aem_t , color = colors ( 2 ), label = r '$\\mathregular{\\Phi_ {aem} }$' ) ax . plot ( t , np . array ([ Phi_a_des ] * len ( t )), color = 'black' , label = r '$\\mathregular{\\Phi_{a,des}}$' ) ax . legend ( loc = 'center right' , bbox_to_anchor = ( 1 , 0.67 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Humidity} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf {anode} $ $\\mathbf {side} $ $\\mathbf{\\Phi}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_Phi_c ( variables , operating_inputs , parameters , ax ) This function plots the humidity, at the cathode side, at different spatial localisations as a function of time. Parameters: ax \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. ax ( Axes ) \u2013 Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 def plot_Phi_c ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the humidity, at the cathode side, at different spatial localisations as a function of time. Parameters ---------- ax.plot(t, np.array([Phi_a_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{a,des}}$') Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and parameters Phi_c_des = operating_inputs [ 'Phi_c_des' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_cgc_t = np . array ( variables [ 'C_v_cgc' ])[ mask ] T_cgc_t = np . array ( variables [ 'T_cgc' ])[ mask ] Phi_csm_t = np . array ( variables [ 'Phi_csm' ])[ mask ] Phi_cem_t = np . array ( variables [ 'Phi_cem' ])[ mask ] # Calculate the humidity Phi Phi_cgc_t = C_v_cgc_t * R * T_cgc_t / Psat ( T_cgc_t ) # Plot the humidity at different spatial localisations: Phi ax . plot ( t , Phi_cgc_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_ {cgc} }$' ) ax . plot ( t , Phi_csm_t , color = colors ( 1 ), label = r '$\\mathregular{\\Phi_ {csm} }$' ) ax . plot ( t , Phi_cem_t , color = colors ( 2 ), label = r '$\\mathregular{\\Phi_ {cem} }$' ) ax . plot ( t , np . array ([ Phi_c_des ] * len ( t )), color = 'black' , label = r '$\\mathregular{\\Phi_{c,des}}$' ) ax . legend ( loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Humidity} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf {cathode} $ $\\mathbf {side} $ $\\mathbf{\\Phi}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_Phi_des ( variables , operating_inputs , parameters , ax ) This function plots the controlled or uncontrolled desired humidity at the anode and cathode as a function of the current density. Parameters ax.plot(t, np.array([Phi_c_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{c,des}}$') variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 def plot_Phi_des ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the controlled or uncontrolled desired humidity at the anode and cathode as a function of the current density. Parameters ax.plot(t, np.array([Phi_c_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{c,des}}$') variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] if parameters [ 'type_control' ] == \"Phi_des\" : Phi_a_des_t = variables [ 'Phi_a_des' ][ mask ] Phi_c_des_t = variables [ 'Phi_c_des' ][ mask ] ax . set_ylabel ( r '$\\mathbf {Controlled} $ $\\mathbf {inlet} $ $\\mathbf {humidity} $ $\\mathbf{\\Phi_ {des} }$' , labelpad = 3 ) else : Phi_a_des_t = np . array ([ operating_inputs [ 'Phi_a_des' ]] * len ( t )) Phi_c_des_t = np . array ([ operating_inputs [ 'Phi_c_des' ]] * len ( t )) ax . set_ylabel ( r '$\\mathbf {Uncontrolled} $ $\\mathbf {inlet} $ $\\mathbf {humidity} $ $\\mathbf{\\Phi_ {des} }$' , labelpad = 3 ) # Plot Phi_des n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of ifc_t ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) Phi_a_des_discretized_t , Phi_c_des_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load Phi_a_des_discretized_t [ i ] = Phi_a_des_t [ idx ] # the last value at the end of each load Phi_c_des_discretized_t [ i ] = Phi_c_des_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , Phi_c_des_discretized_t , color = colors ( 6 ), label = r '$\\mathregular{\\Phi_{c,des}}$' ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) if parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" or \\ parameters [ 'type_auxiliary' ] == \"no_auxiliary\" : ax . scatter ( ifc_discretized_t , Phi_a_des_discretized_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_{a,des}}$' ) ax . legend ([ r '$\\mathregular{\\Phi_{a,des}}$' , r '$\\mathregular{\\Phi_{c,des}}$' ], loc = 'best' ) else : ax . legend ([ r '$\\mathregular{\\Phi_{c,des}}$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_T ( variables , operating_inputs , parameters , ax ) This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. ax ( Axes ) \u2013 Axes on which the vapor concentration will be plotted. Source code in modules/display_modules.py 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 def plot_T ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. n_gdl : int Number of model nodes placed inside each GDL. ax : matplotlib.axes.Axes Axes on which the vapor concentration will be plotted. \"\"\" # Extraction of the operating inputs and parameters T_des = operating_inputs [ 'T_des' ] n_gdl , type_current , type_plot = parameters [ 'n_gdl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables and the operating inputs if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] T_agc_t = np . array ( variables [ 'T_agc' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_agdl_t = np . array ( variables [ f 'T_agdl_ { n_gdl // 2 } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_ampl_t = np . array ( variables [ 'T_ampl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_acl_t = np . array ( variables [ 'T_acl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_mem_t = np . array ( variables [ 'T_mem' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_ccl_t = np . array ( variables [ 'T_ccl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cmpl_t = np . array ( variables [ 'T_cmpl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cgdl_t = np . array ( variables [ f 'T_cgdl_ { n_gdl // 2 } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cgc_t = np . array ( variables [ 'T_cgc' ])[ mask ] - 273.15 # Conversion in \u00b0C. # Plot the temperature at different spatial localisations T_des_t = np . array ([ T_des - 273.15 ] * len ( t )) ax . plot ( t , T_agc_t , color = colors ( 0 )) ax . plot ( t , T_agdl_t , color = colors ( 1 )) ax . plot ( t , T_ampl_t , color = colors ( 2 )) ax . plot ( t , T_acl_t , color = colors ( 3 )) ax . plot ( t , T_mem_t , color = colors ( 4 )) ax . plot ( t , T_ccl_t , color = colors ( 5 )) ax . plot ( t , T_cmpl_t , color = colors ( 6 )) ax . plot ( t , T_cgdl_t , color = colors ( 7 )) ax . plot ( t , T_cgc_t , color = colors ( 8 )) ax . plot ( t , T_des_t , color = 'k' ) ax . legend ([ r '$\\mathregular{T_ {agc} }$' , r '$\\mathregular{T_ {agdl} }$' , r '$\\mathregular{T_ {ampl} }$' , r '$\\mathregular{T_ {acl} }$' , r '$\\mathregular{T_ {mem} }$' , r '$\\mathregular{T_ {ccl} }$' , r '$\\mathregular{T_ {cmpl} }$' , r '$\\mathregular{T_ {cgdl} }$' , r '$\\mathregular{T_ {cgc} }$' , r '$\\mathregular{T_ {des} }$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r \"$\\mathbf {Temperature} $ $\\mathbf {T} $ $\\mathbf{\\left( \u00b0C \\right)}$\" , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_Ucell ( variables , parameters , ax ) This function plots the cell voltage as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the cell voltage will be plotted. Source code in modules/display_modules.py 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 def plot_Ucell ( variables , parameters , ax ): \"\"\"This function plots the cell voltage as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the cell voltage will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] Ucell_t = np . array ( variables [ 'Ucell' ])[ mask ] # Plot the cell voltage: Ucell ax . plot ( t , Ucell_t , color = colors ( 0 ), label = r '$\\mathregular{U_ {cell} }$' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{U_ {cell} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_cell_efficiency ( variables , operating_inputs , parameters , n , ax ) This function plots the fuel cell efficiency eta_fc as a function of the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the fuel cell efficiency. ax ( Axes ) \u2013 Axes on which the fuel cell efficiency will be plotted. Source code in modules/display_modules.py 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 def plot_cell_efficiency ( variables , operating_inputs , parameters , n , ax ): \"\"\"This function plots the fuel cell efficiency eta_fc as a function of the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the fuel cell efficiency. ax : matplotlib.axes.Axes Axes on which the fuel cell efficiency will be plotted. \"\"\" # Extraction of the variables t , Ucell_t , lambda_mem_t = variables [ 't' ], variables [ 'Ucell' ], variables [ 'lambda_mem' ] C_H2_acl_t , C_O2_ccl_t = variables [ 'C_H2_acl' ], variables [ 'C_O2_ccl' ] T_acl_t , T_mem_t , T_ccl_t = variables [ 'T_acl' ], variables [ 'T_mem' ], variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] Hmem , Hacl , Hccl , kappa_co = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'kappa_co' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] # Creation of the fuel cell efficiency: eta_fc ifc_t , Pfc_t , eta_fc_t = np . zeros ( n ), np . zeros ( n ), np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 Pfc_t [ i ] = Ucell_t [ i ] * ifc_t [ i ] Ueq = E0 - 8.5e-4 * ( T_ccl_t [ i ] - 298.15 ) + \\ R * T_ccl_t [ i ] / ( 2 * F ) * ( np . log ( R * T_acl_t [ i ] * C_H2_acl_t [ i ] / Pref ) + 0.5 * np . log ( R * T_ccl_t [ i ] * C_O2_ccl_t [ i ] / Pref )) T_acl_mem_ccl = average ([ T_acl_t [ i ], T_mem_t [ i ], T_ccl_t [ i ]], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl_t [ i ] * k_H2 ( lambda_mem_t [ i ], T_mem_t [ i ], kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl_t [ i ] * k_O2 ( lambda_mem_t [ i ], T_mem_t [ i ], kappa_co ) i_n = ( i_H2 + i_O2 ) / 1e4 # Conversion in A/cm\u00b2 eta_fc_t [ i ] = Pfc_t [ i ] / ( Ueq * ( ifc_t [ i ] + i_n )) # Plot of the fuel cell efficiency: eta_fc plot_specific_line ( ifc_t , eta_fc_t , type_fuel_cell , type_current , type_auxiliary , type_control , None , ax ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 0 ) ax . set_ylabel ( r '$\\mathbf {Fuel} $ $\\mathbf {cell} $ $\\mathbf {efficiency} $ $\\mathbf{\\eta_ {fc} }$' , labelpad = 0 ) ax . legend ( loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_general_instructions ( ax , set_y = True ) This function adds the common instructions for all the plots displayed by AlphaPEM to the ax object. Parameters: ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 def plot_general_instructions ( ax , set_y = True ): \"\"\"This function adds the common instructions for all the plots displayed by AlphaPEM to the ax object. Parameters ---------- ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Get the current x-axis and y-axis limits x_min , x_max = ax . get_xlim () y_min , y_max = ax . get_ylim () # Calculate the major step for the x-axis and y-axis ticks major_step_x = ( x_max - x_min ) / 5 major_step_y = ( y_max - y_min ) / 5 major_step_x_rounded = round_nice ( major_step_x ) major_step_y_rounded = round_nice ( major_step_y ) # Set the major and minor locators for the x-axis and y-axis ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( major_step_x_rounded )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( major_step_x_rounded / 5 )) if set_y : ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( major_step_y_rounded )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( major_step_y_rounded / 5 )) # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure plot_ifc ( variables , operating_inputs , parameters , ax ) This function plots the current density as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the current density. ax ( Axes ) \u2013 Axes on which the current density will be plotted. Source code in modules/display_modules.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def plot_ifc ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the current density as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the current density. ax : matplotlib.axes.Axes Axes on which the current density will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] # Plot the current density: ifc n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of ifc_t ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 ax . plot ( t , ifc_t , color = colors ( 0 ), label = r '$\\mathregular{i_ {fc} }$' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{i_ {fc} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_lambda ( variables , operating_inputs , parameters , ax ) This function plots the water content at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the water content will be plotted. Source code in modules/display_modules.py 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 def plot_lambda ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the water content at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the water content will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters , type_current = parameters [ 'pola_current_parameters' ], parameters [ 'type_current' ] type_plot = parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] lambda_acl_t = np . array ( variables [ 'lambda_acl' ])[ mask ] lambda_mem_t = np . array ( variables [ 'lambda_mem' ])[ mask ] lambda_ccl_t = np . array ( variables [ 'lambda_ccl' ])[ mask ] # Plot the water content at different spatial localisations: lambda if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads which are made ifc_discretized_t , lambda_acl_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) lambda_mem_discretized_t , lambda_ccl_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load lambda_acl_discretized_t [ i ] = lambda_acl_t [ idx ] # the last value at the end of each load lambda_mem_discretized_t [ i ] = lambda_mem_t [ idx ] # the last value at the end of each load lambda_ccl_discretized_t [ i ] = lambda_ccl_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , lambda_acl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , lambda_mem_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , lambda_ccl_discretized_t , marker = 'o' , color = colors ( 4 )) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : ax . plot ( t , lambda_acl_t , color = colors ( 3 )) ax . plot ( t , lambda_mem_t , color = colors ( 4 )) ax . plot ( t , lambda_ccl_t , color = colors ( 5 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Water} $ $\\mathbf {content} $ $\\mathbf{\\lambda}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{\\lambda_ {acl} }$' , r '$\\mathregular{\\lambda_ {mem} }$' , r '$\\mathregular{\\lambda_ {ccl} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_pola_instructions ( type_fuel_cell , ax , show = True ) This function adds the specific instructions for polarisation plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. show ( bool , default: True ) \u2013 If True, the figure will be displayed. Default is True. Source code in modules/display_modules.py 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 def plot_pola_instructions ( type_fuel_cell , ax , show = True ): \"\"\"This function adds the specific instructions for polarisation plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. show : bool, optional If True, the figure will be displayed. Default is True. \"\"\" # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.5 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.5 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.1 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.1 / 5 )) ax . set_xlim ( 0 , 3.0 ) ax . set_ylim ( 0.4 , 1.04 ) # For LF fuel cell elif type_fuel_cell == \"LF\" : ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.4 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.4 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.2 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.2 / 5 )) ax . set_xlim ( - 0.05 , 1.6 ) ax . set_ylim ( 0 , 1.0 ) # For other fuel cell else : pass # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure if show : plt . show () # Show the figure plot_polarisation_curve ( variables , operating_inputs , parameters , ax , show = True ) This function plots the model polarisation curve, and compare it to the experimental one (if it exists). The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the polarisation curve will be plotted. show ( bool , default: True ) \u2013 If True, the polarisation curve will be displayed. If False, it will not be displayed. Source code in modules/display_modules.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def plot_polarisation_curve ( variables , operating_inputs , parameters , ax , show = True ): \"\"\" This function plots the model polarisation curve, and compare it to the experimental one (if it exists). The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the polarisation curve will be plotted. show : bool, optional If True, the polarisation curve will be displayed. If False, it will not be displayed. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] delta_i_pola , i_max_pola = pola_current_parameters [ 'delta_i_pola' ], pola_current_parameters [ 'i_max_pola' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] type_plot = parameters [ 'type_plot' ] # Extraction of the experimental current density and voltage values. i_exp_t , U_exp_t = pola_exp_values ( type_fuel_cell ) # (A.m-2, V). if type_plot == \"fixed\" : # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of ifc and Ucell from the model after each stack stabilisation nb_loads = int ( i_max_pola / delta_i_pola ) # Number of loads which are made ifc_discretized = np . zeros ( nb_loads + 1 ) # One point is taken at ifc = 0, before the first load. Ucell_discretized = np . zeros ( nb_loads + 1 ) # One point is taken at ifc = 0, before the first load. for i in range ( nb_loads + 1 ): t_load = delta_t_ini_pola + i * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized [ i ] = ifc_t [ idx ] # the last value at the end of each load Ucell_discretized [ i ] = Ucell_t [ idx ] # the last value at the end of each load # Plot the experimental polarization curve and calculate the simulation error compared with experimental data if type_fuel_cell != \"manual_setup\" and \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible # Plot of the experimental polarization curve i_exp_t = i_exp_t / 1e4 # Conversion in A/cm\u00b2 plot_experimental_polarisation_curve ( type_fuel_cell , i_exp_t , U_exp_t , ax ) # Calculate the simulation error compared with experimental data # Experimental points are interpolated to correspond to the model points Ucell_interpolated = interp1d ( ifc_discretized , Ucell_discretized , kind = 'linear' )( i_exp_t ) sim_error = calculate_simulation_error ( Ucell_interpolated , U_exp_t ) else : sim_error = None # Plot the model polarisation curve plot_specific_line ( ifc_discretized , Ucell_discretized , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) plot_pola_instructions ( type_fuel_cell , ax , show ) else : # type_plot == \"dynamic\" # Plot of the polarisation curve produced by the model idx = ( np . abs ( t - t [ - 1 ])) . argmin () # index for polarisation measurement ifc = np . array ( current_density ( t [ idx ], parameters ) / 1e4 ) # time for polarisation measurement Ucell = np . array ( Ucell_t [ idx ]) # voltage measurement ax . plot ( ifc , Ucell , 'og' , markersize = 2 ) # Add the common instructions for the plot ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) if type_plot == \"fixed\" : ax . legend ( loc = 'best' ) plot_polarisation_curve_for_cali ( variables , operating_inputs , parameters , ax ) This function plots the model polarisation curve, and compare it to the experimental one. The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the polarisation curve will be plotted. Source code in modules/display_modules.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def plot_polarisation_curve_for_cali ( variables , operating_inputs , parameters , ax ): \"\"\" This function plots the model polarisation curve, and compare it to the experimental one. The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the polarisation curve will be plotted. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_for_cali_parameters = parameters [ 'pola_current_for_cali_parameters' ] delta_t_ini_pola_cali = pola_current_for_cali_parameters [ 'delta_t_ini_pola_cali' ] delta_t_load_pola_cali = pola_current_for_cali_parameters [ 'delta_t_load_pola_cali' ] delta_t_break_pola_cali = pola_current_for_cali_parameters [ 'delta_t_break_pola_cali' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] type_plot = parameters [ 'type_plot' ] # Extraction of the experimental current density and voltage values for the calibration. i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( parameters [ 'type_fuel_cell' ]) # (A.m-2, V). # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of ifc and Ucell from the model after each stack stabilisation nb_loads = len ( i_exp_cali_t ) # Number of loads which are made delta_t_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. ifc_discretized = np . zeros ( nb_loads ) Ucell_discretized = np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola_cali + ( i + 1 ) * delta_t_cali # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized [ i ] = ifc_t [ idx ] # the last value at the end of each load Ucell_discretized [ i ] = Ucell_t [ idx ] # the last value at the end of each load # Plot the experimental polarization curve i_exp_cali_t = i_exp_cali_t / 1e4 # Conversion in A/cm\u00b2 plot_experimental_polarisation_curve ( type_fuel_cell , i_exp_cali_t , U_exp_cali_t , ax ) # Plot the model polarisation curve sim_error = calculate_simulation_error ( Ucell_discretized , U_exp_cali_t ) # Calculate the simulation error plot_specific_line ( ifc_discretized , Ucell_discretized , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) plot_pola_instructions ( type_fuel_cell , ax ) # Add the common instructions for the plot ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) if type_plot == \"fixed\" : ax . legend ( loc = 'best' ) plot_power_density_curve ( variables , operating_inputs , parameters , n , ax ) This function plots the power density curve Pfc, produced by a cell, as a function of the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the power density curve. ax ( Axes ) \u2013 Axes on which the power density curve will be plotted. Source code in modules/display_modules.py 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 def plot_power_density_curve ( variables , operating_inputs , parameters , n , ax ): \"\"\"This function plots the power density curve Pfc, produced by a cell, as a function of the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the power density curve. ax : matplotlib.axes.Axes Axes on which the power density curve will be plotted. \"\"\" # Extraction of the variables t , Ucell_t = variables [ 't' ], variables [ 'Ucell' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] # Creation of the power density function: Pfc ifc_t , Pfc_t = np . zeros ( n ), np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 Pfc_t [ i ] = Ucell_t [ i ] * ifc_t [ i ] # Plot of the power density function: Pfc plot_specific_line ( ifc_t , Pfc_t , type_fuel_cell , type_current , type_auxiliary , type_control , None , ax ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 0 ) ax . set_ylabel ( r '$\\mathbf {Fuel} $ $\\mathbf {cell} $ $\\mathbf {power} $ $\\mathbf {density} $ $\\mathbf{P_ {fc} }$ $\\mathbf{\\left( W.cm^{-2} \\right)}$' , labelpad = 0 ) ax . legend ( loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_s ( variables , operating_inputs , parameters , ax ) This function plots the liquid water saturation at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the liquid water saturation will be plotted. Source code in modules/display_modules.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 def plot_s ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the liquid water saturation at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the liquid water saturation will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] n_gdl , pola_current_parameters = parameters [ 'n_gdl' ], parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] s_agdl_t = np . array ( variables [ f 's_agdl_ { n_gdl // 2 } ' ])[ mask ] s_ampl_t = np . array ( variables [ 's_ampl' ])[ mask ] s_acl_t = np . array ( variables [ 's_acl' ])[ mask ] s_ccl_t = np . array ( variables [ 's_ccl' ])[ mask ] s_cmpl_t = np . array ( variables [ 's_cmpl' ])[ mask ] s_cgdl_t = np . array ( variables [ f 's_cgdl_ { n_gdl // 2 } ' ])[ mask ] # Plot the liquid water saturation at different spatial localisations: s if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) s_agdl_discretized_t , s_ampl_discretized_t , s_acl_discretized_t = [ np . zeros ( nb_loads )] * 3 s_ccl_discretized_t , s_cmpl_discretized_t , s_cgdl_discretized_t = [ np . zeros ( nb_loads )] * 3 for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load s_agdl_discretized_t [ i ] = s_agdl_t [ idx ] # the last value at the end of each load s_ampl_discretized_t [ i ] = s_ampl_t [ idx ] # the last value at the end of each load s_acl_discretized_t [ i ] = s_acl_t [ idx ] # the last value at the end of each load s_ccl_discretized_t [ i ] = s_ccl_t [ idx ] # the last value at the end of each load s_cmpl_discretized_t [ i ] = s_cmpl_t [ idx ] # the last value at the end of each load s_cgdl_discretized_t [ i ] = s_cgdl_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , s_agdl_discretized_t , marker = 'o' , color = colors ( 1 )) ax . scatter ( ifc_discretized_t , s_ampl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , s_acl_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , s_ccl_discretized_t , marker = 'o' , color = colors ( 5 )) ax . scatter ( ifc_discretized_t , s_cmpl_discretized_t , marker = 'o' , color = colors ( 6 )) ax . scatter ( ifc_discretized_t , s_cgdl_discretized_t , marker = 'o' , color = colors ( 7 )) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : ax . plot ( t , s_agdl_t , color = colors ( 1 )) ax . plot ( t , s_ampl_t , color = colors ( 2 )) ax . plot ( t , s_acl_t , color = colors ( 3 )) ax . plot ( t , s_ccl_t , color = colors ( 5 )) ax . plot ( t , s_cmpl_t , color = colors ( 6 )) ax . plot ( t , s_cgdl_t , color = colors ( 7 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Liquid} $ $\\mathbf {water} $ $\\mathbf {saturation} $ $\\mathbf {s} $' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{s_ {agdl} }$' , r '$\\mathregular{s_ {ampl} }$' , r '$\\mathregular{s_ {acl} }$' , r '$\\mathregular{s_ {ccl} }$' , r '$\\mathregular{s_ {cmpl} }$' , r '$\\mathregular{s_ {cgdl} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_specific_line ( x , y , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) This function adds the appropriate plot configuration according to the type_input to the ax object. Parameters: x ( ndarray ) \u2013 x-axis values. y ( ndarray ) \u2013 y-axis values. type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. type_current ( str ) \u2013 Type of current density. type_auxiliary ( str ) \u2013 Type of auxiliary system. type_control ( str ) \u2013 Type of control system. sim_error ( float ) \u2013 Simulation error between the simulated cell voltage and the experimental cell voltage (in %). ax ( Axes ) \u2013 Axes on which the line will be plotted. Source code in modules/display_modules.py 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 def plot_specific_line ( x , y , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ): \"\"\" This function adds the appropriate plot configuration according to the type_input to the ax object. Parameters ---------- x : numpy.ndarray x-axis values. y : numpy.ndarray y-axis values. type_fuel_cell : str Type of fuel cell configuration. type_current : str Type of current density. type_auxiliary : str Type of auxiliary system. type_control : str Type of control system. sim_error : float Simulation error between the simulated cell voltage and the experimental cell voltage (in %). ax : matplotlib.axes.Axes Axes on which the line will be plotted. \"\"\" # For EH-31 fuel cell if type_current == \"polarization\" : if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : if type_fuel_cell == \"EH-31_1.5\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_1.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , '--' , color = colors ( 1 ), label = 'Sim. - P = 2.0 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : if type_control == \"Phi_des\" : ax . plot ( x , y , color = colors ( 5 ), label = r 'Sim. - P = 2.0 bar - controlled $\\mathregular{\\Phi_ {des} }$' ) else : ax . plot ( x , y , color = colors ( 1 ), label = r 'Sim. - P = 2.0 bar - uncontrolled $\\mathregular{\\Phi_ {des} }$' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , '--' , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' ) # For LF fuel cell elif type_fuel_cell == \"LF\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Simulation' ) # For other fuel cell else : ax . plot ( x , y , color = colors ( 0 ), label = 'Simulation' ) elif type_current == \"polarization_for_cali\" : if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : if type_fuel_cell == \"EH-31_1.5\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_1.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = 'Sim. - P = 2.0 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : if type_control == \"Phi_des\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 5 ), label = r 'Sim. - P = 2.0 bar - controlled $\\mathregular{\\Phi_ {des} }$' ) else : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = r 'Sim. - P = 2.0 bar - uncontrolled $\\mathregular{\\Phi_ {des} }$' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' ) # For LF fuel cell elif type_fuel_cell == \"LF\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Simulation' ) # For other fuel cell else : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Simulation' ) else : raise ValueError ( 'Only \"polarization_current\" and \"polarization_current_for_cali\" are considered here.' ) round_nice ( x ) Round the main step to a \"nice\" number. Parameters: x ( float ) \u2013 The value to be rounded. Returns: float \u2013 The value rounded to a \"nice\" number. Source code in modules/display_modules.py 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 def round_nice ( x ): \"\"\"Round the main step to a \"nice\" number. Parameters ---------- x : float The value to be rounded. Returns ------- float The value rounded to a \"nice\" number. \"\"\" exp = np . floor ( np . log10 ( x )) f = x / 10 ** exp if f < 1.5 : nice = 1 elif f < 3 : nice = 2 elif f < 7 : nice = 5 else : nice = 10 return nice * 10 ** exp","title":"Display modules"},{"location":"functions/modules/display_modules/#display-modules","text":"This module is used to accurately plot the figures.","title":"Display modules"},{"location":"functions/modules/display_modules/#modules.display_modules.calculate_simulation_error","text":"This function calculates the simulation error between the simulated cell voltage and the experimental cell voltage. It is calculated as the maximum relative difference between the two voltages (in %). Parameters: Ucell ( ndarray ) \u2013 Simulated cell voltage. U_exp_t ( ndarray ) \u2013 Experimental cell voltage. Returns: float \u2013 Simulation error between the simulated cell voltage and the experimental cell voltage (in %). Source code in modules/display_modules.py 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 def calculate_simulation_error ( Ucell , U_exp_t ): \"\"\"This function calculates the simulation error between the simulated cell voltage and the experimental cell voltage. It is calculated as the maximum relative difference between the two voltages (in %). Parameters ---------- Ucell : numpy.ndarray Simulated cell voltage. U_exp_t : numpy.ndarray Experimental cell voltage. Returns ------- float Simulation error between the simulated cell voltage and the experimental cell voltage (in %). \"\"\" return np . round ( np . max ( np . abs ( Ucell - U_exp_t ) / U_exp_t * 100 ), 2 ) # in %.","title":"calculate_simulation_error"},{"location":"functions/modules/display_modules/#modules.display_modules.make_Fourier_transformation","text":"This function calculates the Fourier transformation of both cell voltage and current density. It will be used to display the Nyquist and Bode diagrams. To generate it at each frequency change, the cell voltage and the current density are recorded. The time for which these points are captured is determined using the following approach: at the beginning of each frequency change, a delta_t_break_EIS time is observed to ensure the dynamic stability of the stack's variables. Subsequently, a delta_t_measurement_EIS time is needed to record the cell voltage and the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: dict \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. Source code in modules/display_modules.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def make_Fourier_transformation ( variables , operating_inputs , parameters ): \"\"\" This function calculates the Fourier transformation of both cell voltage and current density. It will be used to display the Nyquist and Bode diagrams. To generate it at each frequency change, the cell voltage and the current density are recorded. The time for which these points are captured is determined using the following approach: at the beginning of each frequency change, a delta_t_break_EIS time is observed to ensure the dynamic stability of the stack's variables. Subsequently, a delta_t_measurement_EIS time is needed to record the cell voltage and the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] t_EIS = parameters [ 't_EIS' ] # Creation of ifc ifc_t = np . zeros ( len ( t )) for i in range ( len ( t )): ifc_t [ i ] = current_density ( t [ i ], parameters ) # Identify the areas where Ucell and ifc can be measured for the EIS: after equilibrium and at each frequency change t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = t_EIS n_inf = np . where ( t_new_start_EIS <= t [ 0 ])[ 0 ][ - 1 ] # The number of frequency changes which has been mad so far. Ucell_EIS_measured = Ucell_t [ np . where (( t > ( t [ 0 ] + delta_t_break_EIS [ n_inf ])) & ( t < ( t [ 0 ] + delta_t_break_EIS [ n_inf ] + delta_t_measurement_EIS [ n_inf ])))] ifc_EIS_measured = ifc_t [ np . where (( t > ( t [ 0 ] + delta_t_break_EIS [ n_inf ])) & ( t < ( t [ 0 ] + delta_t_break_EIS [ n_inf ] + delta_t_measurement_EIS [ n_inf ])))] # Determination of the Fourier transformation N = Ucell_EIS_measured . size # Number of points used for the Fourier transformation Ucell_Fourier = fft ( Ucell_EIS_measured ) # Ucell Fourier transformation ifc_Fourier = fft ( ifc_EIS_measured ) # ifc Fourier transformation A_period_t = np . concatenate ( ([ np . abs ( Ucell_Fourier )[ 0 ] / N ], np . abs ( Ucell_Fourier [ 1 : N // 2 ]) * 2 / N )) # Recovery of # all amplitude values calculated by fft A = max ( A_period_t [ 1 :]) # Amplitude at the frequency of the perturbation freq_t = fftfreq ( N )[: N // 2 ] # Recovery of all frequency values used by fft f = freq_t [ np . argmax ( A_period_t == A )] # Recovery of the studied frequency return { 'Ucell_Fourier' : Ucell_Fourier , 'ifc_Fourier' : ifc_Fourier , 'A_period_t' : A_period_t , 'A' : A , 'freq_t' : freq_t , 'f' : f , 'N' : N }","title":"make_Fourier_transformation"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Bode_amplitude_instructions","text":"This function adds the instructions for amplitude Bode plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 def plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax ): \"\"\"This function adds the instructions for amplitude Bode plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. ax . set_xscale ( 'log' ) # set logarithmic scale for the x-axis # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( LogLocator ( base = 10.0 , numticks = f_power_max_EIS - f_power_min_EIS + 1 )) ax . xaxis . set_minor_locator ( LogLocator ( base = 10.0 , subs = np . arange ( 2 , 10 ) * .1 , numticks = ( f_power_max_EIS - f_power_min_EIS + 1 ) * len ( np . arange ( 2 , 10 )))) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 30 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 30 / 5 )) ax . set_xlim ([ 10 ** f_power_min_EIS , 10 ** f_power_max_EIS ])","title":"plot_Bode_amplitude_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Bode_phase_instructions","text":"This function adds the instructions for phase Bode plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 def plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax ): \"\"\"This function adds the instructions for phase Bode plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. ax . set_xscale ( 'log' ) # set logarithmic scale for the x-axis if not ax . yaxis_inverted (): ax . invert_yaxis () # Invert the y-axis # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( LogLocator ( base = 10.0 , numticks = f_power_max_EIS - f_power_min_EIS + 1 )) ax . xaxis . set_minor_locator ( LogLocator ( base = 10.0 , subs = np . arange ( 2 , 10 ) * .1 , numticks = ( f_power_max_EIS - f_power_min_EIS + 1 ) * len ( np . arange ( 2 , 10 )))) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 5 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 5 / 5 )) ax . set_xlim ([ 10 ** f_power_min_EIS , 10 ** f_power_max_EIS ])","title":"plot_Bode_phase_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_C_H2","text":"This function plots the hydrogen concentration at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. ax ( Axes ) \u2013 Axes on which the hydrogen concentration will be plotted. Source code in modules/display_modules.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 def plot_C_H2 ( variables , parameters , ax ): \"\"\"This function plots the hydrogen concentration at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl : int Number of model nodes placed inside each GDL. ax : matplotlib.axes.Axes Axes on which the hydrogen concentration will be plotted. \"\"\" # Extraction of the parameters n_gdl , type_current , type_plot = parameters [ 'n_gdl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_H2_agc_t = np . array ( variables [ 'C_H2_agc' ])[ mask ] C_H2_agdl_t = np . array ( variables [ f 'C_H2_agdl_ { n_gdl // 2 } ' ])[ mask ] C_H2_ampl_t = np . array ( variables [ 'C_H2_ampl' ])[ mask ] C_H2_acl_t = np . array ( variables [ 'C_H2_acl' ])[ mask ] # Plot the hydrogen concentration at different spatial localisations: C_H2 ax . plot ( t , C_H2_agc_t , color = colors ( 0 )) ax . plot ( t , C_H2_agdl_t , color = colors ( 1 )) ax . plot ( t , C_H2_ampl_t , color = colors ( 2 )) ax . plot ( t , C_H2_acl_t , color = colors ( 3 )) ax . legend ([ r '$\\mathregular{C_{H_ {2} ,agc}}$' , r '$\\mathregular{C_{H_ {2} ,agdl}}$' , r '$\\mathregular{C_{H_ {2} ,ampl}}$' , r '$\\mathregular{C_{H_ {2} ,acl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Hydrogen} $ $\\mathbf {concentration} $ $\\mathbf{C_{H_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_C_H2"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_C_N2","text":"This function plots the nitrogen concentration as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the nitrogen concentration will be plotted. Source code in modules/display_modules.py 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 def plot_C_N2 ( variables , parameters , ax ): \"\"\"This function plots the nitrogen concentration as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the nitrogen concentration will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_N2_t = np . array ( variables [ 'C_N2' ])[ mask ] # Plot C_N2 ax . plot ( t , C_N2_t , color = colors ( 6 )) ax . legend ([ r '$\\mathregular{C_{N_ {2} }}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Nitrogen} $ $\\mathbf {concentration} $ $\\mathbf{C_{N_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_C_N2"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_C_O2","text":"This function plots the oxygen concentration at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. ax ( Axes ) \u2013 Axes on which the oxygen concentration will be plotted. Source code in modules/display_modules.py 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 def plot_C_O2 ( variables , parameters , ax ): \"\"\"This function plots the oxygen concentration at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl : int Number of model nodes placed inside each GDL. ax : matplotlib.axes.Axes Axes on which the oxygen concentration will be plotted. \"\"\" # Extraction of the parameters n_gdl , type_current , type_plot = parameters [ 'n_gdl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_O2_ccl_t = np . array ( variables [ 'C_O2_ccl' ])[ mask ] C_O2_cmpl_t = np . array ( variables [ 'C_O2_cmpl' ])[ mask ] C_O2_cgdl_t = np . array ( variables [ f 'C_O2_cgdl_ { n_gdl // 2 } ' ])[ mask ] C_O2_cgc_t = np . array ( variables [ 'C_O2_cgc' ])[ mask ] # Plot the oxygen concentration at different spatial localisations: C_O2 ax . plot ( t , C_O2_ccl_t , color = colors ( 5 )) ax . plot ( t , C_O2_cmpl_t , color = colors ( 6 )) ax . plot ( t , C_O2_cgdl_t , color = colors ( 7 )) ax . plot ( t , C_O2_cgc_t , color = colors ( 8 )) ax . legend ([ r '$\\mathregular{C_{O_ {2} ,ccl}}$' , r '$\\mathregular{C_{O_ {2} ,cmpl}}$' , r '$\\mathregular{C_{O_ {2} ,cgdl}}$' , r '$\\mathregular{C_{O_ {2} ,cgc}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Oxygen} $ $\\mathbf {concentration} $ $\\mathbf{C_{O_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_C_O2"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_C_v","text":"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. ax ( Axes ) \u2013 Axes on which the vapor concentration will be plotted. Source code in modules/display_modules.py 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 def plot_C_v ( variables , parameters , ax ): \"\"\"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. n_gdl : int Number of model nodes placed inside each GDL. ax : matplotlib.axes.Axes Axes on which the vapor concentration will be plotted. \"\"\" # Extraction of the parameter n_gdl , type_current , type_plot = parameters [ 'n_gdl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_agc_t = np . array ( variables [ 'C_v_agc' ])[ mask ] C_v_agdl_t = np . array ( variables [ f 'C_v_agdl_ { n_gdl // 2 } ' ])[ mask ] C_v_ampl_t = np . array ( variables [ 'C_v_ampl' ])[ mask ] C_v_acl_t = np . array ( variables [ 'C_v_acl' ])[ mask ] C_v_ccl_t = np . array ( variables [ 'C_v_ccl' ])[ mask ] C_v_cmpl_t = np . array ( variables [ 'C_v_cmpl' ])[ mask ] C_v_cgdl_t = np . array ( variables [ f 'C_v_cgdl_ { n_gdl // 2 } ' ])[ mask ] C_v_cgc_t = np . array ( variables [ 'C_v_cgc' ])[ mask ] T_ccl = np . array ( variables [ 'T_ccl' ])[ mask ] # Plot the vapor concentrations at different spatial localisations Cv C_v_sat_ccl_t = np . array ([ C_v_sat ( T ) for T in T_ccl ]) ax . plot ( t , C_v_agc_t , color = colors ( 0 )) ax . plot ( t , C_v_agdl_t , color = colors ( 1 )) ax . plot ( t , C_v_ampl_t , color = colors ( 2 )) ax . plot ( t , C_v_acl_t , color = colors ( 3 )) ax . plot ( t , C_v_ccl_t , color = colors ( 5 )) ax . plot ( t , C_v_cmpl_t , color = colors ( 6 )) ax . plot ( t , C_v_cgdl_t , color = colors ( 7 )) ax . plot ( t , C_v_cgc_t , color = colors ( 8 )) ax . plot ( t , C_v_sat_ccl_t , color = 'k' ) ax . legend ([ r '$\\mathregular{C_{v,agc}}$' , r '$\\mathregular{C_{v,agdl}}$' , r '$\\mathregular{C_{v,ampl}}$' , r '$\\mathregular{C_{v,acl}}$' , r '$\\mathregular{C_{v,ccl}}$' , r '$\\mathregular{C_{v,cmpl}}$' , r '$\\mathregular{C_{v,cgdl}}$' , r '$\\mathregular{C_{v,cgc}}$' , r '$\\mathregular{C_{v,sat,ccl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r \"$\\mathbf {Vapor} $ $\\mathbf {concentration} $ $\\mathbf{C_ {v} }$ $\\mathbf{\\left( mol.m^{-3} \\right)}$\" , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_C_v"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_Nyquist_instructions","text":"This function adds the instructions for EIS plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. f_Fourier ( ndarray ) \u2013 Frequency at which the EIS is simulated. x ( ndarray ) \u2013 x-axis values for plotting the annotation. y ( ndarray ) \u2013 y-axis values for plotting the annotation. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 def plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , x , y , ax ): \"\"\"This function adds the instructions for EIS plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. f_Fourier : numpy.ndarray Frequency at which the EIS is simulated. x : numpy.ndarray x-axis values for plotting the annotation. y : numpy.ndarray y-axis values for plotting the annotation. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions ax . set_aspect ( 'equal' , adjustable = 'box' ) # Set orthonormal axis. # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : # Double charge transfer if ( f_Fourier >= 70 and f_Fourier <= 80 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , - 40 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) # Auxiliary system if ( f_Fourier >= 0.14 and f_Fourier <= 0.16 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 7 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 1.2 and f_Fourier <= 1.4 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 10 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) # Diffusion if ( f_Fourier >= 0.015 and f_Fourier <= 0.020 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 30 , 0 ), ha = 'center' , fontsize = 14 , rotation = 0 , weight = 'bold' ) if ( f_Fourier >= 0.9 and f_Fourier <= 1.1 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 10 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 70 and f_Fourier <= 90 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , - 40 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 10000 and f_Fourier <= 12000 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 35 , 0 ), ha = 'center' , fontsize = 14 , rotation = 0 , weight = 'bold' ) ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 20 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 20 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 10 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 10 / 5 )) ax . set_xlim ( 30 , 200 ) ax . set_ylim ( - 25 , 55 )","title":"plot_EIS_Nyquist_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_curve_Bode_amplitude","text":"This function is used to plot the amplitude Bode diagram of the EIS curves. Parameters: parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the amplitude Bode diagram will be plotted. Source code in modules/display_modules.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def plot_EIS_curve_Bode_amplitude ( parameters , Fourier_results , ax ): \"\"\"This function is used to plot the amplitude Bode diagram of the EIS curves. Parameters ---------- parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the amplitude Bode diagram will be plotted. \"\"\" # Extraction of the parameters i_EIS , ratio_EIS , f_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ], parameters [ 'f_EIS' ] type_fuel_cell = parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results A , f = Fourier_results [ 'A' ], Fourier_results [ 'f' ] # Calculation of the impedance of the perturbation Z0 = A / ( ratio_EIS * ( - i_EIS )) * 1e7 # in m\u03a9.cm\u00b2. The sign of i is inverted to comply with the standards of EIS, # which measure a device under load rather than a current source. # Plot the amplitude Bode diagram ax . plot ( f , np . abs ( Z0 ), 'o' , color = colors ( 1 ), label = 'Amplitude Bode diagram' ) ax . set_xlabel ( r '$\\mathbf {Frequency} $ $\\mathbf{(Hz,}$ $\\mathbf {logarithmic} $ $\\mathbf{scale)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Impedance} $ $\\mathbf {amplitude} $ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) # Plot instructions plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax )","title":"plot_EIS_curve_Bode_amplitude"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_curve_Bode_angle","text":"This function is used to plot the angle Bode diagram. It only works with an entry signal made with a cosinus (not a sinus). Parameters: Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the angle Bode diagram will be plotted. Source code in modules/display_modules.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def plot_EIS_curve_Bode_angle ( parameters , Fourier_results , ax ): \"\"\"This function is used to plot the angle Bode diagram. It only works with an entry signal made with a cosinus (not a sinus). Parameters ---------- Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the angle Bode diagram will be plotted. \"\"\" # Extraction of the parameters f_EIS , type_fuel_cell = parameters [ 'f_EIS' ], parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] A_period_t , A = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ] f , N = Fourier_results [ 'f' ], Fourier_results [ 'N' ] # Calculation of the dephasing values at the frequency of the perturbation theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) + np . pi # Recovery of all dephasing values calculated by fft. # An angle of pi is added to comply with the standards of EIS, # which measure a device under load rather than a current source. theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation phi_U_i = (( theta_U - theta_i ) * 180 / np . pi ) % 360 # Dephasing between Ucell and ifc with a value between 0 and 360 if phi_U_i > 180 : phi_U_i -= 360 # To have a value between -180 and 180 # Plot the angle Bode diagram ax . plot ( f , phi_U_i , 'o' , color = colors ( 2 ), label = 'Angle Bode diagram' ) ax . set_xlabel ( r '$\\mathbf {Frequency} $ $\\mathbf{(Hz,}$ $\\mathbf {logarithmic} $ $\\mathbf{scale)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Phase} $ $\\mathbf{(^\\circ)}$' , labelpad = 3 ) # Plot instructions plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax )","title":"plot_EIS_curve_Bode_angle"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_curve_Nyquist","text":"This function is used to plot the Nyquist diagram of the EIS curves. Parameters: parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the Nyquist diagram will be plotted. Source code in modules/display_modules.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def plot_EIS_curve_Nyquist ( parameters , Fourier_results , ax ): \"\"\" This function is used to plot the Nyquist diagram of the EIS curves. Parameters ---------- parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the Nyquist diagram will be plotted. \"\"\" # Extraction of the parameters i_EIS , ratio_EIS , type_fuel_cell = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ], parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] f_Fourier = Fourier_results [ 'f' ] A_period_t , A , N = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ], Fourier_results [ 'N' ] # Calculation of the real and imaginary component of the impedance for each period Z0 = A / ( ratio_EIS * ( - i_EIS )) * 1e7 # Impedance of the perturbation in m\u03a9.cm\u00b2. The sign of i is inverted to # comply with the standards of EIS, which measure a device under load rather than a current source. theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation Z_real = Z0 * np . cos ( theta_U - theta_i ) # Real component of the impedance for each period Z_imag = Z0 * np . sin ( theta_U - theta_i ) # Imaginary component of the impedance for each period # Plot the Nyquist diagram ax . plot ( Z_real , - Z_imag , 'o' , color = colors ( 0 ), label = 'Nyquist diagram' ) ax . set_xlabel ( r '$\\mathbf{Z_ {real} }$ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf{-Z_ {imag} }$ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) # Plot instructions plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , Z_real , - Z_imag , ax )","title":"plot_EIS_curve_Nyquist"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_curve_tests","text":"This function is used to test the accuracy of the EIS results. It compares the reconstructed Ucell_Fourier(t) from the Fourier transformation with the current density ifc(t), and displays Ucell(t) given by the model with the reconstructed Ucell_Fourier(t). Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. Source code in modules/display_modules.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def plot_EIS_curve_tests ( variables , operating_inputs , parameters , Fourier_results ): \"\"\"This function is used to test the accuracy of the EIS results. It compares the reconstructed Ucell_Fourier(t) from the Fourier transformation with the current density ifc(t), and displays Ucell(t) given by the model with the reconstructed Ucell_Fourier(t). Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), variables [ 'Ucell' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] i_EIS , ratio_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ] t_EIS , f_EIS = parameters [ 't_EIS' ], parameters [ 'f_EIS' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] A_period_t , A = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ] f , N = Fourier_results [ 'f' ], Fourier_results [ 'N' ] # Reconstructed Ucell with a cosinus form, and comparison of its form with the current density one. t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = t_EIS f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS n_inf = np . where ( t_new_start_EIS <= t [ 0 ])[ 0 ][ - 1 ] # The number of frequency changes which has been made. f_current = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation print ( \"Ucell:\" , round ( A_period_t [ 0 ], 4 ), ' + ' , round ( A , 6 ), \" * np.cos(2*np.pi*\" , round ( f , 4 ), \"*t + \" , round ( theta_U , 4 ), \"). \" ) print ( \"Current:\" , i_EIS , ' + ' , ratio_EIS * i_EIS , \" * np.cos(2*np.pi*\" , round ( f_current [ n_inf ], 4 ), \"*t + \" , round ( theta_i , 4 ), \"). \\n \" ) # Display ifc(t) plt . figure ( 3 ) plt . subplot ( 2 , 1 , 1 ) # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Conversion in A/cm\u00b2 ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Plot of ifc_t plt . plot ( t , ifc_t , color = 'blue' , label = 'ifc' ) plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Current density (A/cm\u00b2)' ) plt . title ( 'The current density \\n behaviour over time' ) # Display Ucell(t) and compare it with the reconstructed Ucell_Fourier(t) from the Fourier transformation plt . subplot ( 2 , 1 , 2 ) Ucell_Fourier = A_period_t [ 0 ] + A * np . cos ( 2 * np . pi * f * t + theta_U ) plt . plot ( t , Ucell_t , color = 'blue' , label = 'Ucell' ) plt . plot ( t , Ucell_Fourier , color = 'black' , label = 'Ucell_Fourier' ) plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Cell voltage (V)' ) plt . title ( 'The cell voltage \\n behaviour over time' )","title":"plot_EIS_curve_tests"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_J","text":"This function plots the sorption and dissolved water flows as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the flows will be plotted. Source code in modules/display_modules.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def plot_J ( variables , parameters , ax ): \"\"\"This function plots the sorption and dissolved water flows as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the flows will be plotted. \"\"\" # Extraction of the operating inputs and the parameters Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] S_abs_acl_t = np . array ( variables [ 'S_abs_acl' ])[ mask ] S_abs_ccl_t = np . array ( variables [ 'S_abs_ccl' ])[ mask ] J_lambda_acl_mem_t = np . array ( variables [ 'J_lambda_acl_mem' ])[ mask ] J_lambda_mem_ccl_t = np . array ( variables [ 'J_lambda_mem_ccl' ])[ mask ] # Plot the sorption and dissolved water flows: J J_abs_acl , J_abs_ccl = S_abs_acl_t * Hacl , S_abs_ccl_t * Hccl # Conversion in mol.m\u207b\u00b2.s\u207b\u00b9 for comparison ax . plot ( t , J_abs_acl , color = colors ( 2 )) ax . plot ( t , J_lambda_acl_mem_t , color = colors ( 3 )) ax . plot ( t , J_abs_ccl , color = colors ( 4 )) ax . plot ( t , J_lambda_mem_ccl_t , color = colors ( 7 )) ax . legend ([ r '$\\mathregular{J_{abs,acl}}$' , r '$\\mathregular{J_{\\lambda,mem,acl}}$' , r '$\\mathregular{J_{abs,ccl}}$' , r '$\\mathregular{J_{\\lambda,mem,ccl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Flows} $ $\\mathbf {J} $ $\\mathbf{\\left( mol.m^{-2}.s^{-1} \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax )","title":"plot_J"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_P","text":"This function plots the pressure at different spatial localisations as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the pressure will be plotted. Source code in modules/display_modules.py 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 def plot_P ( variables , parameters , ax ): \"\"\"This function plots the pressure at different spatial localisations as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the pressure will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] Pagc_t = np . array ( variables [ 'Pagc' ])[ mask ] / 1e5 # Conversion in atm Pcgc_t = np . array ( variables [ 'Pcgc' ])[ mask ] / 1e5 # Conversion in atm Pasm_t = np . array ( variables [ 'Pasm' ])[ mask ] / 1e5 # Conversion in atm Paem_t = np . array ( variables [ 'Paem' ])[ mask ] / 1e5 # Conversion in atm Pcsm_t = np . array ( variables [ 'Pcsm' ])[ mask ] / 1e5 # Conversion in atm Pcem_t = np . array ( variables [ 'Pcem' ])[ mask ] / 1e5 # Conversion in atm # Plot the pressure at different spatial localisations: P ax . plot ( t , Pagc_t , color = colors ( 0 )) ax . plot ( t , Pcgc_t , color = colors ( 6 )) ax . plot ( t , Pasm_t , color = colors ( 7 )) ax . plot ( t , Paem_t , color = colors ( 8 )) ax . plot ( t , Pcsm_t , color = colors ( 9 )) ax . plot ( t , Pcem_t , color = colors ( 3 )) ax . legend ([ r '$\\mathregular{P_ {agc} }$' , r '$\\mathregular{P_ {cgc} }$' , r '$\\mathregular{P_ {asm} }$' , r '$\\mathregular{P_ {aem} }$' , r '$\\mathregular{P_ {csm} }$' , r '$\\mathregular{P_ {cem} }$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Pressure} $ $\\mathbf {P} $ $\\mathbf{\\left( bar \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax )","title":"plot_P"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Phi_a","text":"This function plots the humidity at the anode side, at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. ax ( Axes ) \u2013 Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 def plot_Phi_a ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the humidity at the anode side, at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and parameters Phi_a_des = operating_inputs [ 'Phi_a_des' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_agc_t = np . array ( variables [ 'C_v_agc' ])[ mask ] T_agc_t = np . array ( variables [ 'T_agc' ])[ mask ] Phi_asm_t = np . array ( variables [ 'Phi_asm' ])[ mask ] Phi_aem_t = np . array ( variables [ 'Phi_aem' ])[ mask ] # Calculate the humidity Phi Phi_agc_t = C_v_agc_t * R * T_agc_t / Psat ( T_agc_t ) # Plot the humidity at different spatial localisations: Phi ax . plot ( t , Phi_agc_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_ {agc} }$' ) ax . plot ( t , Phi_asm_t , color = colors ( 1 ), label = r '$\\mathregular{\\Phi_ {asm} }$' ) ax . plot ( t , Phi_aem_t , color = colors ( 2 ), label = r '$\\mathregular{\\Phi_ {aem} }$' ) ax . plot ( t , np . array ([ Phi_a_des ] * len ( t )), color = 'black' , label = r '$\\mathregular{\\Phi_{a,des}}$' ) ax . legend ( loc = 'center right' , bbox_to_anchor = ( 1 , 0.67 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Humidity} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf {anode} $ $\\mathbf {side} $ $\\mathbf{\\Phi}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_Phi_a"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Phi_c","text":"This function plots the humidity, at the cathode side, at different spatial localisations as a function of time. Parameters: ax \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. ax ( Axes ) \u2013 Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 def plot_Phi_c ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the humidity, at the cathode side, at different spatial localisations as a function of time. Parameters ---------- ax.plot(t, np.array([Phi_a_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{a,des}}$') Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and parameters Phi_c_des = operating_inputs [ 'Phi_c_des' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_cgc_t = np . array ( variables [ 'C_v_cgc' ])[ mask ] T_cgc_t = np . array ( variables [ 'T_cgc' ])[ mask ] Phi_csm_t = np . array ( variables [ 'Phi_csm' ])[ mask ] Phi_cem_t = np . array ( variables [ 'Phi_cem' ])[ mask ] # Calculate the humidity Phi Phi_cgc_t = C_v_cgc_t * R * T_cgc_t / Psat ( T_cgc_t ) # Plot the humidity at different spatial localisations: Phi ax . plot ( t , Phi_cgc_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_ {cgc} }$' ) ax . plot ( t , Phi_csm_t , color = colors ( 1 ), label = r '$\\mathregular{\\Phi_ {csm} }$' ) ax . plot ( t , Phi_cem_t , color = colors ( 2 ), label = r '$\\mathregular{\\Phi_ {cem} }$' ) ax . plot ( t , np . array ([ Phi_c_des ] * len ( t )), color = 'black' , label = r '$\\mathregular{\\Phi_{c,des}}$' ) ax . legend ( loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Humidity} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf {cathode} $ $\\mathbf {side} $ $\\mathbf{\\Phi}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_Phi_c"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Phi_des","text":"This function plots the controlled or uncontrolled desired humidity at the anode and cathode as a function of the current density. Parameters ax.plot(t, np.array([Phi_c_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{c,des}}$') variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 def plot_Phi_des ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the controlled or uncontrolled desired humidity at the anode and cathode as a function of the current density. Parameters ax.plot(t, np.array([Phi_c_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{c,des}}$') variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] if parameters [ 'type_control' ] == \"Phi_des\" : Phi_a_des_t = variables [ 'Phi_a_des' ][ mask ] Phi_c_des_t = variables [ 'Phi_c_des' ][ mask ] ax . set_ylabel ( r '$\\mathbf {Controlled} $ $\\mathbf {inlet} $ $\\mathbf {humidity} $ $\\mathbf{\\Phi_ {des} }$' , labelpad = 3 ) else : Phi_a_des_t = np . array ([ operating_inputs [ 'Phi_a_des' ]] * len ( t )) Phi_c_des_t = np . array ([ operating_inputs [ 'Phi_c_des' ]] * len ( t )) ax . set_ylabel ( r '$\\mathbf {Uncontrolled} $ $\\mathbf {inlet} $ $\\mathbf {humidity} $ $\\mathbf{\\Phi_ {des} }$' , labelpad = 3 ) # Plot Phi_des n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of ifc_t ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) Phi_a_des_discretized_t , Phi_c_des_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load Phi_a_des_discretized_t [ i ] = Phi_a_des_t [ idx ] # the last value at the end of each load Phi_c_des_discretized_t [ i ] = Phi_c_des_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , Phi_c_des_discretized_t , color = colors ( 6 ), label = r '$\\mathregular{\\Phi_{c,des}}$' ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) if parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" or \\ parameters [ 'type_auxiliary' ] == \"no_auxiliary\" : ax . scatter ( ifc_discretized_t , Phi_a_des_discretized_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_{a,des}}$' ) ax . legend ([ r '$\\mathregular{\\Phi_{a,des}}$' , r '$\\mathregular{\\Phi_{c,des}}$' ], loc = 'best' ) else : ax . legend ([ r '$\\mathregular{\\Phi_{c,des}}$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_Phi_des"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_T","text":"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. n_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. ax ( Axes ) \u2013 Axes on which the vapor concentration will be plotted. Source code in modules/display_modules.py 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 def plot_T ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. n_gdl : int Number of model nodes placed inside each GDL. ax : matplotlib.axes.Axes Axes on which the vapor concentration will be plotted. \"\"\" # Extraction of the operating inputs and parameters T_des = operating_inputs [ 'T_des' ] n_gdl , type_current , type_plot = parameters [ 'n_gdl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables and the operating inputs if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] T_agc_t = np . array ( variables [ 'T_agc' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_agdl_t = np . array ( variables [ f 'T_agdl_ { n_gdl // 2 } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_ampl_t = np . array ( variables [ 'T_ampl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_acl_t = np . array ( variables [ 'T_acl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_mem_t = np . array ( variables [ 'T_mem' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_ccl_t = np . array ( variables [ 'T_ccl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cmpl_t = np . array ( variables [ 'T_cmpl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cgdl_t = np . array ( variables [ f 'T_cgdl_ { n_gdl // 2 } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cgc_t = np . array ( variables [ 'T_cgc' ])[ mask ] - 273.15 # Conversion in \u00b0C. # Plot the temperature at different spatial localisations T_des_t = np . array ([ T_des - 273.15 ] * len ( t )) ax . plot ( t , T_agc_t , color = colors ( 0 )) ax . plot ( t , T_agdl_t , color = colors ( 1 )) ax . plot ( t , T_ampl_t , color = colors ( 2 )) ax . plot ( t , T_acl_t , color = colors ( 3 )) ax . plot ( t , T_mem_t , color = colors ( 4 )) ax . plot ( t , T_ccl_t , color = colors ( 5 )) ax . plot ( t , T_cmpl_t , color = colors ( 6 )) ax . plot ( t , T_cgdl_t , color = colors ( 7 )) ax . plot ( t , T_cgc_t , color = colors ( 8 )) ax . plot ( t , T_des_t , color = 'k' ) ax . legend ([ r '$\\mathregular{T_ {agc} }$' , r '$\\mathregular{T_ {agdl} }$' , r '$\\mathregular{T_ {ampl} }$' , r '$\\mathregular{T_ {acl} }$' , r '$\\mathregular{T_ {mem} }$' , r '$\\mathregular{T_ {ccl} }$' , r '$\\mathregular{T_ {cmpl} }$' , r '$\\mathregular{T_ {cgdl} }$' , r '$\\mathregular{T_ {cgc} }$' , r '$\\mathregular{T_ {des} }$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r \"$\\mathbf {Temperature} $ $\\mathbf {T} $ $\\mathbf{\\left( \u00b0C \\right)}$\" , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_T"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Ucell","text":"This function plots the cell voltage as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the cell voltage will be plotted. Source code in modules/display_modules.py 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 def plot_Ucell ( variables , parameters , ax ): \"\"\"This function plots the cell voltage as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the cell voltage will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] Ucell_t = np . array ( variables [ 'Ucell' ])[ mask ] # Plot the cell voltage: Ucell ax . plot ( t , Ucell_t , color = colors ( 0 ), label = r '$\\mathregular{U_ {cell} }$' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{U_ {cell} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_Ucell"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_cell_efficiency","text":"This function plots the fuel cell efficiency eta_fc as a function of the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the fuel cell efficiency. ax ( Axes ) \u2013 Axes on which the fuel cell efficiency will be plotted. Source code in modules/display_modules.py 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 def plot_cell_efficiency ( variables , operating_inputs , parameters , n , ax ): \"\"\"This function plots the fuel cell efficiency eta_fc as a function of the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the fuel cell efficiency. ax : matplotlib.axes.Axes Axes on which the fuel cell efficiency will be plotted. \"\"\" # Extraction of the variables t , Ucell_t , lambda_mem_t = variables [ 't' ], variables [ 'Ucell' ], variables [ 'lambda_mem' ] C_H2_acl_t , C_O2_ccl_t = variables [ 'C_H2_acl' ], variables [ 'C_O2_ccl' ] T_acl_t , T_mem_t , T_ccl_t = variables [ 'T_acl' ], variables [ 'T_mem' ], variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] Hmem , Hacl , Hccl , kappa_co = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'kappa_co' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] # Creation of the fuel cell efficiency: eta_fc ifc_t , Pfc_t , eta_fc_t = np . zeros ( n ), np . zeros ( n ), np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 Pfc_t [ i ] = Ucell_t [ i ] * ifc_t [ i ] Ueq = E0 - 8.5e-4 * ( T_ccl_t [ i ] - 298.15 ) + \\ R * T_ccl_t [ i ] / ( 2 * F ) * ( np . log ( R * T_acl_t [ i ] * C_H2_acl_t [ i ] / Pref ) + 0.5 * np . log ( R * T_ccl_t [ i ] * C_O2_ccl_t [ i ] / Pref )) T_acl_mem_ccl = average ([ T_acl_t [ i ], T_mem_t [ i ], T_ccl_t [ i ]], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl_t [ i ] * k_H2 ( lambda_mem_t [ i ], T_mem_t [ i ], kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl_t [ i ] * k_O2 ( lambda_mem_t [ i ], T_mem_t [ i ], kappa_co ) i_n = ( i_H2 + i_O2 ) / 1e4 # Conversion in A/cm\u00b2 eta_fc_t [ i ] = Pfc_t [ i ] / ( Ueq * ( ifc_t [ i ] + i_n )) # Plot of the fuel cell efficiency: eta_fc plot_specific_line ( ifc_t , eta_fc_t , type_fuel_cell , type_current , type_auxiliary , type_control , None , ax ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 0 ) ax . set_ylabel ( r '$\\mathbf {Fuel} $ $\\mathbf {cell} $ $\\mathbf {efficiency} $ $\\mathbf{\\eta_ {fc} }$' , labelpad = 0 ) ax . legend ( loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_cell_efficiency"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_general_instructions","text":"This function adds the common instructions for all the plots displayed by AlphaPEM to the ax object. Parameters: ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 def plot_general_instructions ( ax , set_y = True ): \"\"\"This function adds the common instructions for all the plots displayed by AlphaPEM to the ax object. Parameters ---------- ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Get the current x-axis and y-axis limits x_min , x_max = ax . get_xlim () y_min , y_max = ax . get_ylim () # Calculate the major step for the x-axis and y-axis ticks major_step_x = ( x_max - x_min ) / 5 major_step_y = ( y_max - y_min ) / 5 major_step_x_rounded = round_nice ( major_step_x ) major_step_y_rounded = round_nice ( major_step_y ) # Set the major and minor locators for the x-axis and y-axis ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( major_step_x_rounded )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( major_step_x_rounded / 5 )) if set_y : ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( major_step_y_rounded )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( major_step_y_rounded / 5 )) # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure","title":"plot_general_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_ifc","text":"This function plots the current density as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the current density. ax ( Axes ) \u2013 Axes on which the current density will be plotted. Source code in modules/display_modules.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def plot_ifc ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the current density as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the current density. ax : matplotlib.axes.Axes Axes on which the current density will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] # Plot the current density: ifc n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of ifc_t ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 ax . plot ( t , ifc_t , color = colors ( 0 ), label = r '$\\mathregular{i_ {fc} }$' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{i_ {fc} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_ifc"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_lambda","text":"This function plots the water content at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the water content will be plotted. Source code in modules/display_modules.py 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 def plot_lambda ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the water content at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the water content will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters , type_current = parameters [ 'pola_current_parameters' ], parameters [ 'type_current' ] type_plot = parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] lambda_acl_t = np . array ( variables [ 'lambda_acl' ])[ mask ] lambda_mem_t = np . array ( variables [ 'lambda_mem' ])[ mask ] lambda_ccl_t = np . array ( variables [ 'lambda_ccl' ])[ mask ] # Plot the water content at different spatial localisations: lambda if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads which are made ifc_discretized_t , lambda_acl_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) lambda_mem_discretized_t , lambda_ccl_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load lambda_acl_discretized_t [ i ] = lambda_acl_t [ idx ] # the last value at the end of each load lambda_mem_discretized_t [ i ] = lambda_mem_t [ idx ] # the last value at the end of each load lambda_ccl_discretized_t [ i ] = lambda_ccl_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , lambda_acl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , lambda_mem_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , lambda_ccl_discretized_t , marker = 'o' , color = colors ( 4 )) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : ax . plot ( t , lambda_acl_t , color = colors ( 3 )) ax . plot ( t , lambda_mem_t , color = colors ( 4 )) ax . plot ( t , lambda_ccl_t , color = colors ( 5 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Water} $ $\\mathbf {content} $ $\\mathbf{\\lambda}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{\\lambda_ {acl} }$' , r '$\\mathregular{\\lambda_ {mem} }$' , r '$\\mathregular{\\lambda_ {ccl} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_lambda"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_pola_instructions","text":"This function adds the specific instructions for polarisation plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. show ( bool , default: True ) \u2013 If True, the figure will be displayed. Default is True. Source code in modules/display_modules.py 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 def plot_pola_instructions ( type_fuel_cell , ax , show = True ): \"\"\"This function adds the specific instructions for polarisation plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. show : bool, optional If True, the figure will be displayed. Default is True. \"\"\" # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.5 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.5 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.1 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.1 / 5 )) ax . set_xlim ( 0 , 3.0 ) ax . set_ylim ( 0.4 , 1.04 ) # For LF fuel cell elif type_fuel_cell == \"LF\" : ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.4 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.4 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.2 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.2 / 5 )) ax . set_xlim ( - 0.05 , 1.6 ) ax . set_ylim ( 0 , 1.0 ) # For other fuel cell else : pass # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure if show : plt . show () # Show the figure","title":"plot_pola_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_polarisation_curve","text":"This function plots the model polarisation curve, and compare it to the experimental one (if it exists). The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the polarisation curve will be plotted. show ( bool , default: True ) \u2013 If True, the polarisation curve will be displayed. If False, it will not be displayed. Source code in modules/display_modules.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def plot_polarisation_curve ( variables , operating_inputs , parameters , ax , show = True ): \"\"\" This function plots the model polarisation curve, and compare it to the experimental one (if it exists). The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the polarisation curve will be plotted. show : bool, optional If True, the polarisation curve will be displayed. If False, it will not be displayed. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] delta_i_pola , i_max_pola = pola_current_parameters [ 'delta_i_pola' ], pola_current_parameters [ 'i_max_pola' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] type_plot = parameters [ 'type_plot' ] # Extraction of the experimental current density and voltage values. i_exp_t , U_exp_t = pola_exp_values ( type_fuel_cell ) # (A.m-2, V). if type_plot == \"fixed\" : # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of ifc and Ucell from the model after each stack stabilisation nb_loads = int ( i_max_pola / delta_i_pola ) # Number of loads which are made ifc_discretized = np . zeros ( nb_loads + 1 ) # One point is taken at ifc = 0, before the first load. Ucell_discretized = np . zeros ( nb_loads + 1 ) # One point is taken at ifc = 0, before the first load. for i in range ( nb_loads + 1 ): t_load = delta_t_ini_pola + i * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized [ i ] = ifc_t [ idx ] # the last value at the end of each load Ucell_discretized [ i ] = Ucell_t [ idx ] # the last value at the end of each load # Plot the experimental polarization curve and calculate the simulation error compared with experimental data if type_fuel_cell != \"manual_setup\" and \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible # Plot of the experimental polarization curve i_exp_t = i_exp_t / 1e4 # Conversion in A/cm\u00b2 plot_experimental_polarisation_curve ( type_fuel_cell , i_exp_t , U_exp_t , ax ) # Calculate the simulation error compared with experimental data # Experimental points are interpolated to correspond to the model points Ucell_interpolated = interp1d ( ifc_discretized , Ucell_discretized , kind = 'linear' )( i_exp_t ) sim_error = calculate_simulation_error ( Ucell_interpolated , U_exp_t ) else : sim_error = None # Plot the model polarisation curve plot_specific_line ( ifc_discretized , Ucell_discretized , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) plot_pola_instructions ( type_fuel_cell , ax , show ) else : # type_plot == \"dynamic\" # Plot of the polarisation curve produced by the model idx = ( np . abs ( t - t [ - 1 ])) . argmin () # index for polarisation measurement ifc = np . array ( current_density ( t [ idx ], parameters ) / 1e4 ) # time for polarisation measurement Ucell = np . array ( Ucell_t [ idx ]) # voltage measurement ax . plot ( ifc , Ucell , 'og' , markersize = 2 ) # Add the common instructions for the plot ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) if type_plot == \"fixed\" : ax . legend ( loc = 'best' )","title":"plot_polarisation_curve"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_polarisation_curve_for_cali","text":"This function plots the model polarisation curve, and compare it to the experimental one. The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the polarisation curve will be plotted. Source code in modules/display_modules.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def plot_polarisation_curve_for_cali ( variables , operating_inputs , parameters , ax ): \"\"\" This function plots the model polarisation curve, and compare it to the experimental one. The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the polarisation curve will be plotted. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_for_cali_parameters = parameters [ 'pola_current_for_cali_parameters' ] delta_t_ini_pola_cali = pola_current_for_cali_parameters [ 'delta_t_ini_pola_cali' ] delta_t_load_pola_cali = pola_current_for_cali_parameters [ 'delta_t_load_pola_cali' ] delta_t_break_pola_cali = pola_current_for_cali_parameters [ 'delta_t_break_pola_cali' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] type_plot = parameters [ 'type_plot' ] # Extraction of the experimental current density and voltage values for the calibration. i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( parameters [ 'type_fuel_cell' ]) # (A.m-2, V). # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of ifc and Ucell from the model after each stack stabilisation nb_loads = len ( i_exp_cali_t ) # Number of loads which are made delta_t_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. ifc_discretized = np . zeros ( nb_loads ) Ucell_discretized = np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola_cali + ( i + 1 ) * delta_t_cali # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized [ i ] = ifc_t [ idx ] # the last value at the end of each load Ucell_discretized [ i ] = Ucell_t [ idx ] # the last value at the end of each load # Plot the experimental polarization curve i_exp_cali_t = i_exp_cali_t / 1e4 # Conversion in A/cm\u00b2 plot_experimental_polarisation_curve ( type_fuel_cell , i_exp_cali_t , U_exp_cali_t , ax ) # Plot the model polarisation curve sim_error = calculate_simulation_error ( Ucell_discretized , U_exp_cali_t ) # Calculate the simulation error plot_specific_line ( ifc_discretized , Ucell_discretized , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) plot_pola_instructions ( type_fuel_cell , ax ) # Add the common instructions for the plot ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) if type_plot == \"fixed\" : ax . legend ( loc = 'best' )","title":"plot_polarisation_curve_for_cali"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_power_density_curve","text":"This function plots the power density curve Pfc, produced by a cell, as a function of the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the power density curve. ax ( Axes ) \u2013 Axes on which the power density curve will be plotted. Source code in modules/display_modules.py 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 def plot_power_density_curve ( variables , operating_inputs , parameters , n , ax ): \"\"\"This function plots the power density curve Pfc, produced by a cell, as a function of the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the power density curve. ax : matplotlib.axes.Axes Axes on which the power density curve will be plotted. \"\"\" # Extraction of the variables t , Ucell_t = variables [ 't' ], variables [ 'Ucell' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] # Creation of the power density function: Pfc ifc_t , Pfc_t = np . zeros ( n ), np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 Pfc_t [ i ] = Ucell_t [ i ] * ifc_t [ i ] # Plot of the power density function: Pfc plot_specific_line ( ifc_t , Pfc_t , type_fuel_cell , type_current , type_auxiliary , type_control , None , ax ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 0 ) ax . set_ylabel ( r '$\\mathbf {Fuel} $ $\\mathbf {cell} $ $\\mathbf {power} $ $\\mathbf {density} $ $\\mathbf{P_ {fc} }$ $\\mathbf{\\left( W.cm^{-2} \\right)}$' , labelpad = 0 ) ax . legend ( loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_power_density_curve"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_s","text":"This function plots the liquid water saturation at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the liquid water saturation will be plotted. Source code in modules/display_modules.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 def plot_s ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the liquid water saturation at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the liquid water saturation will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] n_gdl , pola_current_parameters = parameters [ 'n_gdl' ], parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] s_agdl_t = np . array ( variables [ f 's_agdl_ { n_gdl // 2 } ' ])[ mask ] s_ampl_t = np . array ( variables [ 's_ampl' ])[ mask ] s_acl_t = np . array ( variables [ 's_acl' ])[ mask ] s_ccl_t = np . array ( variables [ 's_ccl' ])[ mask ] s_cmpl_t = np . array ( variables [ 's_cmpl' ])[ mask ] s_cgdl_t = np . array ( variables [ f 's_cgdl_ { n_gdl // 2 } ' ])[ mask ] # Plot the liquid water saturation at different spatial localisations: s if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) s_agdl_discretized_t , s_ampl_discretized_t , s_acl_discretized_t = [ np . zeros ( nb_loads )] * 3 s_ccl_discretized_t , s_cmpl_discretized_t , s_cgdl_discretized_t = [ np . zeros ( nb_loads )] * 3 for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load s_agdl_discretized_t [ i ] = s_agdl_t [ idx ] # the last value at the end of each load s_ampl_discretized_t [ i ] = s_ampl_t [ idx ] # the last value at the end of each load s_acl_discretized_t [ i ] = s_acl_t [ idx ] # the last value at the end of each load s_ccl_discretized_t [ i ] = s_ccl_t [ idx ] # the last value at the end of each load s_cmpl_discretized_t [ i ] = s_cmpl_t [ idx ] # the last value at the end of each load s_cgdl_discretized_t [ i ] = s_cgdl_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , s_agdl_discretized_t , marker = 'o' , color = colors ( 1 )) ax . scatter ( ifc_discretized_t , s_ampl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , s_acl_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , s_ccl_discretized_t , marker = 'o' , color = colors ( 5 )) ax . scatter ( ifc_discretized_t , s_cmpl_discretized_t , marker = 'o' , color = colors ( 6 )) ax . scatter ( ifc_discretized_t , s_cgdl_discretized_t , marker = 'o' , color = colors ( 7 )) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : ax . plot ( t , s_agdl_t , color = colors ( 1 )) ax . plot ( t , s_ampl_t , color = colors ( 2 )) ax . plot ( t , s_acl_t , color = colors ( 3 )) ax . plot ( t , s_ccl_t , color = colors ( 5 )) ax . plot ( t , s_cmpl_t , color = colors ( 6 )) ax . plot ( t , s_cgdl_t , color = colors ( 7 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Liquid} $ $\\mathbf {water} $ $\\mathbf {saturation} $ $\\mathbf {s} $' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{s_ {agdl} }$' , r '$\\mathregular{s_ {ampl} }$' , r '$\\mathregular{s_ {acl} }$' , r '$\\mathregular{s_ {ccl} }$' , r '$\\mathregular{s_ {cmpl} }$' , r '$\\mathregular{s_ {cgdl} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_s"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_specific_line","text":"This function adds the appropriate plot configuration according to the type_input to the ax object. Parameters: x ( ndarray ) \u2013 x-axis values. y ( ndarray ) \u2013 y-axis values. type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. type_current ( str ) \u2013 Type of current density. type_auxiliary ( str ) \u2013 Type of auxiliary system. type_control ( str ) \u2013 Type of control system. sim_error ( float ) \u2013 Simulation error between the simulated cell voltage and the experimental cell voltage (in %). ax ( Axes ) \u2013 Axes on which the line will be plotted. Source code in modules/display_modules.py 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 def plot_specific_line ( x , y , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ): \"\"\" This function adds the appropriate plot configuration according to the type_input to the ax object. Parameters ---------- x : numpy.ndarray x-axis values. y : numpy.ndarray y-axis values. type_fuel_cell : str Type of fuel cell configuration. type_current : str Type of current density. type_auxiliary : str Type of auxiliary system. type_control : str Type of control system. sim_error : float Simulation error between the simulated cell voltage and the experimental cell voltage (in %). ax : matplotlib.axes.Axes Axes on which the line will be plotted. \"\"\" # For EH-31 fuel cell if type_current == \"polarization\" : if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : if type_fuel_cell == \"EH-31_1.5\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_1.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , '--' , color = colors ( 1 ), label = 'Sim. - P = 2.0 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : if type_control == \"Phi_des\" : ax . plot ( x , y , color = colors ( 5 ), label = r 'Sim. - P = 2.0 bar - controlled $\\mathregular{\\Phi_ {des} }$' ) else : ax . plot ( x , y , color = colors ( 1 ), label = r 'Sim. - P = 2.0 bar - uncontrolled $\\mathregular{\\Phi_ {des} }$' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , '--' , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . plot ( x , y , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' ) # For LF fuel cell elif type_fuel_cell == \"LF\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Simulation' ) # For other fuel cell else : ax . plot ( x , y , color = colors ( 0 ), label = 'Simulation' ) elif type_current == \"polarization_for_cali\" : if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : if type_fuel_cell == \"EH-31_1.5\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_1.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = 'Sim. - P = 2.0 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : if type_control == \"Phi_des\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 5 ), label = r 'Sim. - P = 2.0 bar - controlled $\\mathregular{\\Phi_ {des} }$' ) else : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = r 'Sim. - P = 2.0 bar - uncontrolled $\\mathregular{\\Phi_ {des} }$' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' ) # For LF fuel cell elif type_fuel_cell == \"LF\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Simulation' ) # For other fuel cell else : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Simulation' ) else : raise ValueError ( 'Only \"polarization_current\" and \"polarization_current_for_cali\" are considered here.' )","title":"plot_specific_line"},{"location":"functions/modules/display_modules/#modules.display_modules.round_nice","text":"Round the main step to a \"nice\" number. Parameters: x ( float ) \u2013 The value to be rounded. Returns: float \u2013 The value rounded to a \"nice\" number. Source code in modules/display_modules.py 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 def round_nice ( x ): \"\"\"Round the main step to a \"nice\" number. Parameters ---------- x : float The value to be rounded. Returns ------- float The value rounded to a \"nice\" number. \"\"\" exp = np . floor ( np . log10 ( x )) f = x / 10 ** exp if f < 1.5 : nice = 1 elif f < 3 : nice = 2 elif f < 7 : nice = 5 else : nice = 10 return nice * 10 ** exp","title":"round_nice"},{"location":"functions/modules/flows_modules/","text":"Flows modules This module is used to calculate intermediate values for the flows calculation. flows_int_values ( sv , operating_inputs , parameters ) This functions calculates intermediate values for the flows calculation. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Pagc ( float ) \u2013 Global pressure in the anode gas channel (Pa). Pcgc ( float ) \u2013 Global pressure in the cathode gas channel (Pa). lambda_acl_mem ( float ) \u2013 Water content in the ACL and the membrane (kg/kg). Source code in modules/flows_modules.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def flows_int_values ( sv , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the flows calculation. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- Pagc : float Global pressure in the anode gas channel (Pa). Pcgc : float Global pressure in the cathode gas channel (Pa). lambda_acl_mem : float Water content in the ACL and the membrane (kg/kg). \"\"\" # Extraction of the variables C_v_agc , C_v_ampl , C_v_acl = sv [ 'C_v_agc' ], sv [ 'C_v_ampl' ], sv [ 'C_v_acl' ] C_v_ccl , C_v_cmpl , C_v_cgc = sv [ 'C_v_ccl' ], sv [ 'C_v_cmpl' ], sv [ 'C_v_cgc' ] s_ampl , s_acl , s_ccl , s_cmpl = sv [ 's_ampl' ], sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 's_cmpl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_agc , C_H2_ampl , C_H2_acl = sv [ 'C_H2_agc' ], sv [ 'C_H2_ampl' ], sv [ 'C_H2_acl' ] C_O2_ccl , C_O2_cmpl , C_O2_cgc = sv [ 'C_O2_ccl' ], sv [ 'C_O2_cmpl' ], sv [ 'C_O2_cgc' ] C_N2 = sv [ 'C_N2' ] T_agc , T_ampl , T_acl , T_mem = sv [ 'T_agc' ], sv [ 'T_ampl' ], sv [ 'T_acl' ], sv [ 'T_mem' ] T_ccl , T_cmpl , T_cgc = sv [ 'T_ccl' ], sv [ 'T_cmpl' ], sv [ 'T_cgc' ] # Extraction of the operating inputs and the parameters epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] e , Hacl , Hccl , Hmem = parameters [ 'e' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'Hmem' ] Hgdl , Hmpl , Wagc , Wcgc = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Wagc' ], parameters [ 'Wcgc' ] Hagc , Hcgc , n_gdl = parameters [ 'Hagc' ], parameters [ 'Hcgc' ], parameters [ 'n_gdl' ] # Transitory parameter H_gdl_node = Hgdl / n_gdl # Pressures in the stack Pagc = ( C_v_agc + C_H2_agc ) * R * T_agc Pagdl = [ None ] + [( sv [ f 'C_v_agdl_ { i } ' ] + sv [ f 'C_H2_agdl_ { i } ' ]) * R * sv [ f 'T_agdl_ { i } ' ] for i in range ( 1 , n_gdl + 1 )] Pampl = ( C_v_ampl + C_H2_ampl ) * R * T_ampl Pacl = ( C_v_acl + C_H2_acl ) * R * T_acl Pccl = ( C_v_ccl + C_O2_ccl + C_N2 ) * R * T_ccl Pcmpl = ( C_v_cmpl + C_O2_cmpl + C_N2 ) * R * T_cmpl Pcgdl = [ None ] + [( sv [ f 'C_v_cgdl_ { i } ' ] + sv [ f 'C_O2_cgdl_ { i } ' ] + C_N2 ) * R * sv [ f 'T_cgdl_ { i } ' ] for i in range ( 1 , n_gdl + 1 )] Pcgc = ( C_v_cgc + C_O2_cgc + C_N2 ) * R * T_cgc # Weighted mean values ... # ... of the water content lambda_acl_mem = average ([ lambda_acl , lambda_mem ], weights = [ Hacl / ( Hacl + Hmem ), Hmem / ( Hacl + Hmem )]) lambda_mem_ccl = average ([ lambda_mem , lambda_ccl ], weights = [ Hmem / ( Hmem + Hccl ), Hccl / ( Hmem + Hccl )]) # ... of the diffusion coefficient of water in the membrane D_acl_mem = average ([ D ( lambda_acl ), D ( lambda_mem )], weights = [ Hacl / ( Hacl + Hmem ), Hmem / ( Hacl + Hmem )]) D_mem_ccl = average ([ D ( lambda_mem ), D ( lambda_ccl )], weights = [ Hmem / ( Hmem + Hccl ), Hccl / ( Hmem + Hccl )]) # ... of the capillary coefficient D_cap_agdl_agdl = [ None ] + [ average ([ Dcap ( 'gdl' , sv [ f 's_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'gdl' , sv [ f 's_agdl_ { i + 1 } ' ], sv [ f 'T_agdl_ { i + 1 } ' ], epsilon_gdl , e , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] D_cap_agdl_ampl = average ([ Dcap ( 'gdl' , sv [ f 's_agdl_ { n_gdl } ' ], sv [ f 'T_agdl_ { n_gdl } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'mpl' , s_ampl , T_ampl , epsilon_mpl , e )], weights = [ H_gdl_node / ( H_gdl_node + Hmpl ), Hmpl / ( H_gdl_node + Hmpl )]) D_cap_ampl_acl = average ([ Dcap ( 'mpl' , s_ampl , T_ampl , epsilon_mpl , e ), Dcap ( 'cl' , s_acl , T_acl , epsilon_cl , e )], weights = [ Hmpl / ( Hmpl + Hacl ), Hacl / ( Hmpl + Hacl )]) D_cap_cgdl_cgdl = [ None ] + [ average ([ Dcap ( 'gdl' , sv [ f 's_cgdl_ { i } ' ], sv [ f 'T_cgdl_ { i } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'gdl' , sv [ f 's_cgdl_ { i + 1 } ' ], sv [ f 'T_cgdl_ { i + 1 } ' ], epsilon_gdl , e , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] D_cap_cmpl_cgdl = average ([ Dcap ( 'mpl' , s_cmpl , T_cmpl , epsilon_mpl , e ), Dcap ( 'gdl' , sv [ 's_cgdl_1' ], sv [ 'T_cgdl_1' ], epsilon_gdl , e , epsilon_c = epsilon_c )], weights = [ Hmpl / ( H_gdl_node + Hmpl ), H_gdl_node / ( H_gdl_node + Hmpl )]) D_cap_ccl_cmpl = average ([ Dcap ( 'cl' , s_ccl , T_ccl , epsilon_cl , e ), Dcap ( 'mpl' , s_cmpl , T_cmpl , epsilon_mpl , e )], weights = [ Hccl / ( Hmpl + Hccl ), Hmpl / ( Hmpl + Hccl )]) # ... of the effective diffusion coefficient between the gas channel and the gas diffusion layer ha_Da_eff_agc_agdl = average ([ h_a ( Pagc , T_agc , Wagc , Hagc ) * Hagc , Da_eff ( 'gdl' , sv [ 's_agdl_1' ], sv [ 'T_agdl_1' ], Pagdl [ 1 ], epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hagc / ( Hagc + H_gdl_node ), H_gdl_node / ( Hagc + H_gdl_node )]) hc_Dc_eff_cgdl_cgc = average ([ h_c ( Pcgc , T_cgc , Wcgc , Hcgc ) * Hcgc , Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { n_gdl } ' ], sv [ f 'T_cgdl_ { n_gdl } ' ], Pcgdl [ n_gdl ], epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hcgc / ( Hcgc + H_gdl_node ), H_gdl_node / ( Hcgc + H_gdl_node )]) # ... of the effective diffusion coefficient Da_eff_agdl_agdl = [ None ] + [ average ([ Da_eff ( 'gdl' , sv [ f 's_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], Pagdl [ i ], epsilon_gdl , epsilon_c = epsilon_c ), Da_eff ( 'gdl' , sv [ f 's_agdl_ { i + 1 } ' ], sv [ f 'T_agdl_ { i + 1 } ' ], Pagdl [ i + 1 ], epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] Da_eff_agdl_ampl = average ([ Da_eff ( 'gdl' , sv [ f 's_agdl_ { n_gdl } ' ], sv [ f 'T_agdl_ { n_gdl } ' ], Pagdl [ n_gdl ], epsilon_gdl , epsilon_c = epsilon_c ), Da_eff ( 'mpl' , s_ampl , T_ampl , Pampl , epsilon_mpl )], weights = [ H_gdl_node / ( H_gdl_node + Hmpl ), Hmpl / ( H_gdl_node + Hmpl )]) Da_eff_ampl_acl = average ([ Da_eff ( 'mpl' , s_ampl , T_ampl , Pampl , epsilon_mpl ), Da_eff ( 'cl' , s_acl , T_acl , Pacl , epsilon_cl )], weights = [ Hmpl / ( Hmpl + Hacl ), Hacl / ( Hmpl + Hacl )]) Dc_eff_cgdl_cgdl = [ None ] + [ average ([ Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { i } ' ], sv [ f 'T_cgdl_ { i } ' ], Pcgdl [ i ], epsilon_gdl , epsilon_c = epsilon_c ), Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { i + 1 } ' ], sv [ f 'T_cgdl_ { i + 1 } ' ], Pcgdl [ i + 1 ], epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] Dc_eff_cmpl_cgdl = average ([ Dc_eff ( 'mpl' , s_cmpl , T_cmpl , Pcmpl , epsilon_mpl ), Dc_eff ( 'gdl' , sv [ 's_cgdl_1' ], sv [ 'T_cgdl_1' ], Pcgdl [ 1 ], epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hmpl / ( H_gdl_node + Hmpl ), H_gdl_node / ( H_gdl_node + Hmpl )]) Dc_eff_ccl_cmpl = average ([ Dc_eff ( 'cl' , s_ccl , T_ccl , Pccl , epsilon_cl ), Dc_eff ( 'mpl' , s_cmpl , T_cmpl , Pcmpl , epsilon_mpl )], weights = [ Hccl / ( Hmpl + Hccl ), Hmpl / ( Hmpl + Hccl )]) # ... of the temperature T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) return ( H_gdl_node , Pagc , Pcgc , lambda_acl_mem , lambda_mem_ccl , D_acl_mem , D_mem_ccl , D_cap_agdl_agdl , D_cap_agdl_ampl , D_cap_ampl_acl , D_cap_cgdl_cgdl , D_cap_cmpl_cgdl , D_cap_ccl_cmpl , ha_Da_eff_agc_agdl , hc_Dc_eff_cgdl_cgc , Da_eff_agdl_agdl , Da_eff_agdl_ampl , Da_eff_ampl_acl , Dc_eff_cgdl_cgdl , Dc_eff_cmpl_cgdl , Dc_eff_ccl_cmpl , T_acl_mem_ccl )","title":"Flows modules"},{"location":"functions/modules/flows_modules/#flows-modules","text":"This module is used to calculate intermediate values for the flows calculation.","title":"Flows modules"},{"location":"functions/modules/flows_modules/#modules.flows_modules.flows_int_values","text":"This functions calculates intermediate values for the flows calculation. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Pagc ( float ) \u2013 Global pressure in the anode gas channel (Pa). Pcgc ( float ) \u2013 Global pressure in the cathode gas channel (Pa). lambda_acl_mem ( float ) \u2013 Water content in the ACL and the membrane (kg/kg). Source code in modules/flows_modules.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def flows_int_values ( sv , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the flows calculation. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- Pagc : float Global pressure in the anode gas channel (Pa). Pcgc : float Global pressure in the cathode gas channel (Pa). lambda_acl_mem : float Water content in the ACL and the membrane (kg/kg). \"\"\" # Extraction of the variables C_v_agc , C_v_ampl , C_v_acl = sv [ 'C_v_agc' ], sv [ 'C_v_ampl' ], sv [ 'C_v_acl' ] C_v_ccl , C_v_cmpl , C_v_cgc = sv [ 'C_v_ccl' ], sv [ 'C_v_cmpl' ], sv [ 'C_v_cgc' ] s_ampl , s_acl , s_ccl , s_cmpl = sv [ 's_ampl' ], sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 's_cmpl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_agc , C_H2_ampl , C_H2_acl = sv [ 'C_H2_agc' ], sv [ 'C_H2_ampl' ], sv [ 'C_H2_acl' ] C_O2_ccl , C_O2_cmpl , C_O2_cgc = sv [ 'C_O2_ccl' ], sv [ 'C_O2_cmpl' ], sv [ 'C_O2_cgc' ] C_N2 = sv [ 'C_N2' ] T_agc , T_ampl , T_acl , T_mem = sv [ 'T_agc' ], sv [ 'T_ampl' ], sv [ 'T_acl' ], sv [ 'T_mem' ] T_ccl , T_cmpl , T_cgc = sv [ 'T_ccl' ], sv [ 'T_cmpl' ], sv [ 'T_cgc' ] # Extraction of the operating inputs and the parameters epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] e , Hacl , Hccl , Hmem = parameters [ 'e' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'Hmem' ] Hgdl , Hmpl , Wagc , Wcgc = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Wagc' ], parameters [ 'Wcgc' ] Hagc , Hcgc , n_gdl = parameters [ 'Hagc' ], parameters [ 'Hcgc' ], parameters [ 'n_gdl' ] # Transitory parameter H_gdl_node = Hgdl / n_gdl # Pressures in the stack Pagc = ( C_v_agc + C_H2_agc ) * R * T_agc Pagdl = [ None ] + [( sv [ f 'C_v_agdl_ { i } ' ] + sv [ f 'C_H2_agdl_ { i } ' ]) * R * sv [ f 'T_agdl_ { i } ' ] for i in range ( 1 , n_gdl + 1 )] Pampl = ( C_v_ampl + C_H2_ampl ) * R * T_ampl Pacl = ( C_v_acl + C_H2_acl ) * R * T_acl Pccl = ( C_v_ccl + C_O2_ccl + C_N2 ) * R * T_ccl Pcmpl = ( C_v_cmpl + C_O2_cmpl + C_N2 ) * R * T_cmpl Pcgdl = [ None ] + [( sv [ f 'C_v_cgdl_ { i } ' ] + sv [ f 'C_O2_cgdl_ { i } ' ] + C_N2 ) * R * sv [ f 'T_cgdl_ { i } ' ] for i in range ( 1 , n_gdl + 1 )] Pcgc = ( C_v_cgc + C_O2_cgc + C_N2 ) * R * T_cgc # Weighted mean values ... # ... of the water content lambda_acl_mem = average ([ lambda_acl , lambda_mem ], weights = [ Hacl / ( Hacl + Hmem ), Hmem / ( Hacl + Hmem )]) lambda_mem_ccl = average ([ lambda_mem , lambda_ccl ], weights = [ Hmem / ( Hmem + Hccl ), Hccl / ( Hmem + Hccl )]) # ... of the diffusion coefficient of water in the membrane D_acl_mem = average ([ D ( lambda_acl ), D ( lambda_mem )], weights = [ Hacl / ( Hacl + Hmem ), Hmem / ( Hacl + Hmem )]) D_mem_ccl = average ([ D ( lambda_mem ), D ( lambda_ccl )], weights = [ Hmem / ( Hmem + Hccl ), Hccl / ( Hmem + Hccl )]) # ... of the capillary coefficient D_cap_agdl_agdl = [ None ] + [ average ([ Dcap ( 'gdl' , sv [ f 's_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'gdl' , sv [ f 's_agdl_ { i + 1 } ' ], sv [ f 'T_agdl_ { i + 1 } ' ], epsilon_gdl , e , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] D_cap_agdl_ampl = average ([ Dcap ( 'gdl' , sv [ f 's_agdl_ { n_gdl } ' ], sv [ f 'T_agdl_ { n_gdl } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'mpl' , s_ampl , T_ampl , epsilon_mpl , e )], weights = [ H_gdl_node / ( H_gdl_node + Hmpl ), Hmpl / ( H_gdl_node + Hmpl )]) D_cap_ampl_acl = average ([ Dcap ( 'mpl' , s_ampl , T_ampl , epsilon_mpl , e ), Dcap ( 'cl' , s_acl , T_acl , epsilon_cl , e )], weights = [ Hmpl / ( Hmpl + Hacl ), Hacl / ( Hmpl + Hacl )]) D_cap_cgdl_cgdl = [ None ] + [ average ([ Dcap ( 'gdl' , sv [ f 's_cgdl_ { i } ' ], sv [ f 'T_cgdl_ { i } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'gdl' , sv [ f 's_cgdl_ { i + 1 } ' ], sv [ f 'T_cgdl_ { i + 1 } ' ], epsilon_gdl , e , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] D_cap_cmpl_cgdl = average ([ Dcap ( 'mpl' , s_cmpl , T_cmpl , epsilon_mpl , e ), Dcap ( 'gdl' , sv [ 's_cgdl_1' ], sv [ 'T_cgdl_1' ], epsilon_gdl , e , epsilon_c = epsilon_c )], weights = [ Hmpl / ( H_gdl_node + Hmpl ), H_gdl_node / ( H_gdl_node + Hmpl )]) D_cap_ccl_cmpl = average ([ Dcap ( 'cl' , s_ccl , T_ccl , epsilon_cl , e ), Dcap ( 'mpl' , s_cmpl , T_cmpl , epsilon_mpl , e )], weights = [ Hccl / ( Hmpl + Hccl ), Hmpl / ( Hmpl + Hccl )]) # ... of the effective diffusion coefficient between the gas channel and the gas diffusion layer ha_Da_eff_agc_agdl = average ([ h_a ( Pagc , T_agc , Wagc , Hagc ) * Hagc , Da_eff ( 'gdl' , sv [ 's_agdl_1' ], sv [ 'T_agdl_1' ], Pagdl [ 1 ], epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hagc / ( Hagc + H_gdl_node ), H_gdl_node / ( Hagc + H_gdl_node )]) hc_Dc_eff_cgdl_cgc = average ([ h_c ( Pcgc , T_cgc , Wcgc , Hcgc ) * Hcgc , Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { n_gdl } ' ], sv [ f 'T_cgdl_ { n_gdl } ' ], Pcgdl [ n_gdl ], epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hcgc / ( Hcgc + H_gdl_node ), H_gdl_node / ( Hcgc + H_gdl_node )]) # ... of the effective diffusion coefficient Da_eff_agdl_agdl = [ None ] + [ average ([ Da_eff ( 'gdl' , sv [ f 's_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], Pagdl [ i ], epsilon_gdl , epsilon_c = epsilon_c ), Da_eff ( 'gdl' , sv [ f 's_agdl_ { i + 1 } ' ], sv [ f 'T_agdl_ { i + 1 } ' ], Pagdl [ i + 1 ], epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] Da_eff_agdl_ampl = average ([ Da_eff ( 'gdl' , sv [ f 's_agdl_ { n_gdl } ' ], sv [ f 'T_agdl_ { n_gdl } ' ], Pagdl [ n_gdl ], epsilon_gdl , epsilon_c = epsilon_c ), Da_eff ( 'mpl' , s_ampl , T_ampl , Pampl , epsilon_mpl )], weights = [ H_gdl_node / ( H_gdl_node + Hmpl ), Hmpl / ( H_gdl_node + Hmpl )]) Da_eff_ampl_acl = average ([ Da_eff ( 'mpl' , s_ampl , T_ampl , Pampl , epsilon_mpl ), Da_eff ( 'cl' , s_acl , T_acl , Pacl , epsilon_cl )], weights = [ Hmpl / ( Hmpl + Hacl ), Hacl / ( Hmpl + Hacl )]) Dc_eff_cgdl_cgdl = [ None ] + [ average ([ Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { i } ' ], sv [ f 'T_cgdl_ { i } ' ], Pcgdl [ i ], epsilon_gdl , epsilon_c = epsilon_c ), Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { i + 1 } ' ], sv [ f 'T_cgdl_ { i + 1 } ' ], Pcgdl [ i + 1 ], epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] Dc_eff_cmpl_cgdl = average ([ Dc_eff ( 'mpl' , s_cmpl , T_cmpl , Pcmpl , epsilon_mpl ), Dc_eff ( 'gdl' , sv [ 's_cgdl_1' ], sv [ 'T_cgdl_1' ], Pcgdl [ 1 ], epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hmpl / ( H_gdl_node + Hmpl ), H_gdl_node / ( H_gdl_node + Hmpl )]) Dc_eff_ccl_cmpl = average ([ Dc_eff ( 'cl' , s_ccl , T_ccl , Pccl , epsilon_cl ), Dc_eff ( 'mpl' , s_cmpl , T_cmpl , Pcmpl , epsilon_mpl )], weights = [ Hccl / ( Hmpl + Hccl ), Hmpl / ( Hmpl + Hccl )]) # ... of the temperature T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) return ( H_gdl_node , Pagc , Pcgc , lambda_acl_mem , lambda_mem_ccl , D_acl_mem , D_mem_ccl , D_cap_agdl_agdl , D_cap_agdl_ampl , D_cap_ampl_acl , D_cap_cgdl_cgdl , D_cap_cmpl_cgdl , D_cap_ccl_cmpl , ha_Da_eff_agc_agdl , hc_Dc_eff_cgdl_cgc , Da_eff_agdl_agdl , Da_eff_agdl_ampl , Da_eff_ampl_acl , Dc_eff_cgdl_cgdl , Dc_eff_cmpl_cgdl , Dc_eff_ccl_cmpl , T_acl_mem_ccl )","title":"flows_int_values"},{"location":"functions/modules/heat_modules/","text":"Heat modules This module is used to calculate intermediate values for the heat transfer calculation. heat_transfer_int_values ( sv , parameters ) This functions calculates intermediate values for the heat calculation. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: k_th_eff_agc_agdl ( float ) \u2013 Effective thermal diffusivity between the AGC and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_agdl_agdl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent GDL layers on the anode side (J.m-1.s-1.K-1). k_th_eff_agdl_ampl ( float ) \u2013 Effective thermal diffusivity between the last GDL layer and the anode microporous layer (J.m-1.s-1.K-1). k_th_eff_ampl_acl ( float ) \u2013 Effective thermal diffusivity between the anode microporous layer and the anode catalyst layer (J.m-1.s-1.K-1). k_th_eff_acl_mem ( float ) \u2013 Effective thermal diffusivity between the anode catalyst layer and the membrane (J.m-1.s-1.K-1). k_th_eff_mem_ccl ( float ) \u2013 Effective thermal diffusivity between the membrane and the cathode catalyst layer (J.m-1.s-1.K-1). k_th_eff_ccl_cmpl ( float ) \u2013 Effective thermal diffusivity between the cathode catalyst layer and the cathode microporous layer (J.m-1.s-1.K-1). k_th_eff_cmpl_cgdl ( float ) \u2013 Effective thermal diffusivity between the cathode microporous layer and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_cgdl_cgdl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent GDL layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cgdl_cgc ( float ) \u2013 Effective thermal diffusivity between the last GDL layer and the CGC (J.m-1.s-1.K-1). Source code in modules/heat_modules.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def heat_transfer_int_values ( sv , parameters ): \"\"\"This functions calculates intermediate values for the heat calculation. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. parameters : dict Parameters of the fuel cell model. Returns ------- k_th_eff_agc_agdl : float Effective thermal diffusivity between the AGC and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_agdl_agdl : list of floats List of effective thermal diffusivities between adjacent GDL layers on the anode side (J.m-1.s-1.K-1). k_th_eff_agdl_ampl : float Effective thermal diffusivity between the last GDL layer and the anode microporous layer (J.m-1.s-1.K-1). k_th_eff_ampl_acl : float Effective thermal diffusivity between the anode microporous layer and the anode catalyst layer (J.m-1.s-1.K-1). k_th_eff_acl_mem : float Effective thermal diffusivity between the anode catalyst layer and the membrane (J.m-1.s-1.K-1). k_th_eff_mem_ccl : float Effective thermal diffusivity between the membrane and the cathode catalyst layer (J.m-1.s-1.K-1). k_th_eff_ccl_cmpl : float Effective thermal diffusivity between the cathode catalyst layer and the cathode microporous layer (J.m-1.s-1.K-1). k_th_eff_cmpl_cgdl : float Effective thermal diffusivity between the cathode microporous layer and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_cgdl_cgdl : list of floats List of effective thermal diffusivities between adjacent GDL layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cgdl_cgc : float Effective thermal diffusivity between the last GDL layer and the CGC (J.m-1.s-1.K-1). \"\"\" # Extraction of the variables C_v_acl , C_v_ampl , C_v_ccl , C_v_cmpl = sv [ 'C_v_acl' ], sv [ 'C_v_ampl' ], sv [ 'C_v_ccl' ], sv [ 'C_v_cmpl' ] s_acl , s_ampl , s_ccl , s_cmpl = sv [ 's_acl' ], sv [ 's_ampl' ], sv [ 's_ccl' ], sv [ 's_cmpl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_ampl , C_H2_acl , C_O2_ccl , C_O2_cmpl = sv [ 'C_H2_ampl' ], sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ], sv [ 'C_O2_cmpl' ] C_N2 = sv [ 'C_N2' ] T_acl , T_ampl , T_mem , T_ccl , T_cmpl = sv [ 'T_acl' ], sv [ 'T_ampl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ], sv [ 'T_cmpl' ] # Extraction of the operating inputs and the parameters Hgdl , Hmpl , Hacl , Hccl = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] Hmem , epsilon_mc , epsilon_gdl = parameters [ 'Hmem' ], parameters [ 'epsilon_mc' ], parameters [ 'epsilon_gdl' ] epsilon_cl , epsilon_mpl = parameters [ 'epsilon_cl' ], parameters [ 'epsilon_mpl' ] epsilon_c , n_gdl = parameters [ 'epsilon_c' ], parameters [ 'n_gdl' ] # Weighted harmonic means of the effective thermal diffusivity k_th_eff_agc_agdl = k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { 1 } ' ], C_v = sv [ f 'C_v_agdl_ { 1 } ' ], s = sv [ f 's_agdl_ { 1 } ' ], C_H2 = sv [ f 'C_H2_agdl_ { 1 } ' ], epsilon = epsilon_gdl , epsilon_c = epsilon_c ) k_th_eff_agdl_agdl = [ None ] + [ average ([ k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], s = sv [ f 's_agdl_ { i } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i } ' ], epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { i + 1 } ' ], C_v = sv [ f 'C_v_agdl_ { i + 1 } ' ], s = sv [ f 's_agdl_ { i + 1 } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i + 1 } ' ], epsilon = epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] k_th_eff_agdl_ampl = average ([ k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { n_gdl } ' ], C_v = sv [ f 'C_v_agdl_ { n_gdl } ' ], s = sv [ f 's_agdl_ { n_gdl } ' ], C_H2 = sv [ f 'C_H2_agdl_ { n_gdl } ' ], epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'ampl' , T_ampl , C_v = C_v_ampl , s = s_ampl , C_H2 = C_H2_ampl , epsilon = epsilon_mpl )], weights = [ Hgdl / 2 , Hmpl / 2 ]) k_th_eff_ampl_acl = average ([ k_th_eff ( 'ampl' , T_ampl , C_v = C_v_ampl , s = s_ampl , C_H2 = C_H2_ampl , epsilon = epsilon_mpl ), k_th_eff ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , epsilon = epsilon_cl , epsilon_mc = epsilon_mc )], weights = [ Hmpl / 2 , Hacl / 2 ]) k_th_eff_acl_mem = average ([ k_th_eff ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'mem' , T_mem , lambdaa = lambda_mem )], weights = [ Hacl / 2 , Hmem / 2 ]) k_th_eff_mem_ccl = average ([ k_th_eff ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2 , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'mem' , T_mem , lambdaa = lambda_mem )], weights = [ Hccl / 2 , Hmem / 2 ]) k_th_eff_ccl_cmpl = average ([ k_th_eff ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2 , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'cmpl' , T_cmpl , C_v = C_v_cmpl , s = s_cmpl , C_O2 = C_O2_cmpl , C_N2 = C_N2 , epsilon = epsilon_mpl )], weights = [ Hccl / 2 , Hmpl / 2 ]) k_th_eff_cmpl_cgdl = average ([ k_th_eff ( 'cmpl' , T_cmpl , C_v = C_v_cmpl , s = s_cmpl , C_O2 = C_O2_cmpl , C_N2 = C_N2 , epsilon = epsilon_mpl ), k_th_eff ( 'cgdl' , sv [ 'T_cgdl_1' ], C_v = sv [ 'C_v_cgdl_1' ], s = sv [ 's_cgdl_1' ], C_O2 = sv [ f 'C_O2_cgdl_1' ], C_N2 = C_N2 , epsilon = epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hmpl / 2 , Hgdl / 2 ]) k_th_eff_cgdl_cgdl = [ None ] + [ average ([ k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], s = sv [ f 's_cgdl_ { i } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i } ' ], C_N2 = C_N2 , epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { i + 1 } ' ], C_v = sv [ f 'C_v_cgdl_ { i + 1 } ' ], s = sv [ f 's_cgdl_ { i + 1 } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i + 1 } ' ], C_N2 = C_N2 , epsilon = epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] k_th_eff_cgdl_cgc = k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { n_gdl } ' ], C_v = sv [ f 'C_v_cgdl_ { n_gdl } ' ], s = sv [ f 's_cgdl_ { n_gdl } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { n_gdl } ' ], C_N2 = C_N2 , epsilon = epsilon_gdl , epsilon_c = epsilon_c ) return ( k_th_eff_agc_agdl , k_th_eff_agdl_agdl , k_th_eff_agdl_ampl , k_th_eff_ampl_acl , k_th_eff_acl_mem , k_th_eff_mem_ccl , k_th_eff_ccl_cmpl , k_th_eff_cmpl_cgdl , k_th_eff_cgdl_cgdl , k_th_eff_cgdl_cgc )","title":"Heat modules"},{"location":"functions/modules/heat_modules/#heat-modules","text":"This module is used to calculate intermediate values for the heat transfer calculation.","title":"Heat modules"},{"location":"functions/modules/heat_modules/#modules.heat_modules.heat_transfer_int_values","text":"This functions calculates intermediate values for the heat calculation. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: k_th_eff_agc_agdl ( float ) \u2013 Effective thermal diffusivity between the AGC and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_agdl_agdl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent GDL layers on the anode side (J.m-1.s-1.K-1). k_th_eff_agdl_ampl ( float ) \u2013 Effective thermal diffusivity between the last GDL layer and the anode microporous layer (J.m-1.s-1.K-1). k_th_eff_ampl_acl ( float ) \u2013 Effective thermal diffusivity between the anode microporous layer and the anode catalyst layer (J.m-1.s-1.K-1). k_th_eff_acl_mem ( float ) \u2013 Effective thermal diffusivity between the anode catalyst layer and the membrane (J.m-1.s-1.K-1). k_th_eff_mem_ccl ( float ) \u2013 Effective thermal diffusivity between the membrane and the cathode catalyst layer (J.m-1.s-1.K-1). k_th_eff_ccl_cmpl ( float ) \u2013 Effective thermal diffusivity between the cathode catalyst layer and the cathode microporous layer (J.m-1.s-1.K-1). k_th_eff_cmpl_cgdl ( float ) \u2013 Effective thermal diffusivity between the cathode microporous layer and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_cgdl_cgdl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent GDL layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cgdl_cgc ( float ) \u2013 Effective thermal diffusivity between the last GDL layer and the CGC (J.m-1.s-1.K-1). Source code in modules/heat_modules.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def heat_transfer_int_values ( sv , parameters ): \"\"\"This functions calculates intermediate values for the heat calculation. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. parameters : dict Parameters of the fuel cell model. Returns ------- k_th_eff_agc_agdl : float Effective thermal diffusivity between the AGC and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_agdl_agdl : list of floats List of effective thermal diffusivities between adjacent GDL layers on the anode side (J.m-1.s-1.K-1). k_th_eff_agdl_ampl : float Effective thermal diffusivity between the last GDL layer and the anode microporous layer (J.m-1.s-1.K-1). k_th_eff_ampl_acl : float Effective thermal diffusivity between the anode microporous layer and the anode catalyst layer (J.m-1.s-1.K-1). k_th_eff_acl_mem : float Effective thermal diffusivity between the anode catalyst layer and the membrane (J.m-1.s-1.K-1). k_th_eff_mem_ccl : float Effective thermal diffusivity between the membrane and the cathode catalyst layer (J.m-1.s-1.K-1). k_th_eff_ccl_cmpl : float Effective thermal diffusivity between the cathode catalyst layer and the cathode microporous layer (J.m-1.s-1.K-1). k_th_eff_cmpl_cgdl : float Effective thermal diffusivity between the cathode microporous layer and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_cgdl_cgdl : list of floats List of effective thermal diffusivities between adjacent GDL layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cgdl_cgc : float Effective thermal diffusivity between the last GDL layer and the CGC (J.m-1.s-1.K-1). \"\"\" # Extraction of the variables C_v_acl , C_v_ampl , C_v_ccl , C_v_cmpl = sv [ 'C_v_acl' ], sv [ 'C_v_ampl' ], sv [ 'C_v_ccl' ], sv [ 'C_v_cmpl' ] s_acl , s_ampl , s_ccl , s_cmpl = sv [ 's_acl' ], sv [ 's_ampl' ], sv [ 's_ccl' ], sv [ 's_cmpl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_ampl , C_H2_acl , C_O2_ccl , C_O2_cmpl = sv [ 'C_H2_ampl' ], sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ], sv [ 'C_O2_cmpl' ] C_N2 = sv [ 'C_N2' ] T_acl , T_ampl , T_mem , T_ccl , T_cmpl = sv [ 'T_acl' ], sv [ 'T_ampl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ], sv [ 'T_cmpl' ] # Extraction of the operating inputs and the parameters Hgdl , Hmpl , Hacl , Hccl = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] Hmem , epsilon_mc , epsilon_gdl = parameters [ 'Hmem' ], parameters [ 'epsilon_mc' ], parameters [ 'epsilon_gdl' ] epsilon_cl , epsilon_mpl = parameters [ 'epsilon_cl' ], parameters [ 'epsilon_mpl' ] epsilon_c , n_gdl = parameters [ 'epsilon_c' ], parameters [ 'n_gdl' ] # Weighted harmonic means of the effective thermal diffusivity k_th_eff_agc_agdl = k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { 1 } ' ], C_v = sv [ f 'C_v_agdl_ { 1 } ' ], s = sv [ f 's_agdl_ { 1 } ' ], C_H2 = sv [ f 'C_H2_agdl_ { 1 } ' ], epsilon = epsilon_gdl , epsilon_c = epsilon_c ) k_th_eff_agdl_agdl = [ None ] + [ average ([ k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], s = sv [ f 's_agdl_ { i } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i } ' ], epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { i + 1 } ' ], C_v = sv [ f 'C_v_agdl_ { i + 1 } ' ], s = sv [ f 's_agdl_ { i + 1 } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i + 1 } ' ], epsilon = epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] k_th_eff_agdl_ampl = average ([ k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { n_gdl } ' ], C_v = sv [ f 'C_v_agdl_ { n_gdl } ' ], s = sv [ f 's_agdl_ { n_gdl } ' ], C_H2 = sv [ f 'C_H2_agdl_ { n_gdl } ' ], epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'ampl' , T_ampl , C_v = C_v_ampl , s = s_ampl , C_H2 = C_H2_ampl , epsilon = epsilon_mpl )], weights = [ Hgdl / 2 , Hmpl / 2 ]) k_th_eff_ampl_acl = average ([ k_th_eff ( 'ampl' , T_ampl , C_v = C_v_ampl , s = s_ampl , C_H2 = C_H2_ampl , epsilon = epsilon_mpl ), k_th_eff ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , epsilon = epsilon_cl , epsilon_mc = epsilon_mc )], weights = [ Hmpl / 2 , Hacl / 2 ]) k_th_eff_acl_mem = average ([ k_th_eff ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'mem' , T_mem , lambdaa = lambda_mem )], weights = [ Hacl / 2 , Hmem / 2 ]) k_th_eff_mem_ccl = average ([ k_th_eff ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2 , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'mem' , T_mem , lambdaa = lambda_mem )], weights = [ Hccl / 2 , Hmem / 2 ]) k_th_eff_ccl_cmpl = average ([ k_th_eff ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2 , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'cmpl' , T_cmpl , C_v = C_v_cmpl , s = s_cmpl , C_O2 = C_O2_cmpl , C_N2 = C_N2 , epsilon = epsilon_mpl )], weights = [ Hccl / 2 , Hmpl / 2 ]) k_th_eff_cmpl_cgdl = average ([ k_th_eff ( 'cmpl' , T_cmpl , C_v = C_v_cmpl , s = s_cmpl , C_O2 = C_O2_cmpl , C_N2 = C_N2 , epsilon = epsilon_mpl ), k_th_eff ( 'cgdl' , sv [ 'T_cgdl_1' ], C_v = sv [ 'C_v_cgdl_1' ], s = sv [ 's_cgdl_1' ], C_O2 = sv [ f 'C_O2_cgdl_1' ], C_N2 = C_N2 , epsilon = epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hmpl / 2 , Hgdl / 2 ]) k_th_eff_cgdl_cgdl = [ None ] + [ average ([ k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], s = sv [ f 's_cgdl_ { i } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i } ' ], C_N2 = C_N2 , epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { i + 1 } ' ], C_v = sv [ f 'C_v_cgdl_ { i + 1 } ' ], s = sv [ f 's_cgdl_ { i + 1 } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i + 1 } ' ], C_N2 = C_N2 , epsilon = epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , n_gdl )] k_th_eff_cgdl_cgc = k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { n_gdl } ' ], C_v = sv [ f 'C_v_cgdl_ { n_gdl } ' ], s = sv [ f 's_cgdl_ { n_gdl } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { n_gdl } ' ], C_N2 = C_N2 , epsilon = epsilon_gdl , epsilon_c = epsilon_c ) return ( k_th_eff_agc_agdl , k_th_eff_agdl_agdl , k_th_eff_agdl_ampl , k_th_eff_ampl_acl , k_th_eff_acl_mem , k_th_eff_mem_ccl , k_th_eff_ccl_cmpl , k_th_eff_cmpl_cgdl , k_th_eff_cgdl_cgdl , k_th_eff_cgdl_cgc )","title":"heat_transfer_int_values"},{"location":"functions/modules/main_modules/","text":"Main modules This module contains some of the required functions for the main.py file. figures_preparation ( computing_parameters ) This function create the required figures and axes according to the type_current and type_display. Parameters: computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Returns: fig1 ( Figure ) \u2013 Figure for the first plot. ax1 ( AxesSubplot ) \u2013 Axes for the first plot. fig2 ( Figure ) \u2013 Figure for the second plot. ax2 ( AxesSubplot ) \u2013 Axes for the second plot. Source code in modules/main_modules.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def figures_preparation ( computing_parameters ): \"\"\" This function create the required figures and axes according to the type_current and type_display. Parameters ---------- computing_parameters : dict Dictionary containing the computing parameters for the simulation. Returns ------- fig1 : matplotlib.figure.Figure Figure for the first plot. ax1 : matplotlib.axes._subplots.AxesSubplot Axes for the first plot. fig2 : matplotlib.figure.Figure Figure for the second plot. ax2 : matplotlib.axes._subplots.AxesSubplot Axes for the second plot. \"\"\" mpl . rcParams [ 'font.family' ] = 'cmr10' # 'cmr10' for English characters and 'DejaVu Serif' for French ones mpl . rcParams [ 'axes.formatter.use_mathtext' ] = True # For the scientific notation mpl . rcParams [ 'lines.linewidth' ] = 2.0 mpl . rcParams [ 'lines.markersize' ] = 5.0 if computing_parameters [ 'type_display' ] == \"no_display\" : fig1 , ax1 = None , None fig2 , ax2 = None , None fig3 , ax3 = None , None # For the step current if computing_parameters [ 'type_current' ] == \"step\" : if computing_parameters [ 'type_display' ] == \"multiple\" : # saving instruction is directly implemented within AlphaPEM.Display here. mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = None , None # Here, additional plots are unnecessary fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 13 # Font size for all text fig1 , ax1 = plt . subplots ( 3 , 3 , figsize = ( 14 , 14 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) # For the polarization curve elif computing_parameters [ 'type_current' ] == \"polarization\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary # For the polarization curve used for the calibration elif computing_parameters [ 'type_current' ] == \"polarization_for_cali\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary # For the EIS curve elif computing_parameters [ 'type_current' ] == \"EIS\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = plt . subplots ( figsize = ( 8 , 8 )) fig3 , ax3 = plt . subplots ( figsize = ( 8 , 8 )) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 13 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) return fig1 , ax1 , fig2 , ax2 , fig3 , ax3 launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 def launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Check if the computing_parameters['type_current'] is valid if computing_parameters [ 'type_plot' ] != \"dynamic\" : raise ValueError ( 'EIS has to be plot with a dynamic type_plot setting, ' 'because max_step has to be adjusted at each frequency.' ) # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None t0_EIS , t_new_start , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = current_parameters [ 't_EIS' ] f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = current_parameters [ 'f_EIS' ] # These are used for EIS max_step # actualization. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested. n = len ( t_new_start ) # It is the plot update number. time_interval = [ 0 , t0_EIS ] # It is the initial time interval. # A preliminary simulation run is necessary to equilibrate the internal variables of the cell at i_EIS # prior to initiating the EIS. Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization t0_EIS_temp = t0_EIS # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ 0 ] + delta_t_break_EIS [ 0 ] + delta_t_measurement_EIS [ 0 ] # It is the final time for # 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which has been # made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) if computing_parameters [ 'type_display' ] == \"multiple\" : print ( \"A display bug prevents the dynamic updating of the graphs, as it appears that too much data is \" \"involved. However, the data is correctly calculated, and the appropriate plots are saved in the \" \"'results' folder. This display bug does not occur when using a 'synthetic' type_display.\" ) # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_EIS_temp = Simulator . variables [ 't' ][ - 1 ] # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ i + 1 ] + delta_t_break_EIS [ i + 1 ] + delta_t_measurement_EIS [ i + 1 ] # It # is the final time for 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which # has been made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # It is the time interval for 1 EIS point. # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Condition to fill for the comparison with experimental values if computing_parameters [ 'type_fuel_cell' ][ 1 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 1 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_1 , U_exp_t_1 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 1 ]) if current_parameters [ 'pola_current_parameters' ][ 1 ][ 'i_max_pola' ] < i_exp_t_1 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_1 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 2 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_2 , U_exp_t_2 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 2 ]) if current_parameters [ 'pola_current_parameters' ][ 2 ][ 'i_max_pola' ] < i_exp_t_2 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_2 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 3 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_3 , U_exp_t_3 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 3 ]) if current_parameters [ 'pola_current_parameters' ][ 3 ][ 'i_max_pola' ] < i_exp_t_3 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_3 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 4 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_4 , U_exp_t_4 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 4 ]) if current_parameters [ 'pola_current_parameters' ][ 4 ][ 'i_max_pola' ] < i_exp_t_4 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_4 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Certain conditions must be met. if ( computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None ): raise ValueError ( 'dynamic plot is not currently intended for use with different inputs.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_load_pola' ] # (s). delta_t_break_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_break_pola' ] # (s). delta_i_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_i_pola' ] # (A.m-2). i_max_pola_1 = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'i_max_pola_1' ] # (A.m-2). # Calculation delta_t_pola = delta_t_load_pola + delta_t_break_pola # s. It is the time of one load. tf = delta_t_ini_pola + int ( i_max_pola_1 / delta_i_pola ) * delta_t_pola # s. It is the polarization current duration. n = int ( tf / delta_t_pola ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola + delta_t_pola ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 ), initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator_1 . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola + ( i + 2 ) * delta_t_pola time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator_1 . solver_variable_names : initial_variable_values . append ( Simulator_1 . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 )) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 = AlphaPEM ( select_nth_elements ( operating_inputs , 2 ), select_nth_elements ( current_parameters , 2 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 2 )) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 = AlphaPEM ( select_nth_elements ( operating_inputs , 3 ), select_nth_elements ( current_parameters , 3 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 3 )) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 = AlphaPEM ( select_nth_elements ( operating_inputs , 4 ), select_nth_elements ( current_parameters , 4 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 4 )) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator_1 . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) launch_AlphaPEM_for_polarization_current_for_calibration ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a polarization current density made for the calibration of the undetermined parameters, and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def launch_AlphaPEM_for_polarization_current_for_calibration ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density made for the calibration of the undetermined parameters, and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Certain conditions must be met. if ( computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None ): raise ValueError ( 'dynamic plot is not currently intended for use with different inputs.' ) if computing_parameters [ 'type_current' ] == \"polarization_for_cali\" : raise ValueError ( 'calibration should not use dynamic plot, as it is not intended for real-time display.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_ini_pola_cali' ] # (s). delta_t_load_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_load_pola_cali' ] # (s). delta_t_break_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_break_pola_cali' ] # (s). i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( computing_parameters [ 'type_fuel_cell' ][ 1 ]) # (A.m-2, V). # Calculation delta_t_pola_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. tf = delta_t_ini_pola_cali + len ( i_exp_cali_t ) * delta_t_pola_cali # s. It is the polarization current duration. n = int ( tf / delta_t_pola_cali ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola_cali + delta_t_pola_cali ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 ), initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator_1 . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola_cali + ( i + 2 ) * delta_t_pola_cali time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator_1 . solver_variable_names : initial_variable_values . append ( Simulator_1 . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Certain conditions must be met. if ( computing_parameters [ 'type_current' ] == \"polarization_for_cali\" and ( computing_parameters [ 'type_fuel_cell' ][ 1 ] == \"manual_setup\" or \\ computing_parameters [ 'type_auxiliary' ] != \"forced-convective_cathode_with_flow-through_anode\" )): raise ValueError ( 'polarization current for calibration should be done with experimental data.' ) # Simulation Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 )) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 = AlphaPEM ( select_nth_elements ( operating_inputs , 2 ), select_nth_elements ( current_parameters , 2 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 2 )) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 = AlphaPEM ( select_nth_elements ( operating_inputs , 3 ), select_nth_elements ( current_parameters , 3 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 3 )) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 = AlphaPEM ( select_nth_elements ( operating_inputs , 4 ), select_nth_elements ( current_parameters , 4 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 4 )) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator_1 . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a step current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a step current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Certain conditions must be met. if computing_parameters [ 'type_display' ] == \"multiple\" : raise ValueError ( 'step current is not thought to be used with step current and multiple display.' + 'There would be too much plots to handle.' ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters tf_step = ( current_parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_break_step' ]) # (s). delta_t_dyn_step = current_parameters [ 'step_current_parameters' ][ 'delta_t_dyn_step' ] # (s). # Calculation n = int ( tf_step / delta_t_dyn_step ) # It is the plot update number. time_interval = [ 0 , delta_t_dyn_step ] # (s). It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = ( i + 2 ) * delta_t_dyn_step time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) select_nth_elements ( d , n ) Select the n-th element from each list in a dictionary. Parameters: d ( dict ) \u2013 Dictionary where values are lists or other objects. n ( int ) \u2013 Index of the element to select from each list. Returns: dict \u2013 New dictionary with the n-th element from each list, or the original value if it is not a list or the list is too short. Source code in modules/main_modules.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def select_nth_elements ( d , n ): \"\"\"Select the n-th element from each list in a dictionary. Parameters ---------- d : dict Dictionary where values are lists or other objects. n : int Index of the element to select from each list. Returns ------- dict New dictionary with the n-th element from each list, or the original value if it is not a list or the list is too short. \"\"\" return { k : ( v [ n ] if isinstance ( v , list ) and len ( v ) > n else v ) for k , v in d . items ()}","title":"Main modules"},{"location":"functions/modules/main_modules/#main-modules","text":"This module contains some of the required functions for the main.py file.","title":"Main modules"},{"location":"functions/modules/main_modules/#modules.main_modules.figures_preparation","text":"This function create the required figures and axes according to the type_current and type_display. Parameters: computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Returns: fig1 ( Figure ) \u2013 Figure for the first plot. ax1 ( AxesSubplot ) \u2013 Axes for the first plot. fig2 ( Figure ) \u2013 Figure for the second plot. ax2 ( AxesSubplot ) \u2013 Axes for the second plot. Source code in modules/main_modules.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def figures_preparation ( computing_parameters ): \"\"\" This function create the required figures and axes according to the type_current and type_display. Parameters ---------- computing_parameters : dict Dictionary containing the computing parameters for the simulation. Returns ------- fig1 : matplotlib.figure.Figure Figure for the first plot. ax1 : matplotlib.axes._subplots.AxesSubplot Axes for the first plot. fig2 : matplotlib.figure.Figure Figure for the second plot. ax2 : matplotlib.axes._subplots.AxesSubplot Axes for the second plot. \"\"\" mpl . rcParams [ 'font.family' ] = 'cmr10' # 'cmr10' for English characters and 'DejaVu Serif' for French ones mpl . rcParams [ 'axes.formatter.use_mathtext' ] = True # For the scientific notation mpl . rcParams [ 'lines.linewidth' ] = 2.0 mpl . rcParams [ 'lines.markersize' ] = 5.0 if computing_parameters [ 'type_display' ] == \"no_display\" : fig1 , ax1 = None , None fig2 , ax2 = None , None fig3 , ax3 = None , None # For the step current if computing_parameters [ 'type_current' ] == \"step\" : if computing_parameters [ 'type_display' ] == \"multiple\" : # saving instruction is directly implemented within AlphaPEM.Display here. mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = None , None # Here, additional plots are unnecessary fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 13 # Font size for all text fig1 , ax1 = plt . subplots ( 3 , 3 , figsize = ( 14 , 14 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) # For the polarization curve elif computing_parameters [ 'type_current' ] == \"polarization\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary # For the polarization curve used for the calibration elif computing_parameters [ 'type_current' ] == \"polarization_for_cali\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary # For the EIS curve elif computing_parameters [ 'type_current' ] == \"EIS\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = plt . subplots ( figsize = ( 8 , 8 )) fig3 , ax3 = plt . subplots ( figsize = ( 8 , 8 )) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 13 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) return fig1 , ax1 , fig2 , ax2 , fig3 , ax3","title":"figures_preparation"},{"location":"functions/modules/main_modules/#modules.main_modules.launch_AlphaPEM_for_EIS_current","text":"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 def launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Check if the computing_parameters['type_current'] is valid if computing_parameters [ 'type_plot' ] != \"dynamic\" : raise ValueError ( 'EIS has to be plot with a dynamic type_plot setting, ' 'because max_step has to be adjusted at each frequency.' ) # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None t0_EIS , t_new_start , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = current_parameters [ 't_EIS' ] f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = current_parameters [ 'f_EIS' ] # These are used for EIS max_step # actualization. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested. n = len ( t_new_start ) # It is the plot update number. time_interval = [ 0 , t0_EIS ] # It is the initial time interval. # A preliminary simulation run is necessary to equilibrate the internal variables of the cell at i_EIS # prior to initiating the EIS. Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization t0_EIS_temp = t0_EIS # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ 0 ] + delta_t_break_EIS [ 0 ] + delta_t_measurement_EIS [ 0 ] # It is the final time for # 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which has been # made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) if computing_parameters [ 'type_display' ] == \"multiple\" : print ( \"A display bug prevents the dynamic updating of the graphs, as it appears that too much data is \" \"involved. However, the data is correctly calculated, and the appropriate plots are saved in the \" \"'results' folder. This display bug does not occur when using a 'synthetic' type_display.\" ) # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_EIS_temp = Simulator . variables [ 't' ][ - 1 ] # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ i + 1 ] + delta_t_break_EIS [ i + 1 ] + delta_t_measurement_EIS [ i + 1 ] # It # is the final time for 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which # has been made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # It is the time interval for 1 EIS point. # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_EIS_current"},{"location":"functions/modules/main_modules/#modules.main_modules.launch_AlphaPEM_for_polarization_current","text":"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Condition to fill for the comparison with experimental values if computing_parameters [ 'type_fuel_cell' ][ 1 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 1 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_1 , U_exp_t_1 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 1 ]) if current_parameters [ 'pola_current_parameters' ][ 1 ][ 'i_max_pola' ] < i_exp_t_1 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_1 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 2 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_2 , U_exp_t_2 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 2 ]) if current_parameters [ 'pola_current_parameters' ][ 2 ][ 'i_max_pola' ] < i_exp_t_2 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_2 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 3 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_3 , U_exp_t_3 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 3 ]) if current_parameters [ 'pola_current_parameters' ][ 3 ][ 'i_max_pola' ] < i_exp_t_3 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_3 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 4 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_4 , U_exp_t_4 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 4 ]) if current_parameters [ 'pola_current_parameters' ][ 4 ][ 'i_max_pola' ] < i_exp_t_4 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_4 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Certain conditions must be met. if ( computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None ): raise ValueError ( 'dynamic plot is not currently intended for use with different inputs.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_load_pola' ] # (s). delta_t_break_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_break_pola' ] # (s). delta_i_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_i_pola' ] # (A.m-2). i_max_pola_1 = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'i_max_pola_1' ] # (A.m-2). # Calculation delta_t_pola = delta_t_load_pola + delta_t_break_pola # s. It is the time of one load. tf = delta_t_ini_pola + int ( i_max_pola_1 / delta_i_pola ) * delta_t_pola # s. It is the polarization current duration. n = int ( tf / delta_t_pola ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola + delta_t_pola ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 ), initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator_1 . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola + ( i + 2 ) * delta_t_pola time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator_1 . solver_variable_names : initial_variable_values . append ( Simulator_1 . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 )) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 = AlphaPEM ( select_nth_elements ( operating_inputs , 2 ), select_nth_elements ( current_parameters , 2 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 2 )) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 = AlphaPEM ( select_nth_elements ( operating_inputs , 3 ), select_nth_elements ( current_parameters , 3 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 3 )) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 = AlphaPEM ( select_nth_elements ( operating_inputs , 4 ), select_nth_elements ( current_parameters , 4 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 4 )) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator_1 . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_polarization_current"},{"location":"functions/modules/main_modules/#modules.main_modules.launch_AlphaPEM_for_polarization_current_for_calibration","text":"Launch the AlphaPEM simulator for a polarization current density made for the calibration of the undetermined parameters, and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def launch_AlphaPEM_for_polarization_current_for_calibration ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density made for the calibration of the undetermined parameters, and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Certain conditions must be met. if ( computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None ): raise ValueError ( 'dynamic plot is not currently intended for use with different inputs.' ) if computing_parameters [ 'type_current' ] == \"polarization_for_cali\" : raise ValueError ( 'calibration should not use dynamic plot, as it is not intended for real-time display.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_ini_pola_cali' ] # (s). delta_t_load_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_load_pola_cali' ] # (s). delta_t_break_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_break_pola_cali' ] # (s). i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( computing_parameters [ 'type_fuel_cell' ][ 1 ]) # (A.m-2, V). # Calculation delta_t_pola_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. tf = delta_t_ini_pola_cali + len ( i_exp_cali_t ) * delta_t_pola_cali # s. It is the polarization current duration. n = int ( tf / delta_t_pola_cali ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola_cali + delta_t_pola_cali ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 ), initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator_1 . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola_cali + ( i + 2 ) * delta_t_pola_cali time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator_1 . solver_variable_names : initial_variable_values . append ( Simulator_1 . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Certain conditions must be met. if ( computing_parameters [ 'type_current' ] == \"polarization_for_cali\" and ( computing_parameters [ 'type_fuel_cell' ][ 1 ] == \"manual_setup\" or \\ computing_parameters [ 'type_auxiliary' ] != \"forced-convective_cathode_with_flow-through_anode\" )): raise ValueError ( 'polarization current for calibration should be done with experimental data.' ) # Simulation Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 )) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 = AlphaPEM ( select_nth_elements ( operating_inputs , 2 ), select_nth_elements ( current_parameters , 2 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 2 )) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 = AlphaPEM ( select_nth_elements ( operating_inputs , 3 ), select_nth_elements ( current_parameters , 3 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 3 )) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 = AlphaPEM ( select_nth_elements ( operating_inputs , 4 ), select_nth_elements ( current_parameters , 4 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 4 )) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator_1 . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_polarization_current_for_calibration"},{"location":"functions/modules/main_modules/#modules.main_modules.launch_AlphaPEM_for_step_current","text":"Launch the AlphaPEM simulator for a step current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a step current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Certain conditions must be met. if computing_parameters [ 'type_display' ] == \"multiple\" : raise ValueError ( 'step current is not thought to be used with step current and multiple display.' + 'There would be too much plots to handle.' ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters tf_step = ( current_parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_break_step' ]) # (s). delta_t_dyn_step = current_parameters [ 'step_current_parameters' ][ 'delta_t_dyn_step' ] # (s). # Calculation n = int ( tf_step / delta_t_dyn_step ) # It is the plot update number. time_interval = [ 0 , delta_t_dyn_step ] # (s). It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = ( i + 2 ) * delta_t_dyn_step time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_step_current"},{"location":"functions/modules/main_modules/#modules.main_modules.select_nth_elements","text":"Select the n-th element from each list in a dictionary. Parameters: d ( dict ) \u2013 Dictionary where values are lists or other objects. n ( int ) \u2013 Index of the element to select from each list. Returns: dict \u2013 New dictionary with the n-th element from each list, or the original value if it is not a list or the list is too short. Source code in modules/main_modules.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def select_nth_elements ( d , n ): \"\"\"Select the n-th element from each list in a dictionary. Parameters ---------- d : dict Dictionary where values are lists or other objects. n : int Index of the element to select from each list. Returns ------- dict New dictionary with the n-th element from each list, or the original value if it is not a list or the list is too short. \"\"\" return { k : ( v [ n ] if isinstance ( v , list ) and len ( v ) > n else v ) for k , v in d . items ()}","title":"select_nth_elements"},{"location":"functions/modules/settings_modules/","text":"Settings modules This modul contains some of the required functions for the settings. EIS_parameters ( f_EIS ) This function gives the time parameters for the EIS_current density function. Parameters: f_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. Returns: t_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. Source code in modules/settings_modules.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def EIS_parameters ( f_EIS ): \"\"\"This function gives the time parameters for the EIS_current density function. Parameters ---------- f_EIS : tuple EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. Returns ------- t_EIS : tuple EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. \"\"\" # Initialisation # Frequencies f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is the tested frequencies nb_period_break_EIS , nb_period_measurement_EIS = 50 , 50 # They are the number of temporal periods which are used # for break and for measurement. It is more accurate to use # periods than time as the frequency range is big. # Time parameters delta_t_break_EIS = np . array ([]) # It is the estimated time for reaching equilibrium at each frequency. delta_t_measurement_EIS = np . array ([]) # It is the estimated time for measuring the voltage response. # Time parameters calculation t0_EIS = 120 * 60 # s. It is the simulation starting time. [0, t0_EIS] is used to let the stack equilibrate to i_EIS. t_new_start_EIS = np . array ([ t0_EIS ]) # It is a list of time parameters which gives the beginning of each frequency # change. for i in range ( nb_f_EIS ): # The goal is to measure nb_f_EIS periods of the signal in order to have precise enough values. T_i = 1 / ( f [ i ]) # s. It is the period of the signal. if i < ( nb_f_EIS - 1 ): delta_t_break_EIS = np . concatenate (( delta_t_break_EIS , [ nb_period_break_EIS * T_i ])) delta_t_measurement_EIS = np . concatenate (( delta_t_measurement_EIS , [ nb_period_measurement_EIS * T_i ])) next_start_EIS = t_new_start_EIS [ i ] + delta_t_break_EIS [ i ] + delta_t_measurement_EIS [ i ] t_new_start_EIS = np . concatenate (( t_new_start_EIS , [ next_start_EIS ])) else : delta_t_break_EIS = np . concatenate (( delta_t_break_EIS , [ nb_period_break_EIS * T_i ])) delta_t_measurement_EIS = np . concatenate (( delta_t_measurement_EIS , [ nb_period_measurement_EIS * T_i ])) tf_EIS = t_new_start_EIS [ - 1 ] + delta_t_break_EIS [ - 1 ] + delta_t_measurement_EIS [ - 1 ] # s. It is the # simulation ending time t_EIS = t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS return t_EIS stored_operating_inputs ( type_fuel_cell ) This function gives the operating inputs which correspond to the given type_fuel_cell. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. i_max_pola ( float ) \u2013 Maximum current density for the polarization curve. Source code in modules/settings_modules.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def stored_operating_inputs ( type_fuel_cell ): \"\"\"This function gives the operating inputs which correspond to the given type_fuel_cell. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. i_max_pola : float Maximum current density for the polarization curve. \"\"\" # For the ZSW Generic Stack fuel cell if type_fuel_cell == \"ZSW-GenStack\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. i_max_pola = 2.5e4 # A.m-2. It is the maximum current density for the polarization curve. # For EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 1.5e5 , 1.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 1.7e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.0\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 1.7e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.25\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.25e5 , 2.25e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 1.7e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.5\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.5e5 , 2.5e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 1.7e4 # A.m-2. It is the maximum current density for the polarization curve. # For other fuel cells else : raise ValueError ( 'the type_fuel_cell given is not valid.' ) return T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , i_max_pola stored_physical_parameters ( type_fuel_cell ) This function gives the physical parameters which correspond to the given type_fuel_cell. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: Hacl ( float ) \u2013 Thickness of the anode catalyst layer in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer in m. epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the CL. Hmem ( float ) \u2013 Thickness of the membrane in m. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in m. epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_c ( float ) \u2013 Compression ratio of the GDL. Hagc ( float ) \u2013 Thickness of the anode gas channel in m. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in m. Wagc ( float ) \u2013 Width of the anode gas channel in m. Wcgc ( float ) \u2013 Width of the cathode gas channel in m. Lgc ( float ) \u2013 Length of the gas channel in m. Aact ( float ) \u2013 Active area of the cell in m\u00b2. e ( float ) \u2013 Capillary exponent. i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode in A.m-2. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c ( float ) \u2013 Overpotential correction exponent. a_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of slim function. b_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the intercept of slim function. a_switch ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl ( float ) \u2013 Volumetric double layer capacitance in F.m-3. Source code in modules/settings_modules.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def stored_physical_parameters ( type_fuel_cell ): \"\"\"This function gives the physical parameters which correspond to the given type_fuel_cell. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- Hacl : float Thickness of the anode catalyst layer in m. Hccl : float Thickness of the cathode catalyst layer in m. epsilon_mc : float Volume fraction of ionomer in the CL. Hmem : float Thickness of the membrane in m. Hgdl : float Thickness of the gas diffusion layer in m. epsilon_gdl : float Anode/cathode GDL porosity. epsilon_c : float Compression ratio of the GDL. Hagc : float Thickness of the anode gas channel in m. Hcgc : float Thickness of the cathode gas channel in m. Wagc : float Width of the anode gas channel in m. Wcgc : float Width of the cathode gas channel in m. Lgc : float Length of the gas channel in m. Aact : float Active area of the cell in m\u00b2. e : float Capillary exponent. i0_c_ref : float Reference exchange current density at the cathode in A.m-2. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c : float Overpotential correction exponent. a_slim : float One of the limit liquid saturation coefficients: the slop of slim function. b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function. a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl : float Volumetric double layer capacitance in F.m-3. \"\"\" # For the ZSW Generic Stack fuel cell if type_fuel_cell == \"ZSW-GenStack\" : # Global Aact = 279.72e-4 # m\u00b2. It is the MEA active area. # Catalyst layer Hacl = 8e-6 # m. It is the thickness of the anode catalyst layer. Hccl = 17e-6 # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.5 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 15e-6 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 127e-6 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.788 # It is the anode/cathode GDL porosity. epsilon_cl = 0.5 # It is the porosity of the catalyst layer, without units. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 70e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.425 # It is the porosity of the microporous layer. # Gas channel Hagc = 230e-6 # m. It is the thickness of the anode gas channel. Hcgc = 300e-6 # m. It is the thickness of the cathode gas channel. Wagc = 430e-6 # m. It is the width of the anode gas channel. Wcgc = 532e-6 # m. It is the width of the cathode gas channel. Lgc = 23.31 # m. It is the length of the gas channel. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 6.795 # A.m-2.It is the reference exchange current density at the cathode. kappa_co = 30.41 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.026 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # For EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Global Aact = 85e-4 # m\u00b2. It is the active area of the catalyst layer. # Catalyst layer Hacl = 8.089e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.3823 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 16.97e-6 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 200e-6 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.7393 # It is the anode/cathode GDL porosity. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 30e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. # Gas channel Hagc = 500e-6 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Wagc = 450e-6 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 9.67 # m. It is the length of the gas channel. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 6.795 # A.m-2.It is the reference exchange current density at the cathode. kappa_co = 30.41 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.026 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 20e6 # F.m-3. It is the volumetric space-charge layer capacitance. # For other fuel cells else : raise ValueError ( 'the type_input given is not valid.' ) return Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , \\ Hagc , Hcgc , Wagc , Wcgc , Lgc , Aact , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl","title":"Settings modules"},{"location":"functions/modules/settings_modules/#settings-modules","text":"This modul contains some of the required functions for the settings.","title":"Settings modules"},{"location":"functions/modules/settings_modules/#modules.settings_modules.EIS_parameters","text":"This function gives the time parameters for the EIS_current density function. Parameters: f_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. Returns: t_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. Source code in modules/settings_modules.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def EIS_parameters ( f_EIS ): \"\"\"This function gives the time parameters for the EIS_current density function. Parameters ---------- f_EIS : tuple EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. Returns ------- t_EIS : tuple EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. \"\"\" # Initialisation # Frequencies f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is the tested frequencies nb_period_break_EIS , nb_period_measurement_EIS = 50 , 50 # They are the number of temporal periods which are used # for break and for measurement. It is more accurate to use # periods than time as the frequency range is big. # Time parameters delta_t_break_EIS = np . array ([]) # It is the estimated time for reaching equilibrium at each frequency. delta_t_measurement_EIS = np . array ([]) # It is the estimated time for measuring the voltage response. # Time parameters calculation t0_EIS = 120 * 60 # s. It is the simulation starting time. [0, t0_EIS] is used to let the stack equilibrate to i_EIS. t_new_start_EIS = np . array ([ t0_EIS ]) # It is a list of time parameters which gives the beginning of each frequency # change. for i in range ( nb_f_EIS ): # The goal is to measure nb_f_EIS periods of the signal in order to have precise enough values. T_i = 1 / ( f [ i ]) # s. It is the period of the signal. if i < ( nb_f_EIS - 1 ): delta_t_break_EIS = np . concatenate (( delta_t_break_EIS , [ nb_period_break_EIS * T_i ])) delta_t_measurement_EIS = np . concatenate (( delta_t_measurement_EIS , [ nb_period_measurement_EIS * T_i ])) next_start_EIS = t_new_start_EIS [ i ] + delta_t_break_EIS [ i ] + delta_t_measurement_EIS [ i ] t_new_start_EIS = np . concatenate (( t_new_start_EIS , [ next_start_EIS ])) else : delta_t_break_EIS = np . concatenate (( delta_t_break_EIS , [ nb_period_break_EIS * T_i ])) delta_t_measurement_EIS = np . concatenate (( delta_t_measurement_EIS , [ nb_period_measurement_EIS * T_i ])) tf_EIS = t_new_start_EIS [ - 1 ] + delta_t_break_EIS [ - 1 ] + delta_t_measurement_EIS [ - 1 ] # s. It is the # simulation ending time t_EIS = t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS return t_EIS","title":"EIS_parameters"},{"location":"functions/modules/settings_modules/#modules.settings_modules.stored_operating_inputs","text":"This function gives the operating inputs which correspond to the given type_fuel_cell. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. i_max_pola ( float ) \u2013 Maximum current density for the polarization curve. Source code in modules/settings_modules.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def stored_operating_inputs ( type_fuel_cell ): \"\"\"This function gives the operating inputs which correspond to the given type_fuel_cell. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. i_max_pola : float Maximum current density for the polarization curve. \"\"\" # For the ZSW Generic Stack fuel cell if type_fuel_cell == \"ZSW-GenStack\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. i_max_pola = 2.5e4 # A.m-2. It is the maximum current density for the polarization curve. # For EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 1.5e5 , 1.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 1.7e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.0\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 1.7e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.25\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.25e5 , 2.25e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 1.7e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.5\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.5e5 , 2.5e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. i_max_pola = 1.7e4 # A.m-2. It is the maximum current density for the polarization curve. # For other fuel cells else : raise ValueError ( 'the type_fuel_cell given is not valid.' ) return T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , i_max_pola","title":"stored_operating_inputs"},{"location":"functions/modules/settings_modules/#modules.settings_modules.stored_physical_parameters","text":"This function gives the physical parameters which correspond to the given type_fuel_cell. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: Hacl ( float ) \u2013 Thickness of the anode catalyst layer in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer in m. epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the CL. Hmem ( float ) \u2013 Thickness of the membrane in m. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in m. epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_c ( float ) \u2013 Compression ratio of the GDL. Hagc ( float ) \u2013 Thickness of the anode gas channel in m. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in m. Wagc ( float ) \u2013 Width of the anode gas channel in m. Wcgc ( float ) \u2013 Width of the cathode gas channel in m. Lgc ( float ) \u2013 Length of the gas channel in m. Aact ( float ) \u2013 Active area of the cell in m\u00b2. e ( float ) \u2013 Capillary exponent. i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode in A.m-2. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c ( float ) \u2013 Overpotential correction exponent. a_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of slim function. b_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the intercept of slim function. a_switch ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl ( float ) \u2013 Volumetric double layer capacitance in F.m-3. Source code in modules/settings_modules.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def stored_physical_parameters ( type_fuel_cell ): \"\"\"This function gives the physical parameters which correspond to the given type_fuel_cell. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- Hacl : float Thickness of the anode catalyst layer in m. Hccl : float Thickness of the cathode catalyst layer in m. epsilon_mc : float Volume fraction of ionomer in the CL. Hmem : float Thickness of the membrane in m. Hgdl : float Thickness of the gas diffusion layer in m. epsilon_gdl : float Anode/cathode GDL porosity. epsilon_c : float Compression ratio of the GDL. Hagc : float Thickness of the anode gas channel in m. Hcgc : float Thickness of the cathode gas channel in m. Wagc : float Width of the anode gas channel in m. Wcgc : float Width of the cathode gas channel in m. Lgc : float Length of the gas channel in m. Aact : float Active area of the cell in m\u00b2. e : float Capillary exponent. i0_c_ref : float Reference exchange current density at the cathode in A.m-2. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c : float Overpotential correction exponent. a_slim : float One of the limit liquid saturation coefficients: the slop of slim function. b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function. a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl : float Volumetric double layer capacitance in F.m-3. \"\"\" # For the ZSW Generic Stack fuel cell if type_fuel_cell == \"ZSW-GenStack\" : # Global Aact = 279.72e-4 # m\u00b2. It is the MEA active area. # Catalyst layer Hacl = 8e-6 # m. It is the thickness of the anode catalyst layer. Hccl = 17e-6 # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.5 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 15e-6 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 127e-6 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.788 # It is the anode/cathode GDL porosity. epsilon_cl = 0.5 # It is the porosity of the catalyst layer, without units. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 70e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.425 # It is the porosity of the microporous layer. # Gas channel Hagc = 230e-6 # m. It is the thickness of the anode gas channel. Hcgc = 300e-6 # m. It is the thickness of the cathode gas channel. Wagc = 430e-6 # m. It is the width of the anode gas channel. Wcgc = 532e-6 # m. It is the width of the cathode gas channel. Lgc = 23.31 # m. It is the length of the gas channel. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 6.795 # A.m-2.It is the reference exchange current density at the cathode. kappa_co = 30.41 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.026 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # For EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Global Aact = 85e-4 # m\u00b2. It is the active area of the catalyst layer. # Catalyst layer Hacl = 8.089e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.3823 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 16.97e-6 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 200e-6 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.7393 # It is the anode/cathode GDL porosity. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 30e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. # Gas channel Hagc = 500e-6 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Wagc = 450e-6 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 9.67 # m. It is the length of the gas channel. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization i0_c_ref = 6.795 # A.m-2.It is the reference exchange current density at the cathode. kappa_co = 30.41 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.026 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 20e6 # F.m-3. It is the volumetric space-charge layer capacitance. # For other fuel cells else : raise ValueError ( 'the type_input given is not valid.' ) return Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , \\ Hagc , Hcgc , Wagc , Wcgc , Lgc , Aact , e , i0_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl","title":"stored_physical_parameters"},{"location":"functions/modules/transitory_functions/","text":"Transitory functions This module contains transitory functions which all have a specific physical meaning for modeling the PEM fuel cell. C_v_sat ( T ) This function calculates the saturated vapor concentration for a perfect gas, in mol.m-3, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Saturated vapor concentration for a perfect gas in mol.m-3. Source code in modules/transitory_functions.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def C_v_sat ( T ): \"\"\"This function calculates the saturated vapor concentration for a perfect gas, in mol.m-3, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Saturated vapor concentration for a perfect gas in mol.m-3. \"\"\" return Psat ( T ) / ( R * T ) Cp0 ( component , T ) This function calculates the specific heat capacity of fluids, in J.kg-1.K-1, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Specific heat capacity of the selected fluid in J.kg-1.K-1. Notes Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition Source code in modules/transitory_functions.py 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 def Cp0 ( component , T ): \"\"\"This function calculates the specific heat capacity of fluids, in J.kg-1.K-1, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Specific heat capacity of the selected fluid in J.kg-1.K-1. Notes ----- Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition\"\"\" if component == 'H2O_l' : # For T >= 298 and T <= 500 K. return 1 / M_H2O * ( - 203.6060 + 1523.290 * ( T / 1000 ) - 3196.413 * ( T / 1000 ) ** 2 + 2474.455 * ( T / 1000 ) ** 3 + 3.855326 / ( T / 1000 ) ** 2 ) elif component == 'H2O_v' : # For T = 350 K. I failed to find a proper equation at the good range of temperature. return 1880 elif component == 'H2' : # For T >= 298 K and T <= 1000 K. return 1 / M_H2 * ( 33.066178 - 11.363417 * ( T / 1000 ) + 11.432816 * ( T / 1000 ) ** 2 - 2.772874 * ( T / 1000 ) ** 3 - 0.158558 / ( T / 1000 ) ** 2 ) elif component == 'O2' : # For T >= 100 K and T <= 700 K. return 1 / M_O2 * ( 31.32234 - 20.23531 * ( T / 1000 ) + 57.86644 * ( T / 1000 ) ** 2 - 36.50624 * ( T / 1000 ) ** 3 - 0.007374 / ( T / 1000 ) ** 2 ) elif component == 'N2' : # For T >= 100 K and T <= 500 K. return 1 / M_N2 * ( 28.98641 + 1.853978 * ( T / 1000 ) - 9.647459 * ( T / 1000 ) ** 2 + 16.63537 * ( T / 1000 ) ** 3 + 0.000117 / ( T / 1000 ) ** 2 ) else : raise ValueError ( \"The element should be either 'H2O_l', 'H2O_v', 'H2', 'O2' or 'N2'.\" ) D ( lambdaa ) This function calculates the diffusion coefficient of water in the membrane, in m\u00b2.s-1. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. Returns: float \u2013 Diffusion coefficient of water in the membrane in m\u00b2.s-1. Source code in modules/transitory_functions.py 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def D ( lambdaa ): \"\"\"This function calculates the diffusion coefficient of water in the membrane, in m\u00b2.s-1. Parameters ---------- lambdaa : float Water content in the membrane. Returns ------- float Diffusion coefficient of water in the membrane in m\u00b2.s-1. \"\"\" return 4.1e-10 * ( lambdaa / 25.0 ) ** 0.15 * ( 1.0 + math . tanh (( lambdaa - 2.5 ) / 1.4 )) Da ( P , T ) This function calculates the diffusion coefficient at the anode, in m\u00b2.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Diffusion coefficient at the anode in m\u00b2.s-1. Source code in modules/transitory_functions.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def Da ( P , T ): \"\"\"This function calculates the diffusion coefficient at the anode, in m\u00b2.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Returns ------- float Diffusion coefficient at the anode in m\u00b2.s-1. \"\"\" return 1.644e-4 * ( T / 333 ) ** 2.334 * ( 101325 / P ) Da_eff ( element , s , T , P , epsilon , epsilon_c = None ) This function calculates the effective diffusion coefficient at the GDL or the CL and at the anode, in m\u00b2.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. P ( float ) \u2013 Pressure in Pa. epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective diffusion coefficient at the anode in m\u00b2.s-1. Source code in modules/transitory_functions.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def Da_eff ( element , s , T , P , epsilon , epsilon_c = None ): \"\"\"This function calculates the effective diffusion coefficient at the GDL or the CL and at the anode, in m\u00b2.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. P : float Pressure in Pa. epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Effective diffusion coefficient at the anode in m\u00b2.s-1. \"\"\" if element == 'gdl' : # The effective diffusion coefficient at the GDL using Tomadakis and Sotirchos model. if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta2 = - 1.59 elif 0.67 <= epsilon <= 0.90 : beta2 = - 0.90 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) return epsilon * (( epsilon - epsilon_p ) / ( 1 - epsilon_p )) ** alpha_p * math . exp ( beta2 * epsilon_c ) * ( 1 - s ) ** 2 * Da ( P , T ) elif element == 'mpl' : # The effective diffusion coefficient at the MPL using Bruggeman model. return epsilon ** tau_mpl * ( 1 - s ) ** tau_mpl * Da ( P , T ) elif element == 'cl' : # The effective diffusion coefficient at the CL using Bruggeman model. return epsilon ** tau_cl * ( 1 - s ) ** tau_cl * Da ( P , T ) else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" ) Dc ( P , T ) This function calculates the diffusion coefficient at the cathode, in m\u00b2.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Diffusion coefficient at the cathode in m\u00b2.s-1. Source code in modules/transitory_functions.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def Dc ( P , T ): \"\"\"This function calculates the diffusion coefficient at the cathode, in m\u00b2.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Returns ------- float Diffusion coefficient at the cathode in m\u00b2.s-1. \"\"\" return 3.242e-5 * ( T / 333 ) ** 2.334 * ( 101325 / P ) Dc_eff ( element , s , T , P , epsilon , epsilon_c = None ) This function calculates the effective diffusion coefficient at the GDL or the CL and at the cathode, in m\u00b2.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. P ( float ) \u2013 Pressure in Pa. epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective diffusion coefficient at the cathode in m\u00b2.s-1. Source code in modules/transitory_functions.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def Dc_eff ( element , s , T , P , epsilon , epsilon_c = None ): \"\"\"This function calculates the effective diffusion coefficient at the GDL or the CL and at the cathode, in m\u00b2.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. P : float Pressure in Pa. epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Effective diffusion coefficient at the cathode in m\u00b2.s-1. \"\"\" if element == 'gdl' : # The effective diffusion coefficient at the GDL using Tomadakis and Sotirchos model. if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta2 = - 1.59 elif 0.67 <= epsilon <= 0.90 : beta2 = - 0.90 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) return epsilon * (( epsilon - epsilon_p ) / ( 1 - epsilon_p )) ** alpha_p * math . exp ( beta2 * epsilon_c ) * ( 1 - s ) ** 2 * Dc ( P , T ) elif element == 'mpl' : # The effective diffusion coefficient at the MPL using Bruggeman model. return epsilon ** tau_mpl * ( 1 - s ) ** tau_mpl * Dc ( P , T ) elif element == 'cl' : # The effective diffusion coefficient at the CL using Bruggeman model. return epsilon ** tau_cl * ( 1 - s ) ** tau_cl * Dc ( P , T ) else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" ) Dcap ( element , s , T , epsilon , e , epsilon_c = None ) This function calculates the capillary coefficient at the GDL or the CL and at the anode, in kg.m.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the capillary coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. epsilon ( float ) \u2013 Porosity. e ( float ) \u2013 Capillary exponent. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Source code in modules/transitory_functions.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def Dcap ( element , s , T , epsilon , e , epsilon_c = None ): \"\"\" This function calculates the capillary coefficient at the GDL or the CL and at the anode, in kg.m.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the capillary coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. epsilon : float Porosity. e : float Capillary exponent. epsilon_c : float, optional Compression ratio of the GDL. \"\"\" if element == 'gdl' : if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) return sigma ( T ) * K0 ( element , epsilon , epsilon_c ) / nu_l ( T ) * abs ( math . cos ( theta_c_gdl )) * \\ ( epsilon / K0 ( element , epsilon , epsilon_c )) ** 0.5 * ( s ** e + 1e-7 ) * ( 1.417 - 4.24 * s + 3.789 * s ** 2 ) elif element == 'mpl' : return sigma ( T ) * K0 ( element , epsilon ) / nu_l ( T ) * abs ( math . cos ( theta_c_mpl )) * \\ ( epsilon / K0 ( element , epsilon )) ** 0.5 * ( s ** e + 1e-7 ) * ( 1.417 - 4.24 * s + 3.789 * s ** 2 ) elif element == 'cl' : return sigma ( T ) * K0 ( element , epsilon ) / nu_l ( T ) * abs ( math . cos ( theta_c_cl )) * \\ ( epsilon / K0 ( element , epsilon )) ** 0.5 * ( s ** e + 1e-7 ) * ( 1.417 - 4.24 * s + 3.789 * s ** 2 ) else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" ) K0 ( element , epsilon , epsilon_c = None ) This function calculates the intrinsic permeability, in m\u00b2, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the intrinsic permeability is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Intrinsic permeability in m\u00b2. Sources Qin Chen 2020 - Two-dimensional multi-physics modeling of porous transport layer in polymer electrolyte membrane electrolyzer for water splitting - for the Blake-Kozeny equation. M.L. Stewart 2005 - A study of pore geometry effects on anisotropy in hydraulic permeability using the lattice-Boltzmann method - for the Blake-Kozeny equation. Source code in modules/transitory_functions.py 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def K0 ( element , epsilon , epsilon_c = None ): \"\"\"This function calculates the intrinsic permeability, in m\u00b2, considering GDL compression. Parameters ---------- element : str Specifies the element for which the intrinsic permeability is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Intrinsic permeability in m\u00b2. Sources ------- 1. Qin Chen 2020 - Two-dimensional multi-physics modeling of porous transport layer in polymer electrolyte membrane electrolyzer for water splitting - for the Blake-Kozeny equation. 2. M.L. Stewart 2005 - A study of pore geometry effects on anisotropy in hydraulic permeability using the lattice-Boltzmann method - for the Blake-Kozeny equation. \"\"\" if element == 'gdl' : if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta1 = - 3.60 elif 0.67 <= epsilon <= 0.90 : beta1 = - 2.60 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) return epsilon / ( 8 * math . log ( epsilon ) ** 2 ) * ( epsilon - epsilon_p ) ** ( alpha_p + 2 ) * \\ 4.6e-6 ** 2 / (( 1 - epsilon_p ) ** alpha_p * (( alpha_p + 1 ) * epsilon - epsilon_p ) ** 2 ) * math . exp ( beta1 * epsilon_c ) elif element == 'mpl' : return ( Dp_mpl ** 2 / 150 ) * ( epsilon ** 3 / (( 1 - epsilon ) ** 2 )) # Using the Blake-Kozeny equation elif element == 'cl' : return ( Dp_cl ** 2 / 150 ) * ( epsilon ** 3 / (( 1 - epsilon ) ** 2 )) # Using the Blake-Kozeny equation else : raise ValueError ( \"The element should be either 'gdl' or 'cl'.\" ) Psat ( T ) This function calculates the saturated partial pressure of vapor, in Pa, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Saturated partial pressure of vapor in Pa. Source code in modules/transitory_functions.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def Psat ( T ): \"\"\"This function calculates the saturated partial pressure of vapor, in Pa, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Saturated partial pressure of vapor in Pa. \"\"\" Tcelsius = T - 273.15 return 101325 * 10 ** ( - 2.1794 + 0.02953 * Tcelsius - 9.1837e-5 * Tcelsius ** 2 + 1.4454e-7 * Tcelsius ** 3 ) Svl ( s , C_v , Ctot , T , epsilon , gamma_cond , gamma_evap ) This function calculates the phase transfer rate of water condensation or evaporation, in mol.m-3.s-1. Parameters: s ( float ) \u2013 Liquid water saturation variable. C_v ( float ) \u2013 Water concentration variable in mol.m-3. Ctot ( float ) \u2013 Total gas concentration in mol.m-3. T ( float ) \u2013 Temperature in K. epsilon ( float ) \u2013 Porosity. gamma_cond ( float ) \u2013 Overall condensation rate constant for water in s-1. gamma_evap ( float ) \u2013 Overall evaporation rate constant for water in Pa-1.s-1. Returns: float \u2013 Phase transfer rate of water condensation or evaporation in mol.m-3.s-1. Source code in modules/transitory_functions.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def Svl ( s , C_v , Ctot , T , epsilon , gamma_cond , gamma_evap ): \"\"\"This function calculates the phase transfer rate of water condensation or evaporation, in mol.m-3.s-1. Parameters ---------- s : float Liquid water saturation variable. C_v : float Water concentration variable in mol.m-3. Ctot : float Total gas concentration in mol.m-3. T : float Temperature in K. epsilon : float Porosity. gamma_cond : float Overall condensation rate constant for water in s-1. gamma_evap : float Overall evaporation rate constant for water in Pa-1.s-1. Returns ------- float Phase transfer rate of water condensation or evaporation in mol.m-3.s-1. \"\"\" if C_v > C_v_sat ( T ): # condensation return gamma_cond * epsilon * ( 1 - s ) * ( C_v / Ctot ) * ( C_v - C_v_sat ( T )) else : # evaporation return - gamma_evap * epsilon * s * rho_H2O_l ( T ) / M_H2O * R * T * ( C_v_sat ( T ) - C_v ) average ( terms , weights = None ) Calculate the weighted arithmetic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling average from numpy. Parameters: terms \u2013 The terms to calculate the average for. weights \u2013 The weights corresponding to each term. If None, uniform weights are assumed. Returns: float \u2013 The weighted arithmetic mean. Source code in modules/transitory_functions.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def average ( terms , weights = None ): \"\"\" Calculate the weighted arithmetic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling average from numpy. Parameters ---------- terms (list of float): The terms to calculate the average for. weights (list of float, optional): The weights corresponding to each term. If None, uniform weights are assumed. Returns ------- float: The weighted arithmetic mean. \"\"\" if weights is None : # If no weights are provided, use uniform weights weights = [ 1 ] * len ( terms ) if len ( terms ) != len ( weights ): raise ValueError ( \"The length of terms and weights must be the same.\" ) # Calculate the weighted arithmetic mean weighted_sum = sum ( w * t for w , t in zip ( weights , terms )) total_weight = sum ( weights ) if total_weight == 0 : return float ( 'nan' ) # Avoid division by zero return weighted_sum / total_weight calculate_rho_Cp0 ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None ) This function calculates the volumetric heat capacity, in J.m-3.K-1, in either the GDL, the MPL, the CL or the membrane. Parameters: element ( str ) \u2013 Specifies the element for which the volumetric heat capacity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T ( float ) \u2013 Temperature in K. C_v ( float , default: None ) \u2013 Water concentration variable in mol.m-3. s ( float , default: None ) \u2013 Liquid water saturation variable. lambdaa ( float , default: None ) \u2013 Water content in the membrane. C_H2 ( float , default: None ) \u2013 Concentration of hydrogen in the AGDL or ACL. C_O2 ( float , default: None ) \u2013 Concentration of oxygen in the CGDL or CCL. C_N2 ( float , default: None ) \u2013 Concentration of nitrogen in the CGDL or CCL. epsilon ( float , default: None ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Volumetric heat capacity in J.m-3.K-1. Source code in modules/transitory_functions.py 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 def calculate_rho_Cp0 ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None ): \"\"\"This function calculates the volumetric heat capacity, in J.m-3.K-1, in either the GDL, the MPL, the CL or the membrane. Parameters ---------- element : str Specifies the element for which the volumetric heat capacity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T : float Temperature in K. C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. C_H2 : float Concentration of hydrogen in the AGDL or ACL. C_O2 : float Concentration of oxygen in the CGDL or CCL. C_N2 : float Concentration of nitrogen in the CGDL or CCL. epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. Returns ------- float Volumetric heat capacity in J.m-3.K-1.\"\"\" if element == 'agdl' or element == 'cgdl' : # The volumetric heat capacity at the GDL if C_v is None or s is None or epsilon is None : raise ValueError ( \"For the GDL, C_v, s and epsilon must be provided.\" ) if element == 'agdl' : # The heat capacity of the gas mixture in the AGDL if C_H2 is None : raise ValueError ( \"For the AGDL, C_H2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T )], weights = [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )]) else : # The heat capacity of the gas mixture in the CGDL if C_O2 is None or C_N2 is None : raise ValueError ( \"For the CGDL, C_O2 and C_N2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )]) return average ([ rho_gdl * Cp_gdl , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) if element == 'ampl' or element == 'cmpl' : # The volumetric heat capacity at the MPL if C_v is None or s is None or epsilon is None : raise ValueError ( \"For the MPL, C_v, s and epsilon must be provided.\" ) if element == 'ampl' : # The heat capacity of the gas mixture in the AMPL if C_H2 is None : raise ValueError ( \"For the AMPL, C_H2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T )], weights = [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )]) else : # The heat capacity of the gas mixture in the CMPL if C_O2 is None or C_N2 is None : raise ValueError ( \"For the CMPL, C_O2 and C_N2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )]) return average ([ rho_gdl * Cp_mpl , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element == 'acl' or element == 'ccl' : # The volumetric heat capacity at the CL if C_v is None or lambdaa is None or s is None or epsilon is None or epsilon_mc is None : raise ValueError ( \"For the CL, C_v, lambdaa, s, epsilon, and epsilon_mc must be provided.\" ) if element == 'acl' : # The heat capacity of the gas mixture in the ACL if C_H2 is None : raise ValueError ( \"For the ACL, C_H2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T )], weights = [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )]) else : # The heat capacity of the gas mixture in the CCL if C_O2 is None or C_N2 is None : raise ValueError ( \"For the CCL, C_O2 and C_N2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )]) return average ([ rho_cl * Cp_cl , rho_mem * Cp_mem , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon - epsilon_mc , epsilon_mc , epsilon * s , epsilon * ( 1 - s )]) elif element == 'mem' : # The volumetric heat capacity at the membrane if lambdaa is None : raise ValueError ( \"For the membrane, lambdaa must be provided.\" ) return average ([ rho_mem * Cp_mem , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T )], weights = [ 1 - fv ( lambdaa , T ), fv ( lambdaa , T )]) else : raise ValueError ( \"The element should be either 'agdl', 'cgdl', 'ampl', 'cmpl', 'acl', 'ccl' or 'mem'.\" ) delta_h_abs ( T ) This function computes the molar enthalpy of absorption of water at a given temperature, in J.mol-1. This reaction is exothermic. Parameters T : float Temperature in K. Returns delta_h_sorp : float Molar enthalpy of absorption in the CL in J.mol-1. Notes For Nafion, the enthalpy of absorption is almost equal to that of liquefaction [vetterFreeOpenReference2019]. Source code in modules/transitory_functions.py 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 def delta_h_abs ( T ): \"\"\"This function computes the molar enthalpy of absorption of water at a given temperature, in J.mol-1. This reaction is exothermic. Parameters ---------- T : float Temperature in K. Returns ------- delta_h_sorp : float Molar enthalpy of absorption in the CL in J.mol-1. Notes ----- For Nafion, the enthalpy of absorption is almost equal to that of liquefaction [vetterFreeOpenReference2019]. \"\"\" return delta_h_liq ( T ) delta_h_liq ( T ) This function computes the molar enthalpy of liquefaction of water at a given temperature, in J.mol-1. It is calculated as the difference in molar enthalpy between liquid water (H2O_l) and water vapor (H2O_v). Parameters T : float Temperature in K. Returns delta_h_liq : float Molar enthalpy of liquefaction in J.mol-1. Notes This value should be close to -42 000 J.mol-1 [vetterFreeOpenReference2019]. Source code in modules/transitory_functions.py 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 def delta_h_liq ( T ): \"\"\"This function computes the molar enthalpy of liquefaction of water at a given temperature, in J.mol-1. It is calculated as the difference in molar enthalpy between liquid water (H2O_l) and water vapor (H2O_v). Parameters ---------- T : float Temperature in K. Returns ------- delta_h_liq : float Molar enthalpy of liquefaction in J.mol-1. Notes ----- This value should be close to -42 000 J.mol-1 [vetterFreeOpenReference2019]. \"\"\" return h0 ( 'H2O_l' , T ) - h0 ( 'H2O_v' , T ) fv ( lambdaa , T ) This function calculates the water volume fraction of the membrane. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. Returns: float \u2013 Water volume fraction of the membrane. Source code in modules/transitory_functions.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def fv ( lambdaa , T ): \"\"\"This function calculates the water volume fraction of the membrane. Parameters ---------- lambdaa : float Water content in the membrane. Returns ------- float Water volume fraction of the membrane. \"\"\" return ( lambdaa * M_H2O / rho_H2O_l ( T )) / ( M_eq / rho_mem + lambdaa * M_H2O / rho_H2O_l ( T )) gamma_sorp ( C_v , s , lambdaa , T , Hcl ) This function calculates the sorption rate of water in the membrane, in s-1. Parameters: C_v ( float ) \u2013 Water concentration variable in mol.m-3. s ( float ) \u2013 Liquid water saturation variable. lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. Hcl ( float ) \u2013 Thickness of the CL layer. Returns: float \u2013 Sorption rate of water in the membrane in s-1. Source code in modules/transitory_functions.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 def gamma_sorp ( C_v , s , lambdaa , T , Hcl ): \"\"\"This function calculates the sorption rate of water in the membrane, in s-1. Parameters ---------- C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. T : float Temperature in K. Hcl : float Thickness of the CL layer. Returns ------- float Sorption rate of water in the membrane in s-1. \"\"\" if lambda_eq ( C_v , s , T ) >= lambdaa : # absorption return ( 1.14e-5 * fv ( lambdaa , T )) / Hcl * math . exp ( 2416 * ( 1 / 303 - 1 / T )) else : # desorption return ( 4.59e-5 * fv ( lambdaa , T )) / Hcl * math . exp ( 2416 * ( 1 / 303 - 1 / T )) h0 ( component , T ) This function calculates the standard enthalpy of fluids, in J.mol-1, as a function of the temperature. The variation of the enthalpy of reaction with temperature is given by Kirchhoff's Law of Thermochemistry. Parameters: component ( str ) \u2013 Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water) or 'H2O_v' (vapor). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Standard enthalpy of the selected fluid in J.mol-1. Notes Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition Source code in modules/transitory_functions.py 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 def h0 ( component , T ): \"\"\"This function calculates the standard enthalpy of fluids, in J.mol-1, as a function of the temperature. The variation of the enthalpy of reaction with temperature is given by Kirchhoff's Law of Thermochemistry. Parameters ---------- component : str Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water) or 'H2O_v' (vapor). T : float Temperature in K. Returns ------- float Standard enthalpy of the selected fluid in J.mol-1. Notes ----- Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition\"\"\" if component == 'H2O_l' : # For T >= 298 and T <= 500 K. return ( - 285.83 - 203.6060 * ( T / 1000 ) + 1523.290 * ( T / 1000 ) ** 2 / 2 - 3196.413 * ( T / 1000 ) ** 3 / 3 + 2474.455 * ( T / 1000 ) ** 4 / 4 - 3.855326 / ( T / 1000 ) - 256.5478 + 285.8304 ) * 1e3 elif component == 'H2O_v' : # For T = 298.15 K. I failed to find a proper equation at the good range of temperature. return - 241.83 * 1e3 + Cp0 ( 'H2O_v' , T ) * M_H2O * ( T - 298.15 ) else : raise ValueError ( \"The element should be either 'H2O_l' or 'H2O_v'\" ) h_a ( P , T , Wgc , Hgc ) This function calculates the effective convective-conductive mass transfer coefficient at the anode, in m.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Wgc ( float ) \u2013 Width of the gas channel in m. Hgc ( float ) \u2013 Thickness of the gas channel in m. Returns: float \u2013 Effective convective-conductive mass transfer coefficient at the anode in m.s-1. Source code in modules/transitory_functions.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def h_a ( P , T , Wgc , Hgc ): \"\"\"This function calculates the effective convective-conductive mass transfer coefficient at the anode, in m.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Wgc : float Width of the gas channel in m. Hgc : float Thickness of the gas channel in m. Returns ------- float Effective convective-conductive mass transfer coefficient at the anode in m.s-1. \"\"\" Sh = 0.9247 * math . log ( Wgc / Hgc ) + 2.3787 # Sherwood coefficient. return Sh * Da ( P , T ) / Hgc h_c ( P , T , Wgc , Hgc ) This function calculates the effective convective-conductive mass transfer coefficient at the cathode, in m.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Wgc ( float ) \u2013 Width of the gas channel in m. Hgc ( float ) \u2013 Thickness of the gas channel in m. Returns: float \u2013 Effective convective-conductive mass transfer coefficient at the cathode in m.s-1. Source code in modules/transitory_functions.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 def h_c ( P , T , Wgc , Hgc ): \"\"\"This function calculates the effective convective-conductive mass transfer coefficient at the cathode, in m.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Wgc : float Width of the gas channel in m. Hgc : float Thickness of the gas channel in m. Returns ------- float Effective convective-conductive mass transfer coefficient at the cathode in m.s-1. \"\"\" Sh = 0.9247 * math . log ( Wgc / Hgc ) + 2.3787 # Sherwood coefficient. return Sh * Dc ( P , T ) / Hgc hmean ( terms , weights = None ) Calculate the weighted harmonic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling hmean from scipy.stats. Parameters: terms \u2013 The terms to calculate the harmonic mean for. weights \u2013 The weights corresponding to each term. If None, uniform weights are assumed. Returns: float \u2013 The weighted harmonic mean. Source code in modules/transitory_functions.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def hmean ( terms , weights = None ): \"\"\" Calculate the weighted harmonic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling hmean from scipy.stats. Parameters ---------- terms (list of float): The terms to calculate the harmonic mean for. weights (list of float): The weights corresponding to each term. If None, uniform weights are assumed. Returns ------- float: The weighted harmonic mean. \"\"\" if weights is None : weights = [ 1 ] * len ( terms ) # Assign equal weights if not provided if len ( terms ) != len ( weights ): raise ValueError ( \"The length of terms and weights must be the same.\" ) # Calculate the weighted harmonic mean weighted_sum = sum (( w / t ) for w , t in zip ( weights , terms ) if t != 0 ) total_weight = sum ( weights ) if weighted_sum == 0 : return float ( 'inf' ) # Avoid division by zero return total_weight / weighted_sum k_H2 ( lambdaa , T , kappa_co ) This function calculates the permeability coefficient of the membrane for hydrogen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns: float \u2013 Permeability coefficient of the membrane for hydrogen in mol.m\u22121.s\u22121.Pa\u22121. Source code in modules/transitory_functions.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 def k_H2 ( lambdaa , T , kappa_co ): \"\"\"This function calculates the permeability coefficient of the membrane for hydrogen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters ---------- lambdaa : float Water content in the membrane. T : float Temperature in K. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns ------- float Permeability coefficient of the membrane for hydrogen in mol.m\u22121.s\u22121.Pa\u22121. \"\"\" # Initialisation of the constants E_H2_v = 2.1e4 # J.mol-1. It is the activation energy of H2 for crossover in the under saturated membrane. E_H2_l = 1.8e4 # J.mol-1. It is the activation energy of H2 for crossover in the liquide-equilibrated membrane. Tref = 303.15 # K. # Calculation of the permeability coefficient of the membrane for hydrogen if lambdaa < 17.6 : return kappa_co * ( 0.29 + 2.2 * fv ( lambdaa , T )) * 1e-14 * math . exp ( E_H2_v / R * ( 1 / Tref - 1 / T )) else : return kappa_co * 1.8 * 1e-14 * math . exp ( E_H2_l / R * ( 1 / Tref - 1 / T )) k_O2 ( lambdaa , T , kappa_co ) This function calculates the permeability coefficient of the membrane for oxygen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns: float \u2013 Permeability coefficient of the membrane for oxygen in mol.m\u22121.s\u22121.Pa\u22121. Source code in modules/transitory_functions.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 def k_O2 ( lambdaa , T , kappa_co ): \"\"\"This function calculates the permeability coefficient of the membrane for oxygen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters ---------- lambdaa : float Water content in the membrane. T : float Temperature in K. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns ------- float Permeability coefficient of the membrane for oxygen in mol.m\u22121.s\u22121.Pa\u22121. \"\"\" # Initialisation of the constants E_O2_v = 2.2e4 # J.mol-1. It is the activation energy of oxygen for crossover in the under saturated membrane. E_O2_l = 2.0e4 # J.mol-1. It is the activation energy of oxygen for crossover in the liquide-equilibrated membrane. Tref = 303.15 # K. # Calculation of the permeability coefficient of the membrane for oxygen if lambdaa < 17.6 : return kappa_co * ( 0.11 + 1.9 * fv ( lambdaa , T )) * 1e-14 * math . exp ( E_O2_v / R * ( 1 / Tref - 1 / T )) else : return kappa_co * 1.2 * 1e-14 * math . exp ( E_O2_l / R * ( 1 / Tref - 1 / T )) k_th ( component , T ) This function calculates the thermal conductivity of fluids, in J.m-1.s-1.K-1, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the thermal conductivity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Thermal conductivity of the selected fluid in J.m-1.s-1.K-1. Notes Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons) Source code in modules/transitory_functions.py 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 def k_th ( component , T ): \"\"\"This function calculates the thermal conductivity of fluids, in J.m-1.s-1.K-1, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the thermal conductivity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Thermal conductivity of the selected fluid in J.m-1.s-1.K-1. Notes ----- Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons)\"\"\" if component == 'H2O_l' : # For T >= 273.16 and T <= 633.15 K. return - 0.2987 + 4.7054e-3 * T - 5.6209e-6 * T ** 2 elif component == 'H2O_v' : # For T >= 150 K and T <= 1500 k. return 5.6199e-3 + 1.5699e-5 * T + 1.0106e-7 * T ** 2 - 2.4282e-11 * T ** 3 elif component == 'H2' : # For T >= 14 K and T <= 1500 K. return 1.0979e-2 + 6.6411e-4 * T - 3.4378e-7 * T ** 2 + 9.7283e-11 * T ** 3 elif component == 'O2' : # For T >= 80 K and T <= 2000 K. return 1.5475e-4 + 9.4153e-5 * T - 2.7529e-8 * T ** 2 + 5.2069e-12 * T ** 3 elif component == 'N2' : # For T >= 63 K and T <= 1500 K. return - 2.2678e-4 + 1.0275e-4 * T - 6.0151e-8 * T ** 2 + 2.2332e-11 * T ** 3 else : raise ValueError ( \"The element should be either 'H2O_l', 'H2O_v', 'H2', 'O2' or 'N2'.\" ) k_th_eff ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None , epsilon_c = None ) This function calculates the effective thermal conductivity, in J.m-1.s-1.K-1, in either the GDL, the MPL, the CL or the membrane. A weighted harmonic average is used for characterizing the conductivity of each material in a layer, instead of a weighted arithmetic average. The physical meaning is that all the heat energy is forced to pass through all the material, as a series resistance network, instead of a parallel one [pharoahEffectiveTransportCoefficients2006]. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T ( float ) \u2013 Temperature in K. C_v ( float , default: None ) \u2013 Water concentration variable in mol.m-3. s ( float , default: None ) \u2013 Liquid water saturation variable. lambdaa ( float , default: None ) \u2013 Water content in the membrane. C_H2 ( float , default: None ) \u2013 Concentration of hydrogen in the AGDL or ACL. C_O2 ( float , default: None ) \u2013 Concentration of oxygen in the CGDL or CCL. C_N2 ( float , default: None ) \u2013 Concentration of nitrogen in the CGDL or CCL. epsilon ( float , default: None ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Effective thermal conductivity in J.m-1.s-1.K-1. Source code in modules/transitory_functions.py 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def k_th_eff ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None , epsilon_c = None ): \"\"\"This function calculates the effective thermal conductivity, in J.m-1.s-1.K-1, in either the GDL, the MPL, the CL or the membrane. A weighted harmonic average is used for characterizing the conductivity of each material in a layer, instead of a weighted arithmetic average. The physical meaning is that all the heat energy is forced to pass through all the material, as a series resistance network, instead of a parallel one [pharoahEffectiveTransportCoefficients2006]. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T : float Temperature in K. C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. C_H2 : float Concentration of hydrogen in the AGDL or ACL. C_O2 : float Concentration of oxygen in the CGDL or CCL. C_N2 : float Concentration of nitrogen in the CGDL or CCL. epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. Returns ------- float Effective thermal conductivity in J.m-1.s-1.K-1.\"\"\" if element == 'agdl' or element == 'cgdl' : # The effective thermal conductivity at the GDL if C_v == None or s == None or epsilon == None or epsilon_c == None : raise ValueError ( \"For the GDL, C_v, s, epsilon and epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta3 = 4.04 elif 0.67 <= epsilon <= 0.90 : beta3 = 4.40 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) if element == 'agdl' : # The thermal conductivity of the gas mixture in the AGDL if C_H2 == None : raise ValueError ( \"For the AGDL, C_H2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T )], [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )], [ M_H2O , M_H2 ]) else : # The thermal conductivity of the gas mixture in the CGDL if C_O2 == None or C_N2 == None : raise ValueError ( \"For the CGDL, C_O2 and C_N2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_gdl * math . exp ( beta3 * epsilon_c ), k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) if element == 'ampl' or element == 'cmpl' : # The effective thermal conductivity at the GDL if C_v == None or s == None or epsilon == None : raise ValueError ( \"For the MPL, C_v, s and epsilon must be provided.\" ) if element == 'ampl' : # The thermal conductivity of the gas mixture in the AGDL if C_H2 == None : raise ValueError ( \"For the AGDL, C_H2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T )], [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )], [ M_H2O , M_H2 ]) else : # The thermal conductivity of the gas mixture in the CGDL if C_O2 == None or C_N2 == None : raise ValueError ( \"For the CGDL, C_O2 and C_N2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_mpl , k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element == 'acl' or element == 'ccl' : # The effective thermal conductivity at the CL if C_v == None or lambdaa == None or s == None or epsilon == None or epsilon_mc == None : raise ValueError ( \"For the CL, C_v, lambdaa, s, epsilon and epsilon_mc must be provided.\" ) k_th_eff_mem = hmean ([ k_th_mem , k_th ( 'H2O_l' , T )], weights = [ 1 - fv ( lambdaa , T ), fv ( lambdaa , T )]) # The effective thermal conductivity at the # membrane if element == 'acl' : # The thermal conductivity of the gas mixture in the ACL if C_H2 == None : raise ValueError ( \"For the ACL, C_H2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T )], [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )], [ M_H2O , M_H2 ]) else : # The thermal conductivity of the gas mixture in the CCL if C_O2 == None or C_N2 == None : raise ValueError ( \"For the CCL, C_O2 and C_N2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_cl , k_th_eff_mem , k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon - epsilon_mc , epsilon_mc , epsilon * s , epsilon * ( 1 - s )]) elif element == 'mem' : # The effective thermal conductivity at the membrane if lambdaa == None : raise ValueError ( \"For the membrane, lambdaa must be provided.\" ) return hmean ([ k_th_mem , k_th ( 'H2O_l' , T )], weights = [ 1 - fv ( lambdaa , T ), fv ( lambdaa , T )]) else : raise ValueError ( \"The element should be either 'agdl', 'cgdl', 'ampl', 'cmpl', 'acl', 'ccl' or 'mem'.\" ) k_th_gaz_mixture ( k_th_g , mu_g , x , M ) This function calculates the thermal conductivity of a gas mixture, in J.m-1.s-1.K-1. The Lindsay\u2013Bromley (Wassiljewa) method is used. Parameters: k_th_g ( list ) \u2013 Thermal conductivities of each pure gas component, in J.m-1.s-1.K-1, at the same temperature. mu_g ( list ) \u2013 Viscosity of each pure gas component, in Pa.s, at the same temperature. x ( list ) \u2013 Mole fractions of each gas component in the mixture (must sum to 1). M ( list ) \u2013 Molar masses of each gas component (in kg.mol-1). Returns: lambda_mix ( float ) \u2013 Thermal conductivity of the gas mixture, in J.m-1.s-1.K-1. Notes Source : [wuMathematicalModelingTransient2009] and [polingPropertiesGasesLiquids2001] Source code in modules/transitory_functions.py 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 def k_th_gaz_mixture ( k_th_g , mu_g , x , M ): \"\"\"This function calculates the thermal conductivity of a gas mixture, in J.m-1.s-1.K-1. The Lindsay\u2013Bromley (Wassiljewa) method is used. Parameters ---------- k_th_g : list Thermal conductivities of each pure gas component, in J.m-1.s-1.K-1, at the same temperature. mu_g : list Viscosity of each pure gas component, in Pa.s, at the same temperature. x : list Mole fractions of each gas component in the mixture (must sum to 1). M : list Molar masses of each gas component (in kg.mol-1). Returns ------- lambda_mix : float Thermal conductivity of the gas mixture, in J.m-1.s-1.K-1. Notes ----- Source : [wuMathematicalModelingTransient2009] and [polingPropertiesGasesLiquids2001]\"\"\" if abs ( sum ( x ) - 1.0 ) > 1e-6 : raise ValueError ( \"The sum of the molar fractions should be 1.\" ) n = len ( k_th_g ) A_W = np . zeros (( n , n )) # Interaction coefficient from Wassiljewa equation. epsilon_TS = 0.85 # Value suggested by Tandon and Saxena in 1965. # Calculation of A_W using Maxon and Saxena suggestion. for i in range ( n ): for j in range ( n ): if i == j : A_W [ i , j ] = 1.0 else : A_W [ i , j ] = ( epsilon_TS * ( 1 + ( mu_g [ i ] / mu_g [ j ]) ** 0.5 * ( M [ j ] / M [ i ]) ** 0.25 ) ** 2 ) / \\ ( 8 * ( 1 + M [ i ] / M [ j ])) ** 0.5 # Calculation of the thermal conductivity of the gas mixture. k_th_gaz_mixture = 0.0 for i in range ( n ): k_th_gaz_mixture += x [ i ] * k_th_g [ i ] / sum ([ x [ j ] * A_W [ i , j ] for j in range ( n )]) return k_th_gaz_mixture lambda_eq ( C_v , s , T ) This function calculates the equilibrium water content in the membrane. Hinatsu's expression modified with Bao's formulation has been selected. Parameters: C_v ( float ) \u2013 Water concentration variable in mol.m-3. s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Equilibrium water content in the membrane. Source code in modules/transitory_functions.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def lambda_eq ( C_v , s , T ): \"\"\"This function calculates the equilibrium water content in the membrane. Hinatsu's expression modified with Bao's formulation has been selected. Parameters ---------- C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. T : float Temperature in K. Returns ------- float Equilibrium water content in the membrane. \"\"\" a_w = C_v / C_v_sat ( T ) + 2 * s # water activity return 0.5 * ( 0.300 + 10.8 * a_w - 16.0 * a_w ** 2 + 14.1 * a_w ** 3 ) * ( 1 - math . tanh ( 100 * ( a_w - 1 ))) \\ + 0.5 * ( 9.2 + 8.6 * ( 1 - math . exp ( - Kshape * ( a_w - 1 )))) * ( 1 + math . tanh ( 100 * ( a_w - 1 ))) mu_gaz ( component , T ) This function calculates the dynamic viscosity of different gases, in Pa.s, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the dynamic viscosity is calculated. Must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Dynamic viscosity of the selected gas in Pa.s. Notes Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons) Source code in modules/transitory_functions.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def mu_gaz ( component , T ): \"\"\"This function calculates the dynamic viscosity of different gases, in Pa.s, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the dynamic viscosity is calculated. Must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Dynamic viscosity of the selected gas in Pa.s. Notes ----- Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons)\"\"\" if component == 'H2O_v' : # For T >= 150 K and T <= 1500 k. return ( 22.8211 + 1.7387e-1 * T + 3.2465e-4 * T ** 2 - 1.4334e-7 * T ** 3 ) * 10 **- 7 elif component == 'H2' : # For T >= 15 K and T <= 1500 K. return ( 1.7611 + 3.4165e-1 * T - 1.8368e-4 * T ** 2 + 5.1147e-8 * T ** 3 ) * 10 **- 7 elif component == 'O2' : # For T >= 54 K and T <= 1500 K. return ( - 4.9433 + 8.0673e-1 * T - 4.0416e-4 * T ** 2 + 1.0111e-7 * T ** 3 ) * 10 **- 7 elif component == 'N2' : # For T >= 63 K and T <= 1970 K. return ( 4.4656 + 6.3814e-1 * T - 2.6596e-4 * T ** 2 + 5.4113e-8 * T ** 3 ) * 10 **- 7 else : raise ValueError ( \"The element should be either 'H2O_v', 'H2', 'O2' or 'N2'.\" ) nu_l ( T ) This function calculates the liquid water kinematic viscosity, in m\u00b2.s-1, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Liquid water kinematic viscosity in m\u00b2.s-1. Source code in modules/transitory_functions.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def nu_l ( T ): \"\"\"This function calculates the liquid water kinematic viscosity, in m\u00b2.s-1, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Liquid water kinematic viscosity in m\u00b2.s-1. \"\"\" mu_l = 2.414 * 10 ** ( - 5 + 247.8 / ( T - 140.0 )) # Pa.s. It is the liquid water dynamic viscosity. return mu_l / rho_H2O_l ( T ) rho_H2O_l ( T ) This function calculates the water density, in kg.m-3, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Water density in kg.m-3. Source code in modules/transitory_functions.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def rho_H2O_l ( T ): \"\"\"This function calculates the water density, in kg.m-3, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Water density in kg.m-3. \"\"\" T_Celsius = T - 273.15 return (( 999.83952 + 16.945176 * T_Celsius - 7.9870401e-3 * T_Celsius ** 2 - 46.170461e-6 * T_Celsius ** 3 + 105.56302e-9 * T_Celsius ** 4 - 280.54253e-12 * T_Celsius ** 5 ) / ( 1 + 16.879850e-3 * T_Celsius )) sigma ( T ) This function calculates the water surface tension, in N.m-1, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Water surface tension in N.m-1. Source code in modules/transitory_functions.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def sigma ( T ): \"\"\"This function calculates the water surface tension, in N.m-1, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Water surface tension in N.m-1. \"\"\" return 235.8e-3 * (( 647.15 - T ) / 647.15 ) ** 1.256 * ( 1 - 0.625 * ( 647.15 - T ) / 647.15 ) sigma_e_eff ( element , epsilon , epsilon_c = None , epsilon_mc = None ) This function calculates the effective electrical conductivity, in \u03a9-1.m-1, in either the GDL, the MPL or the CL, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon ( float ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Effective electrical conductivity in \u03a9-1.m-1. Source code in modules/transitory_functions.py 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 def sigma_e_eff ( element , epsilon , epsilon_c = None , epsilon_mc = None ): \"\"\"This function calculates the effective electrical conductivity, in \u03a9-1.m-1, in either the GDL, the MPL or the CL, considering GDL compression. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. Returns ------- float Effective electrical conductivity in \u03a9-1.m-1. \"\"\" if element == 'gdl' : # The effective electrical conductivity at the GDL if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta3 = 4.04 elif 0.67 <= epsilon <= 0.90 : beta3 = 4.40 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) return ( 1 - epsilon ) * sigma_e_gdl * math . exp ( beta3 * epsilon_c ) # Using the volume fraction of conductive material. elif element == 'mpl' : # The effective electrical conductivity at the MPL return ( 1 - epsilon ) * sigma_e_mpl # Using the volume fraction of conductive material. elif element == 'cl' : # The effective electrical conductivity at the CL if epsilon_mc == None : raise ValueError ( \"For the CL, epsilon_mc must be provided.\" ) return ( 1 - epsilon - epsilon_mc ) * sigma_e_cl # Using the volume fraction of conductive material. else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" ) sigma_p_eff ( element , lambdaa , T , epsilon_mc = None ) This function calculates the effective proton conductivity, in \u03a9-1.m-1, in either the membrane or the CCL. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'mem' (membrane) or 'ccl' (cathode catalyst layer). lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CCL. Returns: float \u2013 Proton conductivity in \u03a9-1.m-1. Source code in modules/transitory_functions.py 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 def sigma_p_eff ( element , lambdaa , T , epsilon_mc = None ): \"\"\"This function calculates the effective proton conductivity, in \u03a9-1.m-1, in either the membrane or the CCL. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'mem' (membrane) or 'ccl' (cathode catalyst layer). lambdaa : float Water content in the membrane. T : float Temperature in K. epsilon_mc : float Volume fraction of ionomer in the CCL. Returns ------- float Proton conductivity in \u03a9-1.m-1. \"\"\" if element == 'mem' : # The proton conductivity at the membrane if lambdaa >= 1 : return ( 0.5139 * lambdaa - 0.326 ) * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) else : return 0.1879 * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) elif element == 'ccl' : # The effective proton conductivity at the cathode catalyst layer if epsilon_mc == None : raise ValueError ( \"For the CCL, epsilon_mc must be provided.\" ) if lambdaa >= 1 : return epsilon_mc * ( 0.5139 * lambdaa - 0.326 ) * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) else : return epsilon_mc * 0.1879 * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) else : raise ValueError ( \"The element should be either 'mem' or 'ccl'.\" )","title":"Transitory functions"},{"location":"functions/modules/transitory_functions/#transitory-functions","text":"This module contains transitory functions which all have a specific physical meaning for modeling the PEM fuel cell.","title":"Transitory functions"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.C_v_sat","text":"This function calculates the saturated vapor concentration for a perfect gas, in mol.m-3, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Saturated vapor concentration for a perfect gas in mol.m-3. Source code in modules/transitory_functions.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def C_v_sat ( T ): \"\"\"This function calculates the saturated vapor concentration for a perfect gas, in mol.m-3, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Saturated vapor concentration for a perfect gas in mol.m-3. \"\"\" return Psat ( T ) / ( R * T )","title":"C_v_sat"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Cp0","text":"This function calculates the specific heat capacity of fluids, in J.kg-1.K-1, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Specific heat capacity of the selected fluid in J.kg-1.K-1. Notes Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition Source code in modules/transitory_functions.py 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 def Cp0 ( component , T ): \"\"\"This function calculates the specific heat capacity of fluids, in J.kg-1.K-1, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Specific heat capacity of the selected fluid in J.kg-1.K-1. Notes ----- Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition\"\"\" if component == 'H2O_l' : # For T >= 298 and T <= 500 K. return 1 / M_H2O * ( - 203.6060 + 1523.290 * ( T / 1000 ) - 3196.413 * ( T / 1000 ) ** 2 + 2474.455 * ( T / 1000 ) ** 3 + 3.855326 / ( T / 1000 ) ** 2 ) elif component == 'H2O_v' : # For T = 350 K. I failed to find a proper equation at the good range of temperature. return 1880 elif component == 'H2' : # For T >= 298 K and T <= 1000 K. return 1 / M_H2 * ( 33.066178 - 11.363417 * ( T / 1000 ) + 11.432816 * ( T / 1000 ) ** 2 - 2.772874 * ( T / 1000 ) ** 3 - 0.158558 / ( T / 1000 ) ** 2 ) elif component == 'O2' : # For T >= 100 K and T <= 700 K. return 1 / M_O2 * ( 31.32234 - 20.23531 * ( T / 1000 ) + 57.86644 * ( T / 1000 ) ** 2 - 36.50624 * ( T / 1000 ) ** 3 - 0.007374 / ( T / 1000 ) ** 2 ) elif component == 'N2' : # For T >= 100 K and T <= 500 K. return 1 / M_N2 * ( 28.98641 + 1.853978 * ( T / 1000 ) - 9.647459 * ( T / 1000 ) ** 2 + 16.63537 * ( T / 1000 ) ** 3 + 0.000117 / ( T / 1000 ) ** 2 ) else : raise ValueError ( \"The element should be either 'H2O_l', 'H2O_v', 'H2', 'O2' or 'N2'.\" )","title":"Cp0"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.D","text":"This function calculates the diffusion coefficient of water in the membrane, in m\u00b2.s-1. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. Returns: float \u2013 Diffusion coefficient of water in the membrane in m\u00b2.s-1. Source code in modules/transitory_functions.py 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def D ( lambdaa ): \"\"\"This function calculates the diffusion coefficient of water in the membrane, in m\u00b2.s-1. Parameters ---------- lambdaa : float Water content in the membrane. Returns ------- float Diffusion coefficient of water in the membrane in m\u00b2.s-1. \"\"\" return 4.1e-10 * ( lambdaa / 25.0 ) ** 0.15 * ( 1.0 + math . tanh (( lambdaa - 2.5 ) / 1.4 ))","title":"D"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Da","text":"This function calculates the diffusion coefficient at the anode, in m\u00b2.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Diffusion coefficient at the anode in m\u00b2.s-1. Source code in modules/transitory_functions.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def Da ( P , T ): \"\"\"This function calculates the diffusion coefficient at the anode, in m\u00b2.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Returns ------- float Diffusion coefficient at the anode in m\u00b2.s-1. \"\"\" return 1.644e-4 * ( T / 333 ) ** 2.334 * ( 101325 / P )","title":"Da"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Da_eff","text":"This function calculates the effective diffusion coefficient at the GDL or the CL and at the anode, in m\u00b2.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. P ( float ) \u2013 Pressure in Pa. epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective diffusion coefficient at the anode in m\u00b2.s-1. Source code in modules/transitory_functions.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 def Da_eff ( element , s , T , P , epsilon , epsilon_c = None ): \"\"\"This function calculates the effective diffusion coefficient at the GDL or the CL and at the anode, in m\u00b2.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. P : float Pressure in Pa. epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Effective diffusion coefficient at the anode in m\u00b2.s-1. \"\"\" if element == 'gdl' : # The effective diffusion coefficient at the GDL using Tomadakis and Sotirchos model. if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta2 = - 1.59 elif 0.67 <= epsilon <= 0.90 : beta2 = - 0.90 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) return epsilon * (( epsilon - epsilon_p ) / ( 1 - epsilon_p )) ** alpha_p * math . exp ( beta2 * epsilon_c ) * ( 1 - s ) ** 2 * Da ( P , T ) elif element == 'mpl' : # The effective diffusion coefficient at the MPL using Bruggeman model. return epsilon ** tau_mpl * ( 1 - s ) ** tau_mpl * Da ( P , T ) elif element == 'cl' : # The effective diffusion coefficient at the CL using Bruggeman model. return epsilon ** tau_cl * ( 1 - s ) ** tau_cl * Da ( P , T ) else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" )","title":"Da_eff"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Dc","text":"This function calculates the diffusion coefficient at the cathode, in m\u00b2.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Diffusion coefficient at the cathode in m\u00b2.s-1. Source code in modules/transitory_functions.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def Dc ( P , T ): \"\"\"This function calculates the diffusion coefficient at the cathode, in m\u00b2.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Returns ------- float Diffusion coefficient at the cathode in m\u00b2.s-1. \"\"\" return 3.242e-5 * ( T / 333 ) ** 2.334 * ( 101325 / P )","title":"Dc"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Dc_eff","text":"This function calculates the effective diffusion coefficient at the GDL or the CL and at the cathode, in m\u00b2.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. P ( float ) \u2013 Pressure in Pa. epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective diffusion coefficient at the cathode in m\u00b2.s-1. Source code in modules/transitory_functions.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def Dc_eff ( element , s , T , P , epsilon , epsilon_c = None ): \"\"\"This function calculates the effective diffusion coefficient at the GDL or the CL and at the cathode, in m\u00b2.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. P : float Pressure in Pa. epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Effective diffusion coefficient at the cathode in m\u00b2.s-1. \"\"\" if element == 'gdl' : # The effective diffusion coefficient at the GDL using Tomadakis and Sotirchos model. if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta2 = - 1.59 elif 0.67 <= epsilon <= 0.90 : beta2 = - 0.90 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) return epsilon * (( epsilon - epsilon_p ) / ( 1 - epsilon_p )) ** alpha_p * math . exp ( beta2 * epsilon_c ) * ( 1 - s ) ** 2 * Dc ( P , T ) elif element == 'mpl' : # The effective diffusion coefficient at the MPL using Bruggeman model. return epsilon ** tau_mpl * ( 1 - s ) ** tau_mpl * Dc ( P , T ) elif element == 'cl' : # The effective diffusion coefficient at the CL using Bruggeman model. return epsilon ** tau_cl * ( 1 - s ) ** tau_cl * Dc ( P , T ) else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" )","title":"Dc_eff"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Dcap","text":"This function calculates the capillary coefficient at the GDL or the CL and at the anode, in kg.m.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the capillary coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. epsilon ( float ) \u2013 Porosity. e ( float ) \u2013 Capillary exponent. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Source code in modules/transitory_functions.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def Dcap ( element , s , T , epsilon , e , epsilon_c = None ): \"\"\" This function calculates the capillary coefficient at the GDL or the CL and at the anode, in kg.m.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the capillary coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. epsilon : float Porosity. e : float Capillary exponent. epsilon_c : float, optional Compression ratio of the GDL. \"\"\" if element == 'gdl' : if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) return sigma ( T ) * K0 ( element , epsilon , epsilon_c ) / nu_l ( T ) * abs ( math . cos ( theta_c_gdl )) * \\ ( epsilon / K0 ( element , epsilon , epsilon_c )) ** 0.5 * ( s ** e + 1e-7 ) * ( 1.417 - 4.24 * s + 3.789 * s ** 2 ) elif element == 'mpl' : return sigma ( T ) * K0 ( element , epsilon ) / nu_l ( T ) * abs ( math . cos ( theta_c_mpl )) * \\ ( epsilon / K0 ( element , epsilon )) ** 0.5 * ( s ** e + 1e-7 ) * ( 1.417 - 4.24 * s + 3.789 * s ** 2 ) elif element == 'cl' : return sigma ( T ) * K0 ( element , epsilon ) / nu_l ( T ) * abs ( math . cos ( theta_c_cl )) * \\ ( epsilon / K0 ( element , epsilon )) ** 0.5 * ( s ** e + 1e-7 ) * ( 1.417 - 4.24 * s + 3.789 * s ** 2 ) else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" )","title":"Dcap"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.K0","text":"This function calculates the intrinsic permeability, in m\u00b2, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the intrinsic permeability is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Intrinsic permeability in m\u00b2. Sources Qin Chen 2020 - Two-dimensional multi-physics modeling of porous transport layer in polymer electrolyte membrane electrolyzer for water splitting - for the Blake-Kozeny equation. M.L. Stewart 2005 - A study of pore geometry effects on anisotropy in hydraulic permeability using the lattice-Boltzmann method - for the Blake-Kozeny equation. Source code in modules/transitory_functions.py 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def K0 ( element , epsilon , epsilon_c = None ): \"\"\"This function calculates the intrinsic permeability, in m\u00b2, considering GDL compression. Parameters ---------- element : str Specifies the element for which the intrinsic permeability is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Intrinsic permeability in m\u00b2. Sources ------- 1. Qin Chen 2020 - Two-dimensional multi-physics modeling of porous transport layer in polymer electrolyte membrane electrolyzer for water splitting - for the Blake-Kozeny equation. 2. M.L. Stewart 2005 - A study of pore geometry effects on anisotropy in hydraulic permeability using the lattice-Boltzmann method - for the Blake-Kozeny equation. \"\"\" if element == 'gdl' : if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta1 = - 3.60 elif 0.67 <= epsilon <= 0.90 : beta1 = - 2.60 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) return epsilon / ( 8 * math . log ( epsilon ) ** 2 ) * ( epsilon - epsilon_p ) ** ( alpha_p + 2 ) * \\ 4.6e-6 ** 2 / (( 1 - epsilon_p ) ** alpha_p * (( alpha_p + 1 ) * epsilon - epsilon_p ) ** 2 ) * math . exp ( beta1 * epsilon_c ) elif element == 'mpl' : return ( Dp_mpl ** 2 / 150 ) * ( epsilon ** 3 / (( 1 - epsilon ) ** 2 )) # Using the Blake-Kozeny equation elif element == 'cl' : return ( Dp_cl ** 2 / 150 ) * ( epsilon ** 3 / (( 1 - epsilon ) ** 2 )) # Using the Blake-Kozeny equation else : raise ValueError ( \"The element should be either 'gdl' or 'cl'.\" )","title":"K0"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Psat","text":"This function calculates the saturated partial pressure of vapor, in Pa, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Saturated partial pressure of vapor in Pa. Source code in modules/transitory_functions.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def Psat ( T ): \"\"\"This function calculates the saturated partial pressure of vapor, in Pa, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Saturated partial pressure of vapor in Pa. \"\"\" Tcelsius = T - 273.15 return 101325 * 10 ** ( - 2.1794 + 0.02953 * Tcelsius - 9.1837e-5 * Tcelsius ** 2 + 1.4454e-7 * Tcelsius ** 3 )","title":"Psat"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Svl","text":"This function calculates the phase transfer rate of water condensation or evaporation, in mol.m-3.s-1. Parameters: s ( float ) \u2013 Liquid water saturation variable. C_v ( float ) \u2013 Water concentration variable in mol.m-3. Ctot ( float ) \u2013 Total gas concentration in mol.m-3. T ( float ) \u2013 Temperature in K. epsilon ( float ) \u2013 Porosity. gamma_cond ( float ) \u2013 Overall condensation rate constant for water in s-1. gamma_evap ( float ) \u2013 Overall evaporation rate constant for water in Pa-1.s-1. Returns: float \u2013 Phase transfer rate of water condensation or evaporation in mol.m-3.s-1. Source code in modules/transitory_functions.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def Svl ( s , C_v , Ctot , T , epsilon , gamma_cond , gamma_evap ): \"\"\"This function calculates the phase transfer rate of water condensation or evaporation, in mol.m-3.s-1. Parameters ---------- s : float Liquid water saturation variable. C_v : float Water concentration variable in mol.m-3. Ctot : float Total gas concentration in mol.m-3. T : float Temperature in K. epsilon : float Porosity. gamma_cond : float Overall condensation rate constant for water in s-1. gamma_evap : float Overall evaporation rate constant for water in Pa-1.s-1. Returns ------- float Phase transfer rate of water condensation or evaporation in mol.m-3.s-1. \"\"\" if C_v > C_v_sat ( T ): # condensation return gamma_cond * epsilon * ( 1 - s ) * ( C_v / Ctot ) * ( C_v - C_v_sat ( T )) else : # evaporation return - gamma_evap * epsilon * s * rho_H2O_l ( T ) / M_H2O * R * T * ( C_v_sat ( T ) - C_v )","title":"Svl"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.average","text":"Calculate the weighted arithmetic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling average from numpy. Parameters: terms \u2013 The terms to calculate the average for. weights \u2013 The weights corresponding to each term. If None, uniform weights are assumed. Returns: float \u2013 The weighted arithmetic mean. Source code in modules/transitory_functions.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def average ( terms , weights = None ): \"\"\" Calculate the weighted arithmetic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling average from numpy. Parameters ---------- terms (list of float): The terms to calculate the average for. weights (list of float, optional): The weights corresponding to each term. If None, uniform weights are assumed. Returns ------- float: The weighted arithmetic mean. \"\"\" if weights is None : # If no weights are provided, use uniform weights weights = [ 1 ] * len ( terms ) if len ( terms ) != len ( weights ): raise ValueError ( \"The length of terms and weights must be the same.\" ) # Calculate the weighted arithmetic mean weighted_sum = sum ( w * t for w , t in zip ( weights , terms )) total_weight = sum ( weights ) if total_weight == 0 : return float ( 'nan' ) # Avoid division by zero return weighted_sum / total_weight","title":"average"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.calculate_rho_Cp0","text":"This function calculates the volumetric heat capacity, in J.m-3.K-1, in either the GDL, the MPL, the CL or the membrane. Parameters: element ( str ) \u2013 Specifies the element for which the volumetric heat capacity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T ( float ) \u2013 Temperature in K. C_v ( float , default: None ) \u2013 Water concentration variable in mol.m-3. s ( float , default: None ) \u2013 Liquid water saturation variable. lambdaa ( float , default: None ) \u2013 Water content in the membrane. C_H2 ( float , default: None ) \u2013 Concentration of hydrogen in the AGDL or ACL. C_O2 ( float , default: None ) \u2013 Concentration of oxygen in the CGDL or CCL. C_N2 ( float , default: None ) \u2013 Concentration of nitrogen in the CGDL or CCL. epsilon ( float , default: None ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Volumetric heat capacity in J.m-3.K-1. Source code in modules/transitory_functions.py 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 def calculate_rho_Cp0 ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None ): \"\"\"This function calculates the volumetric heat capacity, in J.m-3.K-1, in either the GDL, the MPL, the CL or the membrane. Parameters ---------- element : str Specifies the element for which the volumetric heat capacity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T : float Temperature in K. C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. C_H2 : float Concentration of hydrogen in the AGDL or ACL. C_O2 : float Concentration of oxygen in the CGDL or CCL. C_N2 : float Concentration of nitrogen in the CGDL or CCL. epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. Returns ------- float Volumetric heat capacity in J.m-3.K-1.\"\"\" if element == 'agdl' or element == 'cgdl' : # The volumetric heat capacity at the GDL if C_v is None or s is None or epsilon is None : raise ValueError ( \"For the GDL, C_v, s and epsilon must be provided.\" ) if element == 'agdl' : # The heat capacity of the gas mixture in the AGDL if C_H2 is None : raise ValueError ( \"For the AGDL, C_H2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T )], weights = [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )]) else : # The heat capacity of the gas mixture in the CGDL if C_O2 is None or C_N2 is None : raise ValueError ( \"For the CGDL, C_O2 and C_N2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )]) return average ([ rho_gdl * Cp_gdl , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) if element == 'ampl' or element == 'cmpl' : # The volumetric heat capacity at the MPL if C_v is None or s is None or epsilon is None : raise ValueError ( \"For the MPL, C_v, s and epsilon must be provided.\" ) if element == 'ampl' : # The heat capacity of the gas mixture in the AMPL if C_H2 is None : raise ValueError ( \"For the AMPL, C_H2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T )], weights = [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )]) else : # The heat capacity of the gas mixture in the CMPL if C_O2 is None or C_N2 is None : raise ValueError ( \"For the CMPL, C_O2 and C_N2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )]) return average ([ rho_gdl * Cp_mpl , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element == 'acl' or element == 'ccl' : # The volumetric heat capacity at the CL if C_v is None or lambdaa is None or s is None or epsilon is None or epsilon_mc is None : raise ValueError ( \"For the CL, C_v, lambdaa, s, epsilon, and epsilon_mc must be provided.\" ) if element == 'acl' : # The heat capacity of the gas mixture in the ACL if C_H2 is None : raise ValueError ( \"For the ACL, C_H2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T )], weights = [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )]) else : # The heat capacity of the gas mixture in the CCL if C_O2 is None or C_N2 is None : raise ValueError ( \"For the CCL, C_O2 and C_N2 must be provided.\" ) rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )]) return average ([ rho_cl * Cp_cl , rho_mem * Cp_mem , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon - epsilon_mc , epsilon_mc , epsilon * s , epsilon * ( 1 - s )]) elif element == 'mem' : # The volumetric heat capacity at the membrane if lambdaa is None : raise ValueError ( \"For the membrane, lambdaa must be provided.\" ) return average ([ rho_mem * Cp_mem , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T )], weights = [ 1 - fv ( lambdaa , T ), fv ( lambdaa , T )]) else : raise ValueError ( \"The element should be either 'agdl', 'cgdl', 'ampl', 'cmpl', 'acl', 'ccl' or 'mem'.\" )","title":"calculate_rho_Cp0"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.delta_h_abs","text":"This function computes the molar enthalpy of absorption of water at a given temperature, in J.mol-1. This reaction is exothermic. Parameters T : float Temperature in K. Returns delta_h_sorp : float Molar enthalpy of absorption in the CL in J.mol-1. Notes For Nafion, the enthalpy of absorption is almost equal to that of liquefaction [vetterFreeOpenReference2019]. Source code in modules/transitory_functions.py 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 def delta_h_abs ( T ): \"\"\"This function computes the molar enthalpy of absorption of water at a given temperature, in J.mol-1. This reaction is exothermic. Parameters ---------- T : float Temperature in K. Returns ------- delta_h_sorp : float Molar enthalpy of absorption in the CL in J.mol-1. Notes ----- For Nafion, the enthalpy of absorption is almost equal to that of liquefaction [vetterFreeOpenReference2019]. \"\"\" return delta_h_liq ( T )","title":"delta_h_abs"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.delta_h_liq","text":"This function computes the molar enthalpy of liquefaction of water at a given temperature, in J.mol-1. It is calculated as the difference in molar enthalpy between liquid water (H2O_l) and water vapor (H2O_v). Parameters T : float Temperature in K. Returns delta_h_liq : float Molar enthalpy of liquefaction in J.mol-1. Notes This value should be close to -42 000 J.mol-1 [vetterFreeOpenReference2019]. Source code in modules/transitory_functions.py 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 def delta_h_liq ( T ): \"\"\"This function computes the molar enthalpy of liquefaction of water at a given temperature, in J.mol-1. It is calculated as the difference in molar enthalpy between liquid water (H2O_l) and water vapor (H2O_v). Parameters ---------- T : float Temperature in K. Returns ------- delta_h_liq : float Molar enthalpy of liquefaction in J.mol-1. Notes ----- This value should be close to -42 000 J.mol-1 [vetterFreeOpenReference2019]. \"\"\" return h0 ( 'H2O_l' , T ) - h0 ( 'H2O_v' , T )","title":"delta_h_liq"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.fv","text":"This function calculates the water volume fraction of the membrane. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. Returns: float \u2013 Water volume fraction of the membrane. Source code in modules/transitory_functions.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def fv ( lambdaa , T ): \"\"\"This function calculates the water volume fraction of the membrane. Parameters ---------- lambdaa : float Water content in the membrane. Returns ------- float Water volume fraction of the membrane. \"\"\" return ( lambdaa * M_H2O / rho_H2O_l ( T )) / ( M_eq / rho_mem + lambdaa * M_H2O / rho_H2O_l ( T ))","title":"fv"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.gamma_sorp","text":"This function calculates the sorption rate of water in the membrane, in s-1. Parameters: C_v ( float ) \u2013 Water concentration variable in mol.m-3. s ( float ) \u2013 Liquid water saturation variable. lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. Hcl ( float ) \u2013 Thickness of the CL layer. Returns: float \u2013 Sorption rate of water in the membrane in s-1. Source code in modules/transitory_functions.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 def gamma_sorp ( C_v , s , lambdaa , T , Hcl ): \"\"\"This function calculates the sorption rate of water in the membrane, in s-1. Parameters ---------- C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. T : float Temperature in K. Hcl : float Thickness of the CL layer. Returns ------- float Sorption rate of water in the membrane in s-1. \"\"\" if lambda_eq ( C_v , s , T ) >= lambdaa : # absorption return ( 1.14e-5 * fv ( lambdaa , T )) / Hcl * math . exp ( 2416 * ( 1 / 303 - 1 / T )) else : # desorption return ( 4.59e-5 * fv ( lambdaa , T )) / Hcl * math . exp ( 2416 * ( 1 / 303 - 1 / T ))","title":"gamma_sorp"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.h0","text":"This function calculates the standard enthalpy of fluids, in J.mol-1, as a function of the temperature. The variation of the enthalpy of reaction with temperature is given by Kirchhoff's Law of Thermochemistry. Parameters: component ( str ) \u2013 Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water) or 'H2O_v' (vapor). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Standard enthalpy of the selected fluid in J.mol-1. Notes Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition Source code in modules/transitory_functions.py 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 def h0 ( component , T ): \"\"\"This function calculates the standard enthalpy of fluids, in J.mol-1, as a function of the temperature. The variation of the enthalpy of reaction with temperature is given by Kirchhoff's Law of Thermochemistry. Parameters ---------- component : str Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water) or 'H2O_v' (vapor). T : float Temperature in K. Returns ------- float Standard enthalpy of the selected fluid in J.mol-1. Notes ----- Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition\"\"\" if component == 'H2O_l' : # For T >= 298 and T <= 500 K. return ( - 285.83 - 203.6060 * ( T / 1000 ) + 1523.290 * ( T / 1000 ) ** 2 / 2 - 3196.413 * ( T / 1000 ) ** 3 / 3 + 2474.455 * ( T / 1000 ) ** 4 / 4 - 3.855326 / ( T / 1000 ) - 256.5478 + 285.8304 ) * 1e3 elif component == 'H2O_v' : # For T = 298.15 K. I failed to find a proper equation at the good range of temperature. return - 241.83 * 1e3 + Cp0 ( 'H2O_v' , T ) * M_H2O * ( T - 298.15 ) else : raise ValueError ( \"The element should be either 'H2O_l' or 'H2O_v'\" )","title":"h0"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.h_a","text":"This function calculates the effective convective-conductive mass transfer coefficient at the anode, in m.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Wgc ( float ) \u2013 Width of the gas channel in m. Hgc ( float ) \u2013 Thickness of the gas channel in m. Returns: float \u2013 Effective convective-conductive mass transfer coefficient at the anode in m.s-1. Source code in modules/transitory_functions.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def h_a ( P , T , Wgc , Hgc ): \"\"\"This function calculates the effective convective-conductive mass transfer coefficient at the anode, in m.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Wgc : float Width of the gas channel in m. Hgc : float Thickness of the gas channel in m. Returns ------- float Effective convective-conductive mass transfer coefficient at the anode in m.s-1. \"\"\" Sh = 0.9247 * math . log ( Wgc / Hgc ) + 2.3787 # Sherwood coefficient. return Sh * Da ( P , T ) / Hgc","title":"h_a"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.h_c","text":"This function calculates the effective convective-conductive mass transfer coefficient at the cathode, in m.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Wgc ( float ) \u2013 Width of the gas channel in m. Hgc ( float ) \u2013 Thickness of the gas channel in m. Returns: float \u2013 Effective convective-conductive mass transfer coefficient at the cathode in m.s-1. Source code in modules/transitory_functions.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 def h_c ( P , T , Wgc , Hgc ): \"\"\"This function calculates the effective convective-conductive mass transfer coefficient at the cathode, in m.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Wgc : float Width of the gas channel in m. Hgc : float Thickness of the gas channel in m. Returns ------- float Effective convective-conductive mass transfer coefficient at the cathode in m.s-1. \"\"\" Sh = 0.9247 * math . log ( Wgc / Hgc ) + 2.3787 # Sherwood coefficient. return Sh * Dc ( P , T ) / Hgc","title":"h_c"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.hmean","text":"Calculate the weighted harmonic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling hmean from scipy.stats. Parameters: terms \u2013 The terms to calculate the harmonic mean for. weights \u2013 The weights corresponding to each term. If None, uniform weights are assumed. Returns: float \u2013 The weighted harmonic mean. Source code in modules/transitory_functions.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def hmean ( terms , weights = None ): \"\"\" Calculate the weighted harmonic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling hmean from scipy.stats. Parameters ---------- terms (list of float): The terms to calculate the harmonic mean for. weights (list of float): The weights corresponding to each term. If None, uniform weights are assumed. Returns ------- float: The weighted harmonic mean. \"\"\" if weights is None : weights = [ 1 ] * len ( terms ) # Assign equal weights if not provided if len ( terms ) != len ( weights ): raise ValueError ( \"The length of terms and weights must be the same.\" ) # Calculate the weighted harmonic mean weighted_sum = sum (( w / t ) for w , t in zip ( weights , terms ) if t != 0 ) total_weight = sum ( weights ) if weighted_sum == 0 : return float ( 'inf' ) # Avoid division by zero return total_weight / weighted_sum","title":"hmean"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_H2","text":"This function calculates the permeability coefficient of the membrane for hydrogen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns: float \u2013 Permeability coefficient of the membrane for hydrogen in mol.m\u22121.s\u22121.Pa\u22121. Source code in modules/transitory_functions.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 def k_H2 ( lambdaa , T , kappa_co ): \"\"\"This function calculates the permeability coefficient of the membrane for hydrogen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters ---------- lambdaa : float Water content in the membrane. T : float Temperature in K. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns ------- float Permeability coefficient of the membrane for hydrogen in mol.m\u22121.s\u22121.Pa\u22121. \"\"\" # Initialisation of the constants E_H2_v = 2.1e4 # J.mol-1. It is the activation energy of H2 for crossover in the under saturated membrane. E_H2_l = 1.8e4 # J.mol-1. It is the activation energy of H2 for crossover in the liquide-equilibrated membrane. Tref = 303.15 # K. # Calculation of the permeability coefficient of the membrane for hydrogen if lambdaa < 17.6 : return kappa_co * ( 0.29 + 2.2 * fv ( lambdaa , T )) * 1e-14 * math . exp ( E_H2_v / R * ( 1 / Tref - 1 / T )) else : return kappa_co * 1.8 * 1e-14 * math . exp ( E_H2_l / R * ( 1 / Tref - 1 / T ))","title":"k_H2"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_O2","text":"This function calculates the permeability coefficient of the membrane for oxygen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns: float \u2013 Permeability coefficient of the membrane for oxygen in mol.m\u22121.s\u22121.Pa\u22121. Source code in modules/transitory_functions.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 def k_O2 ( lambdaa , T , kappa_co ): \"\"\"This function calculates the permeability coefficient of the membrane for oxygen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters ---------- lambdaa : float Water content in the membrane. T : float Temperature in K. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns ------- float Permeability coefficient of the membrane for oxygen in mol.m\u22121.s\u22121.Pa\u22121. \"\"\" # Initialisation of the constants E_O2_v = 2.2e4 # J.mol-1. It is the activation energy of oxygen for crossover in the under saturated membrane. E_O2_l = 2.0e4 # J.mol-1. It is the activation energy of oxygen for crossover in the liquide-equilibrated membrane. Tref = 303.15 # K. # Calculation of the permeability coefficient of the membrane for oxygen if lambdaa < 17.6 : return kappa_co * ( 0.11 + 1.9 * fv ( lambdaa , T )) * 1e-14 * math . exp ( E_O2_v / R * ( 1 / Tref - 1 / T )) else : return kappa_co * 1.2 * 1e-14 * math . exp ( E_O2_l / R * ( 1 / Tref - 1 / T ))","title":"k_O2"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_th","text":"This function calculates the thermal conductivity of fluids, in J.m-1.s-1.K-1, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the thermal conductivity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Thermal conductivity of the selected fluid in J.m-1.s-1.K-1. Notes Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons) Source code in modules/transitory_functions.py 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 def k_th ( component , T ): \"\"\"This function calculates the thermal conductivity of fluids, in J.m-1.s-1.K-1, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the thermal conductivity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Thermal conductivity of the selected fluid in J.m-1.s-1.K-1. Notes ----- Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons)\"\"\" if component == 'H2O_l' : # For T >= 273.16 and T <= 633.15 K. return - 0.2987 + 4.7054e-3 * T - 5.6209e-6 * T ** 2 elif component == 'H2O_v' : # For T >= 150 K and T <= 1500 k. return 5.6199e-3 + 1.5699e-5 * T + 1.0106e-7 * T ** 2 - 2.4282e-11 * T ** 3 elif component == 'H2' : # For T >= 14 K and T <= 1500 K. return 1.0979e-2 + 6.6411e-4 * T - 3.4378e-7 * T ** 2 + 9.7283e-11 * T ** 3 elif component == 'O2' : # For T >= 80 K and T <= 2000 K. return 1.5475e-4 + 9.4153e-5 * T - 2.7529e-8 * T ** 2 + 5.2069e-12 * T ** 3 elif component == 'N2' : # For T >= 63 K and T <= 1500 K. return - 2.2678e-4 + 1.0275e-4 * T - 6.0151e-8 * T ** 2 + 2.2332e-11 * T ** 3 else : raise ValueError ( \"The element should be either 'H2O_l', 'H2O_v', 'H2', 'O2' or 'N2'.\" )","title":"k_th"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_th_eff","text":"This function calculates the effective thermal conductivity, in J.m-1.s-1.K-1, in either the GDL, the MPL, the CL or the membrane. A weighted harmonic average is used for characterizing the conductivity of each material in a layer, instead of a weighted arithmetic average. The physical meaning is that all the heat energy is forced to pass through all the material, as a series resistance network, instead of a parallel one [pharoahEffectiveTransportCoefficients2006]. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T ( float ) \u2013 Temperature in K. C_v ( float , default: None ) \u2013 Water concentration variable in mol.m-3. s ( float , default: None ) \u2013 Liquid water saturation variable. lambdaa ( float , default: None ) \u2013 Water content in the membrane. C_H2 ( float , default: None ) \u2013 Concentration of hydrogen in the AGDL or ACL. C_O2 ( float , default: None ) \u2013 Concentration of oxygen in the CGDL or CCL. C_N2 ( float , default: None ) \u2013 Concentration of nitrogen in the CGDL or CCL. epsilon ( float , default: None ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Effective thermal conductivity in J.m-1.s-1.K-1. Source code in modules/transitory_functions.py 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def k_th_eff ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None , epsilon_c = None ): \"\"\"This function calculates the effective thermal conductivity, in J.m-1.s-1.K-1, in either the GDL, the MPL, the CL or the membrane. A weighted harmonic average is used for characterizing the conductivity of each material in a layer, instead of a weighted arithmetic average. The physical meaning is that all the heat energy is forced to pass through all the material, as a series resistance network, instead of a parallel one [pharoahEffectiveTransportCoefficients2006]. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T : float Temperature in K. C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. C_H2 : float Concentration of hydrogen in the AGDL or ACL. C_O2 : float Concentration of oxygen in the CGDL or CCL. C_N2 : float Concentration of nitrogen in the CGDL or CCL. epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. Returns ------- float Effective thermal conductivity in J.m-1.s-1.K-1.\"\"\" if element == 'agdl' or element == 'cgdl' : # The effective thermal conductivity at the GDL if C_v == None or s == None or epsilon == None or epsilon_c == None : raise ValueError ( \"For the GDL, C_v, s, epsilon and epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta3 = 4.04 elif 0.67 <= epsilon <= 0.90 : beta3 = 4.40 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) if element == 'agdl' : # The thermal conductivity of the gas mixture in the AGDL if C_H2 == None : raise ValueError ( \"For the AGDL, C_H2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T )], [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )], [ M_H2O , M_H2 ]) else : # The thermal conductivity of the gas mixture in the CGDL if C_O2 == None or C_N2 == None : raise ValueError ( \"For the CGDL, C_O2 and C_N2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_gdl * math . exp ( beta3 * epsilon_c ), k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) if element == 'ampl' or element == 'cmpl' : # The effective thermal conductivity at the GDL if C_v == None or s == None or epsilon == None : raise ValueError ( \"For the MPL, C_v, s and epsilon must be provided.\" ) if element == 'ampl' : # The thermal conductivity of the gas mixture in the AGDL if C_H2 == None : raise ValueError ( \"For the AGDL, C_H2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T )], [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )], [ M_H2O , M_H2 ]) else : # The thermal conductivity of the gas mixture in the CGDL if C_O2 == None or C_N2 == None : raise ValueError ( \"For the CGDL, C_O2 and C_N2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_mpl , k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element == 'acl' or element == 'ccl' : # The effective thermal conductivity at the CL if C_v == None or lambdaa == None or s == None or epsilon == None or epsilon_mc == None : raise ValueError ( \"For the CL, C_v, lambdaa, s, epsilon and epsilon_mc must be provided.\" ) k_th_eff_mem = hmean ([ k_th_mem , k_th ( 'H2O_l' , T )], weights = [ 1 - fv ( lambdaa , T ), fv ( lambdaa , T )]) # The effective thermal conductivity at the # membrane if element == 'acl' : # The thermal conductivity of the gas mixture in the ACL if C_H2 == None : raise ValueError ( \"For the ACL, C_H2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T )], [ C_v / ( C_v + C_H2 ), C_H2 / ( C_v + C_H2 )], [ M_H2O , M_H2 ]) else : # The thermal conductivity of the gas mixture in the CCL if C_O2 == None or C_N2 == None : raise ValueError ( \"For the CCL, C_O2 and C_N2 must be provided.\" ) k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ C_v / ( C_v + C_O2 + C_N2 ), C_O2 / ( C_v + C_O2 + C_N2 ), C_N2 / ( C_v + C_O2 + C_N2 )], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_cl , k_th_eff_mem , k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon - epsilon_mc , epsilon_mc , epsilon * s , epsilon * ( 1 - s )]) elif element == 'mem' : # The effective thermal conductivity at the membrane if lambdaa == None : raise ValueError ( \"For the membrane, lambdaa must be provided.\" ) return hmean ([ k_th_mem , k_th ( 'H2O_l' , T )], weights = [ 1 - fv ( lambdaa , T ), fv ( lambdaa , T )]) else : raise ValueError ( \"The element should be either 'agdl', 'cgdl', 'ampl', 'cmpl', 'acl', 'ccl' or 'mem'.\" )","title":"k_th_eff"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_th_gaz_mixture","text":"This function calculates the thermal conductivity of a gas mixture, in J.m-1.s-1.K-1. The Lindsay\u2013Bromley (Wassiljewa) method is used. Parameters: k_th_g ( list ) \u2013 Thermal conductivities of each pure gas component, in J.m-1.s-1.K-1, at the same temperature. mu_g ( list ) \u2013 Viscosity of each pure gas component, in Pa.s, at the same temperature. x ( list ) \u2013 Mole fractions of each gas component in the mixture (must sum to 1). M ( list ) \u2013 Molar masses of each gas component (in kg.mol-1). Returns: lambda_mix ( float ) \u2013 Thermal conductivity of the gas mixture, in J.m-1.s-1.K-1. Notes Source : [wuMathematicalModelingTransient2009] and [polingPropertiesGasesLiquids2001] Source code in modules/transitory_functions.py 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 def k_th_gaz_mixture ( k_th_g , mu_g , x , M ): \"\"\"This function calculates the thermal conductivity of a gas mixture, in J.m-1.s-1.K-1. The Lindsay\u2013Bromley (Wassiljewa) method is used. Parameters ---------- k_th_g : list Thermal conductivities of each pure gas component, in J.m-1.s-1.K-1, at the same temperature. mu_g : list Viscosity of each pure gas component, in Pa.s, at the same temperature. x : list Mole fractions of each gas component in the mixture (must sum to 1). M : list Molar masses of each gas component (in kg.mol-1). Returns ------- lambda_mix : float Thermal conductivity of the gas mixture, in J.m-1.s-1.K-1. Notes ----- Source : [wuMathematicalModelingTransient2009] and [polingPropertiesGasesLiquids2001]\"\"\" if abs ( sum ( x ) - 1.0 ) > 1e-6 : raise ValueError ( \"The sum of the molar fractions should be 1.\" ) n = len ( k_th_g ) A_W = np . zeros (( n , n )) # Interaction coefficient from Wassiljewa equation. epsilon_TS = 0.85 # Value suggested by Tandon and Saxena in 1965. # Calculation of A_W using Maxon and Saxena suggestion. for i in range ( n ): for j in range ( n ): if i == j : A_W [ i , j ] = 1.0 else : A_W [ i , j ] = ( epsilon_TS * ( 1 + ( mu_g [ i ] / mu_g [ j ]) ** 0.5 * ( M [ j ] / M [ i ]) ** 0.25 ) ** 2 ) / \\ ( 8 * ( 1 + M [ i ] / M [ j ])) ** 0.5 # Calculation of the thermal conductivity of the gas mixture. k_th_gaz_mixture = 0.0 for i in range ( n ): k_th_gaz_mixture += x [ i ] * k_th_g [ i ] / sum ([ x [ j ] * A_W [ i , j ] for j in range ( n )]) return k_th_gaz_mixture","title":"k_th_gaz_mixture"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.lambda_eq","text":"This function calculates the equilibrium water content in the membrane. Hinatsu's expression modified with Bao's formulation has been selected. Parameters: C_v ( float ) \u2013 Water concentration variable in mol.m-3. s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Equilibrium water content in the membrane. Source code in modules/transitory_functions.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def lambda_eq ( C_v , s , T ): \"\"\"This function calculates the equilibrium water content in the membrane. Hinatsu's expression modified with Bao's formulation has been selected. Parameters ---------- C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. T : float Temperature in K. Returns ------- float Equilibrium water content in the membrane. \"\"\" a_w = C_v / C_v_sat ( T ) + 2 * s # water activity return 0.5 * ( 0.300 + 10.8 * a_w - 16.0 * a_w ** 2 + 14.1 * a_w ** 3 ) * ( 1 - math . tanh ( 100 * ( a_w - 1 ))) \\ + 0.5 * ( 9.2 + 8.6 * ( 1 - math . exp ( - Kshape * ( a_w - 1 )))) * ( 1 + math . tanh ( 100 * ( a_w - 1 )))","title":"lambda_eq"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.mu_gaz","text":"This function calculates the dynamic viscosity of different gases, in Pa.s, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the dynamic viscosity is calculated. Must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Dynamic viscosity of the selected gas in Pa.s. Notes Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons) Source code in modules/transitory_functions.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def mu_gaz ( component , T ): \"\"\"This function calculates the dynamic viscosity of different gases, in Pa.s, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the dynamic viscosity is calculated. Must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Dynamic viscosity of the selected gas in Pa.s. Notes ----- Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons)\"\"\" if component == 'H2O_v' : # For T >= 150 K and T <= 1500 k. return ( 22.8211 + 1.7387e-1 * T + 3.2465e-4 * T ** 2 - 1.4334e-7 * T ** 3 ) * 10 **- 7 elif component == 'H2' : # For T >= 15 K and T <= 1500 K. return ( 1.7611 + 3.4165e-1 * T - 1.8368e-4 * T ** 2 + 5.1147e-8 * T ** 3 ) * 10 **- 7 elif component == 'O2' : # For T >= 54 K and T <= 1500 K. return ( - 4.9433 + 8.0673e-1 * T - 4.0416e-4 * T ** 2 + 1.0111e-7 * T ** 3 ) * 10 **- 7 elif component == 'N2' : # For T >= 63 K and T <= 1970 K. return ( 4.4656 + 6.3814e-1 * T - 2.6596e-4 * T ** 2 + 5.4113e-8 * T ** 3 ) * 10 **- 7 else : raise ValueError ( \"The element should be either 'H2O_v', 'H2', 'O2' or 'N2'.\" )","title":"mu_gaz"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.nu_l","text":"This function calculates the liquid water kinematic viscosity, in m\u00b2.s-1, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Liquid water kinematic viscosity in m\u00b2.s-1. Source code in modules/transitory_functions.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def nu_l ( T ): \"\"\"This function calculates the liquid water kinematic viscosity, in m\u00b2.s-1, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Liquid water kinematic viscosity in m\u00b2.s-1. \"\"\" mu_l = 2.414 * 10 ** ( - 5 + 247.8 / ( T - 140.0 )) # Pa.s. It is the liquid water dynamic viscosity. return mu_l / rho_H2O_l ( T )","title":"nu_l"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.rho_H2O_l","text":"This function calculates the water density, in kg.m-3, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Water density in kg.m-3. Source code in modules/transitory_functions.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def rho_H2O_l ( T ): \"\"\"This function calculates the water density, in kg.m-3, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Water density in kg.m-3. \"\"\" T_Celsius = T - 273.15 return (( 999.83952 + 16.945176 * T_Celsius - 7.9870401e-3 * T_Celsius ** 2 - 46.170461e-6 * T_Celsius ** 3 + 105.56302e-9 * T_Celsius ** 4 - 280.54253e-12 * T_Celsius ** 5 ) / ( 1 + 16.879850e-3 * T_Celsius ))","title":"rho_H2O_l"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.sigma","text":"This function calculates the water surface tension, in N.m-1, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Water surface tension in N.m-1. Source code in modules/transitory_functions.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def sigma ( T ): \"\"\"This function calculates the water surface tension, in N.m-1, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Water surface tension in N.m-1. \"\"\" return 235.8e-3 * (( 647.15 - T ) / 647.15 ) ** 1.256 * ( 1 - 0.625 * ( 647.15 - T ) / 647.15 )","title":"sigma"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.sigma_e_eff","text":"This function calculates the effective electrical conductivity, in \u03a9-1.m-1, in either the GDL, the MPL or the CL, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon ( float ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Effective electrical conductivity in \u03a9-1.m-1. Source code in modules/transitory_functions.py 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 def sigma_e_eff ( element , epsilon , epsilon_c = None , epsilon_mc = None ): \"\"\"This function calculates the effective electrical conductivity, in \u03a9-1.m-1, in either the GDL, the MPL or the CL, considering GDL compression. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. Returns ------- float Effective electrical conductivity in \u03a9-1.m-1. \"\"\" if element == 'gdl' : # The effective electrical conductivity at the GDL if epsilon_c == None : raise ValueError ( \"For the GDL, epsilon_c must be provided.\" ) # According to the GDL porosity, the GDL compression effect is different. if 0.50 <= epsilon < 0.67 : beta3 = 4.04 elif 0.67 <= epsilon <= 0.90 : beta3 = 4.40 else : raise ValueError ( \"In order to calculate the effects of the GDL compression on its structure, \" \"epsilon_gdl should be between 0.50 and 0.90.\" ) return ( 1 - epsilon ) * sigma_e_gdl * math . exp ( beta3 * epsilon_c ) # Using the volume fraction of conductive material. elif element == 'mpl' : # The effective electrical conductivity at the MPL return ( 1 - epsilon ) * sigma_e_mpl # Using the volume fraction of conductive material. elif element == 'cl' : # The effective electrical conductivity at the CL if epsilon_mc == None : raise ValueError ( \"For the CL, epsilon_mc must be provided.\" ) return ( 1 - epsilon - epsilon_mc ) * sigma_e_cl # Using the volume fraction of conductive material. else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" )","title":"sigma_e_eff"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.sigma_p_eff","text":"This function calculates the effective proton conductivity, in \u03a9-1.m-1, in either the membrane or the CCL. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'mem' (membrane) or 'ccl' (cathode catalyst layer). lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CCL. Returns: float \u2013 Proton conductivity in \u03a9-1.m-1. Source code in modules/transitory_functions.py 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 def sigma_p_eff ( element , lambdaa , T , epsilon_mc = None ): \"\"\"This function calculates the effective proton conductivity, in \u03a9-1.m-1, in either the membrane or the CCL. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'mem' (membrane) or 'ccl' (cathode catalyst layer). lambdaa : float Water content in the membrane. T : float Temperature in K. epsilon_mc : float Volume fraction of ionomer in the CCL. Returns ------- float Proton conductivity in \u03a9-1.m-1. \"\"\" if element == 'mem' : # The proton conductivity at the membrane if lambdaa >= 1 : return ( 0.5139 * lambdaa - 0.326 ) * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) else : return 0.1879 * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) elif element == 'ccl' : # The effective proton conductivity at the cathode catalyst layer if epsilon_mc == None : raise ValueError ( \"For the CCL, epsilon_mc must be provided.\" ) if lambdaa >= 1 : return epsilon_mc * ( 0.5139 * lambdaa - 0.326 ) * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) else : return epsilon_mc * 0.1879 * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) else : raise ValueError ( \"The element should be either 'mem' or 'ccl'.\" )","title":"sigma_p_eff"}]}