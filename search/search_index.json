{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AlphaPEM AlphaPEM is an open-source software package for simulating proton exchange membrane fuel cell (PEMFC) systems for embedded applications. It is based on a physics-based, finite-volume, one-dimensional (1D), dynamic, two-phase, and non-isothermal model. It quickly simulates the internal states and voltage dynamics of PEMFC systems for all current densities and operating conditions imposed on it. In particular, it is possible to apply a step current density or use current profiles to generate polarization curves or electrochemical impedance spectroscopy (EIS) curves. It can also automatically calibrate the undetermined parameters of the model to simulate a given real fuel cell system. A detailed presentation of this program was published in the peer-reviewed journal SoftwareX. Improvements to AlphaPEM , such as the addition of heat transfer modelling and spatial extension to 1D+1D, will be available in the future. Important note: AlphaPEM is an ongoing research project and is not a commercial product. Therefore, the latest online version may contain bugs, and not all features may be available. Relatively stable versions are listed in the Major updates section. Table of Contents Installation Major updates Work in progress Related publications Installation To install AlphaPEM , follow these steps in a shell: Clone the repository: git clone https://github.com/gassraphael/AlphaPEM.git Navigate to the project directory: cd AlphaPEM Update the Python package manager, pip, to the latest available version: pip install --upgrade pip Install the required dependencies (eventually in a specific environment): pip install numpy scipy matplotlib colorama pygad python3 -m pip install git+https://github.com/RedFantom/ttkthemes Major updates V1.2 - in progress - This version of AlphaPEM includes: the addition of convective flow between the inlet, gas channels, and outlet of the cell, thereby removing the Pukrushpan equations (from Michigan University). auxiliary considerations are temporarily removed, as they require reconstruction. the addition of the MPL to the simulated cell, in both the anode and cathode. the addition of the open-source ZSW GenStack as a calibrated fuel cell case study. V1.1 - 2025.08.18 - This version of AlphaPEM includes: the addition of heat transfer to the program, in cooperation with Pedro Affonso Nobrega (PERSEE, MINES PSL). an improvement of the initial variable values: the algorithm waits for a given time to reach equilibrium, and then the experiment starts (step/pola/EIS). the limit liquid water saturation coefficient ($s_{lim}$) is temporarily removed for future refinement. V1.0 - 2024.09.05 - This version of AlphaPEM corresponds to the one developed during Rapha\u00ebl Gass's PhD from 2021 to 2024. It is based on a physics-based, one-dimensional (1D), dynamic, two-phase, and isothermal model. Work in progress The polarization curves from the EH-31 fuel cell example are no longer calibrated due to recent modifications made to the equations. A calibration of the undeterminate parameters will be performed in the future to correct this issue. If accurate examples are required, the V1.0 version of AlphaPEM can be used. Related publications The detailed model description and simulation results can be found in the following articles and thesis. Published journal papers: AlphaPEM: An Open-Source Dynamic 1D Physics-Based Pem Fuel Cell Model for Embedded Applications (2025, 1st author) In the SoftwareX journal, in arXiv , in HAL or in SSRN (postprint). The objective of this work is to highlight the AlphaPEM software, which has been published as open-source on GitHub. The first version of this PEM fuel cell simulator is based on the dynamic 1D model developed during 2021-2024. An Advanced 1D Physics-Based Model for PEM Hydrogen Fuel Cells With Enhanced Overvoltage Prediction (2025, 1st author) In the International Journal of Hydrogen Energy , in arXiv , in HAL or in SSRN (postprint). The aim of this study was to introduce the dynamic 1D model developed during 2021-2024, emphasizing the adjustment of the equations for this specific model and their numerical resolution. Furthermore, a novel coefficient is proposed to establish a physical relationship between the voltage drop at high currents, the quantity of liquid water in the cell, and operating conditions. A Critical Review of Proton Exchange Membrane Fuel Cells Matter Transports and Voltage Polarisation for Modelling (2024, 1st author) In the Journal of the Electrochemical Society or in HAL (postprint). The aim of this work was to compile, within a single article, all the equations required for the physical modeling of a fuel cell. Each equation is complemented with explanations, critical analysis, and suggestions for potential enhancements. Thesis manuscript: Advanced physical modeling of PEM fuel cells to enhance their performances (2024, 1st author) In HAL (final version). The objective of this thesis was to develop an advanced model for PEMFCs to optimize their control and improve performance. A 1D, dynamic, two-phase, isothermal model was proposed, leading to the development of the open-source software AlphaPEM, which enables accurate simulations and facilitates predictive control strategies for enhanced fuel cell operation.","title":"Home"},{"location":"#alphapem","text":"AlphaPEM is an open-source software package for simulating proton exchange membrane fuel cell (PEMFC) systems for embedded applications. It is based on a physics-based, finite-volume, one-dimensional (1D), dynamic, two-phase, and non-isothermal model. It quickly simulates the internal states and voltage dynamics of PEMFC systems for all current densities and operating conditions imposed on it. In particular, it is possible to apply a step current density or use current profiles to generate polarization curves or electrochemical impedance spectroscopy (EIS) curves. It can also automatically calibrate the undetermined parameters of the model to simulate a given real fuel cell system. A detailed presentation of this program was published in the peer-reviewed journal SoftwareX. Improvements to AlphaPEM , such as the addition of heat transfer modelling and spatial extension to 1D+1D, will be available in the future. Important note: AlphaPEM is an ongoing research project and is not a commercial product. Therefore, the latest online version may contain bugs, and not all features may be available. Relatively stable versions are listed in the Major updates section.","title":"AlphaPEM"},{"location":"#table-of-contents","text":"Installation Major updates Work in progress Related publications","title":"Table of Contents"},{"location":"#installation","text":"To install AlphaPEM , follow these steps in a shell: Clone the repository: git clone https://github.com/gassraphael/AlphaPEM.git Navigate to the project directory: cd AlphaPEM Update the Python package manager, pip, to the latest available version: pip install --upgrade pip Install the required dependencies (eventually in a specific environment): pip install numpy scipy matplotlib colorama pygad python3 -m pip install git+https://github.com/RedFantom/ttkthemes","title":"Installation"},{"location":"#major-updates","text":"V1.2 - in progress - This version of AlphaPEM includes: the addition of convective flow between the inlet, gas channels, and outlet of the cell, thereby removing the Pukrushpan equations (from Michigan University). auxiliary considerations are temporarily removed, as they require reconstruction. the addition of the MPL to the simulated cell, in both the anode and cathode. the addition of the open-source ZSW GenStack as a calibrated fuel cell case study. V1.1 - 2025.08.18 - This version of AlphaPEM includes: the addition of heat transfer to the program, in cooperation with Pedro Affonso Nobrega (PERSEE, MINES PSL). an improvement of the initial variable values: the algorithm waits for a given time to reach equilibrium, and then the experiment starts (step/pola/EIS). the limit liquid water saturation coefficient ($s_{lim}$) is temporarily removed for future refinement. V1.0 - 2024.09.05 - This version of AlphaPEM corresponds to the one developed during Rapha\u00ebl Gass's PhD from 2021 to 2024. It is based on a physics-based, one-dimensional (1D), dynamic, two-phase, and isothermal model.","title":"Major updates"},{"location":"#work-in-progress","text":"The polarization curves from the EH-31 fuel cell example are no longer calibrated due to recent modifications made to the equations. A calibration of the undeterminate parameters will be performed in the future to correct this issue. If accurate examples are required, the V1.0 version of AlphaPEM can be used.","title":"Work in progress"},{"location":"#related-publications","text":"The detailed model description and simulation results can be found in the following articles and thesis. Published journal papers: AlphaPEM: An Open-Source Dynamic 1D Physics-Based Pem Fuel Cell Model for Embedded Applications (2025, 1st author) In the SoftwareX journal, in arXiv , in HAL or in SSRN (postprint). The objective of this work is to highlight the AlphaPEM software, which has been published as open-source on GitHub. The first version of this PEM fuel cell simulator is based on the dynamic 1D model developed during 2021-2024. An Advanced 1D Physics-Based Model for PEM Hydrogen Fuel Cells With Enhanced Overvoltage Prediction (2025, 1st author) In the International Journal of Hydrogen Energy , in arXiv , in HAL or in SSRN (postprint). The aim of this study was to introduce the dynamic 1D model developed during 2021-2024, emphasizing the adjustment of the equations for this specific model and their numerical resolution. Furthermore, a novel coefficient is proposed to establish a physical relationship between the voltage drop at high currents, the quantity of liquid water in the cell, and operating conditions. A Critical Review of Proton Exchange Membrane Fuel Cells Matter Transports and Voltage Polarisation for Modelling (2024, 1st author) In the Journal of the Electrochemical Society or in HAL (postprint). The aim of this work was to compile, within a single article, all the equations required for the physical modeling of a fuel cell. Each equation is complemented with explanations, critical analysis, and suggestions for potential enhancements. Thesis manuscript: Advanced physical modeling of PEM fuel cells to enhance their performances (2024, 1st author) In HAL (final version). The objective of this thesis was to develop an advanced model for PEMFCs to optimize their control and improve performance. A 1D, dynamic, two-phase, isothermal model was proposed, leading to the development of the open-source software AlphaPEM, which enables accurate simulations and facilitates predictive control strategies for enhanced fuel cell operation.","title":"Related publications"},{"location":"about/","text":"Contributions Authors AlphaPEM is firstly developed by Rapha\u00ebl Gass during his PhD thesis in control engineering at the LIS Laboratory in Aix-Marseille University , and in co-supervision with FEMTO-ST Institute , within the FCLab , in Franche-Comt\u00e9 University , from 2021 to 2024. This work has been supervised by Prof. Zhongliang Li (FEMTO-ST), Prof. Rachid Outbib (LIS), Prof. Samir Jemei (FEMTO-ST) and Prof. Daniel Hissel (FEMTO-ST). The development of AlphaPEM was subsequently continued by Rapha\u00ebl Gass during his postdoctoral research from 2025 to 2027 at ENERGY-Lab , University of Reunion island , in partnership with the ZSW Institute in Ulm, Germany. This work was supervised by Prof. Michel Benne (ENERGY-Lab), Associate Prof. C\u00e9dric Damour (ENERGY-Lab), Associate Prof. Dominique Grondin (ENERGY-Lab), and Dr. Florian Wilhelm (ZSW). Financial support This work has been supported: from 2021 to 2024 by French National Research Agency via project DEAL (Grant no. ANR-20-CE05-0016-01), the Region Provence-Alpes-C\u00f4te d\u2019Azur, the EIPHI Graduate School (contract ANR-17-EURE-0002) and the Region Bourgogne Franche-Comt\u00e9. from 2025 to 2027 by European FEDER funds via project OPUS-H2 and the Region Reunion. Licenses AlphaPEM is licensed under the GNU GPL 3.0. See the LICENSE file for more details. It also includes components licensed under the BSD-3-Clause license : calibration/parameter_calibration.py from PyGAD . New contributors Contributions from the community are welcome! If you would like to contribute to AlphaPEM , please follow these steps: Fork the repository. Create a new branch ( git checkout -b feature/YourFeature ). Commit your changes ( git commit -am 'Add some feature' ). Push to the branch ( git push origin feature/YourFeature ). Create a new Pull Request. Contact For any questions or support, please contact me at gassraphael@proton.me .","title":"About"},{"location":"about/#contributions","text":"","title":"Contributions"},{"location":"about/#authors","text":"AlphaPEM is firstly developed by Rapha\u00ebl Gass during his PhD thesis in control engineering at the LIS Laboratory in Aix-Marseille University , and in co-supervision with FEMTO-ST Institute , within the FCLab , in Franche-Comt\u00e9 University , from 2021 to 2024. This work has been supervised by Prof. Zhongliang Li (FEMTO-ST), Prof. Rachid Outbib (LIS), Prof. Samir Jemei (FEMTO-ST) and Prof. Daniel Hissel (FEMTO-ST). The development of AlphaPEM was subsequently continued by Rapha\u00ebl Gass during his postdoctoral research from 2025 to 2027 at ENERGY-Lab , University of Reunion island , in partnership with the ZSW Institute in Ulm, Germany. This work was supervised by Prof. Michel Benne (ENERGY-Lab), Associate Prof. C\u00e9dric Damour (ENERGY-Lab), Associate Prof. Dominique Grondin (ENERGY-Lab), and Dr. Florian Wilhelm (ZSW).","title":"Authors"},{"location":"about/#financial-support","text":"This work has been supported: from 2021 to 2024 by French National Research Agency via project DEAL (Grant no. ANR-20-CE05-0016-01), the Region Provence-Alpes-C\u00f4te d\u2019Azur, the EIPHI Graduate School (contract ANR-17-EURE-0002) and the Region Bourgogne Franche-Comt\u00e9. from 2025 to 2027 by European FEDER funds via project OPUS-H2 and the Region Reunion.","title":"Financial support"},{"location":"about/#licenses","text":"AlphaPEM is licensed under the GNU GPL 3.0. See the LICENSE file for more details. It also includes components licensed under the BSD-3-Clause license : calibration/parameter_calibration.py from PyGAD .","title":"Licenses"},{"location":"about/#new-contributors","text":"Contributions from the community are welcome! If you would like to contribute to AlphaPEM , please follow these steps: Fork the repository. Create a new branch ( git checkout -b feature/YourFeature ). Commit your changes ( git commit -am 'Add some feature' ). Push to the branch ( git push origin feature/YourFeature ). Create a new Pull Request.","title":"New contributors"},{"location":"about/#contact","text":"For any questions or support, please contact me at gassraphael@proton.me .","title":"Contact"},{"location":"functions/GUI/","text":"GUI This file is designated for executing the AlphaPEM software package through a graphical user interface (GUI). Most of the functionalities are available, but some are not implemented. about () This function displays information about the program and its author in a dialog box when the \"About\" button is clicked. Source code in GUI.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def about (): \"\"\"This function displays information about the program and its author in a dialog box when the \"About\" button is clicked. \"\"\" msg = \"\"\"AlphaPEM is an open-source software package for simulating proton exchange membrane fuel cell (PEMFC) systems using physics-based models for embedded applications. It is based on a physics-based, finite-volume, one-dimensional (1D), dynamic, two-phase, and non-isothermal model. It can quickly simulate the internal states and voltage dynamics of PEMFC systems, and produce polarization and EIS curves. It can also automatically calibrate the undetermined parameters of the model to simulate a given real fuel cell system. AlphaPEM is firstly developed by Rapha\u00ebl Gass during his PhD thesis in control engineering at the LIS Laboratory in Aix-Marseille University, and in co-supervision with FEMTO-ST Institute, within the FCLab, in Franche-Comt\u00e9 University, from 2021 to 2024. This work has been supervised by Prof. Zhongliang Li (FEMTO-ST), Prof. Rachid Outbib (LIS), Prof. Samir Jemei (FEMTO-ST) and Prof. Daniel Hissel (FEMTO-ST). It has been supported by French National Research Agency via project DEAL (Grant no. ANR-20-CE05-0016-01, https://deal.lis-lab.fr/), the Region Provence-Alpes-C\u00f4te d\u2019Azur, the EIPHI Graduate School (contract ANR-17-EURE-0002) and the Region Bourgogne Franche-Comt\u00e9. The development of AlphaPEM was subsequently continued by Rapha\u00ebl Gass during his postdoctoral research from 2025 to 2027 at ENERGY-Lab, University of Reunion island, in partnership with the ZSW Institute in Ulm, Germany. This work was supervised by Prof. Michel Benne (ENERGY-Lab), Associate Prof. C\u00e9dric Damour (ENERGY-Lab), Associate Prof. Dominique Grondin (ENERGY-Lab), and Dr. Florian Wilhelm (ZSW). It has been supported by European FEDER funds via project OPUS-H2 (https://www.energylab.re/projets/projets-en-cours/opus-h2/) and the Region Reunion. It is related to the following articles: - Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a, - Gass et al 2025 I.J. of Hydrogen Energy https://doi.org/10.1016/j.ijhydene.2024.11.374. - Gass et al 2025 SoftwareX https://doi.org/10.1016/j.softx.2024.102002. More information can be found in: - AlphaPEM GitHub webpage: https://github.com/gassraphael/AlphaPEM - AlphaPEM documentation webpage: https://gassraphael.github.io/AlphaPEM/ - Author webpage: https://gassraphael.github.io/ If you want to contact me, please send an email to: raphael.gass@univ-reunion.fr.\"\"\" # Create a new top-level window about_window = tk . Toplevel () about_window . title ( 'About this program' ) # Set the size of the window about_window . geometry ( '730x460' ) # Width x Height # Create a label with the message label = ttk . Label ( about_window , text = msg , wraplength = 700 ) # wraplength to wrap text within the given width label . pack ( padx = 15 , pady = 15 ) # Add padding around the label # Create an OK button to close the window ok_button = ttk . Button ( about_window , text = 'OK' , command = about_window . destroy ) ok_button . pack ( pady = 10 ) control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) This function is responsible for validating the user inputs by calling the value_control() function. If the input is valid, it then calls the show_current_button function to perform the requested action based on the button_type. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in GUI.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function is responsible for validating the user inputs by calling the value_control() function. If the input is valid, it then calls the show_current_button function to perform the requested action based on the button_type. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # Control the values value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) # Activate the action show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) create_application () This function creates the main application window and setting its title. It calls the main_frame() function to create the main graphical elements of the window. Source code in GUI.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def create_application (): \"\"\"This function creates the main application window and setting its title. It calls the main_frame() function to create the main graphical elements of the window. \"\"\" # Create the main application window root = ThemedTk ( theme = \"arc\" ) root . configure ( background = '#f5f6f7' ) root . title ( \"AlphaPEM\" ) # Create a canvas and add a scrollbar to it canvas = tk . Canvas ( root ) scrollbar = ttk . Scrollbar ( root , command = canvas . yview ) canvas . configure ( yscrollcommand = scrollbar . set ) frame = ttk . Frame ( canvas ) # Create a frame inside the canvas to add your widgets # Add all the widgets to the frame main_frame ( frame , canvas ) canvas . create_window (( 0 , 0 ), window = frame , anchor = 'nw' ) # Add the frame to the canvas # Adjust the main window and canvas size frame . update_idletasks () root . geometry ( f \" { frame . winfo_width () } x { frame . winfo_height () } \" ) canvas . configure ( scrollregion = canvas . bbox ( 'all' )) canvas . pack ( fill = 'both' , expand = True , side = 'left' ) # Organize the widgets scrollbar . pack ( fill = 'y' , side = 'right' ) root . mainloop () main_frame ( root , canvas ) This function creates the main graphical elements, such as labels, entry widgets, radio buttons, and buttons. It arranges them in the application window (root). It also initializes the choice dictionary variables for various parameters and settings. Parameters: root : ThemedTk The main application window where the graphical elements will be placed. canvas : tk.Canvas The canvas where the main graphical elements will be placed. Source code in GUI.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def main_frame ( root , canvas ): \"\"\"This function creates the main graphical elements, such as labels, entry widgets, radio buttons, and buttons. It arranges them in the application window (root). It also initializes the choice dictionary variables for various parameters and settings. Parameters: ----------- root : ThemedTk The main application window where the graphical elements will be placed. canvas : tk.Canvas The canvas where the main graphical elements will be placed. \"\"\" # Create a custom styles style = ttk . Style () style . configure ( 'Custom.TFrame' , background = '#f5f6f7' ) style . configure ( 'Blue.TButton' , foreground = 'blue' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to blue style . configure ( 'Green.TButton' , foreground = 'green' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to green style . configure ( 'Red.TButton' , foreground = 'red' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to red style . configure ( 'Black.TButton' , foreground = 'black' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to black style . configure ( 'Big.TButton' , font = ( 'cmr10' , 12 , 'bold' )) # Create control variables to track the visibility state of some frame show_info_undetermined_parameters = tk . BooleanVar ( value = False ) show_info_current_density_parameters = tk . BooleanVar ( value = False ) show_info_computing_parameters = tk . BooleanVar ( value = False ) # Create the frames to hold the different set of information # Fuel cell type and operating conditions operating_conditions_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) operating_conditions_frame . grid ( row = 1 , column = 0 , padx = 5 , pady = 5 ) # Accessible physical parameters accessible_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) accessible_parameters_frame . grid ( row = 3 , column = 0 , padx = 5 , pady = 5 ) # Undetermined physical parameters undetermined_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) undetermined_parameters_frame . grid ( row = 5 , column = 0 , padx = 5 , pady = 5 ) undetermined_parameters_frame . grid_remove () # Hide the frame by default # Current density parameters current_density_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) current_density_parameters_frame . grid ( row = 7 , column = 0 , padx = 5 , pady = 5 ) current_density_parameters_frame . grid_remove () # Hide the frame by default # Computing parameters computing_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) computing_parameters_frame . grid ( row = 9 , column = 0 , padx = 5 , pady = 5 ) computing_parameters_frame . grid_remove () # Hide the frame by default # Model possibilities and current density choice model_possibilities_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) model_possibilities_frame . grid ( row = 11 , column = 0 , padx = 5 , pady = 5 ) # Import the current density parameters from the settings file for default value ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) = calculate_current_density_parameters () f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # Create the choice dictionaries choice_operating_conditions = \\ { 'Temperature - Tfc (\u00b0C)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'Anode pressure - Pa (bar)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Cathode pressure - Pc (bar)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Anode stoichiometry - Sa' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Cathode stoichiometry - Sc' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 3 , 'label_column' : 3 }, 'Anode humidity - \u03a6a' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Cathode humidity - \u03a6c' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 3 }, 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 5 }} choice_accessible_parameters = \\ { 'Active area - Aact (cm\u00b2)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 1 }, 'Number of cells - nb_cell' : { 'value' : tk . IntVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 3 }, 'Anode gas channel \\n thickness - Hagc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Anode gas channel \\n width - Wagc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Cathode gas channel \\n width - Wcgc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 3 , 'label_column' : 5 }, 'Gas channel \\n length - Lgc (mm)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Number of channels inside the \\n gas channel - nb_channel_in_gc' : { 'value' : tk . IntVar ( accessible_parameters_frame ), 'label_row' : 3 , 'label_column' : 3 }, 'Distributor length - Ldist (mm)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Exhaust anode manifold throttle \\n area - A_T_a (cm\u00b2)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 4 , 'label_column' : 3 }, 'Exhaust cathode manifold throttle \\n area - A_T_c (cm\u00b2)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 4 , 'label_column' : 5 }, 'Supply anode manifold \\n volume - Vasm (cm\u00b3)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 5 , 'label_column' : 1 }, 'Supply cathode manifold \\n volume - Vcsm (cm\u00b3)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 5 , 'label_column' : 3 }, 'Exhaust anode manifold \\n volume - Vaem (cm\u00b3)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 6 , 'label_column' : 1 }, 'Exhaust cathode manifold \\n volume - Vcem (cm\u00b3)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 6 , 'label_column' : 3 }} choice_undetermined_parameters = \\ { 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 1 }, 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 3 }, 'ACL thickness - Hacl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 5 }, 'CCL thickness - Hccl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 1 }, 'Membrane thickness - Hmem (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 3 }, 'GDL porosity - \u03b5_gdl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 1 , 'label_column' : 5 }, 'CL porosity - \u03b5_cl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'MPL porosity - \u03b5_mpl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Ionomer volume fraction - \u03b5_mc' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Compression ratio - \u03b5_c' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Capillary exponent - e' : { 'value' : tk . IntVar ( undetermined_parameters_frame ), 'label_row' : 3 , 'label_column' : 3 }, 'Electron conduction \\n resistance - Re (\u03a9.mm\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 3 }, 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 5 }, 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 1 }, 'Overpotential correction \\n exponent - \u03ba_c' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 3 }, 'Limit liquid saturation \\n coefficient - a_slim' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 5 }, 'Limit liquid saturation \\n coefficient - b_slim' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 1 }, 'Limit liquid saturation \\n coefficient - a_switch' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 3 }, 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 5 }} choice_current_density_parameters = \\ { 'Stabilisation time \\n - \u0394t_ini_step (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_ini_step' ] / 60 ), 'label_row' : 0 , 'label_column' : 3 }, 'Loading time \\n - \u0394t_load_step (s)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_load_step' ]), 'label_row' : 0 , 'label_column' : 5 }, 'Breaking time \\n - \u0394t_break_step (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_break_step' ] / 60 ), 'label_row' : 1 , 'label_column' : 3 }, 'Current density step \\n - i_step (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'i_step' ] / 1e4 ), 'label_row' : 1 , 'label_column' : 5 }, 'Stabilisation time \\n - \u0394t_ini_pola (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_ini_pola' ] / 60 ), 'label_row' : 2 , 'label_column' : 3 }, 'Loading time \\n - \u0394t_load_pola (s)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_load_pola' ]), 'label_row' : 2 , 'label_column' : 5 }, 'Breaking time \\n - \u0394t_break_pola (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_break_pola' ] / 60 ), 'label_row' : 3 , 'label_column' : 3 }, 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_i_pola' ] / 1e4 ), 'label_row' : 3 , 'label_column' : 5 }, 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , 1.5 ), 'label_row' : 4 , 'label_column' : 3 }, 'Static current \\n - i_EIS (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , i_EIS ), 'label_row' : 5 , 'label_column' : 3 }, 'Current ratio \\n - ratio_EIS (%)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , ratio_EIS ), 'label_row' : 5 , 'label_column' : 5 }, 'Number of points \\n calculated - nb_points_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , nb_points_EIS ), 'label_row' : 6 , 'label_column' : 3 }, 'Power of the \\n initial frequency \\n - f_power_min_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , f_power_min_EIS ), 'label_row' : 6 , 'label_column' : 5 }, 'Power of the \\n final frequency \\n - f_power_max_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , f_power_max_EIS ), 'label_row' : 7 , 'label_column' : 3 }, 'Number of frequencies \\n tested - nb_f_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , nb_f_EIS ), 'label_row' : 7 , 'label_column' : 5 }} choice_computing_parameters = \\ { 'Time for dynamic \\n display - \u0394t_dyn_step (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 300 ), 'label_row' : 0 , 'label_column' : 1 }, 'Purge time - t_purge (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 0.6 ), 'label_row' : 0 , 'label_column' : 3 }, 'Time between two purges \\n - \u0394t_purge (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 15 ), 'label_row' : 0 , 'label_column' : 5 }, 'Number of GC nodes - nb_gc' : { 'value' : tk . IntVar ( computing_parameters_frame , 5 ), 'label_row' : 1 , 'label_column' : 1 }, 'Number of GDL nodes - nb_gdl' : { 'value' : tk . IntVar ( computing_parameters_frame , 5 ), 'label_row' : 1 , 'label_column' : 3 }, 'Number of MPL nodes - nb_mpl' : { 'value' : tk . IntVar ( computing_parameters_frame , 5 ), 'label_row' : 1 , 'label_column' : 5 }, 'Solver relative tolerance - rtol' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 1e-5 ), 'label_row' : 2 , 'label_column' : 1 }, 'Solver absolute tolerance - atol' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 1e-8 ), 'label_row' : 2 , 'label_column' : 3 } } choice_buttons = \\ { 'type_fuel_cell' : { 'value' : tk . StringVar ( operating_conditions_frame , 'Enter your specifications' ), 'label_row' : 0 }, 'type_auxiliary' : { 'value' : tk . IntVar ( model_possibilities_frame , 2 ), 'label_row' : 1 }, 'voltage_zone' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 2 }, 'type_control' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 3 }, 'type_purge' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 4 }, 'type_display' : { 'value' : tk . IntVar ( model_possibilities_frame , 1 ), 'label_row' : 5 }, 'type_plot' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 6 }} # Displays operating conditions and physical parameters on the screen (without their values) # Display the dropdown menu buttons ttk . Button ( root , text = 'Undetermined physical parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( undetermined_parameters_frame , show_info_undetermined_parameters , canvas )) . \\ grid ( row = 4 , column = 0 , padx = 5 , pady = 5 ) ttk . Button ( root , text = 'Current density parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( current_density_parameters_frame , show_info_current_density_parameters , canvas )) . \\ grid ( row = 6 , column = 0 , padx = 5 , pady = 5 ) ttk . Button ( root , text = 'Computing parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( computing_parameters_frame , show_info_computing_parameters , canvas )) . \\ grid ( row = 8 , column = 0 , padx = 5 , pady = 5 ) # Display the labels display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) # Displays the value of the operating conditions and physical parameters on the screen. display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) # Display the radiobuttons on the screen display_radiobuttons ( model_possibilities_frame , choice_buttons ) # Display the 'type of fuel cell' widget on the screen. ttk . Label ( operating_conditions_frame , text = 'Fuel cell:' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 2 ) ttk . OptionMenu ( operating_conditions_frame , choice_buttons [ 'type_fuel_cell' ][ 'value' ], 'Enter your specifications' , 'Enter your specifications' , 'EH-31 1.5 bar (2021)' , 'EH-31 2.0 bar (2021)' , 'EH-31 2.25 bar (2021)' , 'EH-31 2.5 bar (2021)' , command = lambda value : changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons )) . \\ grid ( row = 0 , column = 2 , columnspan = 2 ) # Display the action buttons to select the type of current density to be applied. ttk . Label ( model_possibilities_frame , text = 'Current density:' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 6 , column = 0 , columnspan = 2 , sticky = \"w\" ) current_button = { 'Step curve' : 0 , 'Pola curve' : 1 , 'EIS curve' : 2 } # Button to generate the step curve ttk . Button ( model_possibilities_frame , text = 'Step curve' , style = 'Blue.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'Step curve' ])) \\ . grid ( row = 7 , column = 2 , padx = 10 , pady = 20 ) # Button to generate the Pola curve ttk . Button ( model_possibilities_frame , text = 'Pola curve' , style = 'Green.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'Pola curve' ])) \\ . grid ( row = 7 , column = 3 , padx = 10 , pady = 20 ) # Button to generate the EIS curve ttk . Button ( model_possibilities_frame , text = 'EIS curve' , style = 'Red.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'EIS curve' ])) \\ . grid ( row = 7 , column = 4 , padx = 10 , pady = 20 ) # About button ttk . Button ( model_possibilities_frame , text = 'About' , style = 'Black.TButton' , command = about ) \\ . grid ( row = 7 , column = 5 , ipadx = 12 ) # Ensure the frame sizes are updated root . update_idletasks () set_equal_width ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , model_possibilities_frame ) show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) This function determines the action to be performed based on the button_type. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in GUI.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function determines the action to be performed based on the button_type. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # Retrieves parameter values for predefined stacks and keeps them in their standard unit, or converts user-selected # quantities into standard units. ( T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , Aact , nb_cell , Hgdl , Hmpl , Hacl , Hccl , Hmem , Hagc , Hcgc , Wagc , Wcgc , Lgc , Lm , L_endplate , L_man_gc , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , V_endplate_a , V_endplate_c , V_man_agc , V_man_cgc , epsilon_gdl , epsilon_cl , epsilon_mpl , epsilon_mc , epsilon_c , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl , step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , t_purge , delta_t_purge , nb_gdl , nb_mpl , nb_tl , rtol , atol , type_fuel_cell , voltage_zone , type_auxiliary , type_control , type_purge , type_display , type_plot ) = \\ recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ) # Initialize the operating inputs and parameters dictionaries. current_parameters = { 'step_current_parameters' : step_current_parameters , 'pola_current_parameters' : pola_current_parameters , 'pola_current_for_cali_parameters' : pola_current_for_cali_parameters , 'i_EIS' : i_EIS , 'ratio_EIS' : ratio_EIS , 't_EIS' : t_EIS , 'f_EIS' : f_EIS } accessible_physical_parameters = { 'Aact' : Aact , 'nb_cell' : nb_cell , 'Hagc' : Hagc , 'Hcgc' : Hcgc , 'Wagc' : Wagc , 'Wcgc' : Wcgc , 'Lgc' : Lgc , 'nb_channel_in_gc' : nb_channel_in_gc , 'Ldist' : Ldist , 'Lm' : Lm , 'A_T_a' : A_T_a , 'A_T_c' : A_T_c , 'Vasm' : Vasm , 'Vcsm' : Vcsm , 'Vaem' : Vaem , 'Vcem' : Vcem } undetermined_physical_parameters = { 'Hgdl' : Hgdl , 'Hmpl' : Hmpl , 'Hmem' : Hmem , 'Hacl' : Hacl , 'Hccl' : Hccl , 'epsilon_gdl' : epsilon_gdl , 'epsilon_cl' : epsilon_cl , 'epsilon_mpl' : epsilon_mpl , 'epsilon_mc' : epsilon_mc , 'epsilon_c' : epsilon_c , 'e' : e , 'Re' : Re , 'i0_d_c_ref' : i0_d_c_ref , 'i0_h_c_ref' : i0_h_c_ref , 'kappa_co' : kappa_co , 'kappa_c' : kappa_c , 'a_slim' : a_slim , 'b_slim' : b_slim , 'a_switch' : a_switch , 'C_scl' : C_scl } if current_button == 0 : type_current = \"step\" current_density = step_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des , 'y_H2_in' : y_H2_in } computing_parameters = { 'nb_gc' : nb_gc , 'nb_gdl' : nb_gdl , 'nb_mpl' : nb_mpl , 'nb_tl' : nb_tl , 't_purge' : t_purge , 'rtol' : rtol , 'atol' : atol , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'voltage_zone' : voltage_zone , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) if current_button == 1 : type_current = \"polarization\" current_density = polarization_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des , 'y_H2_in' : y_H2_in } computing_parameters = { 'nb_gc' : nb_gc , 'nb_gdl' : nb_gdl , 'nb_mpl' : nb_mpl , 'nb_tl' : nb_tl , 't_purge' : t_purge , 'rtol' : rtol , 'atol' : atol , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'voltage_zone' : voltage_zone , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) if current_button == 2 : type_current = \"EIS\" current_density = EIS_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des , 'y_H2_in' : y_H2_in } computing_parameters = { 'nb_gc' : nb_gc , 'nb_gdl' : nb_gdl , 'nb_mpl' : nb_mpl , 'nb_tl' : nb_tl , 't_purge' : t_purge , 'rtol' : rtol , 'atol' : atol , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'voltage_zone' : voltage_zone , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) toggle_info ( frame , show_info , canvas ) Toggles the visibility of the given frame and updates the scroll region of the given canvas. Parameters: frame ( Frame ) \u2013 The frame to show or hide. show_info ( BooleanVar ) \u2013 A boolean variable to track the current visibility state. canvas ( Canvas ) \u2013 The canvas to update the scroll region. Source code in GUI.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def toggle_info ( frame , show_info , canvas ): \"\"\" Toggles the visibility of the given frame and updates the scroll region of the given canvas. Parameters ---------- frame : ttk.Frame The frame to show or hide. show_info : tk.BooleanVar A boolean variable to track the current visibility state. canvas : tk.Canvas The canvas to update the scroll region. \"\"\" if show_info . get (): frame . grid_remove () # Hide the info frame show_info . set ( False ) # Update the visibility state else : frame . grid () # Show the info frame show_info . set ( True ) # Update the visibility state canvas . update_idletasks () # Update the scroll region of the given canvas. canvas . configure ( scrollregion = canvas . bbox ( 'all' ))","title":"GUI"},{"location":"functions/GUI/#gui","text":"This file is designated for executing the AlphaPEM software package through a graphical user interface (GUI). Most of the functionalities are available, but some are not implemented.","title":"GUI"},{"location":"functions/GUI/#GUI.about","text":"This function displays information about the program and its author in a dialog box when the \"About\" button is clicked. Source code in GUI.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def about (): \"\"\"This function displays information about the program and its author in a dialog box when the \"About\" button is clicked. \"\"\" msg = \"\"\"AlphaPEM is an open-source software package for simulating proton exchange membrane fuel cell (PEMFC) systems using physics-based models for embedded applications. It is based on a physics-based, finite-volume, one-dimensional (1D), dynamic, two-phase, and non-isothermal model. It can quickly simulate the internal states and voltage dynamics of PEMFC systems, and produce polarization and EIS curves. It can also automatically calibrate the undetermined parameters of the model to simulate a given real fuel cell system. AlphaPEM is firstly developed by Rapha\u00ebl Gass during his PhD thesis in control engineering at the LIS Laboratory in Aix-Marseille University, and in co-supervision with FEMTO-ST Institute, within the FCLab, in Franche-Comt\u00e9 University, from 2021 to 2024. This work has been supervised by Prof. Zhongliang Li (FEMTO-ST), Prof. Rachid Outbib (LIS), Prof. Samir Jemei (FEMTO-ST) and Prof. Daniel Hissel (FEMTO-ST). It has been supported by French National Research Agency via project DEAL (Grant no. ANR-20-CE05-0016-01, https://deal.lis-lab.fr/), the Region Provence-Alpes-C\u00f4te d\u2019Azur, the EIPHI Graduate School (contract ANR-17-EURE-0002) and the Region Bourgogne Franche-Comt\u00e9. The development of AlphaPEM was subsequently continued by Rapha\u00ebl Gass during his postdoctoral research from 2025 to 2027 at ENERGY-Lab, University of Reunion island, in partnership with the ZSW Institute in Ulm, Germany. This work was supervised by Prof. Michel Benne (ENERGY-Lab), Associate Prof. C\u00e9dric Damour (ENERGY-Lab), Associate Prof. Dominique Grondin (ENERGY-Lab), and Dr. Florian Wilhelm (ZSW). It has been supported by European FEDER funds via project OPUS-H2 (https://www.energylab.re/projets/projets-en-cours/opus-h2/) and the Region Reunion. It is related to the following articles: - Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a, - Gass et al 2025 I.J. of Hydrogen Energy https://doi.org/10.1016/j.ijhydene.2024.11.374. - Gass et al 2025 SoftwareX https://doi.org/10.1016/j.softx.2024.102002. More information can be found in: - AlphaPEM GitHub webpage: https://github.com/gassraphael/AlphaPEM - AlphaPEM documentation webpage: https://gassraphael.github.io/AlphaPEM/ - Author webpage: https://gassraphael.github.io/ If you want to contact me, please send an email to: raphael.gass@univ-reunion.fr.\"\"\" # Create a new top-level window about_window = tk . Toplevel () about_window . title ( 'About this program' ) # Set the size of the window about_window . geometry ( '730x460' ) # Width x Height # Create a label with the message label = ttk . Label ( about_window , text = msg , wraplength = 700 ) # wraplength to wrap text within the given width label . pack ( padx = 15 , pady = 15 ) # Add padding around the label # Create an OK button to close the window ok_button = ttk . Button ( about_window , text = 'OK' , command = about_window . destroy ) ok_button . pack ( pady = 10 )","title":"about"},{"location":"functions/GUI/#GUI.control_current_button","text":"This function is responsible for validating the user inputs by calling the value_control() function. If the input is valid, it then calls the show_current_button function to perform the requested action based on the button_type. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in GUI.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function is responsible for validating the user inputs by calling the value_control() function. If the input is valid, it then calls the show_current_button function to perform the requested action based on the button_type. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # Control the values value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) # Activate the action show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button )","title":"control_current_button"},{"location":"functions/GUI/#GUI.create_application","text":"This function creates the main application window and setting its title. It calls the main_frame() function to create the main graphical elements of the window. Source code in GUI.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def create_application (): \"\"\"This function creates the main application window and setting its title. It calls the main_frame() function to create the main graphical elements of the window. \"\"\" # Create the main application window root = ThemedTk ( theme = \"arc\" ) root . configure ( background = '#f5f6f7' ) root . title ( \"AlphaPEM\" ) # Create a canvas and add a scrollbar to it canvas = tk . Canvas ( root ) scrollbar = ttk . Scrollbar ( root , command = canvas . yview ) canvas . configure ( yscrollcommand = scrollbar . set ) frame = ttk . Frame ( canvas ) # Create a frame inside the canvas to add your widgets # Add all the widgets to the frame main_frame ( frame , canvas ) canvas . create_window (( 0 , 0 ), window = frame , anchor = 'nw' ) # Add the frame to the canvas # Adjust the main window and canvas size frame . update_idletasks () root . geometry ( f \" { frame . winfo_width () } x { frame . winfo_height () } \" ) canvas . configure ( scrollregion = canvas . bbox ( 'all' )) canvas . pack ( fill = 'both' , expand = True , side = 'left' ) # Organize the widgets scrollbar . pack ( fill = 'y' , side = 'right' ) root . mainloop ()","title":"create_application"},{"location":"functions/GUI/#GUI.main_frame","text":"This function creates the main graphical elements, such as labels, entry widgets, radio buttons, and buttons. It arranges them in the application window (root). It also initializes the choice dictionary variables for various parameters and settings. Parameters: root : ThemedTk The main application window where the graphical elements will be placed. canvas : tk.Canvas The canvas where the main graphical elements will be placed. Source code in GUI.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def main_frame ( root , canvas ): \"\"\"This function creates the main graphical elements, such as labels, entry widgets, radio buttons, and buttons. It arranges them in the application window (root). It also initializes the choice dictionary variables for various parameters and settings. Parameters: ----------- root : ThemedTk The main application window where the graphical elements will be placed. canvas : tk.Canvas The canvas where the main graphical elements will be placed. \"\"\" # Create a custom styles style = ttk . Style () style . configure ( 'Custom.TFrame' , background = '#f5f6f7' ) style . configure ( 'Blue.TButton' , foreground = 'blue' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to blue style . configure ( 'Green.TButton' , foreground = 'green' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to green style . configure ( 'Red.TButton' , foreground = 'red' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to red style . configure ( 'Black.TButton' , foreground = 'black' , font = ( 'cmr10' , 10 , 'bold' )) # Set the font color to black style . configure ( 'Big.TButton' , font = ( 'cmr10' , 12 , 'bold' )) # Create control variables to track the visibility state of some frame show_info_undetermined_parameters = tk . BooleanVar ( value = False ) show_info_current_density_parameters = tk . BooleanVar ( value = False ) show_info_computing_parameters = tk . BooleanVar ( value = False ) # Create the frames to hold the different set of information # Fuel cell type and operating conditions operating_conditions_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) operating_conditions_frame . grid ( row = 1 , column = 0 , padx = 5 , pady = 5 ) # Accessible physical parameters accessible_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) accessible_parameters_frame . grid ( row = 3 , column = 0 , padx = 5 , pady = 5 ) # Undetermined physical parameters undetermined_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) undetermined_parameters_frame . grid ( row = 5 , column = 0 , padx = 5 , pady = 5 ) undetermined_parameters_frame . grid_remove () # Hide the frame by default # Current density parameters current_density_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) current_density_parameters_frame . grid ( row = 7 , column = 0 , padx = 5 , pady = 5 ) current_density_parameters_frame . grid_remove () # Hide the frame by default # Computing parameters computing_parameters_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) computing_parameters_frame . grid ( row = 9 , column = 0 , padx = 5 , pady = 5 ) computing_parameters_frame . grid_remove () # Hide the frame by default # Model possibilities and current density choice model_possibilities_frame = ttk . Frame ( root , style = 'Custom.TFrame' ) model_possibilities_frame . grid ( row = 11 , column = 0 , padx = 5 , pady = 5 ) # Import the current density parameters from the settings file for default value ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) = calculate_current_density_parameters () f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # Create the choice dictionaries choice_operating_conditions = \\ { 'Temperature - Tfc (\u00b0C)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'Anode pressure - Pa (bar)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Cathode pressure - Pc (bar)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Anode stoichiometry - Sa' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Cathode stoichiometry - Sc' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 3 , 'label_column' : 3 }, 'Anode humidity - \u03a6a' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Cathode humidity - \u03a6c' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 3 }, 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' : { 'value' : tk . DoubleVar ( operating_conditions_frame ), 'label_row' : 4 , 'label_column' : 5 }} choice_accessible_parameters = \\ { 'Active area - Aact (cm\u00b2)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 1 }, 'Number of cells - nb_cell' : { 'value' : tk . IntVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 3 }, 'Anode gas channel \\n thickness - Hagc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Anode gas channel \\n width - Wagc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Cathode gas channel \\n width - Wcgc (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 3 , 'label_column' : 5 }, 'Gas channel \\n length - Lgc (mm)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Number of channels inside the \\n gas channel - nb_channel_in_gc' : { 'value' : tk . IntVar ( accessible_parameters_frame ), 'label_row' : 3 , 'label_column' : 3 }, 'Distributor length - Ldist (mm)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Exhaust anode manifold throttle \\n area - A_T_a (cm\u00b2)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 4 , 'label_column' : 3 }, 'Exhaust cathode manifold throttle \\n area - A_T_c (cm\u00b2)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 4 , 'label_column' : 5 }, 'Supply anode manifold \\n volume - Vasm (cm\u00b3)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 5 , 'label_column' : 1 }, 'Supply cathode manifold \\n volume - Vcsm (cm\u00b3)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 5 , 'label_column' : 3 }, 'Exhaust anode manifold \\n volume - Vaem (cm\u00b3)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 6 , 'label_column' : 1 }, 'Exhaust cathode manifold \\n volume - Vcem (cm\u00b3)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 6 , 'label_column' : 3 }} choice_undetermined_parameters = \\ { 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 1 }, 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 3 }, 'ACL thickness - Hacl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 0 , 'label_column' : 5 }, 'CCL thickness - Hccl (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 1 }, 'Membrane thickness - Hmem (\u00b5m)' : { 'value' : tk . DoubleVar ( accessible_parameters_frame ), 'label_row' : 1 , 'label_column' : 3 }, 'GDL porosity - \u03b5_gdl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 1 , 'label_column' : 5 }, 'CL porosity - \u03b5_cl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 1 }, 'MPL porosity - \u03b5_mpl' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 3 }, 'Ionomer volume fraction - \u03b5_mc' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 2 , 'label_column' : 5 }, 'Compression ratio - \u03b5_c' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 3 , 'label_column' : 1 }, 'Capillary exponent - e' : { 'value' : tk . IntVar ( undetermined_parameters_frame ), 'label_row' : 3 , 'label_column' : 3 }, 'Electron conduction \\n resistance - Re (\u03a9.mm\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 1 }, 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 3 }, 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 4 , 'label_column' : 5 }, 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 1 }, 'Overpotential correction \\n exponent - \u03ba_c' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 3 }, 'Limit liquid saturation \\n coefficient - a_slim' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 5 , 'label_column' : 5 }, 'Limit liquid saturation \\n coefficient - b_slim' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 1 }, 'Limit liquid saturation \\n coefficient - a_switch' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 3 }, 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' : { 'value' : tk . DoubleVar ( undetermined_parameters_frame ), 'label_row' : 6 , 'label_column' : 5 }} choice_current_density_parameters = \\ { 'Stabilisation time \\n - \u0394t_ini_step (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_ini_step' ] / 60 ), 'label_row' : 0 , 'label_column' : 3 }, 'Loading time \\n - \u0394t_load_step (s)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_load_step' ]), 'label_row' : 0 , 'label_column' : 5 }, 'Breaking time \\n - \u0394t_break_step (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'delta_t_break_step' ] / 60 ), 'label_row' : 1 , 'label_column' : 3 }, 'Current density step \\n - i_step (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , step_current_parameters [ 'i_step' ] / 1e4 ), 'label_row' : 1 , 'label_column' : 5 }, 'Stabilisation time \\n - \u0394t_ini_pola (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_ini_pola' ] / 60 ), 'label_row' : 2 , 'label_column' : 3 }, 'Loading time \\n - \u0394t_load_pola (s)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_load_pola' ]), 'label_row' : 2 , 'label_column' : 5 }, 'Breaking time \\n - \u0394t_break_pola (min)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_t_break_pola' ] / 60 ), 'label_row' : 3 , 'label_column' : 3 }, 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , pola_current_parameters [ 'delta_i_pola' ] / 1e4 ), 'label_row' : 3 , 'label_column' : 5 }, 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , 1.5 ), 'label_row' : 4 , 'label_column' : 3 }, 'Static current \\n - i_EIS (A/cm\u00b2)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , i_EIS ), 'label_row' : 5 , 'label_column' : 3 }, 'Current ratio \\n - ratio_EIS (%)' : { 'value' : tk . DoubleVar ( current_density_parameters_frame , ratio_EIS ), 'label_row' : 5 , 'label_column' : 5 }, 'Number of points \\n calculated - nb_points_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , nb_points_EIS ), 'label_row' : 6 , 'label_column' : 3 }, 'Power of the \\n initial frequency \\n - f_power_min_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , f_power_min_EIS ), 'label_row' : 6 , 'label_column' : 5 }, 'Power of the \\n final frequency \\n - f_power_max_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , f_power_max_EIS ), 'label_row' : 7 , 'label_column' : 3 }, 'Number of frequencies \\n tested - nb_f_EIS' : { 'value' : tk . IntVar ( current_density_parameters_frame , nb_f_EIS ), 'label_row' : 7 , 'label_column' : 5 }} choice_computing_parameters = \\ { 'Time for dynamic \\n display - \u0394t_dyn_step (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 300 ), 'label_row' : 0 , 'label_column' : 1 }, 'Purge time - t_purge (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 0.6 ), 'label_row' : 0 , 'label_column' : 3 }, 'Time between two purges \\n - \u0394t_purge (s)' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 15 ), 'label_row' : 0 , 'label_column' : 5 }, 'Number of GC nodes - nb_gc' : { 'value' : tk . IntVar ( computing_parameters_frame , 5 ), 'label_row' : 1 , 'label_column' : 1 }, 'Number of GDL nodes - nb_gdl' : { 'value' : tk . IntVar ( computing_parameters_frame , 5 ), 'label_row' : 1 , 'label_column' : 3 }, 'Number of MPL nodes - nb_mpl' : { 'value' : tk . IntVar ( computing_parameters_frame , 5 ), 'label_row' : 1 , 'label_column' : 5 }, 'Solver relative tolerance - rtol' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 1e-5 ), 'label_row' : 2 , 'label_column' : 1 }, 'Solver absolute tolerance - atol' : { 'value' : tk . DoubleVar ( computing_parameters_frame , 1e-8 ), 'label_row' : 2 , 'label_column' : 3 } } choice_buttons = \\ { 'type_fuel_cell' : { 'value' : tk . StringVar ( operating_conditions_frame , 'Enter your specifications' ), 'label_row' : 0 }, 'type_auxiliary' : { 'value' : tk . IntVar ( model_possibilities_frame , 2 ), 'label_row' : 1 }, 'voltage_zone' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 2 }, 'type_control' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 3 }, 'type_purge' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 4 }, 'type_display' : { 'value' : tk . IntVar ( model_possibilities_frame , 1 ), 'label_row' : 5 }, 'type_plot' : { 'value' : tk . IntVar ( model_possibilities_frame , 0 ), 'label_row' : 6 }} # Displays operating conditions and physical parameters on the screen (without their values) # Display the dropdown menu buttons ttk . Button ( root , text = 'Undetermined physical parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( undetermined_parameters_frame , show_info_undetermined_parameters , canvas )) . \\ grid ( row = 4 , column = 0 , padx = 5 , pady = 5 ) ttk . Button ( root , text = 'Current density parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( current_density_parameters_frame , show_info_current_density_parameters , canvas )) . \\ grid ( row = 6 , column = 0 , padx = 5 , pady = 5 ) ttk . Button ( root , text = 'Computing parameters' , style = 'Big.TButton' , command = lambda : toggle_info ( computing_parameters_frame , show_info_computing_parameters , canvas )) . \\ grid ( row = 8 , column = 0 , padx = 5 , pady = 5 ) # Display the labels display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) # Displays the value of the operating conditions and physical parameters on the screen. display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) # Display the radiobuttons on the screen display_radiobuttons ( model_possibilities_frame , choice_buttons ) # Display the 'type of fuel cell' widget on the screen. ttk . Label ( operating_conditions_frame , text = 'Fuel cell:' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 2 ) ttk . OptionMenu ( operating_conditions_frame , choice_buttons [ 'type_fuel_cell' ][ 'value' ], 'Enter your specifications' , 'Enter your specifications' , 'EH-31 1.5 bar (2021)' , 'EH-31 2.0 bar (2021)' , 'EH-31 2.25 bar (2021)' , 'EH-31 2.5 bar (2021)' , command = lambda value : changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons )) . \\ grid ( row = 0 , column = 2 , columnspan = 2 ) # Display the action buttons to select the type of current density to be applied. ttk . Label ( model_possibilities_frame , text = 'Current density:' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 6 , column = 0 , columnspan = 2 , sticky = \"w\" ) current_button = { 'Step curve' : 0 , 'Pola curve' : 1 , 'EIS curve' : 2 } # Button to generate the step curve ttk . Button ( model_possibilities_frame , text = 'Step curve' , style = 'Blue.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'Step curve' ])) \\ . grid ( row = 7 , column = 2 , padx = 10 , pady = 20 ) # Button to generate the Pola curve ttk . Button ( model_possibilities_frame , text = 'Pola curve' , style = 'Green.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'Pola curve' ])) \\ . grid ( row = 7 , column = 3 , padx = 10 , pady = 20 ) # Button to generate the EIS curve ttk . Button ( model_possibilities_frame , text = 'EIS curve' , style = 'Red.TButton' , command = lambda : control_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button [ 'EIS curve' ])) \\ . grid ( row = 7 , column = 4 , padx = 10 , pady = 20 ) # About button ttk . Button ( model_possibilities_frame , text = 'About' , style = 'Black.TButton' , command = about ) \\ . grid ( row = 7 , column = 5 , ipadx = 12 ) # Ensure the frame sizes are updated root . update_idletasks () set_equal_width ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , model_possibilities_frame )","title":"main_frame"},{"location":"functions/GUI/#GUI.show_current_button","text":"This function determines the action to be performed based on the button_type. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in GUI.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def show_current_button ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function determines the action to be performed based on the button_type. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # Retrieves parameter values for predefined stacks and keeps them in their standard unit, or converts user-selected # quantities into standard units. ( T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , Aact , nb_cell , Hgdl , Hmpl , Hacl , Hccl , Hmem , Hagc , Hcgc , Wagc , Wcgc , Lgc , Lm , L_endplate , L_man_gc , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , V_endplate_a , V_endplate_c , V_man_agc , V_man_cgc , epsilon_gdl , epsilon_cl , epsilon_mpl , epsilon_mc , epsilon_c , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl , step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , t_purge , delta_t_purge , nb_gdl , nb_mpl , nb_tl , rtol , atol , type_fuel_cell , voltage_zone , type_auxiliary , type_control , type_purge , type_display , type_plot ) = \\ recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ) # Initialize the operating inputs and parameters dictionaries. current_parameters = { 'step_current_parameters' : step_current_parameters , 'pola_current_parameters' : pola_current_parameters , 'pola_current_for_cali_parameters' : pola_current_for_cali_parameters , 'i_EIS' : i_EIS , 'ratio_EIS' : ratio_EIS , 't_EIS' : t_EIS , 'f_EIS' : f_EIS } accessible_physical_parameters = { 'Aact' : Aact , 'nb_cell' : nb_cell , 'Hagc' : Hagc , 'Hcgc' : Hcgc , 'Wagc' : Wagc , 'Wcgc' : Wcgc , 'Lgc' : Lgc , 'nb_channel_in_gc' : nb_channel_in_gc , 'Ldist' : Ldist , 'Lm' : Lm , 'A_T_a' : A_T_a , 'A_T_c' : A_T_c , 'Vasm' : Vasm , 'Vcsm' : Vcsm , 'Vaem' : Vaem , 'Vcem' : Vcem } undetermined_physical_parameters = { 'Hgdl' : Hgdl , 'Hmpl' : Hmpl , 'Hmem' : Hmem , 'Hacl' : Hacl , 'Hccl' : Hccl , 'epsilon_gdl' : epsilon_gdl , 'epsilon_cl' : epsilon_cl , 'epsilon_mpl' : epsilon_mpl , 'epsilon_mc' : epsilon_mc , 'epsilon_c' : epsilon_c , 'e' : e , 'Re' : Re , 'i0_d_c_ref' : i0_d_c_ref , 'i0_h_c_ref' : i0_h_c_ref , 'kappa_co' : kappa_co , 'kappa_c' : kappa_c , 'a_slim' : a_slim , 'b_slim' : b_slim , 'a_switch' : a_switch , 'C_scl' : C_scl } if current_button == 0 : type_current = \"step\" current_density = step_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des , 'y_H2_in' : y_H2_in } computing_parameters = { 'nb_gc' : nb_gc , 'nb_gdl' : nb_gdl , 'nb_mpl' : nb_mpl , 'nb_tl' : nb_tl , 't_purge' : t_purge , 'rtol' : rtol , 'atol' : atol , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'voltage_zone' : voltage_zone , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) if current_button == 1 : type_current = \"polarization\" current_density = polarization_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des , 'y_H2_in' : y_H2_in } computing_parameters = { 'nb_gc' : nb_gc , 'nb_gdl' : nb_gdl , 'nb_mpl' : nb_mpl , 'nb_tl' : nb_tl , 't_purge' : t_purge , 'rtol' : rtol , 'atol' : atol , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'voltage_zone' : voltage_zone , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) if current_button == 2 : type_current = \"EIS\" current_density = EIS_current operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des , 'y_H2_in' : y_H2_in } computing_parameters = { 'nb_gc' : nb_gc , 'nb_gdl' : nb_gdl , 'nb_mpl' : nb_mpl , 'nb_tl' : nb_tl , 't_purge' : t_purge , 'rtol' : rtol , 'atol' : atol , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'voltage_zone' : voltage_zone , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters )","title":"show_current_button"},{"location":"functions/GUI/#GUI.toggle_info","text":"Toggles the visibility of the given frame and updates the scroll region of the given canvas. Parameters: frame ( Frame ) \u2013 The frame to show or hide. show_info ( BooleanVar ) \u2013 A boolean variable to track the current visibility state. canvas ( Canvas ) \u2013 The canvas to update the scroll region. Source code in GUI.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def toggle_info ( frame , show_info , canvas ): \"\"\" Toggles the visibility of the given frame and updates the scroll region of the given canvas. Parameters ---------- frame : ttk.Frame The frame to show or hide. show_info : tk.BooleanVar A boolean variable to track the current visibility state. canvas : tk.Canvas The canvas to update the scroll region. \"\"\" if show_info . get (): frame . grid_remove () # Hide the info frame show_info . set ( False ) # Update the visibility state else : frame . grid () # Show the info frame show_info . set ( True ) # Update the visibility state canvas . update_idletasks () # Update the scroll region of the given canvas. canvas . configure ( scrollregion = canvas . bbox ( 'all' ))","title":"toggle_info"},{"location":"functions/main/","text":"main This file is designated for executing the AlphaPEM software package. Most of it should remain unaltered for regular program usage. In the section \"AlphaPEM settings\", users can select various preconfigured configurations for execution: the fuel cell, current density, auxiliary system, control strategy, purge, display and plot used. Adjustments to these configurations can be made within setting.py or current_densities.py and their associated files.","title":"Main"},{"location":"functions/main/#main","text":"This file is designated for executing the AlphaPEM software package. Most of it should remain unaltered for regular program usage. In the section \"AlphaPEM settings\", users can select various preconfigured configurations for execution: the fuel cell, current density, auxiliary system, control strategy, purge, display and plot used. Adjustments to these configurations can be made within setting.py or current_densities.py and their associated files.","title":"main"},{"location":"functions/calibration/experimental_values/","text":"Experimental values This file is designated for executing the AlphaPEM software package. plot_experimental_polarisation_curve ( type_fuel_cell , i_fc_t , U_exp_t , ax ) This function plots the experimental polarisation curve on the same graph as the model results. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. i_fc_t ( ndarray ) \u2013 Current density values. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. ax ( Axes ) \u2013 Axes object on which the experimental data is plotted. Source code in calibration/experimental_values.py 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def plot_experimental_polarisation_curve ( type_fuel_cell , i_fc_t , U_exp_t , ax ): \"\"\" This function plots the experimental polarisation curve on the same graph as the model results. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. i_fc_t : numpy.ndarray Current density values. U_exp_t : numpy.ndarray Experimental values of the voltage. ax : matplotlib.axes.Axes Axes object on which the experimental data is plotted. \"\"\" # ZSW-GenStack if type_fuel_cell == \"ZSW-GenStack\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - nominal operating conditions\" ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P$_a$ = 1.61 bar, P$_c$ = 1.41 bar\" ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P$_a$ = 2.01 bar, P$_c$ = 1.81 bar\" ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P$_a$ = 2.4 bar, P$_c$ = 2.2 bar\" ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P$_a$ = 2.8 bar, P$_c$ = 2.6 bar\" ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - T = 62 \u00b0C\" ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - T = 76 \u00b0C\" ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - T = 84 \u00b0C\" ) # EH-31 elif type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"s\" , color = \"black\" , label = \"Exp. - P = 1.5 bar\" ) elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P = 2.0 bar\" ) elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"^\" , color = \"black\" , label = \"Exp. - P = 2.25 bar\" ) elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"p\" , color = \"black\" , label = \"Exp. - P = 2.5 bar\" ) ax . legend ( loc = 'best' , markerscale = 0.5 ) pola_exp_values ( type_fuel_cell , voltage_zone ) This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used to compare the model results with the experimental data. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. voltage_zone ( str ) \u2013 Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns: i_exp_t ( ndarray ) \u2013 Experimental values of the current density. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. Source code in calibration/experimental_values.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 def pola_exp_values ( type_fuel_cell , voltage_zone ): \"\"\" This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used to compare the model results with the experimental data. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. voltage_zone : str Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns ------- i_exp_t : numpy.ndarray Experimental values of the current density. U_exp_t : numpy.ndarray Experimental values of the voltage. \"\"\" # GenStack is a fuel cell developed in open source by ZSW (https://zenodo.org/records/14223364). if type_fuel_cell == \"ZSW-GenStack\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.953 , 0.864 , 0.838 , 0.819 , 0.804 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.778 , 0.760 , 0.743 , 0.721 , 0.703 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.694 , 0.685 , 0.666 , 0.644 , 0.620 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.593 , 0.579 , 0.546 , 0.486 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 15 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 # Voltage U_exp_t = np . zeros ( 15 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.953 , 0.864 , 0.838 , 0.819 , 0.804 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.778 , 0.760 , 0.743 , 0.721 , 0.703 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.694 , 0.685 , 0.666 , 0.644 , 0.620 elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 18 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.300 , 0.400 , 0.498 , 0.700 , 0.900 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ] = 1.900 , 2.000 , 2.171 # Voltage U_exp_t = np . zeros ( 18 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.936 , 0.835 , 0.809 , 0.795 , 0.783 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.759 , 0.741 , 0.725 , 0.701 , 0.670 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.661 , 0.633 , 0.587 , 0.541 , 0.500 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ] = 0.457 , 0.437 , 0.402 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 9 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ] = 0.300 , 0.400 , 0.498 , 0.700 # Voltage U_exp_t = np . zeros ( 9 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.936 , 0.835 , 0.809 , 0.795 , 0.783 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ] = 0.759 , 0.741 , 0.725 , 0.701 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.415 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.946 , 0.855 , 0.830 , 0.811 , 0.795 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.770 , 0.752 , 0.736 , 0.717 , 0.697 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.685 , 0.677 , 0.655 , 0.629 , 0.599 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.564 , 0.545 , 0.502 , 0.450 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 13 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ] = 0.999 , 1.099 , 1.300 # Voltage U_exp_t = np . zeros ( 13 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.946 , 0.855 , 0.830 , 0.811 , 0.795 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.770 , 0.752 , 0.736 , 0.717 , 0.697 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ] = 0.685 , 0.677 , 0.655 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.300 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.949 , 0.867 , 0.841 , 0.821 , 0.807 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.781 , 0.763 , 0.746 , 0.725 , 0.706 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.697 , 0.687 , 0.670 , 0.651 , 0.630 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.607 , 0.595 , 0.566 , 0.514 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 16 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.300 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ] = 1.900 # Voltage U_exp_t = np . zeros ( 16 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.949 , 0.867 , 0.841 , 0.821 , 0.807 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.781 , 0.763 , 0.746 , 0.725 , 0.706 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.697 , 0.687 , 0.670 , 0.651 , 0.630 U_exp_t [ 15 ] = 0.607 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.947 , 0.872 , 0.846 , 0.827 , 0.812 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.787 , 0.768 , 0.752 , 0.731 , 0.711 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.703 , 0.694 , 0.676 , 0.659 , 0.641 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.622 , 0.610 , 0.588 , 0.547 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 16 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ] = 1.900 # Voltage U_exp_t = np . zeros ( 16 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.947 , 0.872 , 0.846 , 0.827 , 0.812 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.787 , 0.768 , 0.752 , 0.731 , 0.711 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.703 , 0.694 , 0.676 , 0.659 , 0.641 U_exp_t [ 15 ] = 0.622 elif type_fuel_cell == \"ZSW-GenStack_T_62\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.944 , 0.855 , 0.827 , 0.808 , 0.795 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.771 , 0.754 , 0.739 , 0.717 , 0.696 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.685 , 0.675 , 0.653 , 0.631 , 0.606 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.581 , 0.566 , 0.532 , 0.471 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 14 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ] = 0.999 , 1.099 , 1.300 , 1.500 # Voltage U_exp_t = np . zeros ( 14 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.944 , 0.855 , 0.827 , 0.808 , 0.795 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.771 , 0.754 , 0.739 , 0.717 , 0.696 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ] = 0.685 , 0.675 , 0.653 , 0.631 elif type_fuel_cell == \"ZSW-GenStack_T_76\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.900 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.946 , 0.849 , 0.825 , 0.811 , 0.799 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.776 , 0.759 , 0.744 , 0.724 , 0.702 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.691 , 0.679 , 0.652 , 0.621 , 0.587 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.547 , 0.527 , 0.482 , 0.406 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 12 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.900 i_exp_t [ 10 ], i_exp_t [ 11 ] = 0.999 , 1.099 # Voltage U_exp_t = np . zeros ( 12 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.946 , 0.849 , 0.825 , 0.811 , 0.799 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.776 , 0.759 , 0.744 , 0.724 , 0.702 U_exp_t [ 10 ], U_exp_t [ 11 ] = 0.691 , 0.679 elif type_fuel_cell == \"ZSW-GenStack_T_84\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 17 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.300 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ] = 1.900 , 2.000 # Voltage U_exp_t = np . zeros ( 17 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.930 , 0.847 , 0.820 , 0.805 , 0.794 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.772 , 0.756 , 0.741 , 0.718 , 0.686 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.668 , 0.650 , 0.614 , 0.575 , 0.532 U_exp_t [ 15 ], U_exp_t [ 16 ] = 0.486 , 0.461 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 9 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ] = 0.300 , 0.400 , 0.498 , 0.700 # Voltage U_exp_t = np . zeros ( 9 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.930 , 0.847 , 0.820 , 0.805 , 0.794 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ] = 0.772 , 0.756 , 0.741 , 0.718 # EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 37 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.068 , 0.089 , 0.110 , 0.147 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.185 , 0.233 , 0.293 , 0.352 , 0.395 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.455 , 0.510 , 0.556 , 0.620 , 0.672 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.738 , 0.799 , 0.850 , 0.892 , 0.942 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 1.039 , 1.139 , 1.212 , 1.269 , 1.360 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.432 , 1.525 , 1.604 , 1.683 , 1.765 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ], i_exp_t [ 33 ], i_exp_t [ 34 ] = 1.878 , 1.966 , 2.050 , 2.109 , 2.151 i_exp_t [ 35 ], i_exp_t [ 36 ] = 2.188 , 2.246 # Voltage U_exp_t = np . zeros ( 37 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.882 , 0.865 , 0.850 , 0.834 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.823 , 0.811 , 0.794 , 0.781 , 0.772 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.761 , 0.752 , 0.745 , 0.735 , 0.728 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.719 , 0.712 , 0.706 , 0.700 , 0.694 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.681 , 0.668 , 0.660 , 0.653 , 0.641 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.634 , 0.622 , 0.610 , 0.599 , 0.586 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ], U_exp_t [ 33 ], U_exp_t [ 34 ] = 0.570 , 0.556 , 0.540 , 0.530 , 0.521 U_exp_t [ 35 ], U_exp_t [ 36 ] = 0.513 , 0.500 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 29 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.068 , 0.089 , 0.110 , 0.147 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.185 , 0.233 , 0.293 , 0.352 , 0.395 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.455 , 0.510 , 0.556 , 0.620 , 0.672 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.738 , 0.799 , 0.850 , 0.892 , 0.942 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 1.039 , 1.139 , 1.212 , 1.269 , 1.360 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ] = 1.432 , 1.525 , 1.604 , 1.683 # Voltage U_exp_t = np . zeros ( 29 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.882 , 0.865 , 0.850 , 0.834 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.823 , 0.811 , 0.794 , 0.781 , 0.772 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.761 , 0.752 , 0.745 , 0.735 , 0.728 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.719 , 0.712 , 0.706 , 0.700 , 0.694 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.681 , 0.668 , 0.660 , 0.653 , 0.641 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ] = 0.634 , 0.622 , 0.610 , 0.599 elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 49 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.057 , 0.079 , 0.106 , 0.135 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.171 , 0.206 , 0.242 , 0.302 , 0.346 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.395 , 0.434 , 0.476 , 0.531 , 0.570 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.623 , 0.681 , 0.731 , 0.779 , 0.822 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.868 , 0.930 , 0.976 , 1.031 , 1.090 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.134 , 1.205 , 1.242 , 1.312 , 1.358 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ], i_exp_t [ 33 ], i_exp_t [ 34 ] = 1.403 , 1.453 , 1.501 , 1.569 , 1.634 , i_exp_t [ 35 ], i_exp_t [ 36 ], i_exp_t [ 37 ], i_exp_t [ 38 ], i_exp_t [ 39 ] = 1.725 , 1.786 , 1.857 , 1.924 , 1.979 i_exp_t [ 40 ], i_exp_t [ 41 ], i_exp_t [ 42 ], i_exp_t [ 43 ], i_exp_t [ 44 ] = 2.050 , 2.125 , 2.168 , 2.214 , 2.258 i_exp_t [ 45 ], i_exp_t [ 46 ], i_exp_t [ 47 ], i_exp_t [ 48 ] = 2.308 , 2.348 , 2.413 , 2.459 # Voltage U_exp_t = np . zeros ( 49 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.889 , 0.874 , 0.860 , 0.853 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.845 , 0.837 , 0.830 , 0.817 , 0.808 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.800 , 0.792 , 0.786 , 0.779 , 0.772 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.765 , 0.759 , 0.753 , 0.747 , 0.742 , U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.737 , 0.730 , 0.726 , 0.720 , 0.714 , U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.710 , 0.702 , 0.698 , 0.690 , 0.684 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ], U_exp_t [ 33 ], U_exp_t [ 34 ] = 0.679 , 0.673 , 0.668 , 0.659 , 0.651 U_exp_t [ 35 ], U_exp_t [ 36 ], U_exp_t [ 37 ], U_exp_t [ 38 ], U_exp_t [ 39 ] = 0.640 , 0.631 , 0.620 , 0.608 , 0.598 U_exp_t [ 40 ], U_exp_t [ 41 ], U_exp_t [ 42 ], U_exp_t [ 43 ], U_exp_t [ 44 ] = 0.586 , 0.573 , 0.565 , 0.557 , 0.548 U_exp_t [ 45 ], U_exp_t [ 46 ], U_exp_t [ 47 ], U_exp_t [ 48 ] = 0.537 , 0.528 , 0.513 , 0.502 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 28 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.057 , 0.079 , 0.106 , 0.135 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.171 , 0.206 , 0.242 , 0.302 , 0.346 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.395 , 0.434 , 0.476 , 0.531 , 0.570 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.623 , 0.681 , 0.731 , 0.779 , 0.822 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.868 , 0.930 , 0.976 , 1.031 , 1.090 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ] = 1.134 , 1.205 , 1.242 # Voltage U_exp_t = np . zeros ( 28 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.889 , 0.874 , 0.860 , 0.853 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.845 , 0.837 , 0.830 , 0.817 , 0.808 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.800 , 0.792 , 0.786 , 0.779 , 0.772 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.765 , 0.759 , 0.753 , 0.747 , 0.742 , U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.737 , 0.730 , 0.726 , 0.720 , 0.714 , U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ] = 0.710 , 0.702 , 0.698 elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 54 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.056 , 0.095 , 0.120 , 0.138 , 0.160 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.183 , 0.218 , 0.248 , 0.279 , 0.315 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.364 , 0.409 , 0.477 , 0.536 , 0.594 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.641 , 0.697 , 0.748 , 0.809 , 0.866 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.944 , 1.011 , 1.074 , 1.142 , 1.193 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.252 , 1.322 , 1.381 , 1.442 , 1.496 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ], i_exp_t [ 33 ], i_exp_t [ 34 ] = 1.545 , 1.599 , 1.675 , 1.746 , 1.827 i_exp_t [ 35 ], i_exp_t [ 36 ], i_exp_t [ 37 ], i_exp_t [ 38 ], i_exp_t [ 39 ] = 1.868 , 1.918 , 2.004 , 2.053 , 2.114 i_exp_t [ 40 ], i_exp_t [ 41 ], i_exp_t [ 42 ], i_exp_t [ 43 ], i_exp_t [ 44 ] = 2.156 , 2.209 , 2.257 , 2.310 , 2.356 i_exp_t [ 45 ], i_exp_t [ 46 ], i_exp_t [ 47 ], i_exp_t [ 48 ], i_exp_t [ 49 ] = 2.403 , 2.468 , 2.513 , 2.552 , 2.600 i_exp_t [ 50 ], i_exp_t [ 51 ], i_exp_t [ 52 ], i_exp_t [ 53 ] = 2.636 , 2.679 , 2.728 , 2.794 # Voltage U_exp_t = np . zeros ( 54 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.894 , 0.882 , 0.873 , 0.867 , 0.861 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.854 , 0.847 , 0.840 , 0.834 , 0.827 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.819 , 0.812 , 0.801 , 0.793 , 0.786 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.781 , 0.775 , 0.771 , 0.764 , 0.759 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.751 , 0.746 , 0.740 , 0.734 , 0.728 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.723 , 0.715 , 0.709 , 0.703 , 0.698 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ], U_exp_t [ 33 ], U_exp_t [ 34 ] = 0.692 , 0.686 , 0.678 , 0.670 , 0.660 U_exp_t [ 35 ], U_exp_t [ 36 ], U_exp_t [ 37 ], U_exp_t [ 38 ], U_exp_t [ 39 ] = 0.654 , 0.647 , 0.635 , 0.628 , 0.618 U_exp_t [ 40 ], U_exp_t [ 41 ], U_exp_t [ 42 ], U_exp_t [ 43 ], U_exp_t [ 44 ] = 0.613 , 0.604 , 0.596 , 0.587 , 0.580 U_exp_t [ 45 ], U_exp_t [ 46 ], U_exp_t [ 47 ], U_exp_t [ 48 ], U_exp_t [ 49 ] = 0.570 , 0.559 , 0.551 , 0.545 , 0.536 U_exp_t [ 50 ], U_exp_t [ 51 ], U_exp_t [ 52 ], U_exp_t [ 53 ] = 0.528 , 0.520 , 0.511 , 0.497 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 33 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.056 , 0.095 , 0.120 , 0.138 , 0.160 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.183 , 0.218 , 0.248 , 0.279 , 0.315 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.364 , 0.409 , 0.477 , 0.536 , 0.594 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.641 , 0.697 , 0.748 , 0.809 , 0.866 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.944 , 1.011 , 1.074 , 1.142 , 1.193 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.252 , 1.322 , 1.381 , 1.442 , 1.496 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ] = 1.545 , 1.599 , 1.675 # Voltage U_exp_t = np . zeros ( 33 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.894 , 0.882 , 0.873 , 0.867 , 0.861 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.854 , 0.847 , 0.840 , 0.834 , 0.827 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.819 , 0.812 , 0.801 , 0.793 , 0.786 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.781 , 0.775 , 0.771 , 0.764 , 0.759 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.751 , 0.746 , 0.740 , 0.734 , 0.728 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.723 , 0.715 , 0.709 , 0.703 , 0.698 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ] = 0.692 , 0.686 , 0.678 elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 56 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.057 , 0.070 , 0.082 , 0.101 , 0.127 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.145 , 0.168 , 0.200 , 0.234 , 0.267 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.296 , 0.331 , 0.355 , 0.388 , 0.423 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.467 , 0.527 , 0.577 , 0.632 , 0.685 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.740 , 0.789 , 0.845 , 0.898 , 0.953 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.030 , 1.124 , 1.192 , 1.254 , 1.314 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ], i_exp_t [ 33 ], i_exp_t [ 34 ] = 1.364 , 1.434 , 1.514 , 1.587 , 1.643 i_exp_t [ 35 ], i_exp_t [ 36 ], i_exp_t [ 37 ], i_exp_t [ 38 ], i_exp_t [ 39 ] = 1.707 , 1.769 , 1.826 , 1.892 , 1.972 i_exp_t [ 40 ], i_exp_t [ 41 ], i_exp_t [ 42 ], i_exp_t [ 43 ], i_exp_t [ 44 ] = 2.040 , 2.124 , 2.192 , 2.265 , 2.358 i_exp_t [ 45 ], i_exp_t [ 46 ], i_exp_t [ 47 ], i_exp_t [ 48 ], i_exp_t [ 49 ] = 2.429 , 2.508 , 2.572 , 2.624 , 2.691 i_exp_t [ 50 ], i_exp_t [ 51 ], i_exp_t [ 52 ], i_exp_t [ 53 ], i_exp_t [ 54 ] = 2.750 , 2.822 , 2.879 , 2.918 , 2.956 i_exp_t [ 55 ] = 2.988 # Voltage U_exp_t = np . zeros ( 56 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.892 , 0.884 , 0.875 , 0.866 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.861 , 0.856 , 0.850 , 0.845 , 0.840 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.835 , 0.829 , 0.824 , 0.820 , 0.814 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.807 , 0.800 , 0.793 , 0.787 , 0.783 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.778 , 0.775 , 0.771 , 0.767 , 0.763 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.758 , 0.750 , 0.744 , 0.738 , 0.732 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ], U_exp_t [ 33 ], U_exp_t [ 34 ] = 0.726 , 0.719 , 0.712 , 0.703 , 0.697 U_exp_t [ 35 ], U_exp_t [ 36 ], U_exp_t [ 37 ], U_exp_t [ 38 ], U_exp_t [ 39 ] = 0.691 , 0.685 , 0.679 , 0.672 , 0.663 U_exp_t [ 40 ], U_exp_t [ 41 ], U_exp_t [ 42 ], U_exp_t [ 43 ], U_exp_t [ 44 ] = 0.657 , 0.648 , 0.640 , 0.632 , 0.621 U_exp_t [ 45 ], U_exp_t [ 46 ], U_exp_t [ 47 ], U_exp_t [ 48 ], U_exp_t [ 49 ] = 0.610 , 0.600 , 0.591 , 0.584 , 0.575 U_exp_t [ 50 ], U_exp_t [ 51 ], U_exp_t [ 52 ], U_exp_t [ 53 ], U_exp_t [ 54 ] = 0.566 , 0.555 , 0.546 , 0.537 , 0.531 U_exp_t [ 55 ] = 0.524 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 33 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.057 , 0.070 , 0.082 , 0.101 , 0.127 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.145 , 0.168 , 0.200 , 0.234 , 0.267 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.296 , 0.331 , 0.355 , 0.388 , 0.423 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.467 , 0.527 , 0.577 , 0.632 , 0.685 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.740 , 0.789 , 0.845 , 0.898 , 0.953 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.030 , 1.124 , 1.192 , 1.254 , 1.314 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ] = 1.364 , 1.434 , 1.514 # Voltage U_exp_t = np . zeros ( 33 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.892 , 0.884 , 0.875 , 0.866 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.861 , 0.856 , 0.850 , 0.845 , 0.840 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.835 , 0.829 , 0.824 , 0.820 , 0.814 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.807 , 0.800 , 0.793 , 0.787 , 0.783 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.778 , 0.775 , 0.771 , 0.767 , 0.763 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.758 , 0.750 , 0.744 , 0.738 , 0.732 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ] = 0.726 , 0.719 , 0.712 return i_exp_t * 1e4 , U_exp_t # Conversion in A.m-2 pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used for calibrating the model and so are composed of a reduced number of points compare to the pola_exp_values function. These points are specifically chosen to be as few as possible while still providing a good representation of the polarisation curve. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. voltage_zone ( str ) \u2013 Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns: i_exp_t ( ndarray ) \u2013 Experimental values of the current density. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. Source code in calibration/experimental_values.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def pola_exp_values_calibration ( type_fuel_cell , voltage_zone ): \"\"\" This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used for calibrating the model and so are composed of a reduced number of points compare to the pola_exp_values function. These points are specifically chosen to be as few as possible while still providing a good representation of the polarisation curve. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. voltage_zone : str Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns ------- i_exp_t : numpy.ndarray Experimental values of the current density. U_exp_t : numpy.ndarray Experimental values of the voltage. \"\"\" # ZSW fuel cell if type_fuel_cell == \"ZSW-GenStack\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.700 , 2.000 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.953 , 0.864 , 0.743 , 0.685 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.620 , 0.579 , 0.486 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ] = 0.001 , 0.050 , 0.498 , 1.099 , 1.700 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ] = 0.953 , 0.864 , 0.743 , 0.685 , 0.620 elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.300 , 0.700 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 0.900 , 1.500 , 2.171 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.936 , 0.835 , 0.759 , 0.701 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.670 , 0.541 , 0.402 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.300 , 0.700 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.936 , 0.835 , 0.759 , 0.701 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 6 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ] = 0.001 , 0.050 , 0.498 i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ] = 1.300 , 2.000 , 2.415 # Voltage U_exp_cali_t = np . zeros ( 6 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ] = 0.946 , 0.855 , 0.736 U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ] = 0.655 , 0.545 , 0.450 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.300 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.946 , 0.855 , 0.736 , 0.655 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.900 , 2.200 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.949 , 0.867 , 0.746 , 0.687 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.607 , 0.566 , 0.514 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ] = 0.001 , 0.050 , 0.498 , 1.099 , 1.900 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ] = 0.949 , 0.867 , 0.746 , 0.687 , 0.607 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.900 , 2.200 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.947 , 0.872 , 0.752 , 0.694 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.622 , 0.588 , 0.547 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ] = 0.001 , 0.050 , 0.498 , 1.099 , 1.900 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ] = 0.947 , 0.872 , 0.752 , 0.703 , 0.622 elif type_fuel_cell == \"ZSW-GenStack_T_62\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 6 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ] = 0.001 , 0.050 , 0.498 i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ] = 1.500 , 2.000 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 6 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ] = 0.944 , 0.855 , 0.739 U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ] = 0.631 , 0.566 , 0.471 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.500 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.944 , 0.855 , 0.739 , 0.631 elif type_fuel_cell == \"ZSW-GenStack_T_76\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.700 , 2.200 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.946 , 0.849 , 0.744 , 0.679 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.587 , 0.482 , 0.406 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.946 , 0.849 , 0.744 , 0.679 elif type_fuel_cell == \"ZSW-GenStack_T_84\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.300 , 0.700 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 0.901 , 1.500 , 2.000 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.930 , 0.847 , 0.772 , 0.718 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.686 , 0.575 , 0.461 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.300 , 0.700 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.930 , 0.847 , 0.772 , 0.718 # EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.110 , 0.293 , 1.039 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.683 , 1.966 , 2.246 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.850 , 0.794 , 0.681 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.599 , 0.556 , 0.500 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.110 , 0.293 , 1.039 i_exp_cali_t [ 4 ] = 1.683 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.850 , 0.794 , 0.681 U_exp_cali_t [ 4 ] = 0.599 elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 8 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.106 , 0.242 , 0.681 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ], i_exp_cali_t [ 7 ] = 1.242 , 1.501 , 1.979 , 2.459 # Voltage U_exp_cali_t = np . zeros ( 8 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.860 , 0.830 , 0.759 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ], U_exp_cali_t [ 7 ] = 0.698 , 0.668 , 0.598 , 0.502 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.106 , 0.242 , 0.681 i_exp_cali_t [ 4 ] = 1.242 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.860 , 0.830 , 0.759 U_exp_cali_t [ 4 ] = 0.698 elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 8 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.056 , 0.183 , 0.364 , 1.011 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ], i_exp_cali_t [ 7 ] = 1.675 , 1.918 , 2.356 , 2.794 # Voltage U_exp_cali_t = np . zeros ( 8 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.894 , 0.854 , 0.819 , 0.746 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ], U_exp_cali_t [ 7 ] = 0.678 , 0.647 , 0.580 , 0.497 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.056 , 0.183 , 0.364 , 1.011 i_exp_cali_t [ 4 ] = 1.675 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.894 , 0.854 , 0.819 , 0.746 U_exp_cali_t [ 4 ] = 0.678 elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 10 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.057 , 0.127 , 0.296 , 0.527 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ], i_exp_cali_t [ 7 ] = 1.030 , 1.514 , 1.972 , 2.358 i_exp_cali_t [ 8 ], i_exp_cali_t [ 9 ] = 2.691 , 2.988 # Voltage U_exp_cali_t = np . zeros ( 10 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.866 , 0.835 , 0.800 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ], U_exp_cali_t [ 7 ] = 0.758 , 0.712 , 0.663 , 0.621 U_exp_cali_t [ 8 ], U_exp_cali_t [ 9 ] = 0.575 , 0.524 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 6 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.057 , 0.127 , 0.296 , 0.527 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ] = 1.030 , 1.514 # Voltage U_exp_cali_t = np . zeros ( 6 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.866 , 0.835 , 0.800 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ] = 0.758 , 0.712 return i_exp_cali_t * 1e4 , U_exp_cali_t # Conversion in A.m-2","title":"Experimental values"},{"location":"functions/calibration/experimental_values/#experimental-values","text":"This file is designated for executing the AlphaPEM software package.","title":"Experimental values"},{"location":"functions/calibration/experimental_values/#calibration.experimental_values.plot_experimental_polarisation_curve","text":"This function plots the experimental polarisation curve on the same graph as the model results. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. i_fc_t ( ndarray ) \u2013 Current density values. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. ax ( Axes ) \u2013 Axes object on which the experimental data is plotted. Source code in calibration/experimental_values.py 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def plot_experimental_polarisation_curve ( type_fuel_cell , i_fc_t , U_exp_t , ax ): \"\"\" This function plots the experimental polarisation curve on the same graph as the model results. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. i_fc_t : numpy.ndarray Current density values. U_exp_t : numpy.ndarray Experimental values of the voltage. ax : matplotlib.axes.Axes Axes object on which the experimental data is plotted. \"\"\" # ZSW-GenStack if type_fuel_cell == \"ZSW-GenStack\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - nominal operating conditions\" ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P$_a$ = 1.61 bar, P$_c$ = 1.41 bar\" ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P$_a$ = 2.01 bar, P$_c$ = 1.81 bar\" ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P$_a$ = 2.4 bar, P$_c$ = 2.2 bar\" ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P$_a$ = 2.8 bar, P$_c$ = 2.6 bar\" ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - T = 62 \u00b0C\" ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - T = 76 \u00b0C\" ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" : ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - T = 84 \u00b0C\" ) # EH-31 elif type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"s\" , color = \"black\" , label = \"Exp. - P = 1.5 bar\" ) elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"v\" , color = \"black\" , label = \"Exp. - P = 2.0 bar\" ) elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"^\" , color = \"black\" , label = \"Exp. - P = 2.25 bar\" ) elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar ax . scatter ( i_fc_t , U_exp_t , linewidths = 1.5 , marker = \"p\" , color = \"black\" , label = \"Exp. - P = 2.5 bar\" ) ax . legend ( loc = 'best' , markerscale = 0.5 )","title":"plot_experimental_polarisation_curve"},{"location":"functions/calibration/experimental_values/#calibration.experimental_values.pola_exp_values","text":"This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used to compare the model results with the experimental data. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. voltage_zone ( str ) \u2013 Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns: i_exp_t ( ndarray ) \u2013 Experimental values of the current density. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. Source code in calibration/experimental_values.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 def pola_exp_values ( type_fuel_cell , voltage_zone ): \"\"\" This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used to compare the model results with the experimental data. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. voltage_zone : str Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns ------- i_exp_t : numpy.ndarray Experimental values of the current density. U_exp_t : numpy.ndarray Experimental values of the voltage. \"\"\" # GenStack is a fuel cell developed in open source by ZSW (https://zenodo.org/records/14223364). if type_fuel_cell == \"ZSW-GenStack\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.953 , 0.864 , 0.838 , 0.819 , 0.804 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.778 , 0.760 , 0.743 , 0.721 , 0.703 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.694 , 0.685 , 0.666 , 0.644 , 0.620 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.593 , 0.579 , 0.546 , 0.486 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 15 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 # Voltage U_exp_t = np . zeros ( 15 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.953 , 0.864 , 0.838 , 0.819 , 0.804 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.778 , 0.760 , 0.743 , 0.721 , 0.703 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.694 , 0.685 , 0.666 , 0.644 , 0.620 elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 18 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.300 , 0.400 , 0.498 , 0.700 , 0.900 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ] = 1.900 , 2.000 , 2.171 # Voltage U_exp_t = np . zeros ( 18 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.936 , 0.835 , 0.809 , 0.795 , 0.783 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.759 , 0.741 , 0.725 , 0.701 , 0.670 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.661 , 0.633 , 0.587 , 0.541 , 0.500 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ] = 0.457 , 0.437 , 0.402 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 9 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ] = 0.300 , 0.400 , 0.498 , 0.700 # Voltage U_exp_t = np . zeros ( 9 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.936 , 0.835 , 0.809 , 0.795 , 0.783 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ] = 0.759 , 0.741 , 0.725 , 0.701 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.415 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.946 , 0.855 , 0.830 , 0.811 , 0.795 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.770 , 0.752 , 0.736 , 0.717 , 0.697 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.685 , 0.677 , 0.655 , 0.629 , 0.599 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.564 , 0.545 , 0.502 , 0.450 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 13 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ] = 0.999 , 1.099 , 1.300 # Voltage U_exp_t = np . zeros ( 13 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.946 , 0.855 , 0.830 , 0.811 , 0.795 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.770 , 0.752 , 0.736 , 0.717 , 0.697 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ] = 0.685 , 0.677 , 0.655 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.300 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.949 , 0.867 , 0.841 , 0.821 , 0.807 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.781 , 0.763 , 0.746 , 0.725 , 0.706 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.697 , 0.687 , 0.670 , 0.651 , 0.630 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.607 , 0.595 , 0.566 , 0.514 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 16 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.200 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.300 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ] = 1.900 # Voltage U_exp_t = np . zeros ( 16 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.949 , 0.867 , 0.841 , 0.821 , 0.807 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.781 , 0.763 , 0.746 , 0.725 , 0.706 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.697 , 0.687 , 0.670 , 0.651 , 0.630 U_exp_t [ 15 ] = 0.607 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.947 , 0.872 , 0.846 , 0.827 , 0.812 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.787 , 0.768 , 0.752 , 0.731 , 0.711 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.703 , 0.694 , 0.676 , 0.659 , 0.641 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.622 , 0.610 , 0.588 , 0.547 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 16 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ] = 1.900 # Voltage U_exp_t = np . zeros ( 16 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.947 , 0.872 , 0.846 , 0.827 , 0.812 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.787 , 0.768 , 0.752 , 0.731 , 0.711 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.703 , 0.694 , 0.676 , 0.659 , 0.641 U_exp_t [ 15 ] = 0.622 elif type_fuel_cell == \"ZSW-GenStack_T_62\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.944 , 0.855 , 0.827 , 0.808 , 0.795 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.771 , 0.754 , 0.739 , 0.717 , 0.696 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.685 , 0.675 , 0.653 , 0.631 , 0.606 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.581 , 0.566 , 0.532 , 0.471 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 14 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ] = 0.999 , 1.099 , 1.300 , 1.500 # Voltage U_exp_t = np . zeros ( 14 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.944 , 0.855 , 0.827 , 0.808 , 0.795 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.771 , 0.754 , 0.739 , 0.717 , 0.696 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ] = 0.685 , 0.675 , 0.653 , 0.631 elif type_fuel_cell == \"ZSW-GenStack_T_76\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 19 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.900 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ] = 1.900 , 2.000 , 2.200 , 2.500 # Voltage U_exp_t = np . zeros ( 19 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.946 , 0.849 , 0.825 , 0.811 , 0.799 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.776 , 0.759 , 0.744 , 0.724 , 0.702 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.691 , 0.679 , 0.652 , 0.621 , 0.587 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ] = 0.547 , 0.527 , 0.482 , 0.406 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 12 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.299 , 0.400 , 0.498 , 0.700 , 0.900 i_exp_t [ 10 ], i_exp_t [ 11 ] = 0.999 , 1.099 # Voltage U_exp_t = np . zeros ( 12 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.946 , 0.849 , 0.825 , 0.811 , 0.799 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.776 , 0.759 , 0.744 , 0.724 , 0.702 U_exp_t [ 10 ], U_exp_t [ 11 ] = 0.691 , 0.679 elif type_fuel_cell == \"ZSW-GenStack_T_84\" : if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 17 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.300 , 0.400 , 0.498 , 0.700 , 0.901 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.999 , 1.099 , 1.300 , 1.500 , 1.700 i_exp_t [ 15 ], i_exp_t [ 16 ] = 1.900 , 2.000 # Voltage U_exp_t = np . zeros ( 17 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.930 , 0.847 , 0.820 , 0.805 , 0.794 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.772 , 0.756 , 0.741 , 0.718 , 0.686 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.668 , 0.650 , 0.614 , 0.575 , 0.532 U_exp_t [ 15 ], U_exp_t [ 16 ] = 0.486 , 0.461 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 9 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.001 , 0.050 , 0.099 , 0.150 , 0.199 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ] = 0.300 , 0.400 , 0.498 , 0.700 # Voltage U_exp_t = np . zeros ( 9 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.930 , 0.847 , 0.820 , 0.805 , 0.794 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ] = 0.772 , 0.756 , 0.741 , 0.718 # EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 37 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.068 , 0.089 , 0.110 , 0.147 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.185 , 0.233 , 0.293 , 0.352 , 0.395 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.455 , 0.510 , 0.556 , 0.620 , 0.672 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.738 , 0.799 , 0.850 , 0.892 , 0.942 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 1.039 , 1.139 , 1.212 , 1.269 , 1.360 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.432 , 1.525 , 1.604 , 1.683 , 1.765 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ], i_exp_t [ 33 ], i_exp_t [ 34 ] = 1.878 , 1.966 , 2.050 , 2.109 , 2.151 i_exp_t [ 35 ], i_exp_t [ 36 ] = 2.188 , 2.246 # Voltage U_exp_t = np . zeros ( 37 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.882 , 0.865 , 0.850 , 0.834 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.823 , 0.811 , 0.794 , 0.781 , 0.772 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.761 , 0.752 , 0.745 , 0.735 , 0.728 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.719 , 0.712 , 0.706 , 0.700 , 0.694 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.681 , 0.668 , 0.660 , 0.653 , 0.641 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.634 , 0.622 , 0.610 , 0.599 , 0.586 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ], U_exp_t [ 33 ], U_exp_t [ 34 ] = 0.570 , 0.556 , 0.540 , 0.530 , 0.521 U_exp_t [ 35 ], U_exp_t [ 36 ] = 0.513 , 0.500 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 29 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.068 , 0.089 , 0.110 , 0.147 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.185 , 0.233 , 0.293 , 0.352 , 0.395 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.455 , 0.510 , 0.556 , 0.620 , 0.672 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.738 , 0.799 , 0.850 , 0.892 , 0.942 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 1.039 , 1.139 , 1.212 , 1.269 , 1.360 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ] = 1.432 , 1.525 , 1.604 , 1.683 # Voltage U_exp_t = np . zeros ( 29 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.882 , 0.865 , 0.850 , 0.834 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.823 , 0.811 , 0.794 , 0.781 , 0.772 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.761 , 0.752 , 0.745 , 0.735 , 0.728 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.719 , 0.712 , 0.706 , 0.700 , 0.694 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.681 , 0.668 , 0.660 , 0.653 , 0.641 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ] = 0.634 , 0.622 , 0.610 , 0.599 elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 49 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.057 , 0.079 , 0.106 , 0.135 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.171 , 0.206 , 0.242 , 0.302 , 0.346 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.395 , 0.434 , 0.476 , 0.531 , 0.570 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.623 , 0.681 , 0.731 , 0.779 , 0.822 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.868 , 0.930 , 0.976 , 1.031 , 1.090 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.134 , 1.205 , 1.242 , 1.312 , 1.358 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ], i_exp_t [ 33 ], i_exp_t [ 34 ] = 1.403 , 1.453 , 1.501 , 1.569 , 1.634 , i_exp_t [ 35 ], i_exp_t [ 36 ], i_exp_t [ 37 ], i_exp_t [ 38 ], i_exp_t [ 39 ] = 1.725 , 1.786 , 1.857 , 1.924 , 1.979 i_exp_t [ 40 ], i_exp_t [ 41 ], i_exp_t [ 42 ], i_exp_t [ 43 ], i_exp_t [ 44 ] = 2.050 , 2.125 , 2.168 , 2.214 , 2.258 i_exp_t [ 45 ], i_exp_t [ 46 ], i_exp_t [ 47 ], i_exp_t [ 48 ] = 2.308 , 2.348 , 2.413 , 2.459 # Voltage U_exp_t = np . zeros ( 49 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.889 , 0.874 , 0.860 , 0.853 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.845 , 0.837 , 0.830 , 0.817 , 0.808 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.800 , 0.792 , 0.786 , 0.779 , 0.772 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.765 , 0.759 , 0.753 , 0.747 , 0.742 , U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.737 , 0.730 , 0.726 , 0.720 , 0.714 , U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.710 , 0.702 , 0.698 , 0.690 , 0.684 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ], U_exp_t [ 33 ], U_exp_t [ 34 ] = 0.679 , 0.673 , 0.668 , 0.659 , 0.651 U_exp_t [ 35 ], U_exp_t [ 36 ], U_exp_t [ 37 ], U_exp_t [ 38 ], U_exp_t [ 39 ] = 0.640 , 0.631 , 0.620 , 0.608 , 0.598 U_exp_t [ 40 ], U_exp_t [ 41 ], U_exp_t [ 42 ], U_exp_t [ 43 ], U_exp_t [ 44 ] = 0.586 , 0.573 , 0.565 , 0.557 , 0.548 U_exp_t [ 45 ], U_exp_t [ 46 ], U_exp_t [ 47 ], U_exp_t [ 48 ] = 0.537 , 0.528 , 0.513 , 0.502 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 28 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.050 , 0.057 , 0.079 , 0.106 , 0.135 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.171 , 0.206 , 0.242 , 0.302 , 0.346 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.395 , 0.434 , 0.476 , 0.531 , 0.570 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.623 , 0.681 , 0.731 , 0.779 , 0.822 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.868 , 0.930 , 0.976 , 1.031 , 1.090 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ] = 1.134 , 1.205 , 1.242 # Voltage U_exp_t = np . zeros ( 28 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.889 , 0.874 , 0.860 , 0.853 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.845 , 0.837 , 0.830 , 0.817 , 0.808 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.800 , 0.792 , 0.786 , 0.779 , 0.772 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.765 , 0.759 , 0.753 , 0.747 , 0.742 , U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.737 , 0.730 , 0.726 , 0.720 , 0.714 , U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ] = 0.710 , 0.702 , 0.698 elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 54 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.056 , 0.095 , 0.120 , 0.138 , 0.160 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.183 , 0.218 , 0.248 , 0.279 , 0.315 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.364 , 0.409 , 0.477 , 0.536 , 0.594 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.641 , 0.697 , 0.748 , 0.809 , 0.866 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.944 , 1.011 , 1.074 , 1.142 , 1.193 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.252 , 1.322 , 1.381 , 1.442 , 1.496 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ], i_exp_t [ 33 ], i_exp_t [ 34 ] = 1.545 , 1.599 , 1.675 , 1.746 , 1.827 i_exp_t [ 35 ], i_exp_t [ 36 ], i_exp_t [ 37 ], i_exp_t [ 38 ], i_exp_t [ 39 ] = 1.868 , 1.918 , 2.004 , 2.053 , 2.114 i_exp_t [ 40 ], i_exp_t [ 41 ], i_exp_t [ 42 ], i_exp_t [ 43 ], i_exp_t [ 44 ] = 2.156 , 2.209 , 2.257 , 2.310 , 2.356 i_exp_t [ 45 ], i_exp_t [ 46 ], i_exp_t [ 47 ], i_exp_t [ 48 ], i_exp_t [ 49 ] = 2.403 , 2.468 , 2.513 , 2.552 , 2.600 i_exp_t [ 50 ], i_exp_t [ 51 ], i_exp_t [ 52 ], i_exp_t [ 53 ] = 2.636 , 2.679 , 2.728 , 2.794 # Voltage U_exp_t = np . zeros ( 54 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.894 , 0.882 , 0.873 , 0.867 , 0.861 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.854 , 0.847 , 0.840 , 0.834 , 0.827 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.819 , 0.812 , 0.801 , 0.793 , 0.786 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.781 , 0.775 , 0.771 , 0.764 , 0.759 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.751 , 0.746 , 0.740 , 0.734 , 0.728 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.723 , 0.715 , 0.709 , 0.703 , 0.698 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ], U_exp_t [ 33 ], U_exp_t [ 34 ] = 0.692 , 0.686 , 0.678 , 0.670 , 0.660 U_exp_t [ 35 ], U_exp_t [ 36 ], U_exp_t [ 37 ], U_exp_t [ 38 ], U_exp_t [ 39 ] = 0.654 , 0.647 , 0.635 , 0.628 , 0.618 U_exp_t [ 40 ], U_exp_t [ 41 ], U_exp_t [ 42 ], U_exp_t [ 43 ], U_exp_t [ 44 ] = 0.613 , 0.604 , 0.596 , 0.587 , 0.580 U_exp_t [ 45 ], U_exp_t [ 46 ], U_exp_t [ 47 ], U_exp_t [ 48 ], U_exp_t [ 49 ] = 0.570 , 0.559 , 0.551 , 0.545 , 0.536 U_exp_t [ 50 ], U_exp_t [ 51 ], U_exp_t [ 52 ], U_exp_t [ 53 ] = 0.528 , 0.520 , 0.511 , 0.497 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 33 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.056 , 0.095 , 0.120 , 0.138 , 0.160 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.183 , 0.218 , 0.248 , 0.279 , 0.315 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.364 , 0.409 , 0.477 , 0.536 , 0.594 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.641 , 0.697 , 0.748 , 0.809 , 0.866 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.944 , 1.011 , 1.074 , 1.142 , 1.193 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.252 , 1.322 , 1.381 , 1.442 , 1.496 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ] = 1.545 , 1.599 , 1.675 # Voltage U_exp_t = np . zeros ( 33 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.894 , 0.882 , 0.873 , 0.867 , 0.861 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.854 , 0.847 , 0.840 , 0.834 , 0.827 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.819 , 0.812 , 0.801 , 0.793 , 0.786 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.781 , 0.775 , 0.771 , 0.764 , 0.759 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.751 , 0.746 , 0.740 , 0.734 , 0.728 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.723 , 0.715 , 0.709 , 0.703 , 0.698 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ] = 0.692 , 0.686 , 0.678 elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar if voltage_zone == 'full' : # Current density i_exp_t = np . zeros ( 56 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.057 , 0.070 , 0.082 , 0.101 , 0.127 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.145 , 0.168 , 0.200 , 0.234 , 0.267 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.296 , 0.331 , 0.355 , 0.388 , 0.423 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.467 , 0.527 , 0.577 , 0.632 , 0.685 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.740 , 0.789 , 0.845 , 0.898 , 0.953 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.030 , 1.124 , 1.192 , 1.254 , 1.314 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ], i_exp_t [ 33 ], i_exp_t [ 34 ] = 1.364 , 1.434 , 1.514 , 1.587 , 1.643 i_exp_t [ 35 ], i_exp_t [ 36 ], i_exp_t [ 37 ], i_exp_t [ 38 ], i_exp_t [ 39 ] = 1.707 , 1.769 , 1.826 , 1.892 , 1.972 i_exp_t [ 40 ], i_exp_t [ 41 ], i_exp_t [ 42 ], i_exp_t [ 43 ], i_exp_t [ 44 ] = 2.040 , 2.124 , 2.192 , 2.265 , 2.358 i_exp_t [ 45 ], i_exp_t [ 46 ], i_exp_t [ 47 ], i_exp_t [ 48 ], i_exp_t [ 49 ] = 2.429 , 2.508 , 2.572 , 2.624 , 2.691 i_exp_t [ 50 ], i_exp_t [ 51 ], i_exp_t [ 52 ], i_exp_t [ 53 ], i_exp_t [ 54 ] = 2.750 , 2.822 , 2.879 , 2.918 , 2.956 i_exp_t [ 55 ] = 2.988 # Voltage U_exp_t = np . zeros ( 56 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.892 , 0.884 , 0.875 , 0.866 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.861 , 0.856 , 0.850 , 0.845 , 0.840 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.835 , 0.829 , 0.824 , 0.820 , 0.814 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.807 , 0.800 , 0.793 , 0.787 , 0.783 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.778 , 0.775 , 0.771 , 0.767 , 0.763 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.758 , 0.750 , 0.744 , 0.738 , 0.732 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ], U_exp_t [ 33 ], U_exp_t [ 34 ] = 0.726 , 0.719 , 0.712 , 0.703 , 0.697 U_exp_t [ 35 ], U_exp_t [ 36 ], U_exp_t [ 37 ], U_exp_t [ 38 ], U_exp_t [ 39 ] = 0.691 , 0.685 , 0.679 , 0.672 , 0.663 U_exp_t [ 40 ], U_exp_t [ 41 ], U_exp_t [ 42 ], U_exp_t [ 43 ], U_exp_t [ 44 ] = 0.657 , 0.648 , 0.640 , 0.632 , 0.621 U_exp_t [ 45 ], U_exp_t [ 46 ], U_exp_t [ 47 ], U_exp_t [ 48 ], U_exp_t [ 49 ] = 0.610 , 0.600 , 0.591 , 0.584 , 0.575 U_exp_t [ 50 ], U_exp_t [ 51 ], U_exp_t [ 52 ], U_exp_t [ 53 ], U_exp_t [ 54 ] = 0.566 , 0.555 , 0.546 , 0.537 , 0.531 U_exp_t [ 55 ] = 0.524 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_t = np . zeros ( 33 ) i_exp_t [ 0 ], i_exp_t [ 1 ], i_exp_t [ 2 ], i_exp_t [ 3 ], i_exp_t [ 4 ] = 0.057 , 0.070 , 0.082 , 0.101 , 0.127 i_exp_t [ 5 ], i_exp_t [ 6 ], i_exp_t [ 7 ], i_exp_t [ 8 ], i_exp_t [ 9 ] = 0.145 , 0.168 , 0.200 , 0.234 , 0.267 i_exp_t [ 10 ], i_exp_t [ 11 ], i_exp_t [ 12 ], i_exp_t [ 13 ], i_exp_t [ 14 ] = 0.296 , 0.331 , 0.355 , 0.388 , 0.423 i_exp_t [ 15 ], i_exp_t [ 16 ], i_exp_t [ 17 ], i_exp_t [ 18 ], i_exp_t [ 19 ] = 0.467 , 0.527 , 0.577 , 0.632 , 0.685 i_exp_t [ 20 ], i_exp_t [ 21 ], i_exp_t [ 22 ], i_exp_t [ 23 ], i_exp_t [ 24 ] = 0.740 , 0.789 , 0.845 , 0.898 , 0.953 i_exp_t [ 25 ], i_exp_t [ 26 ], i_exp_t [ 27 ], i_exp_t [ 28 ], i_exp_t [ 29 ] = 1.030 , 1.124 , 1.192 , 1.254 , 1.314 i_exp_t [ 30 ], i_exp_t [ 31 ], i_exp_t [ 32 ] = 1.364 , 1.434 , 1.514 # Voltage U_exp_t = np . zeros ( 33 ) U_exp_t [ 0 ], U_exp_t [ 1 ], U_exp_t [ 2 ], U_exp_t [ 3 ], U_exp_t [ 4 ] = 0.900 , 0.892 , 0.884 , 0.875 , 0.866 U_exp_t [ 5 ], U_exp_t [ 6 ], U_exp_t [ 7 ], U_exp_t [ 8 ], U_exp_t [ 9 ] = 0.861 , 0.856 , 0.850 , 0.845 , 0.840 U_exp_t [ 10 ], U_exp_t [ 11 ], U_exp_t [ 12 ], U_exp_t [ 13 ], U_exp_t [ 14 ] = 0.835 , 0.829 , 0.824 , 0.820 , 0.814 U_exp_t [ 15 ], U_exp_t [ 16 ], U_exp_t [ 17 ], U_exp_t [ 18 ], U_exp_t [ 19 ] = 0.807 , 0.800 , 0.793 , 0.787 , 0.783 U_exp_t [ 20 ], U_exp_t [ 21 ], U_exp_t [ 22 ], U_exp_t [ 23 ], U_exp_t [ 24 ] = 0.778 , 0.775 , 0.771 , 0.767 , 0.763 U_exp_t [ 25 ], U_exp_t [ 26 ], U_exp_t [ 27 ], U_exp_t [ 28 ], U_exp_t [ 29 ] = 0.758 , 0.750 , 0.744 , 0.738 , 0.732 U_exp_t [ 30 ], U_exp_t [ 31 ], U_exp_t [ 32 ] = 0.726 , 0.719 , 0.712 return i_exp_t * 1e4 , U_exp_t # Conversion in A.m-2","title":"pola_exp_values"},{"location":"functions/calibration/experimental_values/#calibration.experimental_values.pola_exp_values_calibration","text":"This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used for calibrating the model and so are composed of a reduced number of points compare to the pola_exp_values function. These points are specifically chosen to be as few as possible while still providing a good representation of the polarisation curve. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. voltage_zone ( str ) \u2013 Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns: i_exp_t ( ndarray ) \u2013 Experimental values of the current density. U_exp_t ( ndarray ) \u2013 Experimental values of the voltage. Source code in calibration/experimental_values.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def pola_exp_values_calibration ( type_fuel_cell , voltage_zone ): \"\"\" This function returns the experimental values of polarisation curves made on different fuel cells at different operating conditions. The experimental values are used for calibrating the model and so are composed of a reduced number of points compare to the pola_exp_values function. These points are specifically chosen to be as few as possible while still providing a good representation of the polarisation curve. Parameters ---------- type_fuel_cell : str Type of fuel cell used in the model. This parameter includes the fuel cell used in the model and the corresponding operating conditions. voltage_zone : str Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns ------- i_exp_t : numpy.ndarray Experimental values of the current density. U_exp_t : numpy.ndarray Experimental values of the voltage. \"\"\" # ZSW fuel cell if type_fuel_cell == \"ZSW-GenStack\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.700 , 2.000 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.953 , 0.864 , 0.743 , 0.685 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.620 , 0.579 , 0.486 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ] = 0.001 , 0.050 , 0.498 , 1.099 , 1.700 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ] = 0.953 , 0.864 , 0.743 , 0.685 , 0.620 elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.300 , 0.700 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 0.900 , 1.500 , 2.171 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.936 , 0.835 , 0.759 , 0.701 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.670 , 0.541 , 0.402 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.300 , 0.700 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.936 , 0.835 , 0.759 , 0.701 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 6 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ] = 0.001 , 0.050 , 0.498 i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ] = 1.300 , 2.000 , 2.415 # Voltage U_exp_cali_t = np . zeros ( 6 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ] = 0.946 , 0.855 , 0.736 U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ] = 0.655 , 0.545 , 0.450 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.300 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.946 , 0.855 , 0.736 , 0.655 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.900 , 2.200 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.949 , 0.867 , 0.746 , 0.687 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.607 , 0.566 , 0.514 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ] = 0.001 , 0.050 , 0.498 , 1.099 , 1.900 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ] = 0.949 , 0.867 , 0.746 , 0.687 , 0.607 elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.900 , 2.200 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.947 , 0.872 , 0.752 , 0.694 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.622 , 0.588 , 0.547 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ] = 0.001 , 0.050 , 0.498 , 1.099 , 1.900 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ] = 0.947 , 0.872 , 0.752 , 0.703 , 0.622 elif type_fuel_cell == \"ZSW-GenStack_T_62\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 6 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ] = 0.001 , 0.050 , 0.498 i_exp_cali_t [ 3 ], i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ] = 1.500 , 2.000 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 6 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ] = 0.944 , 0.855 , 0.739 U_exp_cali_t [ 3 ], U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ] = 0.631 , 0.566 , 0.471 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.500 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.944 , 0.855 , 0.739 , 0.631 elif type_fuel_cell == \"ZSW-GenStack_T_76\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.700 , 2.200 , 2.500 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.946 , 0.849 , 0.744 , 0.679 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.587 , 0.482 , 0.406 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.498 , 1.099 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.946 , 0.849 , 0.744 , 0.679 elif type_fuel_cell == \"ZSW-GenStack_T_84\" : if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.300 , 0.700 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 0.901 , 1.500 , 2.000 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.930 , 0.847 , 0.772 , 0.718 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.686 , 0.575 , 0.461 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 4 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.001 , 0.050 , 0.300 , 0.700 # Voltage U_exp_cali_t = np . zeros ( 4 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.930 , 0.847 , 0.772 , 0.718 # EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" : # at 1.5 bar if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 7 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.110 , 0.293 , 1.039 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ] = 1.683 , 1.966 , 2.246 # Voltage U_exp_cali_t = np . zeros ( 7 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.850 , 0.794 , 0.681 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ] = 0.599 , 0.556 , 0.500 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.110 , 0.293 , 1.039 i_exp_cali_t [ 4 ] = 1.683 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.850 , 0.794 , 0.681 U_exp_cali_t [ 4 ] = 0.599 elif type_fuel_cell == \"EH-31_2.0\" : # at 2.0 bar if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 8 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.106 , 0.242 , 0.681 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ], i_exp_cali_t [ 7 ] = 1.242 , 1.501 , 1.979 , 2.459 # Voltage U_exp_cali_t = np . zeros ( 8 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.860 , 0.830 , 0.759 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ], U_exp_cali_t [ 7 ] = 0.698 , 0.668 , 0.598 , 0.502 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.050 , 0.106 , 0.242 , 0.681 i_exp_cali_t [ 4 ] = 1.242 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.860 , 0.830 , 0.759 U_exp_cali_t [ 4 ] = 0.698 elif type_fuel_cell == \"EH-31_2.25\" : # at 2.25 bar if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 8 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.056 , 0.183 , 0.364 , 1.011 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ], i_exp_cali_t [ 7 ] = 1.675 , 1.918 , 2.356 , 2.794 # Voltage U_exp_cali_t = np . zeros ( 8 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.894 , 0.854 , 0.819 , 0.746 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ], U_exp_cali_t [ 7 ] = 0.678 , 0.647 , 0.580 , 0.497 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 5 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.056 , 0.183 , 0.364 , 1.011 i_exp_cali_t [ 4 ] = 1.675 # Voltage U_exp_cali_t = np . zeros ( 5 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.894 , 0.854 , 0.819 , 0.746 U_exp_cali_t [ 4 ] = 0.678 elif type_fuel_cell == \"EH-31_2.5\" : # at 2.5 bar if voltage_zone == 'full' : # Current density i_exp_cali_t = np . zeros ( 10 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.057 , 0.127 , 0.296 , 0.527 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ], i_exp_cali_t [ 6 ], i_exp_cali_t [ 7 ] = 1.030 , 1.514 , 1.972 , 2.358 i_exp_cali_t [ 8 ], i_exp_cali_t [ 9 ] = 2.691 , 2.988 # Voltage U_exp_cali_t = np . zeros ( 10 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.866 , 0.835 , 0.800 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ], U_exp_cali_t [ 6 ], U_exp_cali_t [ 7 ] = 0.758 , 0.712 , 0.663 , 0.621 U_exp_cali_t [ 8 ], U_exp_cali_t [ 9 ] = 0.575 , 0.524 elif voltage_zone == 'before_voltage_drop' : # Current density i_exp_cali_t = np . zeros ( 6 ) i_exp_cali_t [ 0 ], i_exp_cali_t [ 1 ], i_exp_cali_t [ 2 ], i_exp_cali_t [ 3 ] = 0.057 , 0.127 , 0.296 , 0.527 i_exp_cali_t [ 4 ], i_exp_cali_t [ 5 ] = 1.030 , 1.514 # Voltage U_exp_cali_t = np . zeros ( 6 ) U_exp_cali_t [ 0 ], U_exp_cali_t [ 1 ], U_exp_cali_t [ 2 ], U_exp_cali_t [ 3 ] = 0.900 , 0.866 , 0.835 , 0.800 U_exp_cali_t [ 4 ], U_exp_cali_t [ 5 ] = 0.758 , 0.712 return i_exp_cali_t * 1e4 , U_exp_cali_t # Conversion in A.m-2","title":"pola_exp_values_calibration"},{"location":"functions/calibration/parameter_calibration/","text":"Parameter Calibration This file is designated for executing the undetermined parameters' calibration. Most of it should remain unaltered for regular program usage. Users can select here the fuel cell to calibrate, along with the undetermined parameters to modify, and the parameters for the Genetic Algorithm. The experimental fuel cell data are stored in the files calibration_modules.py and experimental_values.py. The parameters employed for the Genetic Algorithm here have proven to be effective, though not necessarily optimal.","title":"Parameter calibration"},{"location":"functions/calibration/parameter_calibration/#parameter-calibration","text":"This file is designated for executing the undetermined parameters' calibration. Most of it should remain unaltered for regular program usage. Users can select here the fuel cell to calibrate, along with the undetermined parameters to modify, and the parameters for the Genetic Algorithm. The experimental fuel cell data are stored in the files calibration_modules.py and experimental_values.py. The parameters employed for the Genetic Algorithm here have proven to be effective, though not necessarily optimal.","title":"Parameter Calibration"},{"location":"functions/configuration/current_densities/","text":"Current densities This file contains the functions that generate the current densities for the simulation. EIS_current ( t , parameters ) Represents a current density used for creating an EIS curve and Bode diagrams. The current density is first equilibrated at i_EIS A.m-2 from 0 to t0_EIS seconds using a step increase. Then, a sinusoidal perturbation is added to the current density. This perturbation has an amplitude of (ratio_EIS * i_EIS) A.m-2 and a frequency of f[n_inf] Hz. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarization current density at time t. Source code in configuration/current_densities.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def EIS_current ( t , parameters ): \"\"\" Represents a current density used for creating an EIS curve and Bode diagrams. The current density is first equilibrated at i_EIS A.m-2 from 0 to t0_EIS seconds using a step increase. Then, a sinusoidal perturbation is added to the current density. This perturbation has an amplitude of (ratio_EIS * i_EIS) A.m-2 and a frequency of f[n_inf] Hz. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarization current density at time t. \"\"\" # Initialisation i_EIS , ratio_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ] # (A/m\u00b2, ). i_EIS is the current for which a # ratio_EIS perturbation is added. t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = parameters [ 't_EIS' ] # It is the initial # EIS time after stack equilibrium, a list of time parameters which gives the beginning of each frequency # change, the final time, a list of time parameters which gives the estimated time for reaching equilibrium # at each frequency, and a list of time parameters which gives the estimated time for measuring the voltage # response at each frequency. f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = parameters [ 'f_EIS' ] # It is the power of the initial # frequency: f_min_EIS = 10**f_power_min_EIS, the power of the final frequency, the number of frequencies # tested and the number of points calculated per specific period. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested, # ranged logarithmically. # Current density for the EIS curve if t < t0_EIS : delta_t_ini = 3 * 60 # s. It is the required time for elevating i_fc from 0 to i_EIS without starving the cell. i_fc = i_EIS * ( 1.0 + math . tanh ( 4 * ( t - 2 * ( delta_t_ini / 2 )) / delta_t_ini )) / 2 else : n_inf = np . where ( t_new_start_EIS <= t )[ 0 ][ - 1 ] # It is the number of frequency changes which has been made so far. i_disruption = ( ratio_EIS * i_EIS ) * math . cos ( 2 * math . pi * f [ n_inf ] * t ) i_fc = i_EIS + i_disruption return i_fc polarization_current ( t , parameters ) This function represents a current density used for creating a polarization curve. For the first delta_t_ini_step seconds, the current density is set to i_ini A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases by the value of delta_i_pola every delta_t, following C\u221e step current increments, until it reaches i_max_pola. Each increment lasts for delta_t_load_pola seconds. After each increment, there is a pause of delta_t_break_pola seconds to allow the stack to reach equilibrium. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarization current density at time t. Source code in configuration/current_densities.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def polarization_current ( t , parameters ): \"\"\" This function represents a current density used for creating a polarization curve. For the first delta_t_ini_step seconds, the current density is set to i_ini A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases by the value of delta_i_pola every delta_t, following C\u221e step current increments, until it reaches i_max_pola. Each increment lasts for delta_t_load_pola seconds. After each increment, there is a pause of delta_t_break_pola seconds to allow the stack to reach equilibrium. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarization current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] # (s). # Loading time for one step current of the polarisation current density function. delta_t_load_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_load_pola' ] # (s). # Breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_break_pola' ] # (s). # Current density step for the polarisation current density function. delta_i_pola = parameters [ 'pola_current_parameters' ][ 'delta_i_pola' ] # (A.m-2). # Maximum current density for the polarization curve. i_max_pola = parameters [ 'pola_current_parameters' ][ 'i_max_pola' ] # (A.m-2). # Calculation of the time parameters # Time of one step. delta_t = delta_t_load_pola + delta_t_break_pola # (s). # Duration of this polarization curve. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola + 1 ) * delta_t # (s). # Number of loads made for this polarization curve. n = int ( tf / delta_t ) # Current density for the polarization curve i_fc = 0 # A.m-2. Initialisation of the current density. for i in range ( n ): i_fc += delta_i_pola * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola - i * delta_t - ( delta_t_load_pola / 2 )) / ( delta_t_load_pola / 2 ))) / 2 return i_fc polarization_current_for_calibration ( t , parameters ) This function represents a current density used for creating a polarisation curve dedicated to the calibration of a specific fuel cell. The principle is similar to the polarization_current function, but it uses experimental values for the current density load. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarisation current density at time t. Source code in configuration/current_densities.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def polarization_current_for_calibration ( t , parameters ): \"\"\"This function represents a current density used for creating a polarisation curve dedicated to the calibration of a specific fuel cell. The principle is similar to the polarization_current function, but it uses experimental values for the current density load. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarisation current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # Loading time for one step current of the polarisation current density function. delta_t_load_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # Breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). type_fuel_cell , voltage_zone = parameters [ 'type_fuel_cell' ], parameters [ 'voltage_zone' ] # The fuel cell for which the calibration is performed. i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) # (A.m-2, V). It is the experimental # current density and voltage values for the calibration. # Calculation of the time parameters # Time of one step. delta_t = delta_t_load_pola_cali + delta_t_break_pola_cali # (s). # Current density for the polarization curve used for calibration i_fc = 0 # A.m-2. Initialisation of the current density. for e in range ( len ( i_exp_cali_t )): if e == 0 : i_fc += i_exp_cali_t [ 0 ] * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola_cali - ( delta_t_load_pola_cali / 2 )) / ( delta_t_load_pola_cali / 2 ))) / 2 else : delta_i_exp_cali = ( i_exp_cali_t [ e ] - i_exp_cali_t [ e - 1 ]) # (A.m-2). It is the difference between the # current density at the current step and the previous one. i_fc += delta_i_exp_cali * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola_cali - e * delta_t - ( delta_t_load_pola_cali / 2 )) / ( delta_t_load_pola_cali / 2 ))) / 2 return i_fc step_current ( t , parameters ) This function represents a step current density experiment. For the first delta_t_ini_step seconds, the current density is set to i_ini A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases from i_ini to i_step A.m-2 in a step change over delta_t_load seconds. Finally, the current density remains at i_step A.m-2. This is a C\u221e function, which is advantageous for enhancing the overall stability of the results. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The step current density at time t. Source code in configuration/current_densities.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def step_current ( t , parameters ): \"\"\" This function represents a step current density experiment. For the first delta_t_ini_step seconds, the current density is set to i_ini A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases from i_ini to i_step A.m-2 in a step change over delta_t_load seconds. Finally, the current density remains at i_step A.m-2. This is a C\u221e function, which is advantageous for enhancing the overall stability of the results. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The step current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_step = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] # (s). # Initial current density used for the stabilisation of the internal states. i_ini = 1.0e4 # (A.m-2). This is the standard value for the initialisation. # Loading time for the step current density function, from 0 to i_step. delta_t_load_step = parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] # (s). # Current density for the step current density function. i_step = parameters [ 'step_current_parameters' ][ 'i_step' ] # (A.m-2). # Step current density return i_ini * ( 1.0 + math . tanh ( 4 * ( t - ( delta_t_load_step / 2 )) / ( delta_t_load_step / 2 ))) / 2 + \\ ( i_step - i_ini ) * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_step - ( delta_t_load_step / 2 )) / ( delta_t_load_step / 2 ))) / 2","title":"Current densities"},{"location":"functions/configuration/current_densities/#current-densities","text":"This file contains the functions that generate the current densities for the simulation.","title":"Current densities"},{"location":"functions/configuration/current_densities/#configuration.current_densities.EIS_current","text":"Represents a current density used for creating an EIS curve and Bode diagrams. The current density is first equilibrated at i_EIS A.m-2 from 0 to t0_EIS seconds using a step increase. Then, a sinusoidal perturbation is added to the current density. This perturbation has an amplitude of (ratio_EIS * i_EIS) A.m-2 and a frequency of f[n_inf] Hz. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarization current density at time t. Source code in configuration/current_densities.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def EIS_current ( t , parameters ): \"\"\" Represents a current density used for creating an EIS curve and Bode diagrams. The current density is first equilibrated at i_EIS A.m-2 from 0 to t0_EIS seconds using a step increase. Then, a sinusoidal perturbation is added to the current density. This perturbation has an amplitude of (ratio_EIS * i_EIS) A.m-2 and a frequency of f[n_inf] Hz. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarization current density at time t. \"\"\" # Initialisation i_EIS , ratio_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ] # (A/m\u00b2, ). i_EIS is the current for which a # ratio_EIS perturbation is added. t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = parameters [ 't_EIS' ] # It is the initial # EIS time after stack equilibrium, a list of time parameters which gives the beginning of each frequency # change, the final time, a list of time parameters which gives the estimated time for reaching equilibrium # at each frequency, and a list of time parameters which gives the estimated time for measuring the voltage # response at each frequency. f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = parameters [ 'f_EIS' ] # It is the power of the initial # frequency: f_min_EIS = 10**f_power_min_EIS, the power of the final frequency, the number of frequencies # tested and the number of points calculated per specific period. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested, # ranged logarithmically. # Current density for the EIS curve if t < t0_EIS : delta_t_ini = 3 * 60 # s. It is the required time for elevating i_fc from 0 to i_EIS without starving the cell. i_fc = i_EIS * ( 1.0 + math . tanh ( 4 * ( t - 2 * ( delta_t_ini / 2 )) / delta_t_ini )) / 2 else : n_inf = np . where ( t_new_start_EIS <= t )[ 0 ][ - 1 ] # It is the number of frequency changes which has been made so far. i_disruption = ( ratio_EIS * i_EIS ) * math . cos ( 2 * math . pi * f [ n_inf ] * t ) i_fc = i_EIS + i_disruption return i_fc","title":"EIS_current"},{"location":"functions/configuration/current_densities/#configuration.current_densities.polarization_current","text":"This function represents a current density used for creating a polarization curve. For the first delta_t_ini_step seconds, the current density is set to i_ini A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases by the value of delta_i_pola every delta_t, following C\u221e step current increments, until it reaches i_max_pola. Each increment lasts for delta_t_load_pola seconds. After each increment, there is a pause of delta_t_break_pola seconds to allow the stack to reach equilibrium. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarization current density at time t. Source code in configuration/current_densities.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def polarization_current ( t , parameters ): \"\"\" This function represents a current density used for creating a polarization curve. For the first delta_t_ini_step seconds, the current density is set to i_ini A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases by the value of delta_i_pola every delta_t, following C\u221e step current increments, until it reaches i_max_pola. Each increment lasts for delta_t_load_pola seconds. After each increment, there is a pause of delta_t_break_pola seconds to allow the stack to reach equilibrium. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarization current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] # (s). # Loading time for one step current of the polarisation current density function. delta_t_load_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_load_pola' ] # (s). # Breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola = parameters [ 'pola_current_parameters' ][ 'delta_t_break_pola' ] # (s). # Current density step for the polarisation current density function. delta_i_pola = parameters [ 'pola_current_parameters' ][ 'delta_i_pola' ] # (A.m-2). # Maximum current density for the polarization curve. i_max_pola = parameters [ 'pola_current_parameters' ][ 'i_max_pola' ] # (A.m-2). # Calculation of the time parameters # Time of one step. delta_t = delta_t_load_pola + delta_t_break_pola # (s). # Duration of this polarization curve. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola + 1 ) * delta_t # (s). # Number of loads made for this polarization curve. n = int ( tf / delta_t ) # Current density for the polarization curve i_fc = 0 # A.m-2. Initialisation of the current density. for i in range ( n ): i_fc += delta_i_pola * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola - i * delta_t - ( delta_t_load_pola / 2 )) / ( delta_t_load_pola / 2 ))) / 2 return i_fc","title":"polarization_current"},{"location":"functions/configuration/current_densities/#configuration.current_densities.polarization_current_for_calibration","text":"This function represents a current density used for creating a polarisation curve dedicated to the calibration of a specific fuel cell. The principle is similar to the polarization_current function, but it uses experimental values for the current density load. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The polarisation current density at time t. Source code in configuration/current_densities.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def polarization_current_for_calibration ( t , parameters ): \"\"\"This function represents a current density used for creating a polarisation curve dedicated to the calibration of a specific fuel cell. The principle is similar to the polarization_current function, but it uses experimental values for the current density load. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The polarisation current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # Loading time for one step current of the polarisation current density function. delta_t_load_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # Breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). type_fuel_cell , voltage_zone = parameters [ 'type_fuel_cell' ], parameters [ 'voltage_zone' ] # The fuel cell for which the calibration is performed. i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) # (A.m-2, V). It is the experimental # current density and voltage values for the calibration. # Calculation of the time parameters # Time of one step. delta_t = delta_t_load_pola_cali + delta_t_break_pola_cali # (s). # Current density for the polarization curve used for calibration i_fc = 0 # A.m-2. Initialisation of the current density. for e in range ( len ( i_exp_cali_t )): if e == 0 : i_fc += i_exp_cali_t [ 0 ] * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola_cali - ( delta_t_load_pola_cali / 2 )) / ( delta_t_load_pola_cali / 2 ))) / 2 else : delta_i_exp_cali = ( i_exp_cali_t [ e ] - i_exp_cali_t [ e - 1 ]) # (A.m-2). It is the difference between the # current density at the current step and the previous one. i_fc += delta_i_exp_cali * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_pola_cali - e * delta_t - ( delta_t_load_pola_cali / 2 )) / ( delta_t_load_pola_cali / 2 ))) / 2 return i_fc","title":"polarization_current_for_calibration"},{"location":"functions/configuration/current_densities/#configuration.current_densities.step_current","text":"This function represents a step current density experiment. For the first delta_t_ini_step seconds, the current density is set to i_ini A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases from i_ini to i_step A.m-2 in a step change over delta_t_load seconds. Finally, the current density remains at i_step A.m-2. This is a C\u221e function, which is advantageous for enhancing the overall stability of the results. Parameters: t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: i_fc : float The step current density at time t. Source code in configuration/current_densities.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def step_current ( t , parameters ): \"\"\" This function represents a step current density experiment. For the first delta_t_ini_step seconds, the current density is set to i_ini A.m-2 to allow the internal states of the fuel cell to stabilise. Then, the current density increases from i_ini to i_step A.m-2 in a step change over delta_t_load seconds. Finally, the current density remains at i_step A.m-2. This is a C\u221e function, which is advantageous for enhancing the overall stability of the results. Parameters: ---------- t : float Time in seconds. parameters : dict A dictionary containing the parameters for the current density function. Returns: ------- i_fc : float The step current density at time t. \"\"\" # Extraction of the parameters # Initial time at zero current density for the stabilisation of the internal states. delta_t_ini_step = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] # (s). # Initial current density used for the stabilisation of the internal states. i_ini = 1.0e4 # (A.m-2). This is the standard value for the initialisation. # Loading time for the step current density function, from 0 to i_step. delta_t_load_step = parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] # (s). # Current density for the step current density function. i_step = parameters [ 'step_current_parameters' ][ 'i_step' ] # (A.m-2). # Step current density return i_ini * ( 1.0 + math . tanh ( 4 * ( t - ( delta_t_load_step / 2 )) / ( delta_t_load_step / 2 ))) / 2 + \\ ( i_step - i_ini ) * ( 1.0 + math . tanh ( 4 * ( t - delta_t_ini_step - ( delta_t_load_step / 2 )) / ( delta_t_load_step / 2 ))) / 2","title":"step_current"},{"location":"functions/configuration/settings/","text":"Settings This file is used to set the parameters of the fuel cell system. calculate_computing_parameters ( step_current_parameters , Hgdl , Hmpl , Hacl ) This function is used to set the computing parameters of the fuel cell system. Parameters: step_current_parameters ( dict ) \u2013 Parameters for the step current density function. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in meters. Hmpl ( float ) \u2013 Thickness of the microporous layer in meters. Hacl ( float ) \u2013 Thickness of the anode catalyst layer in meters. Returns: nb_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. nb_mpl ( int ) \u2013 Number of model nodes placed inside each MPL. nb_tl ( int ) \u2013 Number of model nodes placed inside each transition layer. t_purge ( tuple ) \u2013 Time parameters for purging the system. It is a tuple containing the purge time 'purge_time' in seconds, and the time between two purges 'delta_purge' in seconds. delta_t_dyn_step : float rtol ( float ) \u2013 Relative tolerance for the system of ODEs solver. atol ( float ) \u2013 Absolute tolerance for the system of ODEs solver. step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. Source code in configuration/settings.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def calculate_computing_parameters ( step_current_parameters , Hgdl , Hmpl , Hacl ): \"\"\"This function is used to set the computing parameters of the fuel cell system. Parameters ---------- step_current_parameters : dict Parameters for the step current density function. Hgdl : float Thickness of the gas diffusion layer in meters. Hmpl : float Thickness of the microporous layer in meters. Hacl : float Thickness of the anode catalyst layer in meters. Returns ------- nb_gdl : int Number of model nodes placed inside each GDL. nb_mpl : int Number of model nodes placed inside each MPL. nb_tl : int Number of model nodes placed inside each transition layer. t_purge : tuple Time parameters for purging the system. It is a tuple containing the purge time 'purge_time' in seconds, and the time between two purges 'delta_purge' in seconds. delta_t_dyn_step : float rtol : float Relative tolerance for the system of ODEs solver. atol : float Absolute tolerance for the system of ODEs solver. step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. \"\"\" # Calculation of the minimum thickness of the model node H_node_min = Hacl # m. It is the minimum thickness of the model node. # Setting the number of model points placed inside each layer: nb_gc = 1 # It is the number of model points placed inside each gas channel. nb_gdl = max ( 1 , int ( Hgdl / H_node_min / 4 )) # It is the number of model points placed inside each GDL. nb_mpl = max ( 1 , int ( Hmpl / H_node_min / 3 )) # It is the number of model points placed inside each MPL. print ( 'nb_gdl: ' , nb_gdl , ' nb_mpl: ' , nb_mpl ) # Setting the purging parameters of the system and the dynamic display of the step current density function: t_purge = 0.6 , 15 # (s, s). It is the time parameters for purging the system. delta_t_dyn_step = 2 * 60 # (s). Time for dynamic display of the step current density function. # Setting the tolerances for the system of ODEs solver: rtol = 1e-3 # Relative tolerance for the system of ODEs solver. atol = 1e-6 # Absolute tolerance for the system of ODEs solver. # Update the step current parameters. step_current_parameters [ 'delta_t_dyn_step' ] = delta_t_dyn_step return nb_gc , nb_gdl , nb_mpl , t_purge , rtol , atol calculate_current_density_parameters ( type_current = None ) This function is used to set the parameters of the current density which is imposed to the fuel cell system. Parameters: type_current ( str , default: None ) \u2013 Type of current density which is imposed to the fuel cell system. It can be \"step\", \"polarization\" or \"EIS\". Returns: step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters ( dict ) \u2013 Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS ( float ) \u2013 Parameters for the EIS curve. It is the current for which a perturbation is added. ratio_EIS ( float ) \u2013 Parameters for the EIS curve. It is the ratio of the current for which a perturbation is added. f_EIS ( tuple ) \u2013 Frequency parameters for the EIS_current density function. It is a tuple containing the power of the initial frequency 'f_power_min_EIS' (f_min_EIS = 10**f_power_min_EIS), the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS', and the number of points calculated per specific period 'nb_points_EIS'. t_EIS ( tuple ) \u2013 Time parameters for the EIS_current density function. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS' in seconds, a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS' in seconds, the final time 'tf_EIS' in seconds, a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS' in seconds, and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS' in seconds. current_density ( function, optional. ) \u2013 Current density function. Source code in configuration/settings.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def calculate_current_density_parameters ( type_current = None ): \"\"\"This function is used to set the parameters of the current density which is imposed to the fuel cell system. Parameters ---------- type_current : str Type of current density which is imposed to the fuel cell system. It can be \"step\", \"polarization\" or \"EIS\". Returns ------- step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS : float Parameters for the EIS curve. It is the current for which a perturbation is added. ratio_EIS : float Parameters for the EIS curve. It is the ratio of the current for which a perturbation is added. f_EIS : tuple Frequency parameters for the EIS_current density function. It is a tuple containing the power of the initial frequency 'f_power_min_EIS' (f_min_EIS = 10**f_power_min_EIS), the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS', and the number of points calculated per specific period 'nb_points_EIS'. t_EIS : tuple Time parameters for the EIS_current density function. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS' in seconds, a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS' in seconds, the final time 'tf_EIS' in seconds, a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS' in seconds, and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS' in seconds. current_density : function, optional. Current density function. \"\"\" # Setting the parameters of the step current density function delta_t_ini_step = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states (standard value). delta_t_load_step = 30 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 15 * 60 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 2.0e4 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } # Setting the parameters of the polarization current density function delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. delta_t_ini_pola = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. v_load_pola = 0.01 # (A.m-2.s-1). Loading rate for one step current of the polarisation current density function. delta_t_load_pola = delta_i_pola / v_load_pola # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_parameters = { 'delta_i_pola' : delta_i_pola , 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola } # Setting the parameters of the polarization for calibration current density function delta_t_ini_pola_cali = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 10 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } # Setting the parameters of the EIS current density function i_EIS , ratio_EIS = 1.0e4 , 5 / 100 # (A/m\u00b2, ). Parameters for the EIS curve. f_EIS = - 3 , 5 , 90 , 50 # Frequency parameters for the EIS_current density function. t_EIS = EIS_parameters ( f_EIS ) # Time parameters for the EIS_current density function. # Setting the current density function: if type_current == \"step\" : current_density = step_current elif type_current == \"polarization\" : current_density = polarization_current elif type_current == \"polarization_for_cali\" : current_density = polarization_current_for_calibration elif type_current == \"EIS\" : current_density = EIS_current elif type_current is None : current_density = None # No current density function is set. else : raise ValueError ( 'You have to specify a type_current which is on the list.' ) return ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) calculate_operating_inputs ( pola_current_parameters , type_fuel_cell , voltage_zone ) This function is used to set the operating inputs of the fuel cell system. Parameters: pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density function. type_fuel_cell ( str ) \u2013 Type of fuel cell system. voltage_zone ( str ) \u2013 Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. Source code in configuration/settings.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def calculate_operating_inputs ( pola_current_parameters , type_fuel_cell , voltage_zone ): \"\"\"This function is used to set the operating inputs of the fuel cell system. Parameters ---------- pola_current_parameters : dict Parameters for the polarization current density function. type_fuel_cell : str Type of fuel cell system. voltage_zone : str Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. \"\"\" if type_fuel_cell == \"manual_setup\" : # Setup which are not stored in \"stored_operating_inputs\". T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. i_max_pola = 3.0e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell is None : T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , i_max_pola = None , None , None , None , None , None , None , None , None else : # Stored setup in \"stored_operating_inputs\". T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , i_max_pola = stored_operating_inputs ( type_fuel_cell , voltage_zone ) pola_current_parameters [ 'i_max_pola' ] = i_max_pola # Update the maximum current density for the polarization curve. return T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , pola_current_parameters calculate_physical_parameters ( type_fuel_cell ) This function is used to set the physical parameters of the fuel cell system. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell system. Returns: Hacl ( float ) \u2013 Thickness of the anode catalyst layer in meters. Hacl ( float ) \u2013 Thickness of the cathode catalyst layer in meters. epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the catalyst layer. Hmem ( float ) \u2013 Thickness of the membrane in meters. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in meters. epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_c ( float ) \u2013 Compression ratio of the GDL. Hmpl ( float ) \u2013 Thickness of the microporous layer in meters. epsilon_mpl ( float ) \u2013 Porosity of the microporous layer. Hagc ( float ) \u2013 Thickness of the anode gas channel in meters. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in meters. Wagc ( float ) \u2013 Width of the anode gas channel in meters. Wcgc ( float ) \u2013 Width of the cathode gas channel in meters. Lgc ( float ) \u2013 Length of the gas channel in meters. Aact ( float ) \u2013 Active area of the catalyst layer in meters squared. nb_cell ( int ) \u2013 Number of cell in the stack. A_T_a ( float ) \u2013 Exhaust anode manifold throttle area in m\u00b2. A_T_c ( float ) \u2013 Exhaust cathode manifold throttle area in m\u00b2. Vasm ( float ) \u2013 Supply manifold volume at the anode in m\u00b3. Vcsm ( float ) \u2013 Supply manifold volume at the cathode in m\u00b3. Vaem ( float ) \u2013 Exhaust manifold volume at the anode in m\u00b3. Vcem ( float ) \u2013 Exhaust manifold volume at the cathode in m\u00b3. V_endplate_a ( float ) \u2013 Anode endplate volume in m\u00b3. V_endplate_c ( float ) \u2013 Cathode endplate volume in m\u00b3. V_man_agc ( float ) \u2013 Volume connecting the anode manifold to the gas channel in m\u00b3. V_man_cgc ( float ) \u2013 Volume connecting the cathode manifold to the gas channel in m\u00b3. e ( float ) \u2013 Capillary exponent. i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode in A.m-2. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c ( float ) \u2013 Overpotential correction exponent. a_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of slim function. b_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the intercept of slim function. a_switch ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl ( float ) \u2013 Volumetric double layer capacitance in F.m-3. Source code in configuration/settings.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def calculate_physical_parameters ( type_fuel_cell ): \"\"\"This function is used to set the physical parameters of the fuel cell system. Parameters ---------- type_fuel_cell : str Type of fuel cell system. Returns ------- Hacl : float Thickness of the anode catalyst layer in meters. Hacl : float Thickness of the cathode catalyst layer in meters. epsilon_mc : float Volume fraction of ionomer in the catalyst layer. Hmem : float Thickness of the membrane in meters. Hgdl : float Thickness of the gas diffusion layer in meters. epsilon_gdl : float Anode/cathode GDL porosity. epsilon_c : float Compression ratio of the GDL. Hmpl : float Thickness of the microporous layer in meters. epsilon_mpl : float Porosity of the microporous layer. Hagc : float Thickness of the anode gas channel in meters. Hcgc : float Thickness of the cathode gas channel in meters. Wagc : float Width of the anode gas channel in meters. Wcgc : float Width of the cathode gas channel in meters. Lgc : float Length of the gas channel in meters. Aact : float Active area of the catalyst layer in meters squared. nb_cell : int Number of cell in the stack. A_T_a : float Exhaust anode manifold throttle area in m\u00b2. A_T_c : float Exhaust cathode manifold throttle area in m\u00b2. Vasm : float Supply manifold volume at the anode in m\u00b3. Vcsm : float Supply manifold volume at the cathode in m\u00b3. Vaem : float Exhaust manifold volume at the anode in m\u00b3. Vcem : float Exhaust manifold volume at the cathode in m\u00b3. V_endplate_a : float Anode endplate volume in m\u00b3. V_endplate_c : float Cathode endplate volume in m\u00b3. V_man_agc : float Volume connecting the anode manifold to the gas channel in m\u00b3. V_man_cgc : float Volume connecting the cathode manifold to the gas channel in m\u00b3. e : float Capillary exponent. i0_c_ref : float Reference exchange current density at the cathode in A.m-2. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c : float Overpotential correction exponent. a_slim : float One of the limit liquid saturation coefficients: the slop of slim function. b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function. a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl : float Volumetric double layer capacitance in F.m-3. \"\"\" if type_fuel_cell == \"manual_setup\" : # Setup which are not stored in \"stored_physical_parameters\". # Fuel cell physical parameters: \ud835\udf14 (which are not controllable by the system) # Global Aact = 279.72e-4 # m\u00b2. It is the MEA active area. nb_cell = 1 # . It is the number of cell in the stack. # Catalyst layer Hacl = 8.089e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_mc = 0.3949198274842546 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 2e-5 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 2e-4 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.7011156494971454 # It is the anode/cathode GDL porosity. epsilon_c = 0.27052745219052654 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 3e-5 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. # Gas channel Hagc = 5e-4 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Wagc = 4.5e-4 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 144e-3 # m. It is the length of one channel in the bipolar plate. nb_channel_in_gc = 67 # . It is the number of channels in the bipolar plate. Ldist = 5e-2 # m. It is the estimated length of the distributor, which is the volume between the gas channel and the manifold. # Auxiliaries Lm = 25.8e-3 # m. It is the length of the manifold. L_endplate = 46.8e-3 # m. It is the length of the endplate. A_T_a = 11.8e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = A_T_a # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = 7000e-6 , 7000e-6 # m3. It is the supply manifold volume. Vaem , Vcem = 2400e-6 , 2400e-6 # m-3. It is the exhaust manifold volume. V_endplate_a = 33.6e-6 # m3. It is the anode endplate volume. V_endplate_c = 86.6e-6 # m3. It is the cathode endplate volume. # Interaction parameters between water and PEMFC structure e = 5.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # \u03a9.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.43 # A.m-2. It is the dry reference exchange current density at the cathode. i0_l_c_ref = 1.0e3 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 29.793535549174077 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.6136446641573106 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.0555312850726664 , 0.10514269908118055 , 0.6365424991141914 # It is the limit # liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. else : # Stored setup in \"stored_physical_parameters\". ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , nb_channel_in_gc , Ldist , Lm , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , Aact , nb_cell , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl ) = stored_physical_parameters ( type_fuel_cell ) return ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , nb_channel_in_gc , Ldist , Lm , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , Aact , nb_cell , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl )","title":"Settings"},{"location":"functions/configuration/settings/#settings","text":"This file is used to set the parameters of the fuel cell system.","title":"Settings"},{"location":"functions/configuration/settings/#configuration.settings.calculate_computing_parameters","text":"This function is used to set the computing parameters of the fuel cell system. Parameters: step_current_parameters ( dict ) \u2013 Parameters for the step current density function. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in meters. Hmpl ( float ) \u2013 Thickness of the microporous layer in meters. Hacl ( float ) \u2013 Thickness of the anode catalyst layer in meters. Returns: nb_gdl ( int ) \u2013 Number of model nodes placed inside each GDL. nb_mpl ( int ) \u2013 Number of model nodes placed inside each MPL. nb_tl ( int ) \u2013 Number of model nodes placed inside each transition layer. t_purge ( tuple ) \u2013 Time parameters for purging the system. It is a tuple containing the purge time 'purge_time' in seconds, and the time between two purges 'delta_purge' in seconds. delta_t_dyn_step : float rtol ( float ) \u2013 Relative tolerance for the system of ODEs solver. atol ( float ) \u2013 Absolute tolerance for the system of ODEs solver. step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. Source code in configuration/settings.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def calculate_computing_parameters ( step_current_parameters , Hgdl , Hmpl , Hacl ): \"\"\"This function is used to set the computing parameters of the fuel cell system. Parameters ---------- step_current_parameters : dict Parameters for the step current density function. Hgdl : float Thickness of the gas diffusion layer in meters. Hmpl : float Thickness of the microporous layer in meters. Hacl : float Thickness of the anode catalyst layer in meters. Returns ------- nb_gdl : int Number of model nodes placed inside each GDL. nb_mpl : int Number of model nodes placed inside each MPL. nb_tl : int Number of model nodes placed inside each transition layer. t_purge : tuple Time parameters for purging the system. It is a tuple containing the purge time 'purge_time' in seconds, and the time between two purges 'delta_purge' in seconds. delta_t_dyn_step : float rtol : float Relative tolerance for the system of ODEs solver. atol : float Absolute tolerance for the system of ODEs solver. step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. \"\"\" # Calculation of the minimum thickness of the model node H_node_min = Hacl # m. It is the minimum thickness of the model node. # Setting the number of model points placed inside each layer: nb_gc = 1 # It is the number of model points placed inside each gas channel. nb_gdl = max ( 1 , int ( Hgdl / H_node_min / 4 )) # It is the number of model points placed inside each GDL. nb_mpl = max ( 1 , int ( Hmpl / H_node_min / 3 )) # It is the number of model points placed inside each MPL. print ( 'nb_gdl: ' , nb_gdl , ' nb_mpl: ' , nb_mpl ) # Setting the purging parameters of the system and the dynamic display of the step current density function: t_purge = 0.6 , 15 # (s, s). It is the time parameters for purging the system. delta_t_dyn_step = 2 * 60 # (s). Time for dynamic display of the step current density function. # Setting the tolerances for the system of ODEs solver: rtol = 1e-3 # Relative tolerance for the system of ODEs solver. atol = 1e-6 # Absolute tolerance for the system of ODEs solver. # Update the step current parameters. step_current_parameters [ 'delta_t_dyn_step' ] = delta_t_dyn_step return nb_gc , nb_gdl , nb_mpl , t_purge , rtol , atol","title":"calculate_computing_parameters"},{"location":"functions/configuration/settings/#configuration.settings.calculate_current_density_parameters","text":"This function is used to set the parameters of the current density which is imposed to the fuel cell system. Parameters: type_current ( str , default: None ) \u2013 Type of current density which is imposed to the fuel cell system. It can be \"step\", \"polarization\" or \"EIS\". Returns: step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters ( dict ) \u2013 Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS ( float ) \u2013 Parameters for the EIS curve. It is the current for which a perturbation is added. ratio_EIS ( float ) \u2013 Parameters for the EIS curve. It is the ratio of the current for which a perturbation is added. f_EIS ( tuple ) \u2013 Frequency parameters for the EIS_current density function. It is a tuple containing the power of the initial frequency 'f_power_min_EIS' (f_min_EIS = 10**f_power_min_EIS), the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS', and the number of points calculated per specific period 'nb_points_EIS'. t_EIS ( tuple ) \u2013 Time parameters for the EIS_current density function. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS' in seconds, a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS' in seconds, the final time 'tf_EIS' in seconds, a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS' in seconds, and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS' in seconds. current_density ( function, optional. ) \u2013 Current density function. Source code in configuration/settings.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def calculate_current_density_parameters ( type_current = None ): \"\"\"This function is used to set the parameters of the current density which is imposed to the fuel cell system. Parameters ---------- type_current : str Type of current density which is imposed to the fuel cell system. It can be \"step\", \"polarization\" or \"EIS\". Returns ------- step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS : float Parameters for the EIS curve. It is the current for which a perturbation is added. ratio_EIS : float Parameters for the EIS curve. It is the ratio of the current for which a perturbation is added. f_EIS : tuple Frequency parameters for the EIS_current density function. It is a tuple containing the power of the initial frequency 'f_power_min_EIS' (f_min_EIS = 10**f_power_min_EIS), the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS', and the number of points calculated per specific period 'nb_points_EIS'. t_EIS : tuple Time parameters for the EIS_current density function. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS' in seconds, a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS' in seconds, the final time 'tf_EIS' in seconds, a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS' in seconds, and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS' in seconds. current_density : function, optional. Current density function. \"\"\" # Setting the parameters of the step current density function delta_t_ini_step = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states (standard value). delta_t_load_step = 30 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 15 * 60 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 2.0e4 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } # Setting the parameters of the polarization current density function delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. delta_t_ini_pola = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. v_load_pola = 0.01 # (A.m-2.s-1). Loading rate for one step current of the polarisation current density function. delta_t_load_pola = delta_i_pola / v_load_pola # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_parameters = { 'delta_i_pola' : delta_i_pola , 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola } # Setting the parameters of the polarization for calibration current density function delta_t_ini_pola_cali = 120 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 10 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } # Setting the parameters of the EIS current density function i_EIS , ratio_EIS = 1.0e4 , 5 / 100 # (A/m\u00b2, ). Parameters for the EIS curve. f_EIS = - 3 , 5 , 90 , 50 # Frequency parameters for the EIS_current density function. t_EIS = EIS_parameters ( f_EIS ) # Time parameters for the EIS_current density function. # Setting the current density function: if type_current == \"step\" : current_density = step_current elif type_current == \"polarization\" : current_density = polarization_current elif type_current == \"polarization_for_cali\" : current_density = polarization_current_for_calibration elif type_current == \"EIS\" : current_density = EIS_current elif type_current is None : current_density = None # No current density function is set. else : raise ValueError ( 'You have to specify a type_current which is on the list.' ) return ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density )","title":"calculate_current_density_parameters"},{"location":"functions/configuration/settings/#configuration.settings.calculate_operating_inputs","text":"This function is used to set the operating inputs of the fuel cell system. Parameters: pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density function. type_fuel_cell ( str ) \u2013 Type of fuel cell system. voltage_zone ( str ) \u2013 Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. Source code in configuration/settings.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def calculate_operating_inputs ( pola_current_parameters , type_fuel_cell , voltage_zone ): \"\"\"This function is used to set the operating inputs of the fuel cell system. Parameters ---------- pola_current_parameters : dict Parameters for the polarization current density function. type_fuel_cell : str Type of fuel cell system. voltage_zone : str Zone of the polarization curve which is considered. It can be 'full' or 'before_voltage_drop'. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. \"\"\" if type_fuel_cell == \"manual_setup\" : # Setup which are not stored in \"stored_operating_inputs\". T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. i_max_pola = 3.0e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell is None : T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , i_max_pola = None , None , None , None , None , None , None , None , None else : # Stored setup in \"stored_operating_inputs\". T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , i_max_pola = stored_operating_inputs ( type_fuel_cell , voltage_zone ) pola_current_parameters [ 'i_max_pola' ] = i_max_pola # Update the maximum current density for the polarization curve. return T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , pola_current_parameters","title":"calculate_operating_inputs"},{"location":"functions/configuration/settings/#configuration.settings.calculate_physical_parameters","text":"This function is used to set the physical parameters of the fuel cell system. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell system. Returns: Hacl ( float ) \u2013 Thickness of the anode catalyst layer in meters. Hacl ( float ) \u2013 Thickness of the cathode catalyst layer in meters. epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the catalyst layer. Hmem ( float ) \u2013 Thickness of the membrane in meters. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in meters. epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_c ( float ) \u2013 Compression ratio of the GDL. Hmpl ( float ) \u2013 Thickness of the microporous layer in meters. epsilon_mpl ( float ) \u2013 Porosity of the microporous layer. Hagc ( float ) \u2013 Thickness of the anode gas channel in meters. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in meters. Wagc ( float ) \u2013 Width of the anode gas channel in meters. Wcgc ( float ) \u2013 Width of the cathode gas channel in meters. Lgc ( float ) \u2013 Length of the gas channel in meters. Aact ( float ) \u2013 Active area of the catalyst layer in meters squared. nb_cell ( int ) \u2013 Number of cell in the stack. A_T_a ( float ) \u2013 Exhaust anode manifold throttle area in m\u00b2. A_T_c ( float ) \u2013 Exhaust cathode manifold throttle area in m\u00b2. Vasm ( float ) \u2013 Supply manifold volume at the anode in m\u00b3. Vcsm ( float ) \u2013 Supply manifold volume at the cathode in m\u00b3. Vaem ( float ) \u2013 Exhaust manifold volume at the anode in m\u00b3. Vcem ( float ) \u2013 Exhaust manifold volume at the cathode in m\u00b3. V_endplate_a ( float ) \u2013 Anode endplate volume in m\u00b3. V_endplate_c ( float ) \u2013 Cathode endplate volume in m\u00b3. V_man_agc ( float ) \u2013 Volume connecting the anode manifold to the gas channel in m\u00b3. V_man_cgc ( float ) \u2013 Volume connecting the cathode manifold to the gas channel in m\u00b3. e ( float ) \u2013 Capillary exponent. i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode in A.m-2. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c ( float ) \u2013 Overpotential correction exponent. a_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of slim function. b_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the intercept of slim function. a_switch ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl ( float ) \u2013 Volumetric double layer capacitance in F.m-3. Source code in configuration/settings.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def calculate_physical_parameters ( type_fuel_cell ): \"\"\"This function is used to set the physical parameters of the fuel cell system. Parameters ---------- type_fuel_cell : str Type of fuel cell system. Returns ------- Hacl : float Thickness of the anode catalyst layer in meters. Hacl : float Thickness of the cathode catalyst layer in meters. epsilon_mc : float Volume fraction of ionomer in the catalyst layer. Hmem : float Thickness of the membrane in meters. Hgdl : float Thickness of the gas diffusion layer in meters. epsilon_gdl : float Anode/cathode GDL porosity. epsilon_c : float Compression ratio of the GDL. Hmpl : float Thickness of the microporous layer in meters. epsilon_mpl : float Porosity of the microporous layer. Hagc : float Thickness of the anode gas channel in meters. Hcgc : float Thickness of the cathode gas channel in meters. Wagc : float Width of the anode gas channel in meters. Wcgc : float Width of the cathode gas channel in meters. Lgc : float Length of the gas channel in meters. Aact : float Active area of the catalyst layer in meters squared. nb_cell : int Number of cell in the stack. A_T_a : float Exhaust anode manifold throttle area in m\u00b2. A_T_c : float Exhaust cathode manifold throttle area in m\u00b2. Vasm : float Supply manifold volume at the anode in m\u00b3. Vcsm : float Supply manifold volume at the cathode in m\u00b3. Vaem : float Exhaust manifold volume at the anode in m\u00b3. Vcem : float Exhaust manifold volume at the cathode in m\u00b3. V_endplate_a : float Anode endplate volume in m\u00b3. V_endplate_c : float Cathode endplate volume in m\u00b3. V_man_agc : float Volume connecting the anode manifold to the gas channel in m\u00b3. V_man_cgc : float Volume connecting the cathode manifold to the gas channel in m\u00b3. e : float Capillary exponent. i0_c_ref : float Reference exchange current density at the cathode in A.m-2. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c : float Overpotential correction exponent. a_slim : float One of the limit liquid saturation coefficients: the slop of slim function. b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function. a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl : float Volumetric double layer capacitance in F.m-3. \"\"\" if type_fuel_cell == \"manual_setup\" : # Setup which are not stored in \"stored_physical_parameters\". # Fuel cell physical parameters: \ud835\udf14 (which are not controllable by the system) # Global Aact = 279.72e-4 # m\u00b2. It is the MEA active area. nb_cell = 1 # . It is the number of cell in the stack. # Catalyst layer Hacl = 8.089e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_mc = 0.3949198274842546 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 2e-5 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 2e-4 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.7011156494971454 # It is the anode/cathode GDL porosity. epsilon_c = 0.27052745219052654 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 3e-5 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. # Gas channel Hagc = 5e-4 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Wagc = 4.5e-4 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 144e-3 # m. It is the length of one channel in the bipolar plate. nb_channel_in_gc = 67 # . It is the number of channels in the bipolar plate. Ldist = 5e-2 # m. It is the estimated length of the distributor, which is the volume between the gas channel and the manifold. # Auxiliaries Lm = 25.8e-3 # m. It is the length of the manifold. L_endplate = 46.8e-3 # m. It is the length of the endplate. A_T_a = 11.8e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = A_T_a # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = 7000e-6 , 7000e-6 # m3. It is the supply manifold volume. Vaem , Vcem = 2400e-6 , 2400e-6 # m-3. It is the exhaust manifold volume. V_endplate_a = 33.6e-6 # m3. It is the anode endplate volume. V_endplate_c = 86.6e-6 # m3. It is the cathode endplate volume. # Interaction parameters between water and PEMFC structure e = 5.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # \u03a9.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.43 # A.m-2. It is the dry reference exchange current density at the cathode. i0_l_c_ref = 1.0e3 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 29.793535549174077 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.6136446641573106 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.0555312850726664 , 0.10514269908118055 , 0.6365424991141914 # It is the limit # liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. else : # Stored setup in \"stored_physical_parameters\". ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , nb_channel_in_gc , Ldist , Lm , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , Aact , nb_cell , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl ) = stored_physical_parameters ( type_fuel_cell ) return ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , nb_channel_in_gc , Ldist , Lm , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , Aact , nb_cell , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl )","title":"calculate_physical_parameters"},{"location":"functions/model/AlphaPEM/","text":"AlphaPEM Objectives: Create an open-source software package to simulate the PEM fuel cell for control system applications. Authors: Rapha\u00ebl GASS, Zhongliang LI, Rachid OUTBIB, Samir JEMEI and Daniel HISSEL. This file describes the AlphaPEM class, which is a PEM fuel cell system simulator. The model is one-dimensional, dynamic, biphasic, and isothermal. It has been published in the following articles: - Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a - Gass et al 2024 SSRN http://dx.doi.org/10.2139/ssrn.4812343 AlphaPEM Source code in model/AlphaPEM.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 class AlphaPEM : def __init__ ( self , operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ): \"\"\"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - n_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - n_gdl : int Number of points considered in the GDL (computing parameter). - n_mpl : int Number of points considered in the MPL (computing parameter). - n_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values : list, optional Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval : list, optional Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. \"\"\" # Initialize the operating inputs and parameters dictionaries. self . operating_inputs = operating_inputs self . current_parameters = current_parameters self . accessible_physical_parameters = accessible_physical_parameters self . undetermined_physical_parameters = undetermined_physical_parameters self . computing_parameters = computing_parameters self . parameters = { ** self . current_parameters , ** self . accessible_physical_parameters , ** self . undetermined_physical_parameters , ** self . computing_parameters } if self . operating_inputs [ 'Pa_des' ] < Pext or self . operating_inputs [ 'Pc_des' ] < Pext : raise ValueError ( 'The desired pressure is too low. It cannot be lower than the pressure outside the stack.' ) # Initialize the variables' dictionary. self . solver_variable_names = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_acl' , 'C_v_ccl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_acl' , 's_ccl' , 's_cmpl' , 's_cgdl' , 'lambda_acl' , 'lambda_mem' , 'lambda_ccl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_H2_acl' , 'C_O2_ccl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2_agc' , 'C_N2_cgc' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_acl' , 'T_mem' , 'T_ccl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' , 'eta_c' ] if self . parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" or \\ self . parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_anodic_recirculation\" : self . solver_variable_names . extend ([ 'Pasm' , 'Paem' , 'Pcsm' , 'Pcem' , 'Phi_asm' , 'Phi_aem' , 'Phi_csm' , 'Phi_cem' , 'Wcp' , 'Wa_inj' , 'Wc_inj' , 'Abp_a' , 'Abp_c' ]) self . solver_variable_names_extension () # Several points are considered in each GC, GDL and MPL. This must be # inserted into the solver_variable_names. self . all_variable_names = self . solver_variable_names + [ 't' , 'Ucell' , 'v_a_in' , 'v_c_in' , 'Pa_in' , 'Pc_in' ] + \\ [ 'Phi_a_des' , 'Phi_c_des' ] self . variables = { key : [] for key in self . all_variable_names } # Initialize the control_variables dictionary. self . control_variables = { 't_control_Phi' : 0 , 'Phi_a_des' : self . operating_inputs [ 'Phi_a_des' ], 'Phi_c_des' : self . operating_inputs [ 'Phi_c_des' ]} # Temporary action: simulations with auxiliaries are in reconstruction. if self . parameters [ 'type_auxiliary' ] != \"no_auxiliary\" : self . parameters [ 'type_auxiliary' ] == \"no_auxiliary\" print ( \"Auxiliary considerations are temporarily removed, as they require reconstruction.\" ) # Create the dynamic evolution. # Create time intervals if time_interval is not None : # Initial time interval may be given to the Simulator. self . time_interval = time_interval else : # If not, it is automatically generated. self . time_interval = self . _create_time_interval () # Create the initial variable values if initial_variable_values is not None : # Initial variable values may be given to the Simulator. self . initial_variable_values = initial_variable_values else : # If not, they are generated considering an equilibrium at the operating inputs without current. self . initial_variable_values = self . _create_initial_variable_values () # Resolution of the system of differential equations. event_negative . terminal = True # Integration is stopped if one of the crucial variables becomes negative. self . sol = solve_ivp ( dydt , self . time_interval , self . initial_variable_values , method = 'BDF' , rtol = self . parameters [ 'rtol' ], atol = self . parameters [ 'atol' ], events = event_negative , args = ( self . operating_inputs , self . parameters , self . solver_variable_names , self . control_variables )) # Recover the variable values calculated by the solver into the dictionary. self . _recovery () # Calculate the cell voltage after computing the internal states of the cell. self . variables [ \"Ucell\" ] . extend ( calculate_cell_voltage ( self . variables , self . operating_inputs , self . parameters )) def solver_variable_names_extension ( self ): \"\"\"Several points are considered in each GDL and must be inserted into the solver_variable_names. \"\"\" new_points_location = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_cmpl' , 's_cgdl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2_agc' , 'C_N2_cgc' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' ] for variable in new_points_location : index = self . solver_variable_names . index ( variable ) # Delete the previous points self . solver_variable_names . pop ( index ) # Increase the number of points if variable . endswith ( 'gc' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_gc' ] + 1 )] if variable . endswith ( 'gdl' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_gdl' ] + 1 )] elif variable . endswith ( 'mpl' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_mpl' ] + 1 )] def _create_time_interval ( self ): \"\"\"Calculate the time intervals for numerical resolution, according to the current chosen, if it is not provided. Returns ------- list Time interval for numerical resolution. It is used when initial_variable_values == None. \"\"\" # Extraction of the parameters step_current_parameters = self . parameters [ 'step_current_parameters' ] pola_current_parameters = self . parameters [ 'pola_current_parameters' ] pola_current_for_cali_parameters = self . parameters [ 'pola_current_for_cali_parameters' ] type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] voltage_zone = self . parameters [ 'voltage_zone' ] # Recovery of the good time interval if type_current == \"step\" : t0_interval = 0 # s. tf_interval = step_current_parameters [ 'delta_t_ini_step' ] + step_current_parameters [ 'delta_t_load_step' ] + \\ step_current_parameters [ 'delta_t_break_step' ] # s. elif type_current == \"polarization\" : # Extraction of the parameters delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] # (s). delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] # (s). delta_i_pola = pola_current_parameters [ 'delta_i_pola' ] # (A.m-2).Wccp_des, i_max_pola = pola_current_parameters [ 'i_max_pola' ] # (A.m-2). # Calculation t0_interval = 0 # s. tf_interval = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * ( delta_t_load_pola + delta_t_break_pola ) elif type_current == \"polarization_for_cali\" : # Extraction of the parameters delta_t_ini_pola_cali = pola_current_for_cali_parameters [ 'delta_t_ini_pola_cali' ] # (s). delta_t_load_pola_cali = pola_current_for_cali_parameters [ 'delta_t_load_pola_cali' ] # (s). delta_t_break_pola_cali = pola_current_for_cali_parameters [ 'delta_t_break_pola_cali' ] # (s). i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) # (A.m-2, V). # Calculation delta_t_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. t0_interval = 0 tf_interval = delta_t_ini_pola_cali + len ( i_exp_cali_t ) * delta_t_cali # s. else : # EIS time_interval is calculated in the main.py file. raise ValueError ( \"Please enter a recognized type_current option for calculating the time interval.\" ) # To be reviewed self . control_variables [ 't_control_Phi' ] = t0_interval return [ t0_interval , tf_interval ] def _create_initial_variable_values ( self ): \"\"\"Create the initial values of the solver variables if it is not provided. It is generated considering an equilibrium inside the fuel cell with H2, O2 and N2, at the external pressure, humidity and temperature, without flow or current. Returns ------- list Initial values of the solver variables. It is used when initial_variable_values == None. \"\"\" # Extraction of the operating inputs and parameters current_density , T_des = self . operating_inputs [ 'current_density' ], self . operating_inputs [ 'T_des' ] Pa_des , Pc_des = self . operating_inputs [ 'Pa_des' ], self . operating_inputs [ 'Pc_des' ] Phi_a_des , Phi_c_des = self . operating_inputs [ 'Phi_a_des' ], self . operating_inputs [ 'Phi_c_des' ] y_H2_in = self . operating_inputs [ 'y_H2_in' ] Hmem , kappa_co , kappa_c = self . parameters [ 'Hmem' ], self . parameters [ 'kappa_co' ], self . parameters [ 'kappa_c' ] i0_d_c_ref , i0_h_c_ref = self . parameters [ 'i0_d_c_ref' ], self . parameters [ 'i0_h_c_ref' ] a_slim , b_slim , a_switch = self . parameters [ 'a_slim' ], self . parameters [ 'b_slim' ], self . parameters [ 'a_switch' ] nb_gc , nb_gdl , nb_mpl = self . parameters [ 'nb_gc' ], self . parameters [ 'nb_gdl' ], self . parameters [ 'nb_mpl' ] type_auxiliary = self . parameters [ 'type_auxiliary' ] # Initial fuel cell states # Intermediate values T_ini = T_des # K. It is the initial temperature in the fuel cell. For now, the temperature dynamic evolution # is not considered inside the gas channel and bipolar plates. if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : Pa_ini , Pc_ini = Pext , Pext # Pa. It is the initial pressure in the fuel cell. Phi_a_ini , Phi_c_ini = Phi_ext , Phi_ext # It is the initial relative humidity in the fuel cell. else : # type_auxiliary == \"no_auxiliaries\". For the no_auxiliaries case, the desired values are directly taken as initial values. Pa_ini , Pc_ini = Pa_des , Pc_des # Indeed, the dynamics of the auxiliaries are not considered. Phi_a_ini , Phi_c_ini = Phi_a_des , Phi_c_des # Choosing other values would create an imbalance in the initial state. Psat_ini = 101325 * 10 ** ( - 2.1794 + 0.02953 * ( T_ini - 273.15 ) - 9.1837e-5 * ( T_ini - 273.15 ) ** 2 + 1.4454e-7 * ( T_ini - 273.15 ) ** 3 ) slim = a_slim * ( Pc_ini / 1e5 ) + b_slim s_switch = a_switch * slim # Initial fuel cell states C_v_a_ini = Phi_a_ini * Psat_ini / ( R * T_ini ) # mol.m-3. It is the initial vapor concentration. C_v_c_ini = Phi_c_ini * Psat_ini / ( R * T_ini ) # mol.m-3. It is the initial vapor concentration. C_O2_ini = y_O2_ext * ( Pc_ini - Phi_c_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial O2 # concentration in the fuel cell. C_N2_cgc_ini = ( 1 - y_O2_ext ) * ( Pc_ini - Phi_c_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial N2 # concentration in the anode fuel cell. if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : C_H2_ini = y_H2_in * ( Pa_ini - Phi_a_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial H2 # concentration in the fuel cell. C_N2_agc_ini = ( 1 - y_H2_in ) * ( Pa_ini - Phi_a_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial N2 # concentration in the anode fuel cell. else : C_H2_ini = ( Pa_ini - Phi_a_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial H2 # concentration in the fuel cell. C_N2_agc_ini = 0 # mol.m-3. It is the initial N2 # concentration in the anode fuel cell. s_ini = 0 # It is the initial liquid water saturation in the fuel cell. lambda_mem_ini = lambda_eq ( C_v_c_ini , s_ini , T_ini ) # It is the initial water content in the fuel cell. i_fc_ini = current_density ( self . time_interval [ 0 ], self . parameters ) i_n_ini = 2 * F * R * T_ini / Hmem * C_H2_ini * k_H2 ( lambda_mem_ini , T_ini , kappa_co ) + \\ 4 * F * R * T_ini / Hmem * C_O2_ini * k_O2 ( lambda_mem_ini , T_ini , kappa_co ) f_drop_ini = 0.5 * ( 1.0 - math . tanh (( 4 * s_ini - 2 * slim - 2 * s_switch ) / ( slim - s_switch ))) eta_c_ini = R * T_ini / ( alpha_c * F ) * \\ math . log (( i_fc_ini + i_n_ini ) / ( i0_d_c_ref ** ( 1 - f_drop_ini ) * i0_h_c_ref ** f_drop_ini ) * ( C_O2ref / C_O2_ini ) ** kappa_c ) # It is the initial # cathode overpotential in the fuel cell. # Initial auxiliary system state Wcp_ini = 0 # kg.s-1. It is the flow rate of the air compressor. Wa_inj_ini = 0 # kg.s-1. It is the flow rate of the air compressor at the anode side. Wc_inj_ini = 0 # kg.s-1. It is the flow rate of the air compressor at the cathode side. Abp_a_ini = 0 # It is the throttle area of the back pressure valve at the anode. Abp_c_ini = 0 # It is the throttle area of the back pressure valve at the cathode. # Main variable initialization C_v_agc , C_v_agdl , C_v_ampl , C_v_acl = [ C_v_a_ini ] * 4 C_v_ccl , C_v_cmpl , C_v_cgdl , C_v_cgc = [ C_v_c_ini ] * 4 s_agdl , s_ampl , s_acl , s_ccl , s_cmpl , s_cgdl = [ s_ini ] * 6 s_boundary = 0 # Dirichlet boundary condition lambda_acl , lambda_mem , lambda_ccl = [ lambda_mem_ini ] * 3 C_H2_agc , C_H2_agdl , C_H2_ampl , C_H2_acl = [ C_H2_ini ] * 4 C_O2_ccl , C_O2_cmpl , C_O2_cgdl , C_O2_cgc = [ C_O2_ini ] * 4 if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : C_N2_agc , C_N2_cgc = C_N2_agc_ini , C_N2_cgc_ini # Test bench: simulated H2 recirculation which leads to N2 in the anode. else : C_N2_agc , C_N2_cgc = 0 , C_N2_cgc_ini T_agc , T_agdl , T_ampl , T_acl , T_mem , T_ccl , T_cmpl , T_cgdl , T_cgc = [ T_ini ] * 9 eta_c = eta_c_ini Pasm , Paem = [ Pa_ini ] * 2 Pcsm , Pcem = [ Pc_ini ] * 2 Phi_asm , Phi_aem = [ Phi_a_ini ] * 2 Phi_csm , Phi_cem = [ Phi_c_ini ] * 2 Wcp , Wa_inj , Wc_inj , Abp_a , Abp_c = Wcp_ini , Wa_inj_ini , Wc_inj_ini , Abp_a_ini , Abp_c_ini # Gathering of the variables initial value into one list initial_variable_values = ([ C_v_agc ] * nb_gc + [ C_v_agdl ] * nb_gdl + [ C_v_ampl ] * nb_mpl + [ C_v_acl , C_v_ccl ] + [ C_v_cmpl ] * nb_mpl + [ C_v_cgdl ] * nb_gdl + [ C_v_cgc ] * nb_gc + [ s_boundary ] + [ s_agdl ] * ( nb_gdl - 1 ) + [ s_ampl ] * nb_mpl + [ s_acl , s_ccl ] + [ s_cmpl ] * nb_mpl + [ s_cgdl ] * ( nb_gdl - 1 ) + [ s_boundary ] + [ lambda_acl , lambda_mem , lambda_ccl ] + [ C_H2_agc ] * nb_gc + [ C_H2_agdl ] * nb_gdl + [ C_H2_ampl ] * nb_mpl + [ C_H2_acl , C_O2_ccl ] + [ C_O2_cmpl ] * nb_mpl + [ C_O2_cgdl ] * nb_gdl + [ C_O2_cgc ] * nb_gc + [ C_N2_agc ] * nb_gc + [ C_N2_cgc ] * nb_gc + [ T_agc ] * nb_gc + [ T_agdl ] * nb_gdl + [ T_ampl ] * nb_mpl + [ T_acl , T_mem , T_ccl ] + [ T_cmpl ] * nb_mpl + [ T_cgdl ] * nb_gdl + [ T_cgc ] * nb_gc + [ eta_c ]) if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or \\ type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : initial_variable_values . extend ([ Pasm , Paem , Pcsm , Pcem ] + [ Phi_asm , Phi_aem ] + [ Phi_csm , Phi_cem ] + [ Wcp , Wa_inj , Wc_inj , Abp_a , Abp_c ]) return initial_variable_values def _recovery ( self ): \"\"\"Recover the values which have been calculated by the solver and add them into the variables' dictionary. However, the numerical resolution method does not, by design, recover all the internal states of the stack, even though they are calculated during this process. They therefore have to be recovered manually. \"\"\" # Recovery of the time span self . variables [ 't' ] . extend ( list ( self . sol . t )) # Recovery of the main variables dynamic evolution for index , key in enumerate ( self . solver_variable_names ): self . variables [ key ] . extend ( list ( self . sol . y [ index ])) # Recovery of more variables if self . parameters [ 'type_display' ] != \"no_display\" : # The control variables should be reinitialized. To be reviewed. if self . parameters [ 'type_current' ] == \"step\" : self . control_variables [ 't_control_Phi' ] = 0 else : self . control_variables [ 't_control_Phi' ] = 0 self . control_variables [ 'Phi_a_des' ] = self . operating_inputs [ 'Phi_a_des' ] self . control_variables [ 'Phi_c_des' ] = self . operating_inputs [ 'Phi_c_des' ] for j in range ( len ( self . sol . t )): # For each time... # ... recovery of i_fc. i_fc = self . operating_inputs [ \"current_density\" ]( self . variables [ 't' ][ j ], self . parameters ) # ... recovery of S_abs_acl, S_abs_ccl, Jmem_acl, Jmem_ccl. last_solver_variables = { key : self . variables [ key ][ j ] for key in self . solver_variable_names } flows_recovery = calculate_flows ( self . variables [ 't' ][ j ], last_solver_variables , self . control_variables , i_fc , self . operating_inputs , self . parameters ) for key in [ 'v_a_in' , 'v_c_in' , 'Pa_in' , 'Pc_in' ]: self . variables [ key ] . append ( flows_recovery [ key ]) # ... recovery of Phi_a_des and Phi_c_des. if self . parameters [ \"type_control\" ] == \"Phi_des\" : sv = { 'lambda_mem' : self . variables [ 'lambda_mem' ][ j ], 's_ccl' : self . variables [ 's_ccl' ][ j ]} control_operating_conditions ( self . variables [ 't' ][ j ], sv , self . operating_inputs , self . parameters , self . control_variables ) for key in [ 'Phi_a_des' , 'Phi_c_des' ]: self . variables [ key ] . append ( self . control_variables [ key ]) def Display ( self , ax1 = None , ax2 = None , ax3 = None ): \"\"\"Display the plots of the program. Parameters ---------- ax1 : matplotlib.axes.Axes, optional Axes for the first set of plots. The default is None. ax2 : matplotlib.axes.Axes, optional Axes for the second set of plots. The default is None. ax3 : matplotlib.axes.Axes, optional Axes for the third set of plots. The default is None. \"\"\" # Extraction of the operating inputs and parameters nb_gdl , type_fuel_cell = self . parameters [ 'nb_gdl' ], self . parameters [ 'type_fuel_cell' ] type_current , type_display = self . parameters [ 'type_current' ], self . parameters [ 'type_display' ] # Parameters' preparation n = len ( self . variables [ 't' ]) subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 \\ else type_fuel_cell # Display if type_current == \"step\" : if type_display == \"multiple\" : figs , axes = zip ( * [ plt . subplots ( figsize = ( 8 , 8 )) for _ in range ( 13 )]) plot_ifc ( self . variables , self . operating_inputs , self . parameters , axes [ 0 ]) plot_J ( self . variables , self . parameters , axes [ 1 ]) plot_C_v ( self . variables , self . parameters , axes [ 2 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , axes [ 3 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , axes [ 4 ]) plot_C_O2 ( self . variables , self . parameters , axes [ 5 ]) plot_C_H2 ( self . variables , self . parameters , axes [ 6 ]) plot_C_N2 ( self . variables , self . parameters , axes [ 7 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , axes [ 8 ]) plot_Ucell ( self . variables , self . parameters , axes [ 9 ]) plot_P ( self . variables , self . operating_inputs , self . parameters , axes [ 10 ]) plot_Phi_a ( self . variables , self . operating_inputs , self . parameters , axes [ 11 ]) plot_Phi_c ( self . variables , self . operating_inputs , self . parameters , axes [ 12 ]) # Considering the number of plots, the saving instructions are made here and not in the main.py file. self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_ifc_1.pdf\" , figs [ 0 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_J_1.pdf\" , figs [ 1 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Cv_1.pdf\" , figs [ 2 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_lambda_1.pdf\" , figs [ 3 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_s_1.pdf\" , figs [ 4 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_O2_1.pdf\" , figs [ 5 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_H2_1.pdf\" , figs [ 6 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_N2_1.pdf\" , figs [ 7 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_T_1.pdf\" , figs [ 8 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Ucell_1.pdf\" , figs [ 9 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_P_1.pdf\" , figs [ 10 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_a_1.pdf\" , figs [ 11 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_c_1.pdf\" , figs [ 12 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_ifc ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 0 ]) plot_Ucell ( self . variables , self . parameters , ax1 [ 0 , 1 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 2 ]) plot_C_v ( self . variables , self . parameters , ax1 [ 1 , 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 1 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 2 ]) plot_C_H2 ( self . variables , self . parameters , ax1 [ 2 , 0 ]) plot_C_O2 ( self . variables , self . parameters , ax1 [ 2 , 1 ]) plot_P ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 , 2 ]) plot_v ( self . variables , self . parameters , ax2 [ 0 ]) plot_Re_nb ( self . variables , self . parameters , ax2 [ 1 ]) plt . pause ( 1 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"polarization\" : if type_display == \"multiple\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_power_density_curve ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 1 ]) plot_cell_efficiency ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 2 ]) plot_Phi_des ( self . variables , self . operating_inputs , self . parameters , ax2 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax2 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax2 [ 2 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax2 [ 3 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"no_display\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 , show = False ) elif type_current == \"polarization_for_cali\" : if type_display == \"multiple\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"EIS\" : if type_display == \"multiple\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 ) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax2 ) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax3 ) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 [ 0 ]) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax1 [ 1 ]) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax1 [ 2 ]) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode def Save_plot ( self , fig1 = None , fig2 = None , fig3 = None ): \"\"\"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters ---------- fig1 : matplotlib.figure.Figure, optional Figure for the first plot. The default is None. fig2 : matplotlib.figure.Figure, optional Figure for the second plot. The default is None. fig3 : matplotlib.figure.Figure, optional Figure for the third plot. The default is None. \"\"\" # Extraction of the operating inputs and parameters type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] type_display = self . parameters [ 'type_display' ] # Folder name subfolder_name = type_fuel_cell . split ( '_' )[ 0 ] # For the step current if type_current == \"step\" : if type_display == \"multiple\" : pass # saving instruction is directly implemented within AlphaPEM.Display for this situation. if type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"global_indicators_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_syn_1.pdf\" , fig2 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_1.pdf\" , fig1 ) # For the EIS curve elif type_current == \"EIS\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_amplitude_curve_1.pdf\" , fig2 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_angle_curve_1.pdf\" , fig3 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"impact_cali_on_internal_state_1.pdf\" , fig1 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_cali_1.pdf\" , fig1 ) def Saving_instructions ( self , root_folder , subfolder_name , filename , fig ): \"\"\"Gives the saving instructions for the figures. Parameters ---------- root_folder : str The root folder for the saving. subfolder_name : str The subfolder name for the saving. filename : str The filename for the saving. fig : matplotlib.figure.Figure The figure to be saved. \"\"\" # Create the folder if necessary folder_name = os . path . join ( root_folder , subfolder_name ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the filename without erasing the previous ones counter = 1 while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 if filename [ - 6 ] == \"_\" : # for the numbers between 1 and 9 filename = filename [: - 5 ] + str ( counter ) + \".pdf\" elif filename [ - 7 ] == \"_\" : # for the numbers between 10 and 99. filename = filename [: - 6 ] + str ( counter ) + \".pdf\" else : # for the numbers between 100 and 999. The bigger numbers are not considered. filename = filename [: - 7 ] + str ( counter ) + \".pdf\" # Save the figure file_path = os . path . join ( folder_name , filename ) fig . savefig ( file_path , dpi = 900 , transparent = False , bbox_inches = 'tight' ) Display ( ax1 = None , ax2 = None , ax3 = None ) Display the plots of the program. Parameters: ax1 ( Axes , default: None ) \u2013 Axes for the first set of plots. The default is None. ax2 ( Axes , default: None ) \u2013 Axes for the second set of plots. The default is None. ax3 ( Axes , default: None ) \u2013 Axes for the third set of plots. The default is None. Source code in model/AlphaPEM.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 def Display ( self , ax1 = None , ax2 = None , ax3 = None ): \"\"\"Display the plots of the program. Parameters ---------- ax1 : matplotlib.axes.Axes, optional Axes for the first set of plots. The default is None. ax2 : matplotlib.axes.Axes, optional Axes for the second set of plots. The default is None. ax3 : matplotlib.axes.Axes, optional Axes for the third set of plots. The default is None. \"\"\" # Extraction of the operating inputs and parameters nb_gdl , type_fuel_cell = self . parameters [ 'nb_gdl' ], self . parameters [ 'type_fuel_cell' ] type_current , type_display = self . parameters [ 'type_current' ], self . parameters [ 'type_display' ] # Parameters' preparation n = len ( self . variables [ 't' ]) subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 \\ else type_fuel_cell # Display if type_current == \"step\" : if type_display == \"multiple\" : figs , axes = zip ( * [ plt . subplots ( figsize = ( 8 , 8 )) for _ in range ( 13 )]) plot_ifc ( self . variables , self . operating_inputs , self . parameters , axes [ 0 ]) plot_J ( self . variables , self . parameters , axes [ 1 ]) plot_C_v ( self . variables , self . parameters , axes [ 2 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , axes [ 3 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , axes [ 4 ]) plot_C_O2 ( self . variables , self . parameters , axes [ 5 ]) plot_C_H2 ( self . variables , self . parameters , axes [ 6 ]) plot_C_N2 ( self . variables , self . parameters , axes [ 7 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , axes [ 8 ]) plot_Ucell ( self . variables , self . parameters , axes [ 9 ]) plot_P ( self . variables , self . operating_inputs , self . parameters , axes [ 10 ]) plot_Phi_a ( self . variables , self . operating_inputs , self . parameters , axes [ 11 ]) plot_Phi_c ( self . variables , self . operating_inputs , self . parameters , axes [ 12 ]) # Considering the number of plots, the saving instructions are made here and not in the main.py file. self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_ifc_1.pdf\" , figs [ 0 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_J_1.pdf\" , figs [ 1 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Cv_1.pdf\" , figs [ 2 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_lambda_1.pdf\" , figs [ 3 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_s_1.pdf\" , figs [ 4 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_O2_1.pdf\" , figs [ 5 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_H2_1.pdf\" , figs [ 6 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_N2_1.pdf\" , figs [ 7 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_T_1.pdf\" , figs [ 8 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Ucell_1.pdf\" , figs [ 9 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_P_1.pdf\" , figs [ 10 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_a_1.pdf\" , figs [ 11 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_c_1.pdf\" , figs [ 12 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_ifc ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 0 ]) plot_Ucell ( self . variables , self . parameters , ax1 [ 0 , 1 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 2 ]) plot_C_v ( self . variables , self . parameters , ax1 [ 1 , 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 1 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 2 ]) plot_C_H2 ( self . variables , self . parameters , ax1 [ 2 , 0 ]) plot_C_O2 ( self . variables , self . parameters , ax1 [ 2 , 1 ]) plot_P ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 , 2 ]) plot_v ( self . variables , self . parameters , ax2 [ 0 ]) plot_Re_nb ( self . variables , self . parameters , ax2 [ 1 ]) plt . pause ( 1 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"polarization\" : if type_display == \"multiple\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_power_density_curve ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 1 ]) plot_cell_efficiency ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 2 ]) plot_Phi_des ( self . variables , self . operating_inputs , self . parameters , ax2 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax2 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax2 [ 2 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax2 [ 3 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"no_display\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 , show = False ) elif type_current == \"polarization_for_cali\" : if type_display == \"multiple\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"EIS\" : if type_display == \"multiple\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 ) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax2 ) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax3 ) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 [ 0 ]) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax1 [ 1 ]) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax1 [ 2 ]) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode Save_plot ( fig1 = None , fig2 = None , fig3 = None ) Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters: fig1 ( Figure , default: None ) \u2013 Figure for the first plot. The default is None. fig2 ( Figure , default: None ) \u2013 Figure for the second plot. The default is None. fig3 ( Figure , default: None ) \u2013 Figure for the third plot. The default is None. Source code in model/AlphaPEM.py 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 def Save_plot ( self , fig1 = None , fig2 = None , fig3 = None ): \"\"\"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters ---------- fig1 : matplotlib.figure.Figure, optional Figure for the first plot. The default is None. fig2 : matplotlib.figure.Figure, optional Figure for the second plot. The default is None. fig3 : matplotlib.figure.Figure, optional Figure for the third plot. The default is None. \"\"\" # Extraction of the operating inputs and parameters type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] type_display = self . parameters [ 'type_display' ] # Folder name subfolder_name = type_fuel_cell . split ( '_' )[ 0 ] # For the step current if type_current == \"step\" : if type_display == \"multiple\" : pass # saving instruction is directly implemented within AlphaPEM.Display for this situation. if type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"global_indicators_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_syn_1.pdf\" , fig2 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_1.pdf\" , fig1 ) # For the EIS curve elif type_current == \"EIS\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_amplitude_curve_1.pdf\" , fig2 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_angle_curve_1.pdf\" , fig3 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"impact_cali_on_internal_state_1.pdf\" , fig1 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_cali_1.pdf\" , fig1 ) Saving_instructions ( root_folder , subfolder_name , filename , fig ) Gives the saving instructions for the figures. Parameters: root_folder ( str ) \u2013 The root folder for the saving. subfolder_name ( str ) \u2013 The subfolder name for the saving. filename ( str ) \u2013 The filename for the saving. fig ( Figure ) \u2013 The figure to be saved. Source code in model/AlphaPEM.py 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 def Saving_instructions ( self , root_folder , subfolder_name , filename , fig ): \"\"\"Gives the saving instructions for the figures. Parameters ---------- root_folder : str The root folder for the saving. subfolder_name : str The subfolder name for the saving. filename : str The filename for the saving. fig : matplotlib.figure.Figure The figure to be saved. \"\"\" # Create the folder if necessary folder_name = os . path . join ( root_folder , subfolder_name ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the filename without erasing the previous ones counter = 1 while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 if filename [ - 6 ] == \"_\" : # for the numbers between 1 and 9 filename = filename [: - 5 ] + str ( counter ) + \".pdf\" elif filename [ - 7 ] == \"_\" : # for the numbers between 10 and 99. filename = filename [: - 6 ] + str ( counter ) + \".pdf\" else : # for the numbers between 100 and 999. The bigger numbers are not considered. filename = filename [: - 7 ] + str ( counter ) + \".pdf\" # Save the figure file_path = os . path . join ( folder_name , filename ) fig . savefig ( file_path , dpi = 900 , transparent = False , bbox_inches = 'tight' ) __init__ ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ) Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - n_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - n_gdl : int Number of points considered in the GDL (computing parameter). - n_mpl : int Number of points considered in the MPL (computing parameter). - n_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values ( list , default: None ) \u2013 Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval ( list , default: None ) \u2013 Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. Source code in model/AlphaPEM.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def __init__ ( self , operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ): \"\"\"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - n_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - n_gdl : int Number of points considered in the GDL (computing parameter). - n_mpl : int Number of points considered in the MPL (computing parameter). - n_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values : list, optional Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval : list, optional Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. \"\"\" # Initialize the operating inputs and parameters dictionaries. self . operating_inputs = operating_inputs self . current_parameters = current_parameters self . accessible_physical_parameters = accessible_physical_parameters self . undetermined_physical_parameters = undetermined_physical_parameters self . computing_parameters = computing_parameters self . parameters = { ** self . current_parameters , ** self . accessible_physical_parameters , ** self . undetermined_physical_parameters , ** self . computing_parameters } if self . operating_inputs [ 'Pa_des' ] < Pext or self . operating_inputs [ 'Pc_des' ] < Pext : raise ValueError ( 'The desired pressure is too low. It cannot be lower than the pressure outside the stack.' ) # Initialize the variables' dictionary. self . solver_variable_names = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_acl' , 'C_v_ccl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_acl' , 's_ccl' , 's_cmpl' , 's_cgdl' , 'lambda_acl' , 'lambda_mem' , 'lambda_ccl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_H2_acl' , 'C_O2_ccl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2_agc' , 'C_N2_cgc' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_acl' , 'T_mem' , 'T_ccl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' , 'eta_c' ] if self . parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" or \\ self . parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_anodic_recirculation\" : self . solver_variable_names . extend ([ 'Pasm' , 'Paem' , 'Pcsm' , 'Pcem' , 'Phi_asm' , 'Phi_aem' , 'Phi_csm' , 'Phi_cem' , 'Wcp' , 'Wa_inj' , 'Wc_inj' , 'Abp_a' , 'Abp_c' ]) self . solver_variable_names_extension () # Several points are considered in each GC, GDL and MPL. This must be # inserted into the solver_variable_names. self . all_variable_names = self . solver_variable_names + [ 't' , 'Ucell' , 'v_a_in' , 'v_c_in' , 'Pa_in' , 'Pc_in' ] + \\ [ 'Phi_a_des' , 'Phi_c_des' ] self . variables = { key : [] for key in self . all_variable_names } # Initialize the control_variables dictionary. self . control_variables = { 't_control_Phi' : 0 , 'Phi_a_des' : self . operating_inputs [ 'Phi_a_des' ], 'Phi_c_des' : self . operating_inputs [ 'Phi_c_des' ]} # Temporary action: simulations with auxiliaries are in reconstruction. if self . parameters [ 'type_auxiliary' ] != \"no_auxiliary\" : self . parameters [ 'type_auxiliary' ] == \"no_auxiliary\" print ( \"Auxiliary considerations are temporarily removed, as they require reconstruction.\" ) # Create the dynamic evolution. # Create time intervals if time_interval is not None : # Initial time interval may be given to the Simulator. self . time_interval = time_interval else : # If not, it is automatically generated. self . time_interval = self . _create_time_interval () # Create the initial variable values if initial_variable_values is not None : # Initial variable values may be given to the Simulator. self . initial_variable_values = initial_variable_values else : # If not, they are generated considering an equilibrium at the operating inputs without current. self . initial_variable_values = self . _create_initial_variable_values () # Resolution of the system of differential equations. event_negative . terminal = True # Integration is stopped if one of the crucial variables becomes negative. self . sol = solve_ivp ( dydt , self . time_interval , self . initial_variable_values , method = 'BDF' , rtol = self . parameters [ 'rtol' ], atol = self . parameters [ 'atol' ], events = event_negative , args = ( self . operating_inputs , self . parameters , self . solver_variable_names , self . control_variables )) # Recover the variable values calculated by the solver into the dictionary. self . _recovery () # Calculate the cell voltage after computing the internal states of the cell. self . variables [ \"Ucell\" ] . extend ( calculate_cell_voltage ( self . variables , self . operating_inputs , self . parameters )) solver_variable_names_extension () Several points are considered in each GDL and must be inserted into the solver_variable_names. Source code in model/AlphaPEM.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def solver_variable_names_extension ( self ): \"\"\"Several points are considered in each GDL and must be inserted into the solver_variable_names. \"\"\" new_points_location = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_cmpl' , 's_cgdl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2_agc' , 'C_N2_cgc' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' ] for variable in new_points_location : index = self . solver_variable_names . index ( variable ) # Delete the previous points self . solver_variable_names . pop ( index ) # Increase the number of points if variable . endswith ( 'gc' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_gc' ] + 1 )] if variable . endswith ( 'gdl' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_gdl' ] + 1 )] elif variable . endswith ( 'mpl' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_mpl' ] + 1 )]","title":"AlphaPEM"},{"location":"functions/model/AlphaPEM/#alphapem","text":"Objectives: Create an open-source software package to simulate the PEM fuel cell for control system applications. Authors: Rapha\u00ebl GASS, Zhongliang LI, Rachid OUTBIB, Samir JEMEI and Daniel HISSEL. This file describes the AlphaPEM class, which is a PEM fuel cell system simulator. The model is one-dimensional, dynamic, biphasic, and isothermal. It has been published in the following articles: - Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a - Gass et al 2024 SSRN http://dx.doi.org/10.2139/ssrn.4812343","title":"AlphaPEM"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM","text":"Source code in model/AlphaPEM.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 class AlphaPEM : def __init__ ( self , operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ): \"\"\"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - n_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - n_gdl : int Number of points considered in the GDL (computing parameter). - n_mpl : int Number of points considered in the MPL (computing parameter). - n_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values : list, optional Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval : list, optional Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. \"\"\" # Initialize the operating inputs and parameters dictionaries. self . operating_inputs = operating_inputs self . current_parameters = current_parameters self . accessible_physical_parameters = accessible_physical_parameters self . undetermined_physical_parameters = undetermined_physical_parameters self . computing_parameters = computing_parameters self . parameters = { ** self . current_parameters , ** self . accessible_physical_parameters , ** self . undetermined_physical_parameters , ** self . computing_parameters } if self . operating_inputs [ 'Pa_des' ] < Pext or self . operating_inputs [ 'Pc_des' ] < Pext : raise ValueError ( 'The desired pressure is too low. It cannot be lower than the pressure outside the stack.' ) # Initialize the variables' dictionary. self . solver_variable_names = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_acl' , 'C_v_ccl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_acl' , 's_ccl' , 's_cmpl' , 's_cgdl' , 'lambda_acl' , 'lambda_mem' , 'lambda_ccl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_H2_acl' , 'C_O2_ccl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2_agc' , 'C_N2_cgc' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_acl' , 'T_mem' , 'T_ccl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' , 'eta_c' ] if self . parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" or \\ self . parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_anodic_recirculation\" : self . solver_variable_names . extend ([ 'Pasm' , 'Paem' , 'Pcsm' , 'Pcem' , 'Phi_asm' , 'Phi_aem' , 'Phi_csm' , 'Phi_cem' , 'Wcp' , 'Wa_inj' , 'Wc_inj' , 'Abp_a' , 'Abp_c' ]) self . solver_variable_names_extension () # Several points are considered in each GC, GDL and MPL. This must be # inserted into the solver_variable_names. self . all_variable_names = self . solver_variable_names + [ 't' , 'Ucell' , 'v_a_in' , 'v_c_in' , 'Pa_in' , 'Pc_in' ] + \\ [ 'Phi_a_des' , 'Phi_c_des' ] self . variables = { key : [] for key in self . all_variable_names } # Initialize the control_variables dictionary. self . control_variables = { 't_control_Phi' : 0 , 'Phi_a_des' : self . operating_inputs [ 'Phi_a_des' ], 'Phi_c_des' : self . operating_inputs [ 'Phi_c_des' ]} # Temporary action: simulations with auxiliaries are in reconstruction. if self . parameters [ 'type_auxiliary' ] != \"no_auxiliary\" : self . parameters [ 'type_auxiliary' ] == \"no_auxiliary\" print ( \"Auxiliary considerations are temporarily removed, as they require reconstruction.\" ) # Create the dynamic evolution. # Create time intervals if time_interval is not None : # Initial time interval may be given to the Simulator. self . time_interval = time_interval else : # If not, it is automatically generated. self . time_interval = self . _create_time_interval () # Create the initial variable values if initial_variable_values is not None : # Initial variable values may be given to the Simulator. self . initial_variable_values = initial_variable_values else : # If not, they are generated considering an equilibrium at the operating inputs without current. self . initial_variable_values = self . _create_initial_variable_values () # Resolution of the system of differential equations. event_negative . terminal = True # Integration is stopped if one of the crucial variables becomes negative. self . sol = solve_ivp ( dydt , self . time_interval , self . initial_variable_values , method = 'BDF' , rtol = self . parameters [ 'rtol' ], atol = self . parameters [ 'atol' ], events = event_negative , args = ( self . operating_inputs , self . parameters , self . solver_variable_names , self . control_variables )) # Recover the variable values calculated by the solver into the dictionary. self . _recovery () # Calculate the cell voltage after computing the internal states of the cell. self . variables [ \"Ucell\" ] . extend ( calculate_cell_voltage ( self . variables , self . operating_inputs , self . parameters )) def solver_variable_names_extension ( self ): \"\"\"Several points are considered in each GDL and must be inserted into the solver_variable_names. \"\"\" new_points_location = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_cmpl' , 's_cgdl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2_agc' , 'C_N2_cgc' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' ] for variable in new_points_location : index = self . solver_variable_names . index ( variable ) # Delete the previous points self . solver_variable_names . pop ( index ) # Increase the number of points if variable . endswith ( 'gc' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_gc' ] + 1 )] if variable . endswith ( 'gdl' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_gdl' ] + 1 )] elif variable . endswith ( 'mpl' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_mpl' ] + 1 )] def _create_time_interval ( self ): \"\"\"Calculate the time intervals for numerical resolution, according to the current chosen, if it is not provided. Returns ------- list Time interval for numerical resolution. It is used when initial_variable_values == None. \"\"\" # Extraction of the parameters step_current_parameters = self . parameters [ 'step_current_parameters' ] pola_current_parameters = self . parameters [ 'pola_current_parameters' ] pola_current_for_cali_parameters = self . parameters [ 'pola_current_for_cali_parameters' ] type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] voltage_zone = self . parameters [ 'voltage_zone' ] # Recovery of the good time interval if type_current == \"step\" : t0_interval = 0 # s. tf_interval = step_current_parameters [ 'delta_t_ini_step' ] + step_current_parameters [ 'delta_t_load_step' ] + \\ step_current_parameters [ 'delta_t_break_step' ] # s. elif type_current == \"polarization\" : # Extraction of the parameters delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] # (s). delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] # (s). delta_i_pola = pola_current_parameters [ 'delta_i_pola' ] # (A.m-2).Wccp_des, i_max_pola = pola_current_parameters [ 'i_max_pola' ] # (A.m-2). # Calculation t0_interval = 0 # s. tf_interval = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * ( delta_t_load_pola + delta_t_break_pola ) elif type_current == \"polarization_for_cali\" : # Extraction of the parameters delta_t_ini_pola_cali = pola_current_for_cali_parameters [ 'delta_t_ini_pola_cali' ] # (s). delta_t_load_pola_cali = pola_current_for_cali_parameters [ 'delta_t_load_pola_cali' ] # (s). delta_t_break_pola_cali = pola_current_for_cali_parameters [ 'delta_t_break_pola_cali' ] # (s). i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) # (A.m-2, V). # Calculation delta_t_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. t0_interval = 0 tf_interval = delta_t_ini_pola_cali + len ( i_exp_cali_t ) * delta_t_cali # s. else : # EIS time_interval is calculated in the main.py file. raise ValueError ( \"Please enter a recognized type_current option for calculating the time interval.\" ) # To be reviewed self . control_variables [ 't_control_Phi' ] = t0_interval return [ t0_interval , tf_interval ] def _create_initial_variable_values ( self ): \"\"\"Create the initial values of the solver variables if it is not provided. It is generated considering an equilibrium inside the fuel cell with H2, O2 and N2, at the external pressure, humidity and temperature, without flow or current. Returns ------- list Initial values of the solver variables. It is used when initial_variable_values == None. \"\"\" # Extraction of the operating inputs and parameters current_density , T_des = self . operating_inputs [ 'current_density' ], self . operating_inputs [ 'T_des' ] Pa_des , Pc_des = self . operating_inputs [ 'Pa_des' ], self . operating_inputs [ 'Pc_des' ] Phi_a_des , Phi_c_des = self . operating_inputs [ 'Phi_a_des' ], self . operating_inputs [ 'Phi_c_des' ] y_H2_in = self . operating_inputs [ 'y_H2_in' ] Hmem , kappa_co , kappa_c = self . parameters [ 'Hmem' ], self . parameters [ 'kappa_co' ], self . parameters [ 'kappa_c' ] i0_d_c_ref , i0_h_c_ref = self . parameters [ 'i0_d_c_ref' ], self . parameters [ 'i0_h_c_ref' ] a_slim , b_slim , a_switch = self . parameters [ 'a_slim' ], self . parameters [ 'b_slim' ], self . parameters [ 'a_switch' ] nb_gc , nb_gdl , nb_mpl = self . parameters [ 'nb_gc' ], self . parameters [ 'nb_gdl' ], self . parameters [ 'nb_mpl' ] type_auxiliary = self . parameters [ 'type_auxiliary' ] # Initial fuel cell states # Intermediate values T_ini = T_des # K. It is the initial temperature in the fuel cell. For now, the temperature dynamic evolution # is not considered inside the gas channel and bipolar plates. if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : Pa_ini , Pc_ini = Pext , Pext # Pa. It is the initial pressure in the fuel cell. Phi_a_ini , Phi_c_ini = Phi_ext , Phi_ext # It is the initial relative humidity in the fuel cell. else : # type_auxiliary == \"no_auxiliaries\". For the no_auxiliaries case, the desired values are directly taken as initial values. Pa_ini , Pc_ini = Pa_des , Pc_des # Indeed, the dynamics of the auxiliaries are not considered. Phi_a_ini , Phi_c_ini = Phi_a_des , Phi_c_des # Choosing other values would create an imbalance in the initial state. Psat_ini = 101325 * 10 ** ( - 2.1794 + 0.02953 * ( T_ini - 273.15 ) - 9.1837e-5 * ( T_ini - 273.15 ) ** 2 + 1.4454e-7 * ( T_ini - 273.15 ) ** 3 ) slim = a_slim * ( Pc_ini / 1e5 ) + b_slim s_switch = a_switch * slim # Initial fuel cell states C_v_a_ini = Phi_a_ini * Psat_ini / ( R * T_ini ) # mol.m-3. It is the initial vapor concentration. C_v_c_ini = Phi_c_ini * Psat_ini / ( R * T_ini ) # mol.m-3. It is the initial vapor concentration. C_O2_ini = y_O2_ext * ( Pc_ini - Phi_c_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial O2 # concentration in the fuel cell. C_N2_cgc_ini = ( 1 - y_O2_ext ) * ( Pc_ini - Phi_c_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial N2 # concentration in the anode fuel cell. if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : C_H2_ini = y_H2_in * ( Pa_ini - Phi_a_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial H2 # concentration in the fuel cell. C_N2_agc_ini = ( 1 - y_H2_in ) * ( Pa_ini - Phi_a_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial N2 # concentration in the anode fuel cell. else : C_H2_ini = ( Pa_ini - Phi_a_ini * Psat_ini ) / ( R * T_ini ) # mol.m-3. It is the initial H2 # concentration in the fuel cell. C_N2_agc_ini = 0 # mol.m-3. It is the initial N2 # concentration in the anode fuel cell. s_ini = 0 # It is the initial liquid water saturation in the fuel cell. lambda_mem_ini = lambda_eq ( C_v_c_ini , s_ini , T_ini ) # It is the initial water content in the fuel cell. i_fc_ini = current_density ( self . time_interval [ 0 ], self . parameters ) i_n_ini = 2 * F * R * T_ini / Hmem * C_H2_ini * k_H2 ( lambda_mem_ini , T_ini , kappa_co ) + \\ 4 * F * R * T_ini / Hmem * C_O2_ini * k_O2 ( lambda_mem_ini , T_ini , kappa_co ) f_drop_ini = 0.5 * ( 1.0 - math . tanh (( 4 * s_ini - 2 * slim - 2 * s_switch ) / ( slim - s_switch ))) eta_c_ini = R * T_ini / ( alpha_c * F ) * \\ math . log (( i_fc_ini + i_n_ini ) / ( i0_d_c_ref ** ( 1 - f_drop_ini ) * i0_h_c_ref ** f_drop_ini ) * ( C_O2ref / C_O2_ini ) ** kappa_c ) # It is the initial # cathode overpotential in the fuel cell. # Initial auxiliary system state Wcp_ini = 0 # kg.s-1. It is the flow rate of the air compressor. Wa_inj_ini = 0 # kg.s-1. It is the flow rate of the air compressor at the anode side. Wc_inj_ini = 0 # kg.s-1. It is the flow rate of the air compressor at the cathode side. Abp_a_ini = 0 # It is the throttle area of the back pressure valve at the anode. Abp_c_ini = 0 # It is the throttle area of the back pressure valve at the cathode. # Main variable initialization C_v_agc , C_v_agdl , C_v_ampl , C_v_acl = [ C_v_a_ini ] * 4 C_v_ccl , C_v_cmpl , C_v_cgdl , C_v_cgc = [ C_v_c_ini ] * 4 s_agdl , s_ampl , s_acl , s_ccl , s_cmpl , s_cgdl = [ s_ini ] * 6 s_boundary = 0 # Dirichlet boundary condition lambda_acl , lambda_mem , lambda_ccl = [ lambda_mem_ini ] * 3 C_H2_agc , C_H2_agdl , C_H2_ampl , C_H2_acl = [ C_H2_ini ] * 4 C_O2_ccl , C_O2_cmpl , C_O2_cgdl , C_O2_cgc = [ C_O2_ini ] * 4 if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : C_N2_agc , C_N2_cgc = C_N2_agc_ini , C_N2_cgc_ini # Test bench: simulated H2 recirculation which leads to N2 in the anode. else : C_N2_agc , C_N2_cgc = 0 , C_N2_cgc_ini T_agc , T_agdl , T_ampl , T_acl , T_mem , T_ccl , T_cmpl , T_cgdl , T_cgc = [ T_ini ] * 9 eta_c = eta_c_ini Pasm , Paem = [ Pa_ini ] * 2 Pcsm , Pcem = [ Pc_ini ] * 2 Phi_asm , Phi_aem = [ Phi_a_ini ] * 2 Phi_csm , Phi_cem = [ Phi_c_ini ] * 2 Wcp , Wa_inj , Wc_inj , Abp_a , Abp_c = Wcp_ini , Wa_inj_ini , Wc_inj_ini , Abp_a_ini , Abp_c_ini # Gathering of the variables initial value into one list initial_variable_values = ([ C_v_agc ] * nb_gc + [ C_v_agdl ] * nb_gdl + [ C_v_ampl ] * nb_mpl + [ C_v_acl , C_v_ccl ] + [ C_v_cmpl ] * nb_mpl + [ C_v_cgdl ] * nb_gdl + [ C_v_cgc ] * nb_gc + [ s_boundary ] + [ s_agdl ] * ( nb_gdl - 1 ) + [ s_ampl ] * nb_mpl + [ s_acl , s_ccl ] + [ s_cmpl ] * nb_mpl + [ s_cgdl ] * ( nb_gdl - 1 ) + [ s_boundary ] + [ lambda_acl , lambda_mem , lambda_ccl ] + [ C_H2_agc ] * nb_gc + [ C_H2_agdl ] * nb_gdl + [ C_H2_ampl ] * nb_mpl + [ C_H2_acl , C_O2_ccl ] + [ C_O2_cmpl ] * nb_mpl + [ C_O2_cgdl ] * nb_gdl + [ C_O2_cgc ] * nb_gc + [ C_N2_agc ] * nb_gc + [ C_N2_cgc ] * nb_gc + [ T_agc ] * nb_gc + [ T_agdl ] * nb_gdl + [ T_ampl ] * nb_mpl + [ T_acl , T_mem , T_ccl ] + [ T_cmpl ] * nb_mpl + [ T_cgdl ] * nb_gdl + [ T_cgc ] * nb_gc + [ eta_c ]) if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or \\ type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" : initial_variable_values . extend ([ Pasm , Paem , Pcsm , Pcem ] + [ Phi_asm , Phi_aem ] + [ Phi_csm , Phi_cem ] + [ Wcp , Wa_inj , Wc_inj , Abp_a , Abp_c ]) return initial_variable_values def _recovery ( self ): \"\"\"Recover the values which have been calculated by the solver and add them into the variables' dictionary. However, the numerical resolution method does not, by design, recover all the internal states of the stack, even though they are calculated during this process. They therefore have to be recovered manually. \"\"\" # Recovery of the time span self . variables [ 't' ] . extend ( list ( self . sol . t )) # Recovery of the main variables dynamic evolution for index , key in enumerate ( self . solver_variable_names ): self . variables [ key ] . extend ( list ( self . sol . y [ index ])) # Recovery of more variables if self . parameters [ 'type_display' ] != \"no_display\" : # The control variables should be reinitialized. To be reviewed. if self . parameters [ 'type_current' ] == \"step\" : self . control_variables [ 't_control_Phi' ] = 0 else : self . control_variables [ 't_control_Phi' ] = 0 self . control_variables [ 'Phi_a_des' ] = self . operating_inputs [ 'Phi_a_des' ] self . control_variables [ 'Phi_c_des' ] = self . operating_inputs [ 'Phi_c_des' ] for j in range ( len ( self . sol . t )): # For each time... # ... recovery of i_fc. i_fc = self . operating_inputs [ \"current_density\" ]( self . variables [ 't' ][ j ], self . parameters ) # ... recovery of S_abs_acl, S_abs_ccl, Jmem_acl, Jmem_ccl. last_solver_variables = { key : self . variables [ key ][ j ] for key in self . solver_variable_names } flows_recovery = calculate_flows ( self . variables [ 't' ][ j ], last_solver_variables , self . control_variables , i_fc , self . operating_inputs , self . parameters ) for key in [ 'v_a_in' , 'v_c_in' , 'Pa_in' , 'Pc_in' ]: self . variables [ key ] . append ( flows_recovery [ key ]) # ... recovery of Phi_a_des and Phi_c_des. if self . parameters [ \"type_control\" ] == \"Phi_des\" : sv = { 'lambda_mem' : self . variables [ 'lambda_mem' ][ j ], 's_ccl' : self . variables [ 's_ccl' ][ j ]} control_operating_conditions ( self . variables [ 't' ][ j ], sv , self . operating_inputs , self . parameters , self . control_variables ) for key in [ 'Phi_a_des' , 'Phi_c_des' ]: self . variables [ key ] . append ( self . control_variables [ key ]) def Display ( self , ax1 = None , ax2 = None , ax3 = None ): \"\"\"Display the plots of the program. Parameters ---------- ax1 : matplotlib.axes.Axes, optional Axes for the first set of plots. The default is None. ax2 : matplotlib.axes.Axes, optional Axes for the second set of plots. The default is None. ax3 : matplotlib.axes.Axes, optional Axes for the third set of plots. The default is None. \"\"\" # Extraction of the operating inputs and parameters nb_gdl , type_fuel_cell = self . parameters [ 'nb_gdl' ], self . parameters [ 'type_fuel_cell' ] type_current , type_display = self . parameters [ 'type_current' ], self . parameters [ 'type_display' ] # Parameters' preparation n = len ( self . variables [ 't' ]) subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 \\ else type_fuel_cell # Display if type_current == \"step\" : if type_display == \"multiple\" : figs , axes = zip ( * [ plt . subplots ( figsize = ( 8 , 8 )) for _ in range ( 13 )]) plot_ifc ( self . variables , self . operating_inputs , self . parameters , axes [ 0 ]) plot_J ( self . variables , self . parameters , axes [ 1 ]) plot_C_v ( self . variables , self . parameters , axes [ 2 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , axes [ 3 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , axes [ 4 ]) plot_C_O2 ( self . variables , self . parameters , axes [ 5 ]) plot_C_H2 ( self . variables , self . parameters , axes [ 6 ]) plot_C_N2 ( self . variables , self . parameters , axes [ 7 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , axes [ 8 ]) plot_Ucell ( self . variables , self . parameters , axes [ 9 ]) plot_P ( self . variables , self . operating_inputs , self . parameters , axes [ 10 ]) plot_Phi_a ( self . variables , self . operating_inputs , self . parameters , axes [ 11 ]) plot_Phi_c ( self . variables , self . operating_inputs , self . parameters , axes [ 12 ]) # Considering the number of plots, the saving instructions are made here and not in the main.py file. self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_ifc_1.pdf\" , figs [ 0 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_J_1.pdf\" , figs [ 1 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Cv_1.pdf\" , figs [ 2 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_lambda_1.pdf\" , figs [ 3 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_s_1.pdf\" , figs [ 4 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_O2_1.pdf\" , figs [ 5 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_H2_1.pdf\" , figs [ 6 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_N2_1.pdf\" , figs [ 7 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_T_1.pdf\" , figs [ 8 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Ucell_1.pdf\" , figs [ 9 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_P_1.pdf\" , figs [ 10 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_a_1.pdf\" , figs [ 11 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_c_1.pdf\" , figs [ 12 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_ifc ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 0 ]) plot_Ucell ( self . variables , self . parameters , ax1 [ 0 , 1 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 2 ]) plot_C_v ( self . variables , self . parameters , ax1 [ 1 , 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 1 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 2 ]) plot_C_H2 ( self . variables , self . parameters , ax1 [ 2 , 0 ]) plot_C_O2 ( self . variables , self . parameters , ax1 [ 2 , 1 ]) plot_P ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 , 2 ]) plot_v ( self . variables , self . parameters , ax2 [ 0 ]) plot_Re_nb ( self . variables , self . parameters , ax2 [ 1 ]) plt . pause ( 1 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"polarization\" : if type_display == \"multiple\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_power_density_curve ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 1 ]) plot_cell_efficiency ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 2 ]) plot_Phi_des ( self . variables , self . operating_inputs , self . parameters , ax2 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax2 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax2 [ 2 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax2 [ 3 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"no_display\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 , show = False ) elif type_current == \"polarization_for_cali\" : if type_display == \"multiple\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"EIS\" : if type_display == \"multiple\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 ) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax2 ) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax3 ) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 [ 0 ]) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax1 [ 1 ]) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax1 [ 2 ]) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode def Save_plot ( self , fig1 = None , fig2 = None , fig3 = None ): \"\"\"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters ---------- fig1 : matplotlib.figure.Figure, optional Figure for the first plot. The default is None. fig2 : matplotlib.figure.Figure, optional Figure for the second plot. The default is None. fig3 : matplotlib.figure.Figure, optional Figure for the third plot. The default is None. \"\"\" # Extraction of the operating inputs and parameters type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] type_display = self . parameters [ 'type_display' ] # Folder name subfolder_name = type_fuel_cell . split ( '_' )[ 0 ] # For the step current if type_current == \"step\" : if type_display == \"multiple\" : pass # saving instruction is directly implemented within AlphaPEM.Display for this situation. if type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"global_indicators_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_syn_1.pdf\" , fig2 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_1.pdf\" , fig1 ) # For the EIS curve elif type_current == \"EIS\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_amplitude_curve_1.pdf\" , fig2 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_angle_curve_1.pdf\" , fig3 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"impact_cali_on_internal_state_1.pdf\" , fig1 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_cali_1.pdf\" , fig1 ) def Saving_instructions ( self , root_folder , subfolder_name , filename , fig ): \"\"\"Gives the saving instructions for the figures. Parameters ---------- root_folder : str The root folder for the saving. subfolder_name : str The subfolder name for the saving. filename : str The filename for the saving. fig : matplotlib.figure.Figure The figure to be saved. \"\"\" # Create the folder if necessary folder_name = os . path . join ( root_folder , subfolder_name ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the filename without erasing the previous ones counter = 1 while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 if filename [ - 6 ] == \"_\" : # for the numbers between 1 and 9 filename = filename [: - 5 ] + str ( counter ) + \".pdf\" elif filename [ - 7 ] == \"_\" : # for the numbers between 10 and 99. filename = filename [: - 6 ] + str ( counter ) + \".pdf\" else : # for the numbers between 100 and 999. The bigger numbers are not considered. filename = filename [: - 7 ] + str ( counter ) + \".pdf\" # Save the figure file_path = os . path . join ( folder_name , filename ) fig . savefig ( file_path , dpi = 900 , transparent = False , bbox_inches = 'tight' )","title":"AlphaPEM"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.Display","text":"Display the plots of the program. Parameters: ax1 ( Axes , default: None ) \u2013 Axes for the first set of plots. The default is None. ax2 ( Axes , default: None ) \u2013 Axes for the second set of plots. The default is None. ax3 ( Axes , default: None ) \u2013 Axes for the third set of plots. The default is None. Source code in model/AlphaPEM.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 def Display ( self , ax1 = None , ax2 = None , ax3 = None ): \"\"\"Display the plots of the program. Parameters ---------- ax1 : matplotlib.axes.Axes, optional Axes for the first set of plots. The default is None. ax2 : matplotlib.axes.Axes, optional Axes for the second set of plots. The default is None. ax3 : matplotlib.axes.Axes, optional Axes for the third set of plots. The default is None. \"\"\" # Extraction of the operating inputs and parameters nb_gdl , type_fuel_cell = self . parameters [ 'nb_gdl' ], self . parameters [ 'type_fuel_cell' ] type_current , type_display = self . parameters [ 'type_current' ], self . parameters [ 'type_display' ] # Parameters' preparation n = len ( self . variables [ 't' ]) subfolder_name = type_fuel_cell [: type_fuel_cell . rfind ( '_' )] if type_fuel_cell . rfind ( '_' ) != - 1 \\ else type_fuel_cell # Display if type_current == \"step\" : if type_display == \"multiple\" : figs , axes = zip ( * [ plt . subplots ( figsize = ( 8 , 8 )) for _ in range ( 13 )]) plot_ifc ( self . variables , self . operating_inputs , self . parameters , axes [ 0 ]) plot_J ( self . variables , self . parameters , axes [ 1 ]) plot_C_v ( self . variables , self . parameters , axes [ 2 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , axes [ 3 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , axes [ 4 ]) plot_C_O2 ( self . variables , self . parameters , axes [ 5 ]) plot_C_H2 ( self . variables , self . parameters , axes [ 6 ]) plot_C_N2 ( self . variables , self . parameters , axes [ 7 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , axes [ 8 ]) plot_Ucell ( self . variables , self . parameters , axes [ 9 ]) plot_P ( self . variables , self . operating_inputs , self . parameters , axes [ 10 ]) plot_Phi_a ( self . variables , self . operating_inputs , self . parameters , axes [ 11 ]) plot_Phi_c ( self . variables , self . operating_inputs , self . parameters , axes [ 12 ]) # Considering the number of plots, the saving instructions are made here and not in the main.py file. self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_ifc_1.pdf\" , figs [ 0 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_J_1.pdf\" , figs [ 1 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Cv_1.pdf\" , figs [ 2 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_lambda_1.pdf\" , figs [ 3 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_s_1.pdf\" , figs [ 4 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_O2_1.pdf\" , figs [ 5 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_H2_1.pdf\" , figs [ 6 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_C_N2_1.pdf\" , figs [ 7 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_T_1.pdf\" , figs [ 8 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Ucell_1.pdf\" , figs [ 9 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_P_1.pdf\" , figs [ 10 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_a_1.pdf\" , figs [ 11 ]) self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_Phi_c_1.pdf\" , figs [ 12 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_ifc ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 0 ]) plot_Ucell ( self . variables , self . parameters , ax1 [ 0 , 1 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 , 2 ]) plot_C_v ( self . variables , self . parameters , ax1 [ 1 , 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 1 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 , 2 ]) plot_C_H2 ( self . variables , self . parameters , ax1 [ 2 , 0 ]) plot_C_O2 ( self . variables , self . parameters , ax1 [ 2 , 1 ]) plot_P ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 , 2 ]) plot_v ( self . variables , self . parameters , ax2 [ 0 ]) plot_Re_nb ( self . variables , self . parameters , ax2 [ 1 ]) plt . pause ( 1 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"polarization\" : if type_display == \"multiple\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_power_density_curve ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 1 ]) plot_cell_efficiency ( self . variables , self . operating_inputs , self . parameters , n , ax1 [ 2 ]) plot_Phi_des ( self . variables , self . operating_inputs , self . parameters , ax2 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax2 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax2 [ 2 ]) plot_T ( self . variables , self . operating_inputs , self . parameters , ax2 [ 3 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"no_display\" : plot_polarisation_curve ( self . variables , self . operating_inputs , self . parameters , ax1 , show = False ) elif type_current == \"polarization_for_cali\" : if type_display == \"multiple\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 [ 0 ]) plot_lambda ( self . variables , self . operating_inputs , self . parameters , ax1 [ 1 ]) plot_s ( self . variables , self . operating_inputs , self . parameters , ax1 [ 2 ]) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : plot_polarisation_curve_for_cali ( self . variables , self . operating_inputs , self . parameters , ax1 ) plt . pause ( 0.01 ) # A break is necessary to plot the new points in dynamic mode elif type_current == \"EIS\" : if type_display == \"multiple\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 ) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax2 ) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax3 ) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode elif type_display == \"synthetic\" : Fourier_results = make_Fourier_transformation ( self . variables , self . operating_inputs , self . parameters ) plot_EIS_curve_Nyquist ( self . parameters , Fourier_results , ax1 [ 0 ]) plot_EIS_curve_Bode_amplitude ( self . parameters , Fourier_results , ax1 [ 1 ]) plot_EIS_curve_Bode_angle ( self . parameters , Fourier_results , ax1 [ 2 ]) # # Tests to verify the accuracy of EIS simulation. # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results) plt . pause ( 0.1 ) # A break is necessary to plot the new points in dynamic mode","title":"Display"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.Save_plot","text":"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters: fig1 ( Figure , default: None ) \u2013 Figure for the first plot. The default is None. fig2 ( Figure , default: None ) \u2013 Figure for the second plot. The default is None. fig3 ( Figure , default: None ) \u2013 Figure for the third plot. The default is None. Source code in model/AlphaPEM.py 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 def Save_plot ( self , fig1 = None , fig2 = None , fig3 = None ): \"\"\"Saves the plots. The names of the files are automatically generated according to the type_current and the type_display. Parameters ---------- fig1 : matplotlib.figure.Figure, optional Figure for the first plot. The default is None. fig2 : matplotlib.figure.Figure, optional Figure for the second plot. The default is None. fig3 : matplotlib.figure.Figure, optional Figure for the third plot. The default is None. \"\"\" # Extraction of the operating inputs and parameters type_fuel_cell , type_current = self . parameters [ 'type_fuel_cell' ], self . parameters [ 'type_current' ] type_display = self . parameters [ 'type_display' ] # Folder name subfolder_name = type_fuel_cell . split ( '_' )[ 0 ] # For the step current if type_current == \"step\" : if type_display == \"multiple\" : pass # saving instruction is directly implemented within AlphaPEM.Display for this situation. if type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"step_current_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"global_indicators_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_syn_1.pdf\" , fig2 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_1.pdf\" , fig1 ) # For the EIS curve elif type_current == \"EIS\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_1.pdf\" , fig1 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_amplitude_curve_1.pdf\" , fig2 ) self . Saving_instructions ( \"results\" , subfolder_name , \"Bode_angle_curve_1.pdf\" , fig3 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"Nyquist_plot_syn_1.pdf\" , fig1 ) # For the polarization curve elif type_current == \"polarization\" : if type_display == \"multiple\" : self . Saving_instructions ( \"results\" , subfolder_name , \"impact_cali_on_internal_state_1.pdf\" , fig1 ) elif type_display == \"synthetic\" : self . Saving_instructions ( \"results\" , subfolder_name , \"pola_curve_cali_1.pdf\" , fig1 )","title":"Save_plot"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.Saving_instructions","text":"Gives the saving instructions for the figures. Parameters: root_folder ( str ) \u2013 The root folder for the saving. subfolder_name ( str ) \u2013 The subfolder name for the saving. filename ( str ) \u2013 The filename for the saving. fig ( Figure ) \u2013 The figure to be saved. Source code in model/AlphaPEM.py 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 def Saving_instructions ( self , root_folder , subfolder_name , filename , fig ): \"\"\"Gives the saving instructions for the figures. Parameters ---------- root_folder : str The root folder for the saving. subfolder_name : str The subfolder name for the saving. filename : str The filename for the saving. fig : matplotlib.figure.Figure The figure to be saved. \"\"\" # Create the folder if necessary folder_name = os . path . join ( root_folder , subfolder_name ) if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the filename without erasing the previous ones counter = 1 while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 if filename [ - 6 ] == \"_\" : # for the numbers between 1 and 9 filename = filename [: - 5 ] + str ( counter ) + \".pdf\" elif filename [ - 7 ] == \"_\" : # for the numbers between 10 and 99. filename = filename [: - 6 ] + str ( counter ) + \".pdf\" else : # for the numbers between 100 and 999. The bigger numbers are not considered. filename = filename [: - 7 ] + str ( counter ) + \".pdf\" # Save the figure file_path = os . path . join ( folder_name , filename ) fig . savefig ( file_path , dpi = 900 , transparent = False , bbox_inches = 'tight' )","title":"Saving_instructions"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.__init__","text":"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - n_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - n_gdl : int Number of points considered in the GDL (computing parameter). - n_mpl : int Number of points considered in the MPL (computing parameter). - n_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values ( list , default: None ) \u2013 Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval ( list , default: None ) \u2013 Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. Source code in model/AlphaPEM.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def __init__ ( self , operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values = None , time_interval = None ): \"\"\"Initialise all parameters defining a fuel cell stack operation: nominal operating conditions, applied electrical load, dimensions, and undetermined variables. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - n_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). Wagc : float Width of the anode gas channel in m (accessible physical parameter). Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). Lgc : float Length of the gas channel in m (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - n_gdl : int Number of points considered in the GDL (computing parameter). - n_mpl : int Number of points considered in the MPL (computing parameter). - n_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). initial_variable_values : list, optional Initial values of the solver variables. The default is None, which implies that initial values are generated considering an equilibrium at the operating inputs without current. time_interval : list, optional Time intervals for numerical resolution. The default is None, which implies that it is automatically generated according to the data given in the current density parameters. \"\"\" # Initialize the operating inputs and parameters dictionaries. self . operating_inputs = operating_inputs self . current_parameters = current_parameters self . accessible_physical_parameters = accessible_physical_parameters self . undetermined_physical_parameters = undetermined_physical_parameters self . computing_parameters = computing_parameters self . parameters = { ** self . current_parameters , ** self . accessible_physical_parameters , ** self . undetermined_physical_parameters , ** self . computing_parameters } if self . operating_inputs [ 'Pa_des' ] < Pext or self . operating_inputs [ 'Pc_des' ] < Pext : raise ValueError ( 'The desired pressure is too low. It cannot be lower than the pressure outside the stack.' ) # Initialize the variables' dictionary. self . solver_variable_names = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_acl' , 'C_v_ccl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_acl' , 's_ccl' , 's_cmpl' , 's_cgdl' , 'lambda_acl' , 'lambda_mem' , 'lambda_ccl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_H2_acl' , 'C_O2_ccl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2_agc' , 'C_N2_cgc' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_acl' , 'T_mem' , 'T_ccl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' , 'eta_c' ] if self . parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" or \\ self . parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_anodic_recirculation\" : self . solver_variable_names . extend ([ 'Pasm' , 'Paem' , 'Pcsm' , 'Pcem' , 'Phi_asm' , 'Phi_aem' , 'Phi_csm' , 'Phi_cem' , 'Wcp' , 'Wa_inj' , 'Wc_inj' , 'Abp_a' , 'Abp_c' ]) self . solver_variable_names_extension () # Several points are considered in each GC, GDL and MPL. This must be # inserted into the solver_variable_names. self . all_variable_names = self . solver_variable_names + [ 't' , 'Ucell' , 'v_a_in' , 'v_c_in' , 'Pa_in' , 'Pc_in' ] + \\ [ 'Phi_a_des' , 'Phi_c_des' ] self . variables = { key : [] for key in self . all_variable_names } # Initialize the control_variables dictionary. self . control_variables = { 't_control_Phi' : 0 , 'Phi_a_des' : self . operating_inputs [ 'Phi_a_des' ], 'Phi_c_des' : self . operating_inputs [ 'Phi_c_des' ]} # Temporary action: simulations with auxiliaries are in reconstruction. if self . parameters [ 'type_auxiliary' ] != \"no_auxiliary\" : self . parameters [ 'type_auxiliary' ] == \"no_auxiliary\" print ( \"Auxiliary considerations are temporarily removed, as they require reconstruction.\" ) # Create the dynamic evolution. # Create time intervals if time_interval is not None : # Initial time interval may be given to the Simulator. self . time_interval = time_interval else : # If not, it is automatically generated. self . time_interval = self . _create_time_interval () # Create the initial variable values if initial_variable_values is not None : # Initial variable values may be given to the Simulator. self . initial_variable_values = initial_variable_values else : # If not, they are generated considering an equilibrium at the operating inputs without current. self . initial_variable_values = self . _create_initial_variable_values () # Resolution of the system of differential equations. event_negative . terminal = True # Integration is stopped if one of the crucial variables becomes negative. self . sol = solve_ivp ( dydt , self . time_interval , self . initial_variable_values , method = 'BDF' , rtol = self . parameters [ 'rtol' ], atol = self . parameters [ 'atol' ], events = event_negative , args = ( self . operating_inputs , self . parameters , self . solver_variable_names , self . control_variables )) # Recover the variable values calculated by the solver into the dictionary. self . _recovery () # Calculate the cell voltage after computing the internal states of the cell. self . variables [ \"Ucell\" ] . extend ( calculate_cell_voltage ( self . variables , self . operating_inputs , self . parameters ))","title":"__init__"},{"location":"functions/model/AlphaPEM/#model.AlphaPEM.AlphaPEM.solver_variable_names_extension","text":"Several points are considered in each GDL and must be inserted into the solver_variable_names. Source code in model/AlphaPEM.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def solver_variable_names_extension ( self ): \"\"\"Several points are considered in each GDL and must be inserted into the solver_variable_names. \"\"\" new_points_location = [ 'C_v_agc' , 'C_v_agdl' , 'C_v_ampl' , 'C_v_cmpl' , 'C_v_cgdl' , 'C_v_cgc' , 's_agdl' , 's_ampl' , 's_cmpl' , 's_cgdl' , 'C_H2_agc' , 'C_H2_agdl' , 'C_H2_ampl' , 'C_O2_cmpl' , 'C_O2_cgdl' , 'C_O2_cgc' , 'C_N2_agc' , 'C_N2_cgc' , 'T_agc' , 'T_agdl' , 'T_ampl' , 'T_cmpl' , 'T_cgdl' , 'T_cgc' ] for variable in new_points_location : index = self . solver_variable_names . index ( variable ) # Delete the previous points self . solver_variable_names . pop ( index ) # Increase the number of points if variable . endswith ( 'gc' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_gc' ] + 1 )] if variable . endswith ( 'gdl' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_gdl' ] + 1 )] elif variable . endswith ( 'mpl' ): self . solver_variable_names [ index : index ] = [ f ' { variable } _ { i } ' for i in range ( 1 , self . parameters [ 'nb_mpl' ] + 1 )]","title":"solver_variable_names_extension"},{"location":"functions/model/auxiliaries/","text":"Auxiliaries This file represents all the flows passing through the auxiliaries. It is a component of the fuel cell model. auxiliaries ( t , sv , control_variables , i_fc , Jv_agc_agdl , Jv_cgdl_cgc , J_H2_agc_agdl , J_O2_cgdl_cgc , operating_inputs , parameters ) This function calculates the flows passing through the auxiliaries. Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables ( dict ) \u2013 Variables controlled by the user. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). Jv_agc_agdl ( list ) \u2013 Vapor flow between the AGC and the AGDL at each GC node (mol.m-2.s-1). Jv_cgdl_cgc ( list ) \u2013 Vapor flow between the CGDL and the CGC at each GC node (mol.m-2.s-1). J_H2_agc_agdl ( list ) \u2013 H2 flow between the AGC and the AGDL at each GC node (mol.m-2.s-1). J_O2_cgdl_cgc ( list ) \u2013 O2 flow between the CGDL and the CGC at each GC node (mol.m-2.s-1). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Jv ( dict ) \u2013 Vapor flow between the different layers (mol.m-2.s-1). J_H2 ( dict ) \u2013 Hydrogen flow between the different layers (mol.m-2.s-1). J_O2 ( dict ) \u2013 Oxygen flow between the different layers (mol.m-2.s-1). J_N2 ( dict ) \u2013 Nitrogen flow between the different layers (mol.m-2.s-1). W ( dict ) \u2013 Global flows through the auxiliaries (mol.s-1). W_v ( dict ) \u2013 Vapor flows through the auxiliaries (mol.s-1). v_a_in ( float ) \u2013 Velocity evolution at the inlet of the anode (m.s-1). v_c_in ( float ) \u2013 Velocity evolution at the inlet of the cathode (m.s-1). Pa_in ( float ) \u2013 Inlet pressure at the anode side (Pa). Pc_in ( float ) \u2013 Inlet pressure at the cathode side (Pa). Source code in model/auxiliaries.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def auxiliaries ( t , sv , control_variables , i_fc , Jv_agc_agdl , Jv_cgdl_cgc , J_H2_agc_agdl , J_O2_cgdl_cgc , operating_inputs , parameters ): \"\"\"This function calculates the flows passing through the auxiliaries. Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables : dict Variables controlled by the user. i_fc : float Fuel cell current density at time t (A.m-2). Jv_agc_agdl : list Vapor flow between the AGC and the AGDL at each GC node (mol.m-2.s-1). Jv_cgdl_cgc : list Vapor flow between the CGDL and the CGC at each GC node (mol.m-2.s-1). J_H2_agc_agdl : list H2 flow between the AGC and the AGDL at each GC node (mol.m-2.s-1). J_O2_cgdl_cgc : list O2 flow between the CGDL and the CGC at each GC node (mol.m-2.s-1). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- Jv : dict Vapor flow between the different layers (mol.m-2.s-1). J_H2 : dict Hydrogen flow between the different layers (mol.m-2.s-1). J_O2 : dict Oxygen flow between the different layers (mol.m-2.s-1). J_N2 : dict Nitrogen flow between the different layers (mol.m-2.s-1). W : dict Global flows through the auxiliaries (mol.s-1). W_v : dict Vapor flows through the auxiliaries (mol.s-1). v_a_in : float Velocity evolution at the inlet of the anode (m.s-1). v_c_in : float Velocity evolution at the inlet of the cathode (m.s-1). Pa_in : float Inlet pressure at the anode side (Pa). Pc_in : float Inlet pressure at the cathode side (Pa). \"\"\" # __________________________________________________Preliminaries___________________________________________________ # Extraction of the variables Pasm , Paem , Pcsm , Pcem = sv . get ( 'Pasm' , None ), sv . get ( 'Paem' , None ), sv . get ( 'Pcsm' , None ), sv . get ( 'Pcem' , None ) Phi_asm , Phi_aem = sv . get ( 'Phi_asm' , None ), sv . get ( 'Phi_aem' , None ) Phi_csm , Phi_cem = sv . get ( 'Phi_csm' , None ), sv . get ( 'Phi_cem' , None ) Wcp , Wa_inj , Wc_inj = sv . get ( 'Wcp' , None ), sv . get ( 'Wa_inj' , None ), sv . get ( 'Wc_inj' , None ) # Extraction of the operating inputs and the parameters T_des , Phi_a_des , Phi_c_des = operating_inputs [ 'T_des' ], operating_inputs [ 'Phi_a_des' ], operating_inputs [ 'Phi_c_des' ] Sa , Sc , y_H2_in = operating_inputs [ 'Sa' ], operating_inputs [ 'Sc' ], operating_inputs [ 'y_H2_in' ] Aact , nb_cell , Hagc , Hcgc = parameters [ 'Aact' ], parameters [ 'nb_cell' ], parameters [ 'Hagc' ], parameters [ 'Hcgc' ] Wagc , Wcgc , nb_channel_in_gc = parameters [ 'Wagc' ], parameters [ 'Wcgc' ], parameters [ 'nb_channel_in_gc' ] A_T_a , A_T_c = parameters [ 'A_T_a' ], parameters [ 'A_T_c' ] nb_gc , type_auxiliary = parameters [ 'nb_gc' ], parameters [ 'type_auxiliary' ] # Intermediate values # Commun intermediate values with dif_eq_modules.py which allows to avoid redundant calculations P , Phi , y_H2 , y_O2 , M , rho , k_purge , Abp_a , Abp_c , mu_gaz , i_n = \\ auxiliaries_int_values_which_are_commun_with_dif_eq ( t , sv , operating_inputs , parameters ) v_a , v_c , Pa_in , Pc_in = calculate_velocity_evolution ( sv , control_variables , i_fc , i_n , Jv_agc_agdl , Jv_cgdl_cgc , J_H2_agc_agdl , J_O2_cgdl_cgc , operating_inputs , parameters , mu_gaz ) W_des = desired_flows ( sv , control_variables , i_fc , i_n , Pa_in , Pc_in , operating_inputs , parameters ) # _________________________________________Inlet and outlet global flows____________________________________________ \"\"\"Global flows here refer to flows that integrate all the chemical species circulating together. Slight differences are to be noted in the expression of these flows depending on the type of auxiliary selected. \"\"\" # Anode flow through the auxiliaries in mol.s-1 if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Wa_in = rho_asm_in_to_asm * v_a * A_T_a # Wasm_to_asm_out = rho_asm_to_asm_out * v_a * Hagc * Wagc # Wasm_out_to_agc = rho_asm_out_to_agc * v_a * Hagc * Wagc # Wagc_to_aem_in = rho_agc_to_aem_in * v_a * Hagc * Wagc # Waem_in_to_aem = rho_aem_in_to_aem * v_a * Hagc * Wagc # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # Attention: pr\u00e9voir un d\u00e9bit minimal pour la pompe, comme les d\u00e9bits entrants. # Ware = Maem_out_re * (Paem_out_re / (Paem_out_re - Phi_aem_out_re * Psat(T_des))) * \\ # (Sa - 1) * i_fc / (2 * F) * (nb_cell * Aact) # The pump exactly compensates the pressure drop. # Wasm_in_re_to_asm = rho_asm_in_re_to_asm * v_a * A_T_a # Waem_to_aem_out_re = rho_aem_to_aem_out_re * v_a * A_T_a # Waem_to_aem_out = k_purge * rho_aem_to_aem_out * v_a * A_T_a # Wa_out = k_purge * rho_aem_out_to_ext * v_a * A_T_a # else: # type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\": # Ware = None # Wasm_in_re_to_asm = None # Waem_to_aem_out_re = None # Waem_to_aem_out = rho_aem_to_aem_out * v_a * Abp_a # Wa_out = rho_aem_out_to_ext * v_a * Abp_a else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): Wa_in = W_des [ 'H2' ] + W_des [ 'H2O_inj_a' ] # This expression is also present in calculate_velocity_evolution. Wa_out = P [ f 'agc_ { nb_gc } ' ] / ( R * T_des ) * v_a [ nb_gc ] * Hagc * Wagc * nb_cell * nb_channel_in_gc Ware , Wasm_to_agc , Wagc_to_aem = [ None ] * 3 # Anode flow entering/leaving the stack in mol.m-2.s-1 if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Ja_in = 0 # Ja_out = 0 else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): Ja_in = Wa_in / ( Hagc * Wagc ) / nb_cell / nb_channel_in_gc # This expression is also present in calculate_velocity_evolution. Ja_out = Wa_out / ( Hagc * Wagc ) / nb_cell / nb_channel_in_gc # Cathode flow through the auxiliaries in mol.s-1 if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Wc_in = rho_csm_in_to_csm * v_c * A_T_c # Wcsm_to_csm_out = rho_csm_to_csm_out * v_c * Hcgc * Wcgc # Wcsm_out_to_cgc = rho_csm_out_to_cgc * v_c * Hcgc * Wcgc # Wcgc_to_cem_in = rho_cgc_to_cem_in * v_c * Hcgc * Wcgc # Wcem_in_to_cem = rho_cem_in_to_cem * v_c * Hcgc * Wcgc # Wcem_to_cem_out = rho_cem_to_cem_out * v_c * Abp_c # Wc_out = rho_cem_out_to_ext * v_c * Abp_c else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): Wc_in = W_des [ 'dry_air' ] + W_des [ 'H2O_inj_c' ] # This expression is also present in calculate_velocity_evolution. Wc_out = P [ f 'cgc_ { nb_gc } ' ] / ( R * T_des ) * v_c [ nb_gc ] * Hcgc * Wcgc * nb_cell * nb_channel_in_gc Wcsm_to_cgc , Wcgc_to_cem = [ None ] * 2 # Cathode flow entering/leaving the stack in mol.m-2.s-1 Jc_in = Wc_in / ( Hcgc * Wcgc ) / nb_cell / nb_channel_in_gc # This expression is also present in calculate_velocity_evolution. Jc_out = Wc_out / ( Hcgc * Wcgc ) / nb_cell / nb_channel_in_gc # ________________________________________Inlet and outlet specific flows___________________________________________ \"\"\"Specific flows here refer to flows that integrate only a single chemical species within the ensemble of species circulating together. For example, only the water vapor flow within the ensemble of hydrogen and water vapor. \"\"\" # Vapor flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Jv_agc_in = Phi_asm * Psat(T_des) / Pasm * Ja_in else : # elif type_auxiliary == \"no_auxiliary\": Jv_agc_in = Phi_a_des * Psat ( T_des ) / Pa_in * Ja_in Jv_agc_agc = [ None ] + [ sv [ f 'C_v_agc_ { i } ' ] * v_a [ i ] for i in range ( 1 , nb_gc )] Jv_agc_out = sv [ f 'C_v_agc_ { nb_gc } ' ] * R * T_des / P [ f 'agc_ { nb_gc } ' ] * Ja_out if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Jv_cgc_in = Phi_csm * Psat(T_des) / Pcsm * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": Jv_cgc_in = Phi_c_des * Psat ( T_des ) / Pc_in * Jc_in Jv_cgc_cgc = [ None ] + [ sv [ f 'C_v_cgc_ { i } ' ] * v_c [ i ] for i in range ( 1 , nb_gc )] Jv_cgc_out = sv [ f 'C_v_cgc_ { nb_gc } ' ] * R * T_des / P [ f 'cgc_ { nb_gc } ' ] * Jc_out # H2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # J_H2_agc_in = y_H2['asm_out'] * (1 - Phi_asm_out_to_agc * Psat(T_des) / Pasm_out_to_agc) * Ja_in # J_H2_agc_agc = None # J_H2_agc_out = y_H2_agc * (1 - Phi_agc_to_aem_in * Psat(T_des) / Pagc_to_aem_in) * Ja_out else : # elif type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or type_auxiliary == \"no_auxiliary\": J_H2_agc_in = ( 1 - Phi_a_des * Psat ( T_des ) / Pa_in ) * Ja_in J_H2_agc_agc = [ None ] + [ sv [ f 'C_H2_agc_ { i } ' ] * v_a [ i ] for i in range ( 1 , nb_gc )] J_H2_agc_out = sv [ f 'C_H2_agc_ { nb_gc } ' ] * R * T_des / P [ f 'agc_ { nb_gc } ' ] * Ja_out # O2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # J_O2_cgc_in = y_O2_csm * (1 - Phi_csm * Psat(T_des) / Pcsm) * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": J_O2_cgc_in = y_O2_ext * ( 1 - Phi_c_des * Psat ( T_des ) / Pc_in ) * Jc_in J_O2_cgc_cgc = [ None ] + [ sv [ f 'C_O2_cgc_ { i } ' ] * v_c [ i ] for i in range ( 1 , nb_gc )] J_O2_cgc_out = sv [ f 'C_O2_cgc_ { nb_gc } ' ] * R * T_des / P [ f 'cgc_ { nb_gc } ' ] * Jc_out # N2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # J_N2_agc_in = (1 - y_H2['asm_out']) * (1 - Phi_asm_out_to_agc * Psat(T_des) / Pasm_out_to_agc) * Ja_in # J_N2_agc_out = (1 - y_H2_agc) * (1 - Phi_agc_to_aem_in * Psat(T_des) / Pagc_to_aem_in) * Ja_out # J_N2_cgc_in = (1 - y_O2_csm_out_to_cgc) * (1 - Phi_csm_out_to_cgc * Psat(T_des) / Pcsm_out_to_cgc) * Jc_in # J_N2_cgc_out = (1 - y_O2_cgc_to_cem_in) * (1 - Phi_cgc_to_cem_in * Psat(T_des) / Pcgc_to_cem_in) * Jc_out else : # elif type_auxiliary == \"no_auxiliary\": J_N2_agc_in = 0 J_N2_agc_agc = [ None ] + [ 0 ] * ( nb_gc - 1 ) J_N2_agc_out = 0 J_N2_cgc_in = ( 1 - y_O2_ext ) * ( 1 - Phi_c_des * Psat ( T_des ) / Pc_in ) * Jc_in J_N2_cgc_cgc = [ None ] + [ sv [ f 'C_N2_cgc_ { i } ' ] * v_c [ i ] for i in range ( 1 , nb_gc )] J_N2_cgc_out = sv [ f 'C_N2_cgc_ { nb_gc } ' ] * R * T_des / P [ f 'cgc_ { nb_gc } ' ] * Jc_out # Vapor flows at the manifold (mol.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Wv_asm_in_to_asm = Phi_asm_in_to_asm * Psat(T_des) / Pasm_in_to_asm * Wa_in # Wv_asm_to_asm_out = Phi_asm_to_asm_out * Psat(T_des) / Pasm_to_asm_out * Wasm_to_asm_out # Wv_asm_out_to_agc = Phi_asm_out_to_agc * Psat(T_des) / Pasm_out_to_agc * Wasm_out_to_agc # Wv_agc_to_aem_in = Phi_agc_to_aem_in * Psat(T_des) / Pagc_to_aem_in * Wagc_to_aem_in # Wv_aem_in_to_aem = Phi_aem_in_to_aem * Psat(T_des) / Paem_in_to_aem * Waem_in_to_aem # Wv_aem_to_aem_out = Phi_aem_to_aem_out * Psat(T_des) / Paem_to_aem_out * Waem_to_aem_out # Wv_a_out = Phi_aem_out * Psat(T_des) / Paem_out * Wa_out # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # # At the anode side # Wv_asm_ext_to_in = 0 # Wv_asm_in_re_to_asm = Phi_asm_in_re_to_asm * Psat(T_des) / Pasm_in_re_to_asm * Wasm_in_re_to_asm # Wv_aem_to_aem_out_re = Phi_aem_to_aem_out_re * Psat(T_des) / Paem_to_aem_out_re * Waem_to_aem_out_re # Wv_are = Phi_aem_out_re * Psat(T_des) / Paem_out_re * (Ware / M['aem_out_re']) # The pump exactly compensates the pressure drop. # else: # type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\": # # At the anode side # Wv_asm_ext_to_in = Wa_inj / M_H2O # Wv_asm_in_re_to_asm = None # Wv_aem_to_aem_out_re = None # Wv_are = None # # At the cathode side # Wv_csm_ext_to_in = Phi_ext * Psat(Text) / Pext * (Wcp / M['ext']) + Wc_inj / M_H2O # Wv_csm_in_to_csm = Phi_csm_in_to_csm * Psat(T_des) / Pcsm_in_to_csm * Wc_in # Wv_csm_to_csm_out = Phi_csm_to_csm_out * Psat(T_des) / Pcsm_to_csm_out * Wcsm_to_csm_out # Wv_csm_out_to_cgc = Phi_csm_out_to_cgc * Psat(T_des) / Pcsm_out_to_cgc * Wcsm_out_to_cgc # Wv_cgc_to_cem_in = Phi_cgc_to_cem_in * Psat(T_des) / Pcgc_to_cem_in * Wcgc_to_cem_in # Wv_cem_in_to_cem = Phi_cem_in_to_cem * Psat(T_des) / Pcem_in_to_cem * Wcem_in_to_cem # Wv_cem_to_cem_out = Phi_cem_to_cem_out * Psat(T_des) / Pcem_to_cem_out * Wcem_to_cem_out # Wv_c_out = Phi_cem_out * Psat(T_des) / Pcem_out * Wc_out else : # elif type_auxiliary == \"no_auxiliary\": Wv_are , Wv_a_in , Wv_asm_to_agc , Wv_agc_to_aem , Wv_a_out = [ None ] * 5 Wv_c_in , Wv_csm_to_cgc , Wv_cgc_to_cem , Wv_c_out = [ None ] * 4 return { 'Jv' : { 'agc_in' : Jv_agc_in , 'agc_agc' : Jv_agc_agc , 'agc_out' : Jv_agc_out , 'cgc_in' : Jv_cgc_in , 'cgc_cgc' : Jv_cgc_cgc , 'cgc_out' : Jv_cgc_out }, 'J_H2' : { 'agc_in' : J_H2_agc_in , 'agc_agc' : J_H2_agc_agc , 'agc_out' : J_H2_agc_out }, 'J_O2' : { 'cgc_in' : J_O2_cgc_in , 'cgc_cgc' : J_O2_cgc_cgc , 'cgc_out' : J_O2_cgc_out }, 'J_N2' : { 'agc_in' : J_N2_agc_in , 'agc_agc' : J_N2_agc_agc , 'agc_out' : J_N2_agc_out , 'cgc_in' : J_N2_cgc_in , 'cgc_cgc' : J_N2_cgc_cgc , 'cgc_out' : J_N2_cgc_out }, 'W' : { 'are' : Ware , 'a_in' : Wa_in , 'asm_to_agc' : Wasm_to_agc , 'agc_to_aem' : Wagc_to_aem , 'a_out' : Wa_out , 'c_in' : Wc_in , 'csm_to_cgc' : Wcsm_to_cgc , 'cgc_to_cem' : Wcgc_to_cem , 'c_out' : Wc_out }, 'W_v' : { 'a_in' : Wv_a_in , 'are' : Wv_are , 'asm_to_agc' : Wv_asm_to_agc , 'agc_to_aem' : Wv_agc_to_aem , 'a_out' : Wv_a_out , 'c_in' : Wv_c_in , 'csm_to_cgc' : Wv_csm_to_cgc , 'cgc_to_cem' : Wv_cgc_to_cem , 'c_out' : Wv_c_out }, 'v_a_in' : v_a [ 0 ], 'v_c_in' : v_c [ 0 ], 'Pa_in' : Pa_in , 'Pc_in' : Pc_in }","title":"Auxiliaries"},{"location":"functions/model/auxiliaries/#auxiliaries","text":"This file represents all the flows passing through the auxiliaries. It is a component of the fuel cell model.","title":"Auxiliaries"},{"location":"functions/model/auxiliaries/#model.auxiliaries.auxiliaries","text":"This function calculates the flows passing through the auxiliaries. Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables ( dict ) \u2013 Variables controlled by the user. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). Jv_agc_agdl ( list ) \u2013 Vapor flow between the AGC and the AGDL at each GC node (mol.m-2.s-1). Jv_cgdl_cgc ( list ) \u2013 Vapor flow between the CGDL and the CGC at each GC node (mol.m-2.s-1). J_H2_agc_agdl ( list ) \u2013 H2 flow between the AGC and the AGDL at each GC node (mol.m-2.s-1). J_O2_cgdl_cgc ( list ) \u2013 O2 flow between the CGDL and the CGC at each GC node (mol.m-2.s-1). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Jv ( dict ) \u2013 Vapor flow between the different layers (mol.m-2.s-1). J_H2 ( dict ) \u2013 Hydrogen flow between the different layers (mol.m-2.s-1). J_O2 ( dict ) \u2013 Oxygen flow between the different layers (mol.m-2.s-1). J_N2 ( dict ) \u2013 Nitrogen flow between the different layers (mol.m-2.s-1). W ( dict ) \u2013 Global flows through the auxiliaries (mol.s-1). W_v ( dict ) \u2013 Vapor flows through the auxiliaries (mol.s-1). v_a_in ( float ) \u2013 Velocity evolution at the inlet of the anode (m.s-1). v_c_in ( float ) \u2013 Velocity evolution at the inlet of the cathode (m.s-1). Pa_in ( float ) \u2013 Inlet pressure at the anode side (Pa). Pc_in ( float ) \u2013 Inlet pressure at the cathode side (Pa). Source code in model/auxiliaries.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def auxiliaries ( t , sv , control_variables , i_fc , Jv_agc_agdl , Jv_cgdl_cgc , J_H2_agc_agdl , J_O2_cgdl_cgc , operating_inputs , parameters ): \"\"\"This function calculates the flows passing through the auxiliaries. Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. control_variables : dict Variables controlled by the user. i_fc : float Fuel cell current density at time t (A.m-2). Jv_agc_agdl : list Vapor flow between the AGC and the AGDL at each GC node (mol.m-2.s-1). Jv_cgdl_cgc : list Vapor flow between the CGDL and the CGC at each GC node (mol.m-2.s-1). J_H2_agc_agdl : list H2 flow between the AGC and the AGDL at each GC node (mol.m-2.s-1). J_O2_cgdl_cgc : list O2 flow between the CGDL and the CGC at each GC node (mol.m-2.s-1). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- Jv : dict Vapor flow between the different layers (mol.m-2.s-1). J_H2 : dict Hydrogen flow between the different layers (mol.m-2.s-1). J_O2 : dict Oxygen flow between the different layers (mol.m-2.s-1). J_N2 : dict Nitrogen flow between the different layers (mol.m-2.s-1). W : dict Global flows through the auxiliaries (mol.s-1). W_v : dict Vapor flows through the auxiliaries (mol.s-1). v_a_in : float Velocity evolution at the inlet of the anode (m.s-1). v_c_in : float Velocity evolution at the inlet of the cathode (m.s-1). Pa_in : float Inlet pressure at the anode side (Pa). Pc_in : float Inlet pressure at the cathode side (Pa). \"\"\" # __________________________________________________Preliminaries___________________________________________________ # Extraction of the variables Pasm , Paem , Pcsm , Pcem = sv . get ( 'Pasm' , None ), sv . get ( 'Paem' , None ), sv . get ( 'Pcsm' , None ), sv . get ( 'Pcem' , None ) Phi_asm , Phi_aem = sv . get ( 'Phi_asm' , None ), sv . get ( 'Phi_aem' , None ) Phi_csm , Phi_cem = sv . get ( 'Phi_csm' , None ), sv . get ( 'Phi_cem' , None ) Wcp , Wa_inj , Wc_inj = sv . get ( 'Wcp' , None ), sv . get ( 'Wa_inj' , None ), sv . get ( 'Wc_inj' , None ) # Extraction of the operating inputs and the parameters T_des , Phi_a_des , Phi_c_des = operating_inputs [ 'T_des' ], operating_inputs [ 'Phi_a_des' ], operating_inputs [ 'Phi_c_des' ] Sa , Sc , y_H2_in = operating_inputs [ 'Sa' ], operating_inputs [ 'Sc' ], operating_inputs [ 'y_H2_in' ] Aact , nb_cell , Hagc , Hcgc = parameters [ 'Aact' ], parameters [ 'nb_cell' ], parameters [ 'Hagc' ], parameters [ 'Hcgc' ] Wagc , Wcgc , nb_channel_in_gc = parameters [ 'Wagc' ], parameters [ 'Wcgc' ], parameters [ 'nb_channel_in_gc' ] A_T_a , A_T_c = parameters [ 'A_T_a' ], parameters [ 'A_T_c' ] nb_gc , type_auxiliary = parameters [ 'nb_gc' ], parameters [ 'type_auxiliary' ] # Intermediate values # Commun intermediate values with dif_eq_modules.py which allows to avoid redundant calculations P , Phi , y_H2 , y_O2 , M , rho , k_purge , Abp_a , Abp_c , mu_gaz , i_n = \\ auxiliaries_int_values_which_are_commun_with_dif_eq ( t , sv , operating_inputs , parameters ) v_a , v_c , Pa_in , Pc_in = calculate_velocity_evolution ( sv , control_variables , i_fc , i_n , Jv_agc_agdl , Jv_cgdl_cgc , J_H2_agc_agdl , J_O2_cgdl_cgc , operating_inputs , parameters , mu_gaz ) W_des = desired_flows ( sv , control_variables , i_fc , i_n , Pa_in , Pc_in , operating_inputs , parameters ) # _________________________________________Inlet and outlet global flows____________________________________________ \"\"\"Global flows here refer to flows that integrate all the chemical species circulating together. Slight differences are to be noted in the expression of these flows depending on the type of auxiliary selected. \"\"\" # Anode flow through the auxiliaries in mol.s-1 if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Wa_in = rho_asm_in_to_asm * v_a * A_T_a # Wasm_to_asm_out = rho_asm_to_asm_out * v_a * Hagc * Wagc # Wasm_out_to_agc = rho_asm_out_to_agc * v_a * Hagc * Wagc # Wagc_to_aem_in = rho_agc_to_aem_in * v_a * Hagc * Wagc # Waem_in_to_aem = rho_aem_in_to_aem * v_a * Hagc * Wagc # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # Attention: pr\u00e9voir un d\u00e9bit minimal pour la pompe, comme les d\u00e9bits entrants. # Ware = Maem_out_re * (Paem_out_re / (Paem_out_re - Phi_aem_out_re * Psat(T_des))) * \\ # (Sa - 1) * i_fc / (2 * F) * (nb_cell * Aact) # The pump exactly compensates the pressure drop. # Wasm_in_re_to_asm = rho_asm_in_re_to_asm * v_a * A_T_a # Waem_to_aem_out_re = rho_aem_to_aem_out_re * v_a * A_T_a # Waem_to_aem_out = k_purge * rho_aem_to_aem_out * v_a * A_T_a # Wa_out = k_purge * rho_aem_out_to_ext * v_a * A_T_a # else: # type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\": # Ware = None # Wasm_in_re_to_asm = None # Waem_to_aem_out_re = None # Waem_to_aem_out = rho_aem_to_aem_out * v_a * Abp_a # Wa_out = rho_aem_out_to_ext * v_a * Abp_a else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): Wa_in = W_des [ 'H2' ] + W_des [ 'H2O_inj_a' ] # This expression is also present in calculate_velocity_evolution. Wa_out = P [ f 'agc_ { nb_gc } ' ] / ( R * T_des ) * v_a [ nb_gc ] * Hagc * Wagc * nb_cell * nb_channel_in_gc Ware , Wasm_to_agc , Wagc_to_aem = [ None ] * 3 # Anode flow entering/leaving the stack in mol.m-2.s-1 if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Ja_in = 0 # Ja_out = 0 else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): Ja_in = Wa_in / ( Hagc * Wagc ) / nb_cell / nb_channel_in_gc # This expression is also present in calculate_velocity_evolution. Ja_out = Wa_out / ( Hagc * Wagc ) / nb_cell / nb_channel_in_gc # Cathode flow through the auxiliaries in mol.s-1 if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Wc_in = rho_csm_in_to_csm * v_c * A_T_c # Wcsm_to_csm_out = rho_csm_to_csm_out * v_c * Hcgc * Wcgc # Wcsm_out_to_cgc = rho_csm_out_to_cgc * v_c * Hcgc * Wcgc # Wcgc_to_cem_in = rho_cgc_to_cem_in * v_c * Hcgc * Wcgc # Wcem_in_to_cem = rho_cem_in_to_cem * v_c * Hcgc * Wcgc # Wcem_to_cem_out = rho_cem_to_cem_out * v_c * Abp_c # Wc_out = rho_cem_out_to_ext * v_c * Abp_c else : # elif type_auxiliary == \"no_auxiliary\" (only 1 cell): Wc_in = W_des [ 'dry_air' ] + W_des [ 'H2O_inj_c' ] # This expression is also present in calculate_velocity_evolution. Wc_out = P [ f 'cgc_ { nb_gc } ' ] / ( R * T_des ) * v_c [ nb_gc ] * Hcgc * Wcgc * nb_cell * nb_channel_in_gc Wcsm_to_cgc , Wcgc_to_cem = [ None ] * 2 # Cathode flow entering/leaving the stack in mol.m-2.s-1 Jc_in = Wc_in / ( Hcgc * Wcgc ) / nb_cell / nb_channel_in_gc # This expression is also present in calculate_velocity_evolution. Jc_out = Wc_out / ( Hcgc * Wcgc ) / nb_cell / nb_channel_in_gc # ________________________________________Inlet and outlet specific flows___________________________________________ \"\"\"Specific flows here refer to flows that integrate only a single chemical species within the ensemble of species circulating together. For example, only the water vapor flow within the ensemble of hydrogen and water vapor. \"\"\" # Vapor flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Jv_agc_in = Phi_asm * Psat(T_des) / Pasm * Ja_in else : # elif type_auxiliary == \"no_auxiliary\": Jv_agc_in = Phi_a_des * Psat ( T_des ) / Pa_in * Ja_in Jv_agc_agc = [ None ] + [ sv [ f 'C_v_agc_ { i } ' ] * v_a [ i ] for i in range ( 1 , nb_gc )] Jv_agc_out = sv [ f 'C_v_agc_ { nb_gc } ' ] * R * T_des / P [ f 'agc_ { nb_gc } ' ] * Ja_out if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Jv_cgc_in = Phi_csm * Psat(T_des) / Pcsm * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": Jv_cgc_in = Phi_c_des * Psat ( T_des ) / Pc_in * Jc_in Jv_cgc_cgc = [ None ] + [ sv [ f 'C_v_cgc_ { i } ' ] * v_c [ i ] for i in range ( 1 , nb_gc )] Jv_cgc_out = sv [ f 'C_v_cgc_ { nb_gc } ' ] * R * T_des / P [ f 'cgc_ { nb_gc } ' ] * Jc_out # H2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # J_H2_agc_in = y_H2['asm_out'] * (1 - Phi_asm_out_to_agc * Psat(T_des) / Pasm_out_to_agc) * Ja_in # J_H2_agc_agc = None # J_H2_agc_out = y_H2_agc * (1 - Phi_agc_to_aem_in * Psat(T_des) / Pagc_to_aem_in) * Ja_out else : # elif type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or type_auxiliary == \"no_auxiliary\": J_H2_agc_in = ( 1 - Phi_a_des * Psat ( T_des ) / Pa_in ) * Ja_in J_H2_agc_agc = [ None ] + [ sv [ f 'C_H2_agc_ { i } ' ] * v_a [ i ] for i in range ( 1 , nb_gc )] J_H2_agc_out = sv [ f 'C_H2_agc_ { nb_gc } ' ] * R * T_des / P [ f 'agc_ { nb_gc } ' ] * Ja_out # O2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # J_O2_cgc_in = y_O2_csm * (1 - Phi_csm * Psat(T_des) / Pcsm) * Jc_in else : # elif type_auxiliary == \"no_auxiliary\": J_O2_cgc_in = y_O2_ext * ( 1 - Phi_c_des * Psat ( T_des ) / Pc_in ) * Jc_in J_O2_cgc_cgc = [ None ] + [ sv [ f 'C_O2_cgc_ { i } ' ] * v_c [ i ] for i in range ( 1 , nb_gc )] J_O2_cgc_out = sv [ f 'C_O2_cgc_ { nb_gc } ' ] * R * T_des / P [ f 'cgc_ { nb_gc } ' ] * Jc_out # N2 flows at the GC (mol.m-2.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # J_N2_agc_in = (1 - y_H2['asm_out']) * (1 - Phi_asm_out_to_agc * Psat(T_des) / Pasm_out_to_agc) * Ja_in # J_N2_agc_out = (1 - y_H2_agc) * (1 - Phi_agc_to_aem_in * Psat(T_des) / Pagc_to_aem_in) * Ja_out # J_N2_cgc_in = (1 - y_O2_csm_out_to_cgc) * (1 - Phi_csm_out_to_cgc * Psat(T_des) / Pcsm_out_to_cgc) * Jc_in # J_N2_cgc_out = (1 - y_O2_cgc_to_cem_in) * (1 - Phi_cgc_to_cem_in * Psat(T_des) / Pcgc_to_cem_in) * Jc_out else : # elif type_auxiliary == \"no_auxiliary\": J_N2_agc_in = 0 J_N2_agc_agc = [ None ] + [ 0 ] * ( nb_gc - 1 ) J_N2_agc_out = 0 J_N2_cgc_in = ( 1 - y_O2_ext ) * ( 1 - Phi_c_des * Psat ( T_des ) / Pc_in ) * Jc_in J_N2_cgc_cgc = [ None ] + [ sv [ f 'C_N2_cgc_ { i } ' ] * v_c [ i ] for i in range ( 1 , nb_gc )] J_N2_cgc_out = sv [ f 'C_N2_cgc_ { nb_gc } ' ] * R * T_des / P [ f 'cgc_ { nb_gc } ' ] * Jc_out # Vapor flows at the manifold (mol.s-1) if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\" or \\ type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" : pass # Wv_asm_in_to_asm = Phi_asm_in_to_asm * Psat(T_des) / Pasm_in_to_asm * Wa_in # Wv_asm_to_asm_out = Phi_asm_to_asm_out * Psat(T_des) / Pasm_to_asm_out * Wasm_to_asm_out # Wv_asm_out_to_agc = Phi_asm_out_to_agc * Psat(T_des) / Pasm_out_to_agc * Wasm_out_to_agc # Wv_agc_to_aem_in = Phi_agc_to_aem_in * Psat(T_des) / Pagc_to_aem_in * Wagc_to_aem_in # Wv_aem_in_to_aem = Phi_aem_in_to_aem * Psat(T_des) / Paem_in_to_aem * Waem_in_to_aem # Wv_aem_to_aem_out = Phi_aem_to_aem_out * Psat(T_des) / Paem_to_aem_out * Waem_to_aem_out # Wv_a_out = Phi_aem_out * Psat(T_des) / Paem_out * Wa_out # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # # At the anode side # Wv_asm_ext_to_in = 0 # Wv_asm_in_re_to_asm = Phi_asm_in_re_to_asm * Psat(T_des) / Pasm_in_re_to_asm * Wasm_in_re_to_asm # Wv_aem_to_aem_out_re = Phi_aem_to_aem_out_re * Psat(T_des) / Paem_to_aem_out_re * Waem_to_aem_out_re # Wv_are = Phi_aem_out_re * Psat(T_des) / Paem_out_re * (Ware / M['aem_out_re']) # The pump exactly compensates the pressure drop. # else: # type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\": # # At the anode side # Wv_asm_ext_to_in = Wa_inj / M_H2O # Wv_asm_in_re_to_asm = None # Wv_aem_to_aem_out_re = None # Wv_are = None # # At the cathode side # Wv_csm_ext_to_in = Phi_ext * Psat(Text) / Pext * (Wcp / M['ext']) + Wc_inj / M_H2O # Wv_csm_in_to_csm = Phi_csm_in_to_csm * Psat(T_des) / Pcsm_in_to_csm * Wc_in # Wv_csm_to_csm_out = Phi_csm_to_csm_out * Psat(T_des) / Pcsm_to_csm_out * Wcsm_to_csm_out # Wv_csm_out_to_cgc = Phi_csm_out_to_cgc * Psat(T_des) / Pcsm_out_to_cgc * Wcsm_out_to_cgc # Wv_cgc_to_cem_in = Phi_cgc_to_cem_in * Psat(T_des) / Pcgc_to_cem_in * Wcgc_to_cem_in # Wv_cem_in_to_cem = Phi_cem_in_to_cem * Psat(T_des) / Pcem_in_to_cem * Wcem_in_to_cem # Wv_cem_to_cem_out = Phi_cem_to_cem_out * Psat(T_des) / Pcem_to_cem_out * Wcem_to_cem_out # Wv_c_out = Phi_cem_out * Psat(T_des) / Pcem_out * Wc_out else : # elif type_auxiliary == \"no_auxiliary\": Wv_are , Wv_a_in , Wv_asm_to_agc , Wv_agc_to_aem , Wv_a_out = [ None ] * 5 Wv_c_in , Wv_csm_to_cgc , Wv_cgc_to_cem , Wv_c_out = [ None ] * 4 return { 'Jv' : { 'agc_in' : Jv_agc_in , 'agc_agc' : Jv_agc_agc , 'agc_out' : Jv_agc_out , 'cgc_in' : Jv_cgc_in , 'cgc_cgc' : Jv_cgc_cgc , 'cgc_out' : Jv_cgc_out }, 'J_H2' : { 'agc_in' : J_H2_agc_in , 'agc_agc' : J_H2_agc_agc , 'agc_out' : J_H2_agc_out }, 'J_O2' : { 'cgc_in' : J_O2_cgc_in , 'cgc_cgc' : J_O2_cgc_cgc , 'cgc_out' : J_O2_cgc_out }, 'J_N2' : { 'agc_in' : J_N2_agc_in , 'agc_agc' : J_N2_agc_agc , 'agc_out' : J_N2_agc_out , 'cgc_in' : J_N2_cgc_in , 'cgc_cgc' : J_N2_cgc_cgc , 'cgc_out' : J_N2_cgc_out }, 'W' : { 'are' : Ware , 'a_in' : Wa_in , 'asm_to_agc' : Wasm_to_agc , 'agc_to_aem' : Wagc_to_aem , 'a_out' : Wa_out , 'c_in' : Wc_in , 'csm_to_cgc' : Wcsm_to_cgc , 'cgc_to_cem' : Wcgc_to_cem , 'c_out' : Wc_out }, 'W_v' : { 'a_in' : Wv_a_in , 'are' : Wv_are , 'asm_to_agc' : Wv_asm_to_agc , 'agc_to_aem' : Wv_agc_to_aem , 'a_out' : Wv_a_out , 'c_in' : Wv_c_in , 'csm_to_cgc' : Wv_csm_to_cgc , 'cgc_to_cem' : Wv_cgc_to_cem , 'c_out' : Wv_c_out }, 'v_a_in' : v_a [ 0 ], 'v_c_in' : v_c [ 0 ], 'Pa_in' : Pa_in , 'Pc_in' : Pc_in }","title":"auxiliaries"},{"location":"functions/model/cell_voltage/","text":"Cell voltage This file represents the equations for calculating the cell voltage. It is a component of the fuel cell model. calculate_cell_voltage ( variables , operating_inputs , parameters ) This function calculates the cell voltage at each time step. Parameters: variables ( dict ) \u2013 The dictionary containing the variables calculated by the solver. operating_inputs ( dict ) \u2013 The dictionary containing the operating inputs. parameters ( dict ) \u2013 The dictionary containing the parameters. Returns: Ucell_t ( list ) \u2013 The cell voltage at each time step. Source code in model/cell_voltage.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def calculate_cell_voltage ( variables , operating_inputs , parameters ): \"\"\"This function calculates the cell voltage at each time step. Parameters ---------- variables : dict The dictionary containing the variables calculated by the solver. operating_inputs : dict The dictionary containing the operating inputs. parameters : dict The dictionary containing the parameters. Returns ------- Ucell_t : list The cell voltage at each time step. \"\"\" # Extraction of the variables t , lambda_mem_t , lambda_ccl_t = variables [ 't' ], variables [ 'lambda_mem' ], variables [ 'lambda_ccl' ] C_H2_acl_t , C_O2_ccl_t , eta_c_t = variables [ 'C_H2_acl' ], variables [ 'C_O2_ccl' ], variables [ 'eta_c' ] T_acl_t , T_mem_t , T_ccl_t = variables [ 'T_acl' ], variables [ 'T_mem' ], variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_mc , Re , kappa_co = parameters [ 'epsilon_mc' ], parameters [ 'Re' ], parameters [ 'kappa_co' ] # Initialisation n = len ( t ) Ucell_t = [ 0 ] * n # Loop for having Ucell_t at each time step for i in range ( n ): # Recovery of the already calculated variable values at each time step lambda_mem , lambda_ccl = lambda_mem_t [ i ], lambda_ccl_t [ i ] C_H2_acl , C_O2_ccl = C_H2_acl_t [ i ], C_O2_ccl_t [ i ] T_acl , T_mem , T_ccl = T_acl_t [ i ], T_mem_t [ i ], T_ccl_t [ i ] eta_c = eta_c_t [ i ] # Current density value at this time step i_fc = operating_inputs [ 'current_density' ]( t [ i ], parameters ) # The equilibrium potential Ueq = E0 - 8.5e-4 * ( T_ccl - 298.15 ) + R * T_ccl / ( 2 * F ) * ( math . log ( R * T_acl * C_H2_acl / Pref ) + 0.5 * math . log ( R * T_ccl * C_O2_ccl / Pref )) # The crossover current density T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # The proton resistance # The proton resistance at the membrane : Rmem Rmem = Hmem / sigma_p_eff ( 'mem' , lambda_mem , T_mem ) # The proton resistance at the cathode catalyst layer : Rccl Rccl = Hccl / sigma_p_eff ( 'ccl' , lambda_ccl , T_ccl , epsilon_mc ) # The total proton resistance Rp = Rmem + Rccl # its value is around [4-7]e-6 ohm.m\u00b2. # The cell voltage Ucell_t [ i ] = Ueq - eta_c - ( i_fc + i_n ) * ( Rp + Re ) return Ucell_t calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ) This function calculates the intermediate values needed for the calculation of the cathode overpotential dynamic evolution. Parameters: solver_variables ( dict ) \u2013 The dictionary containing the variables calculated by the solver. operating_inputs ( dict ) \u2013 The dictionary containing the operating inputs. parameters ( dict ) \u2013 The dictionary containing the parameters. Returns: dict \u2013 The dictionary containing the crossover current density i_n at time t, and the liquid water induced voltage drop function f_drop at time t. Source code in model/cell_voltage.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ): \"\"\"This function calculates the intermediate values needed for the calculation of the cathode overpotential dynamic evolution. Parameters ---------- solver_variables : dict The dictionary containing the variables calculated by the solver. operating_inputs : dict The dictionary containing the operating inputs. parameters : dict The dictionary containing the parameters. Returns ------- dict The dictionary containing the crossover current density i_n at time t, and the liquid water induced voltage drop function f_drop at time t. \"\"\" # Extraction of the variables s_ccl , lambda_mem = solver_variables [ 's_ccl' ], solver_variables [ 'lambda_mem' ] # Extraction of the operating inputs and the parameters Pc_des = operating_inputs [ 'Pc_des' ] a_slim , b_slim , a_switch = parameters [ 'a_slim' ], parameters [ 'b_slim' ], parameters [ 'a_switch' ] # The liquid water induced voltage drop function f_drop slim = a_slim * ( Pc_des / 1e5 ) + b_slim s_switch = a_switch * slim f_drop = 0.5 * ( 1.0 - math . tanh (( 4 * s_ccl - 2 * slim - 2 * s_switch ) / ( slim - s_switch ))) return { 'f_drop' : f_drop }","title":"Cell voltage"},{"location":"functions/model/cell_voltage/#cell-voltage","text":"This file represents the equations for calculating the cell voltage. It is a component of the fuel cell model.","title":"Cell voltage"},{"location":"functions/model/cell_voltage/#model.cell_voltage.calculate_cell_voltage","text":"This function calculates the cell voltage at each time step. Parameters: variables ( dict ) \u2013 The dictionary containing the variables calculated by the solver. operating_inputs ( dict ) \u2013 The dictionary containing the operating inputs. parameters ( dict ) \u2013 The dictionary containing the parameters. Returns: Ucell_t ( list ) \u2013 The cell voltage at each time step. Source code in model/cell_voltage.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def calculate_cell_voltage ( variables , operating_inputs , parameters ): \"\"\"This function calculates the cell voltage at each time step. Parameters ---------- variables : dict The dictionary containing the variables calculated by the solver. operating_inputs : dict The dictionary containing the operating inputs. parameters : dict The dictionary containing the parameters. Returns ------- Ucell_t : list The cell voltage at each time step. \"\"\" # Extraction of the variables t , lambda_mem_t , lambda_ccl_t = variables [ 't' ], variables [ 'lambda_mem' ], variables [ 'lambda_ccl' ] C_H2_acl_t , C_O2_ccl_t , eta_c_t = variables [ 'C_H2_acl' ], variables [ 'C_O2_ccl' ], variables [ 'eta_c' ] T_acl_t , T_mem_t , T_ccl_t = variables [ 'T_acl' ], variables [ 'T_mem' ], variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_mc , Re , kappa_co = parameters [ 'epsilon_mc' ], parameters [ 'Re' ], parameters [ 'kappa_co' ] # Initialisation n = len ( t ) Ucell_t = [ 0 ] * n # Loop for having Ucell_t at each time step for i in range ( n ): # Recovery of the already calculated variable values at each time step lambda_mem , lambda_ccl = lambda_mem_t [ i ], lambda_ccl_t [ i ] C_H2_acl , C_O2_ccl = C_H2_acl_t [ i ], C_O2_ccl_t [ i ] T_acl , T_mem , T_ccl = T_acl_t [ i ], T_mem_t [ i ], T_ccl_t [ i ] eta_c = eta_c_t [ i ] # Current density value at this time step i_fc = operating_inputs [ 'current_density' ]( t [ i ], parameters ) # The equilibrium potential Ueq = E0 - 8.5e-4 * ( T_ccl - 298.15 ) + R * T_ccl / ( 2 * F ) * ( math . log ( R * T_acl * C_H2_acl / Pref ) + 0.5 * math . log ( R * T_ccl * C_O2_ccl / Pref )) # The crossover current density T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # The proton resistance # The proton resistance at the membrane : Rmem Rmem = Hmem / sigma_p_eff ( 'mem' , lambda_mem , T_mem ) # The proton resistance at the cathode catalyst layer : Rccl Rccl = Hccl / sigma_p_eff ( 'ccl' , lambda_ccl , T_ccl , epsilon_mc ) # The total proton resistance Rp = Rmem + Rccl # its value is around [4-7]e-6 ohm.m\u00b2. # The cell voltage Ucell_t [ i ] = Ueq - eta_c - ( i_fc + i_n ) * ( Rp + Re ) return Ucell_t","title":"calculate_cell_voltage"},{"location":"functions/model/cell_voltage/#model.cell_voltage.calculate_eta_c_intermediate_values","text":"This function calculates the intermediate values needed for the calculation of the cathode overpotential dynamic evolution. Parameters: solver_variables ( dict ) \u2013 The dictionary containing the variables calculated by the solver. operating_inputs ( dict ) \u2013 The dictionary containing the operating inputs. parameters ( dict ) \u2013 The dictionary containing the parameters. Returns: dict \u2013 The dictionary containing the crossover current density i_n at time t, and the liquid water induced voltage drop function f_drop at time t. Source code in model/cell_voltage.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ): \"\"\"This function calculates the intermediate values needed for the calculation of the cathode overpotential dynamic evolution. Parameters ---------- solver_variables : dict The dictionary containing the variables calculated by the solver. operating_inputs : dict The dictionary containing the operating inputs. parameters : dict The dictionary containing the parameters. Returns ------- dict The dictionary containing the crossover current density i_n at time t, and the liquid water induced voltage drop function f_drop at time t. \"\"\" # Extraction of the variables s_ccl , lambda_mem = solver_variables [ 's_ccl' ], solver_variables [ 'lambda_mem' ] # Extraction of the operating inputs and the parameters Pc_des = operating_inputs [ 'Pc_des' ] a_slim , b_slim , a_switch = parameters [ 'a_slim' ], parameters [ 'b_slim' ], parameters [ 'a_switch' ] # The liquid water induced voltage drop function f_drop slim = a_slim * ( Pc_des / 1e5 ) + b_slim s_switch = a_switch * slim f_drop = 0.5 * ( 1.0 - math . tanh (( 4 * s_ccl - 2 * slim - 2 * s_switch ) / ( slim - s_switch ))) return { 'f_drop' : f_drop }","title":"calculate_eta_c_intermediate_values"},{"location":"functions/model/control/","text":"Control This module contains the function that control the operating conditions of the MEA system. control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ) This function controls the operating conditions of the MEA system, if required. It is currently in construction. Parameters: t ( float ) \u2013 Time (s). solver_variables ( dict ) \u2013 Dictionary containing the solver variables. operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs. parameters ( dict ) \u2013 Dictionary containing the parameters. control_variables ( dict ) \u2013 Dictionary containing the control variables. Source code in model/control.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ): \"\"\"This function controls the operating conditions of the MEA system, if required. It is currently in construction. Parameters ---------- t : float Time (s). solver_variables : dict Dictionary containing the solver variables. operating_inputs : dict Dictionary containing the operating inputs. parameters : dict Dictionary containing the parameters. control_variables : dict Dictionary containing the control variables. \"\"\" pass","title":"Control"},{"location":"functions/model/control/#control","text":"This module contains the function that control the operating conditions of the MEA system.","title":"Control"},{"location":"functions/model/control/#model.control.control_operating_conditions","text":"This function controls the operating conditions of the MEA system, if required. It is currently in construction. Parameters: t ( float ) \u2013 Time (s). solver_variables ( dict ) \u2013 Dictionary containing the solver variables. operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs. parameters ( dict ) \u2013 Dictionary containing the parameters. control_variables ( dict ) \u2013 Dictionary containing the control variables. Source code in model/control.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ): \"\"\"This function controls the operating conditions of the MEA system, if required. It is currently in construction. Parameters ---------- t : float Time (s). solver_variables : dict Dictionary containing the solver variables. operating_inputs : dict Dictionary containing the operating inputs. parameters : dict Dictionary containing the parameters. control_variables : dict Dictionary containing the control variables. \"\"\" pass","title":"control_operating_conditions"},{"location":"functions/model/dif_eq/","text":"Differential equations This file represents all the differential equations used for the fuel cell model. dydt ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ) This function gives the system of differential equations to solve. Parameters: t ( float ) \u2013 Time (s). y ( ndarray ) \u2013 Numpy list of the solver variables. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. solver_variable_names ( list ) \u2013 Names of the solver variables. control_variables ( dict ) \u2013 Variables controlled by the user. Returns: dydt ( list ) \u2013 List containing the derivative of the solver variables. Source code in model/dif_eq.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def dydt ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ): \"\"\"This function gives the system of differential equations to solve. Parameters ---------- t : float Time (s). y : numpy.ndarray Numpy list of the solver variables. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. solver_variable_names : list Names of the solver variables. control_variables : dict Variables controlled by the user. Returns ------- dydt : list List containing the derivative of the solver variables. \"\"\" # Creation of the dif_eq dictionary. It is an intermediate calculation to simplify the writing of the code. dif_eq = {( 'd' + key + ' / dt' ): None for key in solver_variable_names } # Creation of the solver_variables dict. It is an intermediate calculation to simplify the writing of the code. solver_variables = {} for index , key in enumerate ( solver_variable_names ): solver_variables [ key ] = y [ index ] # Modifications of the operating conditions in real time, if required. if parameters [ \"type_control\" ] != \"no_control\" : control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ) # Intermediate values i_fc = operating_inputs [ 'current_density' ]( t , parameters ) dif_eq_int_values = calculate_dif_eq_int_values ( t , solver_variables , control_variables , operating_inputs , parameters ) eta_c_intermediate_values = calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ) # Calculation of the flows matter_flows_dico = calculate_flows ( t , solver_variables , control_variables , i_fc , operating_inputs , parameters ) heat_flows_dico = calculate_heat_transfers ( solver_variables , i_fc , operating_inputs , parameters , ** matter_flows_dico ) # Calculation of the dynamic evolutions # Inside the MEA calculate_dyn_dissoved_water_evolution_inside_MEA ( dif_eq , ** parameters , ** matter_flows_dico ) calculate_dyn_liquid_water_evolution_inside_MEA ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_vapor_evolution_inside_MEA ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_H2_O2_N2_evolution_inside_MEA ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_voltage_evolution ( dif_eq , i_fc , ** solver_variables , ** operating_inputs , ** parameters , ** dif_eq_int_values , ** eta_c_intermediate_values ) calculate_dyn_temperature_evolution_inside_MEA ( dif_eq , ** parameters , ** dif_eq_int_values , ** heat_flows_dico ) # Inside the gaz channels and the manifolds calculate_dyn_gas_evolution_inside_gas_channel ( dif_eq , ** parameters , ** matter_flows_dico ) calculate_dyn_temperature_evolution_inside_gas_channel ( dif_eq , ** parameters ) if parameters [ 'type_auxiliary' ] != \"no_auxiliary\" : calculate_dyn_manifold_pressure_and_humidity_evolution ( dif_eq , ** operating_inputs , ** parameters , ** matter_flows_dico ) # Inside the auxiliaries if parameters [ 'type_auxiliary' ] != \"no_auxiliary\" : calculate_dyn_air_compressor_evolution ( dif_eq , ** solver_variables , ** parameters ) calculate_dyn_humidifier_evolution ( dif_eq , ** solver_variables , ** parameters , ** dif_eq_int_values ) calculate_dyn_throttle_area_controler ( dif_eq , solver_variables , ** operating_inputs , ** parameters , ** matter_flows_dico ) # dif_eq is converted to dydt because the solver requires an ordered list to work dydt = np . array ([ dif_eq [ 'd' + key + ' / dt' ] for key in solver_variable_names ]) return dydt","title":"Differentiel equations"},{"location":"functions/model/dif_eq/#differential-equations","text":"This file represents all the differential equations used for the fuel cell model.","title":"Differential equations"},{"location":"functions/model/dif_eq/#model.dif_eq.dydt","text":"This function gives the system of differential equations to solve. Parameters: t ( float ) \u2013 Time (s). y ( ndarray ) \u2013 Numpy list of the solver variables. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. solver_variable_names ( list ) \u2013 Names of the solver variables. control_variables ( dict ) \u2013 Variables controlled by the user. Returns: dydt ( list ) \u2013 List containing the derivative of the solver variables. Source code in model/dif_eq.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def dydt ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ): \"\"\"This function gives the system of differential equations to solve. Parameters ---------- t : float Time (s). y : numpy.ndarray Numpy list of the solver variables. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. solver_variable_names : list Names of the solver variables. control_variables : dict Variables controlled by the user. Returns ------- dydt : list List containing the derivative of the solver variables. \"\"\" # Creation of the dif_eq dictionary. It is an intermediate calculation to simplify the writing of the code. dif_eq = {( 'd' + key + ' / dt' ): None for key in solver_variable_names } # Creation of the solver_variables dict. It is an intermediate calculation to simplify the writing of the code. solver_variables = {} for index , key in enumerate ( solver_variable_names ): solver_variables [ key ] = y [ index ] # Modifications of the operating conditions in real time, if required. if parameters [ \"type_control\" ] != \"no_control\" : control_operating_conditions ( t , solver_variables , operating_inputs , parameters , control_variables ) # Intermediate values i_fc = operating_inputs [ 'current_density' ]( t , parameters ) dif_eq_int_values = calculate_dif_eq_int_values ( t , solver_variables , control_variables , operating_inputs , parameters ) eta_c_intermediate_values = calculate_eta_c_intermediate_values ( solver_variables , operating_inputs , parameters ) # Calculation of the flows matter_flows_dico = calculate_flows ( t , solver_variables , control_variables , i_fc , operating_inputs , parameters ) heat_flows_dico = calculate_heat_transfers ( solver_variables , i_fc , operating_inputs , parameters , ** matter_flows_dico ) # Calculation of the dynamic evolutions # Inside the MEA calculate_dyn_dissoved_water_evolution_inside_MEA ( dif_eq , ** parameters , ** matter_flows_dico ) calculate_dyn_liquid_water_evolution_inside_MEA ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_vapor_evolution_inside_MEA ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_H2_O2_N2_evolution_inside_MEA ( dif_eq , solver_variables , ** parameters , ** matter_flows_dico ) calculate_dyn_voltage_evolution ( dif_eq , i_fc , ** solver_variables , ** operating_inputs , ** parameters , ** dif_eq_int_values , ** eta_c_intermediate_values ) calculate_dyn_temperature_evolution_inside_MEA ( dif_eq , ** parameters , ** dif_eq_int_values , ** heat_flows_dico ) # Inside the gaz channels and the manifolds calculate_dyn_gas_evolution_inside_gas_channel ( dif_eq , ** parameters , ** matter_flows_dico ) calculate_dyn_temperature_evolution_inside_gas_channel ( dif_eq , ** parameters ) if parameters [ 'type_auxiliary' ] != \"no_auxiliary\" : calculate_dyn_manifold_pressure_and_humidity_evolution ( dif_eq , ** operating_inputs , ** parameters , ** matter_flows_dico ) # Inside the auxiliaries if parameters [ 'type_auxiliary' ] != \"no_auxiliary\" : calculate_dyn_air_compressor_evolution ( dif_eq , ** solver_variables , ** parameters ) calculate_dyn_humidifier_evolution ( dif_eq , ** solver_variables , ** parameters , ** dif_eq_int_values ) calculate_dyn_throttle_area_controler ( dif_eq , solver_variables , ** operating_inputs , ** parameters , ** matter_flows_dico ) # dif_eq is converted to dydt because the solver requires an ordered list to work dydt = np . array ([ dif_eq [ 'd' + key + ' / dt' ] for key in solver_variable_names ]) return dydt","title":"dydt"},{"location":"functions/model/flows/","text":"Flows This file represents all the matter flows inside the fuel cell system. It is a component of the fuel cell model. calculate_flows ( t , sv , control_variables , i_fc , operating_inputs , parameters ) This function calculates the flows inside the fuel cell system. Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables ( dict ) \u2013 Variables controlled by the user. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: dict \u2013 Flows inside the fuel cell system. Source code in model/flows.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def calculate_flows ( t , sv , control_variables , i_fc , operating_inputs , parameters ): \"\"\"This function calculates the flows inside the fuel cell system. Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables : dict Variables controlled by the user. i_fc : float Fuel cell current density at time t (A.m-2). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- dict Flows inside the fuel cell system. \"\"\" # ___________________________________________________Preliminaries__________________________________________________ # Extraction of the variables C_v_acl , C_v_ccl = sv [ 'C_v_acl' ], sv [ 'C_v_ccl' ] s_acl , s_ccl = sv [ 's_acl' ], sv [ 's_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] # Extraction of the operating inputs and parameters T_des = operating_inputs [ 'T_des' ] Aact , Hmem , Hacl , Hccl = parameters [ 'Aact' ], parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] Wagc , Wcgc , Hagc , Hcgc = parameters [ 'Wagc' ], parameters [ 'Wcgc' ], parameters [ 'Hagc' ], parameters [ 'Hcgc' ] Lgc , nb_channel_in_gc = parameters [ 'Lgc' ], parameters [ 'nb_channel_in_gc' ] epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] e , kappa_co = parameters [ 'e' ], parameters [ 'kappa_co' ] nb_gc , nb_gdl , nb_mpl = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] # Intermediate values ( H_gdl_node , H_mpl_node , Pagc , Pcgc , J_EOD_acl_mem , J_EOD_mem_ccl , D_acl_mem , D_mem_ccl , D_cap_agdl_agdl , D_cap_agdl_ampl , D_cap_ampl_ampl , D_cap_ampl_acl , D_cap_ccl_cmpl , D_cap_cmpl_cmpl , D_cap_cmpl_cgdl , D_cap_cgdl_cgdl , Da_eff_agdl_agdl , Da_eff_agdl_ampl , Da_eff_ampl_ampl , Da_eff_ampl_acl , Dc_eff_ccl_cmpl , Dc_eff_cmpl_cmpl , Dc_eff_cmpl_cgdl , Dc_eff_cgdl_cgdl , T_acl_mem_ccl ) = \\ flows_int_values ( sv , i_fc , operating_inputs , parameters ) C_N2_a_mean = ( sum ( sv [ f 'C_N2_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) C_N2_c_mean = ( sum ( sv [ f 'C_N2_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) # ________________________________________Dissolved water flows (mol.m-2.s-1)_______________________________________ # Anode side J_lambda_acl_mem = J_EOD_acl_mem - rho_mem / M_eq * D_acl_mem * d_dx ( y_minus = lambda_acl , y_plus = lambda_mem , dx_minus = Hacl / 2 , dx_plus = Hmem / 2 ) # Cathode side J_lambda_mem_ccl = J_EOD_mem_ccl - rho_mem / M_eq * D_mem_ccl * d_dx ( y_minus = lambda_mem , y_plus = lambda_ccl , dx_minus = Hmem / 2 , dx_plus = Hccl / 2 ) # _________________________________________Liquid water flows (kg.m-2.s-1)__________________________________________ # Anode side s_agc = 0 # Dirichlet boundary condition (taken at the agc/agdl border). Jl_agc_agdl = - Dcap ( 'gdl' , sv [ 's_agdl_1' ], sv [ 'T_agdl_1' ], epsilon_gdl , e , epsilon_c = epsilon_c ) * \\ d_dx ( y_minus = s_agc , y_plus = sv [ 's_agdl_1' ], dx = H_gdl_node / 2 ) Jl_agdl_agdl = [ None ] + [ - D_cap_agdl_agdl [ i ] * d_dx ( y_minus = sv [ f 's_agdl_ { i } ' ], y_plus = sv [ f 's_agdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] Jl_agdl_ampl = - D_cap_agdl_ampl * d_dx ( y_minus = sv [ f 's_agdl_ { nb_gdl } ' ], y_plus = sv [ 's_ampl_1' ], dx_minus = H_gdl_node / 2 , dx_plus = H_mpl_node / 2 ) Jl_ampl_ampl = [ None ] + [ - D_cap_ampl_ampl [ i ] * d_dx ( y_minus = sv [ f 's_ampl_ { i } ' ], y_plus = sv [ f 's_ampl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] Jl_ampl_acl = - D_cap_ampl_acl * d_dx ( y_minus = sv [ f 's_ampl_ { nb_mpl } ' ], y_plus = s_acl , dx_minus = H_mpl_node / 2 , dx_plus = Hacl / 2 ) # Cathode side s_cgc = 0 # Dirichlet boundary condition (taken at the cgc/cgdl border). Jl_ccl_cmpl = - D_cap_ccl_cmpl * d_dx ( y_minus = s_ccl , y_plus = sv [ 's_cmpl_1' ], dx_minus = Hccl / 2 , dx_plus = H_mpl_node / 2 ) Jl_cmpl_cmpl = [ None ] + [ - D_cap_cmpl_cmpl [ i ] * d_dx ( y_minus = sv [ f 's_cmpl_ { i } ' ], y_plus = sv [ f 's_cmpl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] Jl_cmpl_cgdl = - D_cap_cmpl_cgdl * d_dx ( y_minus = sv [ f 's_cmpl_ { nb_mpl } ' ], y_plus = sv [ 's_cgdl_1' ], dx_minus = H_mpl_node / 2 , dx_plus = H_gdl_node / 2 ) Jl_cgdl_cgdl = [ None ] + [ - D_cap_cgdl_cgdl [ i ] * d_dx ( y_minus = sv [ f 's_cgdl_ { i } ' ], y_plus = sv [ f 's_cgdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] Jl_cgdl_cgc = - Dcap ( 'gdl' , sv [ f 's_cgdl_ { nb_gdl } ' ], sv [ f 'T_cgdl_ { nb_gdl } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ) * \\ d_dx ( y_minus = sv [ f 's_cgdl_ { nb_gdl } ' ], y_plus = s_cgc , dx = H_gdl_node / 2 ) # _____________________________________________Vapor flows (mol.m-2.s-1)____________________________________________ # Convective vapor flows # Anode side Jv_agc_agdl = [ None ] + [ h_a ( Pagc [ i ], T_des , Wagc , Hagc ) * ( sv [ f 'C_v_agc_ { i } ' ] - sv [ 'C_v_agdl_1' ]) for i in range ( 1 , nb_gc + 1 )] # Cathode side Jv_cgdl_cgc = [ None ] + [ h_c ( Pcgc [ i ], T_des , Wcgc , Hcgc ) * ( sv [ f 'C_v_cgdl_ { nb_gdl } ' ] - sv [ f 'C_v_cgc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 )] # Conductive vapor flows # Anode side Jv_agdl_agdl = [ None ] + [ - Da_eff_agdl_agdl [ i ] * d_dx ( y_minus = sv [ f 'C_v_agdl_ { i } ' ], y_plus = sv [ f 'C_v_agdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] Jv_agdl_ampl = - Da_eff_agdl_ampl * d_dx ( y_minus = sv [ f 'C_v_agdl_ { nb_gdl } ' ], y_plus = sv [ 'C_v_ampl_1' ], dx_minus = H_gdl_node / 2 , dx_plus = H_mpl_node / 2 ) Jv_ampl_ampl = [ None ] + [ - Da_eff_ampl_ampl [ i ] * d_dx ( y_minus = sv [ f 'C_v_ampl_ { i } ' ], y_plus = sv [ f 'C_v_ampl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] Jv_ampl_acl = - Da_eff_ampl_acl * d_dx ( y_minus = sv [ f 'C_v_ampl_ { nb_mpl } ' ], y_plus = C_v_acl , dx_minus = H_mpl_node / 2 , dx_plus = Hacl / 2 ) # Cathode side Jv_ccl_cmpl = - Dc_eff_ccl_cmpl * d_dx ( y_minus = C_v_ccl , y_plus = sv [ 'C_v_cmpl_1' ], dx_minus = Hccl / 2 , dx_plus = H_mpl_node / 2 ) Jv_cmpl_cmpl = [ None ] + [ - Dc_eff_cmpl_cmpl [ i ] * d_dx ( y_minus = sv [ f 'C_v_cmpl_ { i } ' ], y_plus = sv [ f 'C_v_cmpl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] Jv_cmpl_cgdl = - Dc_eff_cmpl_cgdl * d_dx ( y_minus = sv [ f 'C_v_cmpl_ { nb_mpl } ' ], y_plus = sv [ 'C_v_cgdl_1' ], dx_minus = H_mpl_node / 2 , dx_plus = H_gdl_node / 2 ) Jv_cgdl_cgdl = [ None ] + [ - Dc_eff_cgdl_cgdl [ i ] * d_dx ( y_minus = sv [ f 'C_v_cgdl_ { i } ' ], y_plus = sv [ f 'C_v_cgdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] # __________________________________________H2 and O2 flows (mol.m-2.s-1)___________________________________________ # Hydrogen and oxygen consumption # Anode side S_H2_acl = - i_fc / ( 2 * F * Hacl ) - \\ R * T_acl_mem_ccl / ( Hmem * Hacl ) * ( k_H2 ( lambda_mem , T_mem , kappa_co ) * C_H2_acl + 2 * k_O2 ( lambda_mem , T_mem , kappa_co ) * C_O2_ccl ) # Cathode side S_O2_ccl = - i_fc / ( 4 * F * Hccl ) - \\ R * T_acl_mem_ccl / ( Hmem * Hccl ) * ( k_O2 ( lambda_mem , T_mem , kappa_co ) * C_O2_ccl + 1 / 2 * k_H2 ( lambda_mem , T_mem , kappa_co ) * C_H2_acl ) # Conductive-convective H2 and O2 flows # Anode side J_H2_agc_agdl = [ None ] + [ h_a ( Pagc [ i ], T_des , Wagc , Hagc ) * ( sv [ f 'C_H2_agc_ { i } ' ] - sv [ 'C_H2_agdl_1' ]) for i in range ( 1 , nb_gc + 1 )] # Cathode side J_O2_cgdl_cgc = [ None ] + [ h_c ( Pcgc [ i ], T_des , Wcgc , Hcgc ) * ( sv [ f 'C_O2_cgdl_ { nb_gdl } ' ] - sv [ f 'C_O2_cgc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 )] # Conductive H2 and O2 flows # Anode side J_H2_agdl_agdl = [ None ] + [ - Da_eff_agdl_agdl [ i ] * d_dx ( y_minus = sv [ f 'C_H2_agdl_ { i } ' ], y_plus = sv [ f 'C_H2_agdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] J_H2_agdl_ampl = - Da_eff_agdl_ampl * d_dx ( y_minus = sv [ f 'C_H2_agdl_ { nb_gdl } ' ], y_plus = sv [ 'C_H2_ampl_1' ], dx_minus = H_gdl_node / 2 , dx_plus = H_mpl_node / 2 ) J_H2_ampl_ampl = [ None ] + [ - Da_eff_ampl_ampl [ i ] * d_dx ( y_minus = sv [ f 'C_H2_ampl_ { i } ' ], y_plus = sv [ f 'C_H2_ampl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] J_H2_ampl_acl = - Da_eff_ampl_acl * d_dx ( y_minus = sv [ f 'C_H2_ampl_ { nb_mpl } ' ], y_plus = C_H2_acl , dx_minus = H_mpl_node / 2 , dx_plus = Hacl / 2 ) # Cathode side J_O2_ccl_cmpl = - Dc_eff_ccl_cmpl * d_dx ( y_minus = C_O2_ccl , y_plus = sv [ 'C_O2_cmpl_1' ], dx_minus = Hccl / 2 , dx_plus = H_mpl_node / 2 ) J_O2_cmpl_cmpl = [ None ] + [ - Dc_eff_cmpl_cmpl [ i ] * d_dx ( y_minus = sv [ f 'C_O2_cmpl_ { i } ' ], y_plus = sv [ f 'C_O2_cmpl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] J_O2_cmpl_cgdl = - Dc_eff_cmpl_cgdl * d_dx ( y_minus = sv [ f 'C_O2_cmpl_ { nb_mpl } ' ], y_plus = sv [ 'C_O2_cgdl_1' ], dx_minus = H_mpl_node / 2 , dx_plus = H_gdl_node / 2 ) J_O2_cgdl_cgdl = [ None ] + [ - Dc_eff_cgdl_cgdl [ i ] * d_dx ( y_minus = sv [ f 'C_O2_cgdl_ { i } ' ], y_plus = sv [ f 'C_O2_cgdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] # __________________________________________Water generated (mol.m-3.s-1)___________________________________________ # Water produced in the membrane at the CL through the chemical reaction and crossover # Anode side Sp_acl = 2 * k_O2 ( lambda_mem , T_mem , kappa_co ) * R * T_acl_mem_ccl / ( Hmem * Hacl ) * C_O2_ccl # Cathode side Sp_ccl = i_fc / ( 2 * F * Hccl ) + k_H2 ( lambda_mem , T_mem , kappa_co ) * R * T_acl_mem_ccl / ( Hmem * Hccl ) * C_H2_acl # Water absorption in the CL: # Anode side S_abs_acl = gamma_sorp ( C_v_acl , s_acl , lambda_acl , T_acl , Hacl ) * rho_mem / M_eq * \\ ( lambda_eq ( C_v_acl , s_acl , T_acl ) - lambda_acl ) # Cathode side S_abs_ccl = gamma_sorp ( C_v_ccl , s_ccl , lambda_ccl , T_ccl , Hccl ) * rho_mem / M_eq * \\ ( lambda_eq ( C_v_ccl , s_ccl , T_ccl ) - lambda_ccl ) # Liquid water generated through vapor condensation or degenerated through evaporation # Anode side Sl_agdl = [ None ] + [ Svl ( element = 'anode' , s = sv [ f 's_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], Ctot = sv [ f 'C_v_agdl_ { i } ' ] + sv [ f 'C_H2_agdl_ { i } ' ] + C_N2_a_mean , T = sv [ f 'T_agdl_ { i } ' ], epsilon = epsilon_gdl ) for i in range ( 1 , nb_gdl + 1 )] Sl_ampl = [ None ] + [ Svl ( element = 'anode' , s = sv [ f 's_ampl_ { i } ' ], C_v = sv [ f 'C_v_ampl_ { i } ' ], Ctot = sv [ f 'C_v_ampl_ { i } ' ] + sv [ f 'C_H2_ampl_ { i } ' ] + C_N2_a_mean , T = sv [ f 'T_ampl_ { i } ' ], epsilon = epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )] Sl_acl = Svl ( element = 'anode' , s = s_acl , C_v = C_v_acl , Ctot = C_v_acl + C_H2_acl + C_N2_a_mean , T = T_acl , epsilon = epsilon_cl ) # Cathode side Sl_ccl = Svl ( element = 'cathode' , s = s_ccl , C_v = C_v_ccl , Ctot = C_v_ccl + C_O2_ccl + C_N2_c_mean , T = T_ccl , epsilon = epsilon_cl ) Sl_cmpl = [ None ] + [ Svl ( element = 'cathode' , s = sv [ f 's_cmpl_ { i } ' ], C_v = sv [ f 'C_v_cmpl_ { i } ' ], Ctot = sv [ f 'C_v_cmpl_ { i } ' ] + sv [ f 'C_O2_cmpl_ { i } ' ] + C_N2_c_mean , T = sv [ f 'T_cmpl_ { i } ' ], epsilon = epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )] Sl_cgdl = [ None ] + [ Svl ( element = 'cathode' , s = sv [ f 's_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], Ctot = sv [ f 'C_v_cgdl_ { i } ' ] + sv [ f 'C_O2_cgdl_ { i } ' ] + C_N2_c_mean , T = sv [ f 'T_cgdl_ { i } ' ], epsilon = epsilon_gdl ) for i in range ( 1 , nb_gdl + 1 )] # Vapor generated through liquid water evaporation or degenerated through condensation # Anode side Sv_agdl = [ None ] + [ - x for x in Sl_agdl [ 1 :]] Sv_ampl = [ None ] + [ - x for x in Sl_ampl [ 1 :]] Sv_acl = - Sl_acl # Cathode side Sv_ccl = - Sl_ccl Sv_cmpl = [ None ] + [ - x for x in Sl_cmpl [ 1 :]] Sv_cgdl = [ None ] + [ - x for x in Sl_cgdl [ 1 :]] # ____________________________________________Auxiliary flows (mol.s-1)_____________________________________________ auxiliary_flows_dico = auxiliaries ( t , sv , control_variables , i_fc , Jv_agc_agdl , Jv_cgdl_cgc , J_H2_agc_agdl , J_O2_cgdl_cgc , operating_inputs , parameters ) # _____________________________________Assemble and return the flow dictionary______________________________________ return { ** auxiliary_flows_dico , 'Jv' : { ** auxiliary_flows_dico . get ( 'Jv' , {}), 'agc_agdl' : Jv_agc_agdl , 'agdl_agdl' : Jv_agdl_agdl , 'agdl_ampl' : Jv_agdl_ampl , 'ampl_ampl' : Jv_ampl_ampl , 'ampl_acl' : Jv_ampl_acl , 'ccl_cmpl' : Jv_ccl_cmpl , 'cmpl_cmpl' : Jv_cmpl_cmpl , 'cmpl_cgdl' : Jv_cmpl_cgdl , 'cgdl_cgdl' : Jv_cgdl_cgdl , 'cgdl_cgc' : Jv_cgdl_cgc }, 'Jl' : { 'agc_agdl' : Jl_agc_agdl , 'agdl_agdl' : Jl_agdl_agdl , 'agdl_ampl' : Jl_agdl_ampl , 'ampl_ampl' : Jl_ampl_ampl , 'ampl_acl' : Jl_ampl_acl , 'ccl_cmpl' : Jl_ccl_cmpl , 'cmpl_cmpl' : Jl_cmpl_cmpl , 'cmpl_cgdl' : Jl_cmpl_cgdl , 'cgdl_cgdl' : Jl_cgdl_cgdl , 'cgdl_cgc' : Jl_cgdl_cgc }, 'J_lambda' : { 'acl_mem' : J_lambda_acl_mem , 'mem_ccl' : J_lambda_mem_ccl }, 'J_H2' : { ** auxiliary_flows_dico . get ( 'J_H2' , {}), 'agc_agdl' : J_H2_agc_agdl , 'agdl_agdl' : J_H2_agdl_agdl , 'agdl_ampl' : J_H2_agdl_ampl , 'ampl_ampl' : J_H2_ampl_ampl , 'ampl_acl' : J_H2_ampl_acl }, 'J_O2' : { ** auxiliary_flows_dico . get ( 'J_O2' , {}), 'ccl_cmpl' : J_O2_ccl_cmpl , 'cmpl_cmpl' : J_O2_cmpl_cmpl , 'cmpl_cgdl' : J_O2_cmpl_cgdl , 'cgdl_cgdl' : J_O2_cgdl_cgdl , 'cgdl_cgc' : J_O2_cgdl_cgc }, 'S_abs' : { 'acl' : S_abs_acl , 'ccl' : S_abs_ccl }, 'Sp' :{ 'acl' : Sp_acl , 'ccl' : Sp_ccl }, 'S_H2' :{ 'acl' : S_H2_acl }, 'S_O2' : { 'ccl' : S_O2_ccl }, 'Sv' : { 'agdl' : Sv_agdl , 'ampl' : Sv_ampl , 'acl' : Sv_acl , 'ccl' : Sv_ccl , 'cmpl' : Sv_cmpl , 'cgdl' : Sv_cgdl }, 'Sl' : { 'agdl' : Sl_agdl , 'ampl' : Sl_ampl , 'acl' : Sl_acl , 'ccl' : Sl_ccl , 'cmpl' : Sl_cmpl , 'cgdl' : Sl_cgdl }}","title":"Flows"},{"location":"functions/model/flows/#flows","text":"This file represents all the matter flows inside the fuel cell system. It is a component of the fuel cell model.","title":"Flows"},{"location":"functions/model/flows/#model.flows.calculate_flows","text":"This function calculates the flows inside the fuel cell system. Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables ( dict ) \u2013 Variables controlled by the user. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: dict \u2013 Flows inside the fuel cell system. Source code in model/flows.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def calculate_flows ( t , sv , control_variables , i_fc , operating_inputs , parameters ): \"\"\"This function calculates the flows inside the fuel cell system. Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables : dict Variables controlled by the user. i_fc : float Fuel cell current density at time t (A.m-2). operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- dict Flows inside the fuel cell system. \"\"\" # ___________________________________________________Preliminaries__________________________________________________ # Extraction of the variables C_v_acl , C_v_ccl = sv [ 'C_v_acl' ], sv [ 'C_v_ccl' ] s_acl , s_ccl = sv [ 's_acl' ], sv [ 's_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] # Extraction of the operating inputs and parameters T_des = operating_inputs [ 'T_des' ] Aact , Hmem , Hacl , Hccl = parameters [ 'Aact' ], parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] Wagc , Wcgc , Hagc , Hcgc = parameters [ 'Wagc' ], parameters [ 'Wcgc' ], parameters [ 'Hagc' ], parameters [ 'Hcgc' ] Lgc , nb_channel_in_gc = parameters [ 'Lgc' ], parameters [ 'nb_channel_in_gc' ] epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] e , kappa_co = parameters [ 'e' ], parameters [ 'kappa_co' ] nb_gc , nb_gdl , nb_mpl = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] # Intermediate values ( H_gdl_node , H_mpl_node , Pagc , Pcgc , J_EOD_acl_mem , J_EOD_mem_ccl , D_acl_mem , D_mem_ccl , D_cap_agdl_agdl , D_cap_agdl_ampl , D_cap_ampl_ampl , D_cap_ampl_acl , D_cap_ccl_cmpl , D_cap_cmpl_cmpl , D_cap_cmpl_cgdl , D_cap_cgdl_cgdl , Da_eff_agdl_agdl , Da_eff_agdl_ampl , Da_eff_ampl_ampl , Da_eff_ampl_acl , Dc_eff_ccl_cmpl , Dc_eff_cmpl_cmpl , Dc_eff_cmpl_cgdl , Dc_eff_cgdl_cgdl , T_acl_mem_ccl ) = \\ flows_int_values ( sv , i_fc , operating_inputs , parameters ) C_N2_a_mean = ( sum ( sv [ f 'C_N2_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) C_N2_c_mean = ( sum ( sv [ f 'C_N2_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) # ________________________________________Dissolved water flows (mol.m-2.s-1)_______________________________________ # Anode side J_lambda_acl_mem = J_EOD_acl_mem - rho_mem / M_eq * D_acl_mem * d_dx ( y_minus = lambda_acl , y_plus = lambda_mem , dx_minus = Hacl / 2 , dx_plus = Hmem / 2 ) # Cathode side J_lambda_mem_ccl = J_EOD_mem_ccl - rho_mem / M_eq * D_mem_ccl * d_dx ( y_minus = lambda_mem , y_plus = lambda_ccl , dx_minus = Hmem / 2 , dx_plus = Hccl / 2 ) # _________________________________________Liquid water flows (kg.m-2.s-1)__________________________________________ # Anode side s_agc = 0 # Dirichlet boundary condition (taken at the agc/agdl border). Jl_agc_agdl = - Dcap ( 'gdl' , sv [ 's_agdl_1' ], sv [ 'T_agdl_1' ], epsilon_gdl , e , epsilon_c = epsilon_c ) * \\ d_dx ( y_minus = s_agc , y_plus = sv [ 's_agdl_1' ], dx = H_gdl_node / 2 ) Jl_agdl_agdl = [ None ] + [ - D_cap_agdl_agdl [ i ] * d_dx ( y_minus = sv [ f 's_agdl_ { i } ' ], y_plus = sv [ f 's_agdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] Jl_agdl_ampl = - D_cap_agdl_ampl * d_dx ( y_minus = sv [ f 's_agdl_ { nb_gdl } ' ], y_plus = sv [ 's_ampl_1' ], dx_minus = H_gdl_node / 2 , dx_plus = H_mpl_node / 2 ) Jl_ampl_ampl = [ None ] + [ - D_cap_ampl_ampl [ i ] * d_dx ( y_minus = sv [ f 's_ampl_ { i } ' ], y_plus = sv [ f 's_ampl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] Jl_ampl_acl = - D_cap_ampl_acl * d_dx ( y_minus = sv [ f 's_ampl_ { nb_mpl } ' ], y_plus = s_acl , dx_minus = H_mpl_node / 2 , dx_plus = Hacl / 2 ) # Cathode side s_cgc = 0 # Dirichlet boundary condition (taken at the cgc/cgdl border). Jl_ccl_cmpl = - D_cap_ccl_cmpl * d_dx ( y_minus = s_ccl , y_plus = sv [ 's_cmpl_1' ], dx_minus = Hccl / 2 , dx_plus = H_mpl_node / 2 ) Jl_cmpl_cmpl = [ None ] + [ - D_cap_cmpl_cmpl [ i ] * d_dx ( y_minus = sv [ f 's_cmpl_ { i } ' ], y_plus = sv [ f 's_cmpl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] Jl_cmpl_cgdl = - D_cap_cmpl_cgdl * d_dx ( y_minus = sv [ f 's_cmpl_ { nb_mpl } ' ], y_plus = sv [ 's_cgdl_1' ], dx_minus = H_mpl_node / 2 , dx_plus = H_gdl_node / 2 ) Jl_cgdl_cgdl = [ None ] + [ - D_cap_cgdl_cgdl [ i ] * d_dx ( y_minus = sv [ f 's_cgdl_ { i } ' ], y_plus = sv [ f 's_cgdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] Jl_cgdl_cgc = - Dcap ( 'gdl' , sv [ f 's_cgdl_ { nb_gdl } ' ], sv [ f 'T_cgdl_ { nb_gdl } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ) * \\ d_dx ( y_minus = sv [ f 's_cgdl_ { nb_gdl } ' ], y_plus = s_cgc , dx = H_gdl_node / 2 ) # _____________________________________________Vapor flows (mol.m-2.s-1)____________________________________________ # Convective vapor flows # Anode side Jv_agc_agdl = [ None ] + [ h_a ( Pagc [ i ], T_des , Wagc , Hagc ) * ( sv [ f 'C_v_agc_ { i } ' ] - sv [ 'C_v_agdl_1' ]) for i in range ( 1 , nb_gc + 1 )] # Cathode side Jv_cgdl_cgc = [ None ] + [ h_c ( Pcgc [ i ], T_des , Wcgc , Hcgc ) * ( sv [ f 'C_v_cgdl_ { nb_gdl } ' ] - sv [ f 'C_v_cgc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 )] # Conductive vapor flows # Anode side Jv_agdl_agdl = [ None ] + [ - Da_eff_agdl_agdl [ i ] * d_dx ( y_minus = sv [ f 'C_v_agdl_ { i } ' ], y_plus = sv [ f 'C_v_agdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] Jv_agdl_ampl = - Da_eff_agdl_ampl * d_dx ( y_minus = sv [ f 'C_v_agdl_ { nb_gdl } ' ], y_plus = sv [ 'C_v_ampl_1' ], dx_minus = H_gdl_node / 2 , dx_plus = H_mpl_node / 2 ) Jv_ampl_ampl = [ None ] + [ - Da_eff_ampl_ampl [ i ] * d_dx ( y_minus = sv [ f 'C_v_ampl_ { i } ' ], y_plus = sv [ f 'C_v_ampl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] Jv_ampl_acl = - Da_eff_ampl_acl * d_dx ( y_minus = sv [ f 'C_v_ampl_ { nb_mpl } ' ], y_plus = C_v_acl , dx_minus = H_mpl_node / 2 , dx_plus = Hacl / 2 ) # Cathode side Jv_ccl_cmpl = - Dc_eff_ccl_cmpl * d_dx ( y_minus = C_v_ccl , y_plus = sv [ 'C_v_cmpl_1' ], dx_minus = Hccl / 2 , dx_plus = H_mpl_node / 2 ) Jv_cmpl_cmpl = [ None ] + [ - Dc_eff_cmpl_cmpl [ i ] * d_dx ( y_minus = sv [ f 'C_v_cmpl_ { i } ' ], y_plus = sv [ f 'C_v_cmpl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] Jv_cmpl_cgdl = - Dc_eff_cmpl_cgdl * d_dx ( y_minus = sv [ f 'C_v_cmpl_ { nb_mpl } ' ], y_plus = sv [ 'C_v_cgdl_1' ], dx_minus = H_mpl_node / 2 , dx_plus = H_gdl_node / 2 ) Jv_cgdl_cgdl = [ None ] + [ - Dc_eff_cgdl_cgdl [ i ] * d_dx ( y_minus = sv [ f 'C_v_cgdl_ { i } ' ], y_plus = sv [ f 'C_v_cgdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] # __________________________________________H2 and O2 flows (mol.m-2.s-1)___________________________________________ # Hydrogen and oxygen consumption # Anode side S_H2_acl = - i_fc / ( 2 * F * Hacl ) - \\ R * T_acl_mem_ccl / ( Hmem * Hacl ) * ( k_H2 ( lambda_mem , T_mem , kappa_co ) * C_H2_acl + 2 * k_O2 ( lambda_mem , T_mem , kappa_co ) * C_O2_ccl ) # Cathode side S_O2_ccl = - i_fc / ( 4 * F * Hccl ) - \\ R * T_acl_mem_ccl / ( Hmem * Hccl ) * ( k_O2 ( lambda_mem , T_mem , kappa_co ) * C_O2_ccl + 1 / 2 * k_H2 ( lambda_mem , T_mem , kappa_co ) * C_H2_acl ) # Conductive-convective H2 and O2 flows # Anode side J_H2_agc_agdl = [ None ] + [ h_a ( Pagc [ i ], T_des , Wagc , Hagc ) * ( sv [ f 'C_H2_agc_ { i } ' ] - sv [ 'C_H2_agdl_1' ]) for i in range ( 1 , nb_gc + 1 )] # Cathode side J_O2_cgdl_cgc = [ None ] + [ h_c ( Pcgc [ i ], T_des , Wcgc , Hcgc ) * ( sv [ f 'C_O2_cgdl_ { nb_gdl } ' ] - sv [ f 'C_O2_cgc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 )] # Conductive H2 and O2 flows # Anode side J_H2_agdl_agdl = [ None ] + [ - Da_eff_agdl_agdl [ i ] * d_dx ( y_minus = sv [ f 'C_H2_agdl_ { i } ' ], y_plus = sv [ f 'C_H2_agdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] J_H2_agdl_ampl = - Da_eff_agdl_ampl * d_dx ( y_minus = sv [ f 'C_H2_agdl_ { nb_gdl } ' ], y_plus = sv [ 'C_H2_ampl_1' ], dx_minus = H_gdl_node / 2 , dx_plus = H_mpl_node / 2 ) J_H2_ampl_ampl = [ None ] + [ - Da_eff_ampl_ampl [ i ] * d_dx ( y_minus = sv [ f 'C_H2_ampl_ { i } ' ], y_plus = sv [ f 'C_H2_ampl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] J_H2_ampl_acl = - Da_eff_ampl_acl * d_dx ( y_minus = sv [ f 'C_H2_ampl_ { nb_mpl } ' ], y_plus = C_H2_acl , dx_minus = H_mpl_node / 2 , dx_plus = Hacl / 2 ) # Cathode side J_O2_ccl_cmpl = - Dc_eff_ccl_cmpl * d_dx ( y_minus = C_O2_ccl , y_plus = sv [ 'C_O2_cmpl_1' ], dx_minus = Hccl / 2 , dx_plus = H_mpl_node / 2 ) J_O2_cmpl_cmpl = [ None ] + [ - Dc_eff_cmpl_cmpl [ i ] * d_dx ( y_minus = sv [ f 'C_O2_cmpl_ { i } ' ], y_plus = sv [ f 'C_O2_cmpl_ { i + 1 } ' ], dx = H_mpl_node / 2 ) for i in range ( 1 , nb_mpl )] J_O2_cmpl_cgdl = - Dc_eff_cmpl_cgdl * d_dx ( y_minus = sv [ f 'C_O2_cmpl_ { nb_mpl } ' ], y_plus = sv [ 'C_O2_cgdl_1' ], dx_minus = H_mpl_node / 2 , dx_plus = H_gdl_node / 2 ) J_O2_cgdl_cgdl = [ None ] + [ - Dc_eff_cgdl_cgdl [ i ] * d_dx ( y_minus = sv [ f 'C_O2_cgdl_ { i } ' ], y_plus = sv [ f 'C_O2_cgdl_ { i + 1 } ' ], dx = H_gdl_node / 2 ) for i in range ( 1 , nb_gdl )] # __________________________________________Water generated (mol.m-3.s-1)___________________________________________ # Water produced in the membrane at the CL through the chemical reaction and crossover # Anode side Sp_acl = 2 * k_O2 ( lambda_mem , T_mem , kappa_co ) * R * T_acl_mem_ccl / ( Hmem * Hacl ) * C_O2_ccl # Cathode side Sp_ccl = i_fc / ( 2 * F * Hccl ) + k_H2 ( lambda_mem , T_mem , kappa_co ) * R * T_acl_mem_ccl / ( Hmem * Hccl ) * C_H2_acl # Water absorption in the CL: # Anode side S_abs_acl = gamma_sorp ( C_v_acl , s_acl , lambda_acl , T_acl , Hacl ) * rho_mem / M_eq * \\ ( lambda_eq ( C_v_acl , s_acl , T_acl ) - lambda_acl ) # Cathode side S_abs_ccl = gamma_sorp ( C_v_ccl , s_ccl , lambda_ccl , T_ccl , Hccl ) * rho_mem / M_eq * \\ ( lambda_eq ( C_v_ccl , s_ccl , T_ccl ) - lambda_ccl ) # Liquid water generated through vapor condensation or degenerated through evaporation # Anode side Sl_agdl = [ None ] + [ Svl ( element = 'anode' , s = sv [ f 's_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], Ctot = sv [ f 'C_v_agdl_ { i } ' ] + sv [ f 'C_H2_agdl_ { i } ' ] + C_N2_a_mean , T = sv [ f 'T_agdl_ { i } ' ], epsilon = epsilon_gdl ) for i in range ( 1 , nb_gdl + 1 )] Sl_ampl = [ None ] + [ Svl ( element = 'anode' , s = sv [ f 's_ampl_ { i } ' ], C_v = sv [ f 'C_v_ampl_ { i } ' ], Ctot = sv [ f 'C_v_ampl_ { i } ' ] + sv [ f 'C_H2_ampl_ { i } ' ] + C_N2_a_mean , T = sv [ f 'T_ampl_ { i } ' ], epsilon = epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )] Sl_acl = Svl ( element = 'anode' , s = s_acl , C_v = C_v_acl , Ctot = C_v_acl + C_H2_acl + C_N2_a_mean , T = T_acl , epsilon = epsilon_cl ) # Cathode side Sl_ccl = Svl ( element = 'cathode' , s = s_ccl , C_v = C_v_ccl , Ctot = C_v_ccl + C_O2_ccl + C_N2_c_mean , T = T_ccl , epsilon = epsilon_cl ) Sl_cmpl = [ None ] + [ Svl ( element = 'cathode' , s = sv [ f 's_cmpl_ { i } ' ], C_v = sv [ f 'C_v_cmpl_ { i } ' ], Ctot = sv [ f 'C_v_cmpl_ { i } ' ] + sv [ f 'C_O2_cmpl_ { i } ' ] + C_N2_c_mean , T = sv [ f 'T_cmpl_ { i } ' ], epsilon = epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )] Sl_cgdl = [ None ] + [ Svl ( element = 'cathode' , s = sv [ f 's_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], Ctot = sv [ f 'C_v_cgdl_ { i } ' ] + sv [ f 'C_O2_cgdl_ { i } ' ] + C_N2_c_mean , T = sv [ f 'T_cgdl_ { i } ' ], epsilon = epsilon_gdl ) for i in range ( 1 , nb_gdl + 1 )] # Vapor generated through liquid water evaporation or degenerated through condensation # Anode side Sv_agdl = [ None ] + [ - x for x in Sl_agdl [ 1 :]] Sv_ampl = [ None ] + [ - x for x in Sl_ampl [ 1 :]] Sv_acl = - Sl_acl # Cathode side Sv_ccl = - Sl_ccl Sv_cmpl = [ None ] + [ - x for x in Sl_cmpl [ 1 :]] Sv_cgdl = [ None ] + [ - x for x in Sl_cgdl [ 1 :]] # ____________________________________________Auxiliary flows (mol.s-1)_____________________________________________ auxiliary_flows_dico = auxiliaries ( t , sv , control_variables , i_fc , Jv_agc_agdl , Jv_cgdl_cgc , J_H2_agc_agdl , J_O2_cgdl_cgc , operating_inputs , parameters ) # _____________________________________Assemble and return the flow dictionary______________________________________ return { ** auxiliary_flows_dico , 'Jv' : { ** auxiliary_flows_dico . get ( 'Jv' , {}), 'agc_agdl' : Jv_agc_agdl , 'agdl_agdl' : Jv_agdl_agdl , 'agdl_ampl' : Jv_agdl_ampl , 'ampl_ampl' : Jv_ampl_ampl , 'ampl_acl' : Jv_ampl_acl , 'ccl_cmpl' : Jv_ccl_cmpl , 'cmpl_cmpl' : Jv_cmpl_cmpl , 'cmpl_cgdl' : Jv_cmpl_cgdl , 'cgdl_cgdl' : Jv_cgdl_cgdl , 'cgdl_cgc' : Jv_cgdl_cgc }, 'Jl' : { 'agc_agdl' : Jl_agc_agdl , 'agdl_agdl' : Jl_agdl_agdl , 'agdl_ampl' : Jl_agdl_ampl , 'ampl_ampl' : Jl_ampl_ampl , 'ampl_acl' : Jl_ampl_acl , 'ccl_cmpl' : Jl_ccl_cmpl , 'cmpl_cmpl' : Jl_cmpl_cmpl , 'cmpl_cgdl' : Jl_cmpl_cgdl , 'cgdl_cgdl' : Jl_cgdl_cgdl , 'cgdl_cgc' : Jl_cgdl_cgc }, 'J_lambda' : { 'acl_mem' : J_lambda_acl_mem , 'mem_ccl' : J_lambda_mem_ccl }, 'J_H2' : { ** auxiliary_flows_dico . get ( 'J_H2' , {}), 'agc_agdl' : J_H2_agc_agdl , 'agdl_agdl' : J_H2_agdl_agdl , 'agdl_ampl' : J_H2_agdl_ampl , 'ampl_ampl' : J_H2_ampl_ampl , 'ampl_acl' : J_H2_ampl_acl }, 'J_O2' : { ** auxiliary_flows_dico . get ( 'J_O2' , {}), 'ccl_cmpl' : J_O2_ccl_cmpl , 'cmpl_cmpl' : J_O2_cmpl_cmpl , 'cmpl_cgdl' : J_O2_cmpl_cgdl , 'cgdl_cgdl' : J_O2_cgdl_cgdl , 'cgdl_cgc' : J_O2_cgdl_cgc }, 'S_abs' : { 'acl' : S_abs_acl , 'ccl' : S_abs_ccl }, 'Sp' :{ 'acl' : Sp_acl , 'ccl' : Sp_ccl }, 'S_H2' :{ 'acl' : S_H2_acl }, 'S_O2' : { 'ccl' : S_O2_ccl }, 'Sv' : { 'agdl' : Sv_agdl , 'ampl' : Sv_ampl , 'acl' : Sv_acl , 'ccl' : Sv_ccl , 'cmpl' : Sv_cmpl , 'cgdl' : Sv_cgdl }, 'Sl' : { 'agdl' : Sl_agdl , 'ampl' : Sl_ampl , 'acl' : Sl_acl , 'ccl' : Sl_ccl , 'cmpl' : Sl_cmpl , 'cgdl' : Sl_cgdl }}","title":"calculate_flows"},{"location":"functions/model/heat_transfer/","text":"Heat Transfer This file represents all the heat transfers occuring inside the fuel cell system. It is a component of the fuel cell model. calculate_heat_transfers ( sv , i_fc , operating_inputs , parameters , S_abs , Sl , ** kwargs ) This function calculates the heat transfers occurring inside the fuel cell system. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). parameters ( dict ) \u2013 Parameters of the fuel cell model. S_abs ( dict ) \u2013 Water absorption rates from the CL to the membrane (mol.m-3.s-1). Sl ( dict ) \u2013 Liquid water absorption rates (mol.m-3.s-1). Returns: dict \u2013 Heat transfers occuring inside the fuel cell system. Source code in model/heat_transfer.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def calculate_heat_transfers ( sv , i_fc , operating_inputs , parameters , S_abs , Sl , ** kwargs ): \"\"\"This function calculates the heat transfers occurring inside the fuel cell system. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc : float Fuel cell current density at time t (A.m-2). parameters : dict Parameters of the fuel cell model. S_abs : dict Water absorption rates from the CL to the membrane (mol.m-3.s-1). Sl : dict Liquid water absorption rates (mol.m-3.s-1). Returns ------- dict Heat transfers occuring inside the fuel cell system. \"\"\" # ___________________________________________________Preliminaries__________________________________________________ # Extraction of the variables T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] s_acl , s_ccl , eta_c = sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 'eta_c' ] # Extraction of the operating inputs and parameters T_des = operating_inputs [ 'T_des' ] epsilon_mc , epsilon_gdl , epsilon_cl = parameters [ 'epsilon_mc' ], parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] nb_gdl , nb_mpl = parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] Hmem , Hgdl , Hmpl = parameters [ 'Hmem' ], parameters [ 'Hgdl' ], parameters [ 'Hmpl' ] Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] # Intermediate values ( Hgdl_node , Hmpl_node , k_th_eff_agc_agdl , k_th_eff_agdl_agdl , k_th_eff_agdl_ampl , k_th_eff_ampl_ampl , k_th_eff_ampl_acl , k_th_eff_acl_mem , k_th_eff_mem_ccl , k_th_eff_ccl_cmpl , k_th_eff_cmpl_cmpl , k_th_eff_cmpl_cgdl , k_th_eff_cgdl_cgdl , k_th_eff_cgdl_cgc ) = heat_transfer_int_values ( sv , parameters ) # ______________________________________________Heat flows (J.m-2.s-1)______________________________________________ # Anode side T_agc_mean = T_des T_cgc_mean = T_des Jt_agc_agdl = - k_th_eff_agc_agdl * d_dx ( y_minus = T_agc_mean , y_plus = sv [ 'T_agdl_1' ], dx = Hgdl_node / 2 ) Jt_agdl_agdl = { f 'agdl_agdl_ { i } ' : - k_th_eff_agdl_agdl [ i ] * d_dx ( y_minus = sv [ f 'T_agdl_ { i } ' ], y_plus = sv [ f 'T_agdl_ { i + 1 } ' ], dx = Hgdl_node / 2 ) for i in range ( 1 , nb_gdl )} Jt_agdl_ampl = - k_th_eff_agdl_ampl * d_dx ( y_minus = sv [ f 'T_agdl_ { nb_gdl } ' ], y_plus = sv [ 'T_ampl_1' ], dx_minus = Hgdl_node / 2 , dx_plus = Hmpl_node / 2 ) Jt_ampl_ampl = { f 'ampl_ampl_ { i } ' : - k_th_eff_ampl_ampl [ i ] * d_dx ( y_minus = sv [ f 'T_ampl_ { i } ' ], y_plus = sv [ f 'T_ampl_ { i + 1 } ' ], dx = Hmpl_node / 2 ) for i in range ( 1 , nb_mpl )} Jt_ampl_acl = - k_th_eff_ampl_acl * d_dx ( y_minus = sv [ f 'T_ampl_ { nb_mpl } ' ], y_plus = T_acl , dx_minus = Hmpl_node / 2 , dx_plus = Hacl / 2 ) # Membrane side Jt_acl_mem = - k_th_eff_acl_mem * d_dx ( y_minus = T_acl , y_plus = T_mem , dx_minus = Hacl / 2 , dx_plus = Hmem / 2 ) Jt_mem_ccl = - k_th_eff_mem_ccl * d_dx ( y_minus = T_mem , y_plus = T_ccl , dx_minus = Hmem / 2 , dx_plus = Hccl / 2 ) # Cathode side Jt_ccl_cmpl = - k_th_eff_ccl_cmpl * d_dx ( y_minus = T_ccl , y_plus = sv [ 'T_cmpl_1' ], dx_minus = Hccl / 2 , dx_plus = Hmpl_node / 2 ) Jt_cmpl_cmpl = { f 'cmpl_cmpl_ { i } ' : - k_th_eff_cmpl_cmpl [ i ] * d_dx ( y_minus = sv [ f 'T_cmpl_ { i } ' ], y_plus = sv [ f 'T_cmpl_ { i + 1 } ' ], dx = Hmpl_node / 2 ) for i in range ( 1 , nb_mpl )} Jt_cmpl_cgdl = - k_th_eff_cmpl_cgdl * d_dx ( y_minus = sv [ f 'T_cmpl_ { nb_mpl } ' ], y_plus = sv [ 'T_cgdl_1' ], dx_minus = Hmpl_node , dx_plus = Hgdl_node ) Jt_cgdl_cgdl = { f 'cgdl_cgdl_ { i } ' : - k_th_eff_cgdl_cgdl [ i ] * d_dx ( y_minus = sv [ f 'T_cgdl_ { i } ' ], y_plus = sv [ f 'T_cgdl_ { i + 1 } ' ], dx = Hgdl_node / 2 ) for i in range ( 1 , nb_gdl )} Jt_cgdl_cgc = - k_th_eff_cgdl_cgc * d_dx ( y_minus = sv [ f 'T_cgdl_ { nb_gdl } ' ], y_plus = T_cgc_mean , dx = Hgdl_node / 2 ) Jt = { 'agc_agdl' : Jt_agc_agdl , ** Jt_agdl_agdl , 'agdl_ampl' : Jt_agdl_ampl , ** Jt_ampl_ampl , 'ampl_acl' : Jt_ampl_acl , 'acl_mem' : Jt_acl_mem , 'mem_ccl' : Jt_mem_ccl , 'ccl_cmpl' : Jt_ccl_cmpl , ** Jt_cmpl_cmpl , 'cmpl_cgdl' : Jt_cmpl_cgdl , ** Jt_cgdl_cgdl , 'cgdl_cgc' : Jt_cgdl_cgc } # ____________________________________________Heat generated (J.m-3.s-1)____________________________________________ # The heat dissipated by the electrochemical reaction 2*H2 + O2 -> 2*H2O, in J.m-3.s-1. # It is given by the sum of Peltier and activation heats [vetterFreeOpenReference2019]. S_r_acl = i_fc / ( 2 * F * Hacl ) # mol.m-3.s-1. It is the amount of hydrogen consumed at the ACL. S_r_ccl = i_fc / ( 4 * F * Hccl ) # mol.m-3.s-1. It is the amount of oxygen consumed at the CCL. Q_r = { 'acl' : S_r_acl * T_acl * ( - delta_s_HOR ), 'ccl' : S_r_ccl * T_ccl * ( - delta_s_ORR ) + i_fc * eta_c / Hccl } # The heat dissipated by the absorption of water from the CL to the membrane, in J.m-3.s-1. Q_sorp = { 'acl' : S_abs [ 'acl' ] * ( - delta_h_abs ( T_acl )), 'ccl' : S_abs [ 'ccl' ] * ( - delta_h_abs ( T_ccl ))} # The heat dissipated by the liquefaction of vapor water, in J.m-3.s-1. Q_liq = { ** { f 'agdl_ { i } ' : Sl [ 'agdl' ][ i ] * ( - delta_h_liq ( sv [ f 'T_agdl_ { i } ' ])) for i in range ( 1 , nb_gdl + 1 )}, ** { f 'cgdl_ { i } ' : Sl [ 'cgdl' ][ i ] * ( - delta_h_liq ( sv [ f 'T_cgdl_ { i } ' ])) for i in range ( 1 , nb_gdl + 1 )}, ** { f 'ampl_ { i } ' : Sl [ 'ampl' ][ i ] * ( - delta_h_liq ( sv [ f 'T_ampl_ { i } ' ])) for i in range ( 1 , nb_mpl + 1 )}, ** { f 'cmpl_ { i } ' : Sl [ 'cmpl' ][ i ] * ( - delta_h_liq ( sv [ f 'T_cmpl_ { i } ' ])) for i in range ( 1 , nb_mpl + 1 )}, 'acl' : Sl [ 'acl' ] * ( - delta_h_liq ( T_acl )), 'ccl' : Sl [ 'ccl' ] * ( - delta_h_liq ( T_ccl )) } # The heat dissipated by the ionic currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_p = { 'mem' : i_fc ** 2 / sigma_p_eff ( 'mem' , lambda_mem , T_mem ), 'ccl' : i_fc ** 2 / ( 3 * sigma_p_eff ( 'ccl' , lambda_ccl , T_ccl , epsilon_mc ))} # The heat dissipated by the electric currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_e = { ** { f 'agdl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'gdl' , epsilon_gdl , epsilon_c = epsilon_c ) for i in range ( 1 , nb_gdl + 1 )}, ** { f 'ampl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'mpl' , epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )}, 'acl' : i_fc ** 2 / sigma_e_eff ( 'cl' , epsilon_cl , epsilon_mc = epsilon_mc ), 'ccl' : i_fc ** 2 / ( 3 * sigma_e_eff ( 'cl' , epsilon_cl , epsilon_mc = epsilon_mc )), ** { f 'cmpl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'mpl' , epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )}, ** { f 'cgdl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'gdl' , epsilon_gdl , epsilon_c = epsilon_c ) for i in range ( 1 , nb_gdl + 1 )}} return { 'Jt' : Jt , 'Q_r' : Q_r , 'Q_sorp' : Q_sorp , 'Q_liq' : Q_liq , 'Q_p' : Q_p , 'Q_e' : Q_e }","title":"Heat transfer"},{"location":"functions/model/heat_transfer/#heat-transfer","text":"This file represents all the heat transfers occuring inside the fuel cell system. It is a component of the fuel cell model.","title":"Heat Transfer"},{"location":"functions/model/heat_transfer/#model.heat_transfer.calculate_heat_transfers","text":"This function calculates the heat transfers occurring inside the fuel cell system. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc ( float ) \u2013 Fuel cell current density at time t (A.m-2). parameters ( dict ) \u2013 Parameters of the fuel cell model. S_abs ( dict ) \u2013 Water absorption rates from the CL to the membrane (mol.m-3.s-1). Sl ( dict ) \u2013 Liquid water absorption rates (mol.m-3.s-1). Returns: dict \u2013 Heat transfers occuring inside the fuel cell system. Source code in model/heat_transfer.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def calculate_heat_transfers ( sv , i_fc , operating_inputs , parameters , S_abs , Sl , ** kwargs ): \"\"\"This function calculates the heat transfers occurring inside the fuel cell system. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc : float Fuel cell current density at time t (A.m-2). parameters : dict Parameters of the fuel cell model. S_abs : dict Water absorption rates from the CL to the membrane (mol.m-3.s-1). Sl : dict Liquid water absorption rates (mol.m-3.s-1). Returns ------- dict Heat transfers occuring inside the fuel cell system. \"\"\" # ___________________________________________________Preliminaries__________________________________________________ # Extraction of the variables T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] s_acl , s_ccl , eta_c = sv [ 's_acl' ], sv [ 's_ccl' ], sv [ 'eta_c' ] # Extraction of the operating inputs and parameters T_des = operating_inputs [ 'T_des' ] epsilon_mc , epsilon_gdl , epsilon_cl = parameters [ 'epsilon_mc' ], parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] nb_gdl , nb_mpl = parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] Hmem , Hgdl , Hmpl = parameters [ 'Hmem' ], parameters [ 'Hgdl' ], parameters [ 'Hmpl' ] Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] # Intermediate values ( Hgdl_node , Hmpl_node , k_th_eff_agc_agdl , k_th_eff_agdl_agdl , k_th_eff_agdl_ampl , k_th_eff_ampl_ampl , k_th_eff_ampl_acl , k_th_eff_acl_mem , k_th_eff_mem_ccl , k_th_eff_ccl_cmpl , k_th_eff_cmpl_cmpl , k_th_eff_cmpl_cgdl , k_th_eff_cgdl_cgdl , k_th_eff_cgdl_cgc ) = heat_transfer_int_values ( sv , parameters ) # ______________________________________________Heat flows (J.m-2.s-1)______________________________________________ # Anode side T_agc_mean = T_des T_cgc_mean = T_des Jt_agc_agdl = - k_th_eff_agc_agdl * d_dx ( y_minus = T_agc_mean , y_plus = sv [ 'T_agdl_1' ], dx = Hgdl_node / 2 ) Jt_agdl_agdl = { f 'agdl_agdl_ { i } ' : - k_th_eff_agdl_agdl [ i ] * d_dx ( y_minus = sv [ f 'T_agdl_ { i } ' ], y_plus = sv [ f 'T_agdl_ { i + 1 } ' ], dx = Hgdl_node / 2 ) for i in range ( 1 , nb_gdl )} Jt_agdl_ampl = - k_th_eff_agdl_ampl * d_dx ( y_minus = sv [ f 'T_agdl_ { nb_gdl } ' ], y_plus = sv [ 'T_ampl_1' ], dx_minus = Hgdl_node / 2 , dx_plus = Hmpl_node / 2 ) Jt_ampl_ampl = { f 'ampl_ampl_ { i } ' : - k_th_eff_ampl_ampl [ i ] * d_dx ( y_minus = sv [ f 'T_ampl_ { i } ' ], y_plus = sv [ f 'T_ampl_ { i + 1 } ' ], dx = Hmpl_node / 2 ) for i in range ( 1 , nb_mpl )} Jt_ampl_acl = - k_th_eff_ampl_acl * d_dx ( y_minus = sv [ f 'T_ampl_ { nb_mpl } ' ], y_plus = T_acl , dx_minus = Hmpl_node / 2 , dx_plus = Hacl / 2 ) # Membrane side Jt_acl_mem = - k_th_eff_acl_mem * d_dx ( y_minus = T_acl , y_plus = T_mem , dx_minus = Hacl / 2 , dx_plus = Hmem / 2 ) Jt_mem_ccl = - k_th_eff_mem_ccl * d_dx ( y_minus = T_mem , y_plus = T_ccl , dx_minus = Hmem / 2 , dx_plus = Hccl / 2 ) # Cathode side Jt_ccl_cmpl = - k_th_eff_ccl_cmpl * d_dx ( y_minus = T_ccl , y_plus = sv [ 'T_cmpl_1' ], dx_minus = Hccl / 2 , dx_plus = Hmpl_node / 2 ) Jt_cmpl_cmpl = { f 'cmpl_cmpl_ { i } ' : - k_th_eff_cmpl_cmpl [ i ] * d_dx ( y_minus = sv [ f 'T_cmpl_ { i } ' ], y_plus = sv [ f 'T_cmpl_ { i + 1 } ' ], dx = Hmpl_node / 2 ) for i in range ( 1 , nb_mpl )} Jt_cmpl_cgdl = - k_th_eff_cmpl_cgdl * d_dx ( y_minus = sv [ f 'T_cmpl_ { nb_mpl } ' ], y_plus = sv [ 'T_cgdl_1' ], dx_minus = Hmpl_node , dx_plus = Hgdl_node ) Jt_cgdl_cgdl = { f 'cgdl_cgdl_ { i } ' : - k_th_eff_cgdl_cgdl [ i ] * d_dx ( y_minus = sv [ f 'T_cgdl_ { i } ' ], y_plus = sv [ f 'T_cgdl_ { i + 1 } ' ], dx = Hgdl_node / 2 ) for i in range ( 1 , nb_gdl )} Jt_cgdl_cgc = - k_th_eff_cgdl_cgc * d_dx ( y_minus = sv [ f 'T_cgdl_ { nb_gdl } ' ], y_plus = T_cgc_mean , dx = Hgdl_node / 2 ) Jt = { 'agc_agdl' : Jt_agc_agdl , ** Jt_agdl_agdl , 'agdl_ampl' : Jt_agdl_ampl , ** Jt_ampl_ampl , 'ampl_acl' : Jt_ampl_acl , 'acl_mem' : Jt_acl_mem , 'mem_ccl' : Jt_mem_ccl , 'ccl_cmpl' : Jt_ccl_cmpl , ** Jt_cmpl_cmpl , 'cmpl_cgdl' : Jt_cmpl_cgdl , ** Jt_cgdl_cgdl , 'cgdl_cgc' : Jt_cgdl_cgc } # ____________________________________________Heat generated (J.m-3.s-1)____________________________________________ # The heat dissipated by the electrochemical reaction 2*H2 + O2 -> 2*H2O, in J.m-3.s-1. # It is given by the sum of Peltier and activation heats [vetterFreeOpenReference2019]. S_r_acl = i_fc / ( 2 * F * Hacl ) # mol.m-3.s-1. It is the amount of hydrogen consumed at the ACL. S_r_ccl = i_fc / ( 4 * F * Hccl ) # mol.m-3.s-1. It is the amount of oxygen consumed at the CCL. Q_r = { 'acl' : S_r_acl * T_acl * ( - delta_s_HOR ), 'ccl' : S_r_ccl * T_ccl * ( - delta_s_ORR ) + i_fc * eta_c / Hccl } # The heat dissipated by the absorption of water from the CL to the membrane, in J.m-3.s-1. Q_sorp = { 'acl' : S_abs [ 'acl' ] * ( - delta_h_abs ( T_acl )), 'ccl' : S_abs [ 'ccl' ] * ( - delta_h_abs ( T_ccl ))} # The heat dissipated by the liquefaction of vapor water, in J.m-3.s-1. Q_liq = { ** { f 'agdl_ { i } ' : Sl [ 'agdl' ][ i ] * ( - delta_h_liq ( sv [ f 'T_agdl_ { i } ' ])) for i in range ( 1 , nb_gdl + 1 )}, ** { f 'cgdl_ { i } ' : Sl [ 'cgdl' ][ i ] * ( - delta_h_liq ( sv [ f 'T_cgdl_ { i } ' ])) for i in range ( 1 , nb_gdl + 1 )}, ** { f 'ampl_ { i } ' : Sl [ 'ampl' ][ i ] * ( - delta_h_liq ( sv [ f 'T_ampl_ { i } ' ])) for i in range ( 1 , nb_mpl + 1 )}, ** { f 'cmpl_ { i } ' : Sl [ 'cmpl' ][ i ] * ( - delta_h_liq ( sv [ f 'T_cmpl_ { i } ' ])) for i in range ( 1 , nb_mpl + 1 )}, 'acl' : Sl [ 'acl' ] * ( - delta_h_liq ( T_acl )), 'ccl' : Sl [ 'ccl' ] * ( - delta_h_liq ( T_ccl )) } # The heat dissipated by the ionic currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_p = { 'mem' : i_fc ** 2 / sigma_p_eff ( 'mem' , lambda_mem , T_mem ), 'ccl' : i_fc ** 2 / ( 3 * sigma_p_eff ( 'ccl' , lambda_ccl , T_ccl , epsilon_mc ))} # The heat dissipated by the electric currents (Joule heating + Ohm's law), in J.m-3.s-1. Q_e = { ** { f 'agdl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'gdl' , epsilon_gdl , epsilon_c = epsilon_c ) for i in range ( 1 , nb_gdl + 1 )}, ** { f 'ampl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'mpl' , epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )}, 'acl' : i_fc ** 2 / sigma_e_eff ( 'cl' , epsilon_cl , epsilon_mc = epsilon_mc ), 'ccl' : i_fc ** 2 / ( 3 * sigma_e_eff ( 'cl' , epsilon_cl , epsilon_mc = epsilon_mc )), ** { f 'cmpl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'mpl' , epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )}, ** { f 'cgdl_ { i } ' : i_fc ** 2 / sigma_e_eff ( 'gdl' , epsilon_gdl , epsilon_c = epsilon_c ) for i in range ( 1 , nb_gdl + 1 )}} return { 'Jt' : Jt , 'Q_r' : Q_r , 'Q_sorp' : Q_sorp , 'Q_liq' : Q_liq , 'Q_p' : Q_p , 'Q_e' : Q_e }","title":"calculate_heat_transfers"},{"location":"functions/modules/GUI_modules/","text":"GUI modules This module contains some of the required functions for the GUI.py file. changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ) This function is called when the user selects a specific option from a dropdown menu for the type of fuel cell. Depending on the selected option, it either hides or displays specific input fields (labels or entry widgets) on the GUI. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choices_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ): \"\"\"This function is called when the user selects a specific option from a dropdown menu for the type of fuel cell. Depending on the selected option, it either hides or displays specific input fields (labels or entry widgets) on the GUI. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choices_buttons : dict A dictionary containing the button information. \"\"\" if choices_buttons [ 'type_fuel_cell' ][ 'value' ] . get () != 'Enter your specifications' : # Recovers the new settings recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ) # Display the labels for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Label ( operating_conditions_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Label ( accessible_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Label ( undetermined_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Label ( current_density_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Label ( computing_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) else : # choices_buttons['type_fuel_cell']['value'].get() == 'Enter your specifications': # Saves and displays the user entries for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Entry ( operating_conditions_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Entry ( accessible_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Entry ( undetermined_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Entry ( current_density_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Entry ( computing_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) This function displays labels on the GUI, representing operating conditions and physical parameters, without their actual values. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. Source code in modules/GUI_modules.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ): \"\"\"This function displays labels on the GUI, representing operating conditions and physical parameters, without their actual values. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. \"\"\" # Display the titles ttk . Label ( operating_conditions_frame , text = 'Operating conditions' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 1 , column = 0 , columnspan = 6 , ipady = 15 ) ttk . Label ( accessible_parameters_frame , text = 'Accessible physical parameters' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 6 , ipady = 15 ) # Display the labels for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Label ( operating_conditions_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Label ( accessible_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Label ( undetermined_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # current density parameters ttk . Label ( current_density_parameters_frame , text = 'Step current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Label ( current_density_parameters_frame , text = 'Polarization current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 2 , column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Label ( current_density_parameters_frame , text = 'EIS current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 5 , column = 0 , columnspan = 2 , sticky = \"w\" ) for k , v in choice_current_density_parameters . items (): ttk . Label ( current_density_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Label ( computing_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ) This function displays entry widgets on the GUI. There, the user can enter values for operating conditions and physical parameters. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. Source code in modules/GUI_modules.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ): \"\"\"This function displays entry widgets on the GUI. There, the user can enter values for operating conditions and physical parameters. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. \"\"\" # Display the value for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Entry ( operating_conditions_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Entry ( accessible_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Entry ( undetermined_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Entry ( current_density_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Entry ( computing_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) display_radiobuttons ( model_possibilities_frame , choices_buttons ) This function displays radiobuttons on the GUI, allowing the user to make choices for control, results display, plot style, etc. Parameters: model_possibilities_frame ( Frame ) \u2013 The frame where the graphical elements for the model possibilities and the choice of current density are placed. choices_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def display_radiobuttons ( model_possibilities_frame , choices_buttons ): \"\"\"This function displays radiobuttons on the GUI, allowing the user to make choices for control, results display, plot style, etc. Parameters ---------- model_possibilities_frame : ttk.Frame The frame where the graphical elements for the model possibilities and the choice of current density are placed. choices_buttons : dict A dictionary containing the button information. \"\"\" ttk . Label ( model_possibilities_frame , text = 'Model possibilities' , font = ( 'cmr10' , 12 , 'bold' )) \\ . grid ( row = 0 , column = 0 , columnspan = 6 , ipady = 15 ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Auxiliaries: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 0 , columnspan = 1 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No auxiliaries' , value = 0 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Forced-convective cathode \\n with anodic recirculation' , value = 1 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Forced-convective cathode \\n with flow-through anode' , value = 2 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Voltage zone: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'voltage_zone' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Full' , value = 0 , variable = choices_buttons [ 'voltage_zone' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'voltage_zone' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Before voltage drop' , value = 1 , variable = choices_buttons [ 'voltage_zone' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'voltage_zone' ][ 'label_row' ], column = 3 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Control: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No control' , value = 0 , variable = choices_buttons [ 'type_control' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Humidity' , value = 1 , variable = choices_buttons [ 'type_control' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 3 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Purge: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No purge' , value = 0 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Periodic' , value = 1 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Constant' , value = 2 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Display: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No display' , value = 0 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Synthetic' , value = 1 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Multiple' , value = 2 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Plot: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Fixed' , value = 0 , variable = choices_buttons [ 'type_plot' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Dynamic' , value = 1 , variable = choices_buttons [ 'type_plot' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 3 , sticky = \"w\" ) launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 def launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None t0_EIS , t_new_start , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = current_parameters [ 't_EIS' ] f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = current_parameters [ 'f_EIS' ] # These are used for EIS max_step # actualization. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested. n = len ( t_new_start ) # It is the plot update number. time_interval = [ 0 , t0_EIS ] # It is the initial time interval. # A preliminary simulation run is necessary to equilibrate the internal variables of the cell at i_EIS # prior to initiating the EIS. Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization t0_EIS_temp = t0_EIS # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ 0 ] + delta_t_break_EIS [ 0 ] + delta_t_measurement_EIS [ 0 ] # It is the final time for # 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which has been # made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) if computing_parameters [ 'type_display' ] == \"multiple\" : print ( \"A display bug prevents the dynamic updating of the graphs, as it appears that too much data is \" \"involved. However, the data is correctly calculated, and the appropriate plots are saved in the \" \"'results' folder. This display bug does not occur when using a 'synthetic' type_display.\" ) # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_EIS_temp = Simulator . variables [ 't' ][ - 1 ] # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ i + 1 ] + delta_t_break_EIS [ i + 1 ] + delta_t_measurement_EIS [ i + 1 ] # It # is the final time for 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which # has been made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # It is the time interval for 1 EIS point. # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 def launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_load_pola' ] # (s). delta_t_break_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_break_pola' ] # (s). delta_i_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_i_pola' ] # (A.m-2). i_max_pola = current_parameters [ 'pola_current_parameters' ][ 'i_max_pola' ] # (A.m-2). # Calculation delta_t_pola = delta_t_load_pola + delta_t_break_pola # s. It is the time of one load. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * delta_t_pola # s. It is the polarization current duration. n = int ( tf / delta_t_pola ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola + delta_t_pola ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola + ( i + 2 ) * delta_t_pola time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a step current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 def launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a step current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Check if the type_fuel_cell and type_current are valid if computing_parameters [ 'type_current' ] == \"step\" and computing_parameters [ 'type_display' ] == \"multiple\" : raise ValueError ( 'dynamic plot is not thought to be used with step current and multiple display.' + 'There would be too much plots to handle.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters tf_step = ( current_parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_break_step' ]) # (s). delta_t_dyn_step = current_parameters [ 'step_current_parameters' ][ 'delta_t_dyn_step' ] # (s). # Calculation n = int ( tf_step / delta_t_dyn_step ) # It is the plot update number. time_interval = [ 0 , delta_t_dyn_step ] # (s). It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = ( i + 2 ) * delta_t_dyn_step time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ) This function retrieves parameter values for predefined stacks (e.g., \"EH-31 1.5 bar (2021)\", \"Biao Xie 1.0 bar (2015)\", etc.) and converts them to appropriate units for display on the GUI. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ): \"\"\"This function retrieves parameter values for predefined stacks (e.g., \"EH-31 1.5 bar (2021)\", \"Biao Xie 1.0 bar (2015)\", etc.) and converts them to appropriate units for display on the GUI. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. \"\"\" # type_fuel_cell recovery if choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 1.5 bar (2021)\" : type_fuel_cell = \"EH-31_1.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.0 bar (2021)\" : type_fuel_cell = \"EH-31_2.0\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.25 bar (2021)\" : type_fuel_cell = \"EH-31_2.25\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.5 bar (2021)\" : type_fuel_cell = \"EH-31_2.5\" if choice_buttons [ 'voltage_zone' ][ 'value' ] . get () == 0 : voltage_zone = \"full\" else : voltage_zone = \"before_voltage_drop\" ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) = calculate_current_density_parameters () T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , i_max_pola = stored_operating_inputs ( type_fuel_cell , voltage_zone ) ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , nb_channel_in_gc , Ldist , Lm , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , Aact , nb_cell , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl ) = stored_physical_parameters ( type_fuel_cell ) nb_gc , nb_gdl , nb_mpl , t_purge , rtol , atol = calculate_computing_parameters ( step_current_parameters , Hgdl , Hmpl , Hacl ) # operating conditions recovery choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . set ( round ( T_des - 273.15 , 4 )) # \u00b0C choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . set ( round ( Pa_des / 1e5 , 4 )) # bar choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . set ( round ( Pc_des / 1e5 , 4 )) # bar choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . set ( round ( Sa , 4 )) choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . set ( round ( Sc , 4 )) choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . set ( round ( Phi_a_des , 4 )) choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . set ( round ( Phi_c_des , 4 )) choice_operating_conditions [ 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' ][ 'value' ] . set ( round ( y_H2_in , 4 )) # accessible physical parameters recovery choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . set ( round ( Aact * 1e4 , 4 )) # cm\u00b2 choice_accessible_parameters [ 'Number of cells - nb_cell' ][ 'value' ] . set ( int ( nb_cell )) choice_accessible_parameters [ 'Anode gas channel \\n thickness - Hagc (\u00b5m)' ][ 'value' ] . set ( round ( Hagc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' ][ 'value' ] . set ( round ( Hcgc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'Anode gas channel \\n width - Wagc (\u00b5m)' ][ 'value' ] . set ( round ( Wagc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'Cathode gas channel \\n width - Wcgc (\u00b5m)' ][ 'value' ] . set ( round ( Wcgc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'Gas channel \\n length - Lgc (m)' ][ 'value' ] . set ( round ( Lgc * 1e3 , 4 )) # mm choice_accessible_parameters [ 'Number of channels inside the \\n gas channel - nb_channel_in_gc' ][ 'value' ] . set ( int ( nb_channel_in_gc )) choice_accessible_parameters [ 'Distributor length - L_dist (mm)' ][ 'value' ] . set ( round ( Ldist * 1e3 , 4 )) # mm choice_accessible_parameters [ 'Manifold length - Lm (mm)' ][ 'value' ] . set ( round ( Lm * 1e3 , 4 )) # mm choice_accessible_parameters [ 'Exhaust anode manifold throttle \\n area - A_T_a (cm\u00b2)' ][ 'value' ] . set ( round ( A_T_a * 1e4 , 4 )) # cm\u00b2 choice_accessible_parameters [ 'Exhaust cathode manifold throttle \\n area - A_T_c (cm\u00b2)' ][ 'value' ] . set ( round ( A_T_c * 1e4 , 4 )) # cm\u00b2 choice_accessible_parameters [ 'Supply anode manifold \\n volume - Vasm (cm\u00b3)' ][ 'value' ] . set ( round ( Vasm * 1e6 , 4 )) # cm\u00b3 choice_accessible_parameters [ 'Supply cathode manifold \\n volume - Vcsm (cm\u00b3)' ][ 'value' ] . set ( round ( Vcsm * 1e6 , 4 )) # cm\u00b3 choice_accessible_parameters [ 'Exhaust anode manifold \\n volume - Vaem (cm\u00b3)' ][ 'value' ] . set ( round ( Vaem * 1e6 , 4 )) # cm\u00b3 choice_accessible_parameters [ 'Exhaust cathode manifold \\n volume - Vcem (cm\u00b3)' ][ 'value' ] . set ( round ( Vcem * 1e6 , 4 )) # cm\u00b3 # undetermined physical parameters recovery choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . set ( round ( Hgdl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer) \\n (without the transition layer)' ][ 'value' ] . set ( round ( Hmpl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . set ( round ( Hacl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . set ( round ( Hccl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . set ( round ( Hmem * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . set ( round ( epsilon_gdl , 4 )) choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . set ( round ( epsilon_cl , 4 )) choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . set ( round ( epsilon_mpl , 4 )) choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . set ( round ( epsilon_mc , 4 )) choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . set ( round ( epsilon_c , 4 )) choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . set ( e ) choice_undetermined_parameters [ 'Electron conduction \\n resistance - Re (\u03a9.mm\u00b2)' ][ 'value' ] . set ( round ( Re * 1e6 , 4 )) # A.mm-2 choice_undetermined_parameters [ 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' ][ 'value' ] . set ( round ( i0_d_c_ref , 4 )) # A.m-2 choice_undetermined_parameters [ 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' ][ 'value' ] . set ( round ( i0_h_c_ref , 4 )) # A.m-2 choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . set ( round ( kappa_co , 4 )) # mol.m-1.s-1.Pa-1 choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . set ( round ( kappa_c , 4 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . set ( round ( a_slim , 7 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . set ( round ( b_slim , 7 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . set ( round ( a_switch , 7 )) choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . set ( round ( C_scl * 1e-6 , 4 )) # F.cm-3 # i_max_pola recovery choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . set ( round ( i_max_pola / 1e4 , 4 )) # A/cm\u00b2 # computing parameters recovery choice_computing_parameters [ 'Number of GC nodes - nb_gc' ][ 'value' ] . set ( nb_gc ) choice_computing_parameters [ 'Number of GDL nodes - nb_gdl' ][ 'value' ] . set ( nb_gdl ) choice_computing_parameters [ 'Number of MPL nodes - nb_mpl' ][ 'value' ] . set ( nb_mpl ) choice_computing_parameters [ 'Solver relative tolerance - rtol' ][ 'value' ] . set ( rtol ) choice_computing_parameters [ 'Solver absolute tolerance - atol' ][ 'value' ] . set ( atol ) recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ) This function retrieves and converts the parameter values from the GUI into standard units for further calculations. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ): \"\"\"This function retrieves and converts the parameter values from the GUI into standard units for further calculations. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. \"\"\" # operating conditions T_des = choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . get () + 273.15 # K Pa_des = choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . get () * 1e5 # Pa Pc_des = choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () * 1e5 # Pa Sa = choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () Sc = choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () Phi_a_des = choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () Phi_c_des = choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () y_H2_in = choice_operating_conditions [ 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' ][ 'value' ] . get () # accessible physical parameters Aact = choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . get () * 1e-4 # m\u00b2 nb_cell = int ( choice_accessible_parameters [ 'Number of cells - nb_cell' ][ 'value' ] . get ()) Hagc = choice_accessible_parameters [ 'Anode gas channel \\n thickness - Hagc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hcgc = choice_accessible_parameters [ 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Wagc = choice_accessible_parameters [ 'Anode gas channel \\n width - Wagc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Wcgc = choice_accessible_parameters [ 'Cathode gas channel \\n width - Wcgc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Lgc = choice_accessible_parameters [ 'Gas channel \\n length - Lgc (m)' ][ 'value' ] . get () * 1e-3 # m Lm = choice_accessible_parameters [ 'Manifold length - Lm (mm)' ][ 'value' ] . get () * 1e-3 # m Ldist = choice_accessible_parameters [ 'Distributor length - Ldist (mm)' ][ 'value' ] . get () * 1e-3 # m L_man_gc = choice_accessible_parameters [ 'Manifold-GC connection length - L_man_gc (mm)' ][ 'value' ] . get () * 1e-3 # m A_T_a = choice_accessible_parameters [ 'Exhaust anode manifold throttle \\n area - A_T_a (cm\u00b2)' ][ 'value' ] . get () * 1e-4 # m\u00b2 A_T_c = choice_accessible_parameters [ 'Exhaust cathode manifold throttle \\n area - A_T_c (cm\u00b2)' ][ 'value' ] . get () * 1e-4 # m\u00b2 Vasm = choice_accessible_parameters [ 'Supply anode manifold \\n volume - Vasm (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 Vcsm = choice_accessible_parameters [ 'Supply cathode manifold \\n volume - Vcsm (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 Vaem = choice_accessible_parameters [ 'Exhaust anode manifold \\n volume - Vaem (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 Vcem = choice_accessible_parameters [ 'Exhaust cathode manifold \\n volume - Vcem (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 V_endplate_a = choice_accessible_parameters [ 'Anode endplate volume - V_endplate_c (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 V_endplate_c = choice_accessible_parameters [ 'Cathode endplate volume - V_endplate_c (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 # undetermined physical parameters Hgdl = choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () * 1e-6 # m Hmpl = choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () * 1e-6 # m Hacl = choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hccl = choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hmem = choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m epsilon_gdl = choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () epsilon_cl = choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () epsilon_mpl = choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () epsilon_mc = choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () epsilon_c = choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () e = choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () Re = choice_undetermined_parameters [ 'Electron conduction \\n resistance - Re (\u03a9.mm\u00b2)' ][ 'value' ] . get () * 1e-6 # \u03a9.m\u00b2 i0_d_c_ref = choice_undetermined_parameters [ 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' ][ 'value' ] . get () # A.m-2 i0_h_c_ref = choice_undetermined_parameters [ 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' ][ 'value' ] . get () # A.m-2 kappa_co = choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () # mol.m-1.s-1.Pa-1 kappa_c = choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () a_slim = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () b_slim = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () a_switch = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () C_scl = choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () * 1e6 # F.m-3 # current density parameters delta_t_ini_step = choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_step (min)' ][ 'value' ] . get () * 60 #s delta_t_load_step = choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_step (s)' ][ 'value' ] . get () #s delta_t_break_step = choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_step (min)' ][ 'value' ] . get () * 60 #s i_step = choice_current_density_parameters [ 'Current density step \\n - i_step (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 delta_t_dyn_step = choice_computing_parameters [ 'Time for dynamic \\n display - \u0394t_dyn_step (s)' ][ 'value' ] . get () #s step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step , 'delta_t_dyn_step' : delta_t_dyn_step } delta_t_ini_pola = choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_pola (min)' ][ 'value' ] . get () * 60 #s delta_t_load_pola = choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_pola (s)' ][ 'value' ] . get () #s delta_t_break_pola = choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_pola (min)' ][ 'value' ] . get () * 60 #s delta_i_pola = choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 i_max_pola = choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola , 'i_max_pola' : i_max_pola } pola_current_for_cali_parameters = None # Calibration is not implemented in the GUI. i_EIS = choice_current_density_parameters [ 'Static current \\n - i_EIS (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # (A.m-2) ratio_EIS = choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () / 100 f_EIS = ( choice_current_density_parameters [ 'Power of the \\n initial frequency \\n - f_power_min_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Power of the \\n final frequency \\n - f_power_max_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get ()) t_EIS = EIS_parameters ( f_EIS ) # Time parameters for the EIS_current density function. # computing parameters t_purge = choice_computing_parameters [ 'Purge time - t_purge (s)' ][ 'value' ] . get () # s delta_t_purge = choice_computing_parameters [ 'Time between two purges \\n - \u0394t_purge (s)' ][ 'value' ] . get () # s nb_gc = choice_computing_parameters [ 'Number of GC nodes - nb_gc' ][ 'value' ] . get () nb_gdl = choice_computing_parameters [ 'Number of GDL nodes - nb_gdl' ][ 'value' ] . get () nb_mpl = choice_computing_parameters [ 'Number of MPL nodes - nb_mpl' ][ 'value' ] . get () rtol = choice_computing_parameters [ 'Solver relative tolerance - rtol' ][ 'value' ] . get () atol = choice_computing_parameters [ 'Solver absolute tolerance - atol' ][ 'value' ] . get () if choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 1.5 bar (2021)\" : type_fuel_cell = \"EH-31_1.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.0 bar (2021)\" : type_fuel_cell = \"EH-31_2.0\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.25 bar (2021)\" : type_fuel_cell = \"EH-31_2.25\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.5 bar (2021)\" : type_fuel_cell = \"EH-31_2.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"Enter your specifications\" : type_fuel_cell = \"manual_setup\" if choice_buttons [ 'type_auxiliary' ][ 'value' ] . get () == 0 : type_auxiliary = \"no_auxiliary\" elif choice_buttons [ 'type_auxiliary' ][ 'value' ] . get () == 1 : type_auxiliary = \"forced-convective_cathode_with_anodic_recirculation\" else : type_auxiliary = \"forced-convective_cathode_with_flow-through_anode\" if choice_buttons [ 'voltage_zone' ][ 'value' ] . get () == 0 : voltage_zone = \"full\" else : voltage_zone = \"before_voltage_drop\" if choice_buttons [ 'type_control' ][ 'value' ] . get () == 0 : type_control = \"no_control\" else : type_control = \"Phi_des\" if choice_buttons [ 'type_purge' ][ 'value' ] . get () == 0 : type_purge = \"no_purge\" elif choice_buttons [ 'type_purge' ][ 'value' ] . get () == 1 : type_purge = \"periodic_purge\" else : type_purge = \"constant_purge\" if choice_buttons [ 'type_display' ][ 'value' ] . get () == 0 : type_display = \"no_display\" elif choice_buttons [ 'type_display' ][ 'value' ] . get () == 1 : type_display = \"synthetic\" else : type_display = \"multiple\" if choice_buttons [ 'type_plot' ][ 'value' ] . get () == 0 : type_plot = \"fixed\" else : type_plot = \"dynamic\" return ( T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , Aact , nb_cell , Hgdl , Hmpl , Hacl , Hccl , Hmem , Hagc , Hcgc , Wagc , Wcgc , Lgc , Ldist , Lm , L_man_gc , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , V_endplate_a , V_endplate_c , epsilon_gdl , epsilon_cl , epsilon_mpl , epsilon_mc , epsilon_c , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl , step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , t_purge , delta_t_purge , nb_gdl , nb_mpl , nb_tl , rtol , atol , type_fuel_cell , voltage_zone , type_auxiliary , type_control , type_purge , type_display , type_plot ) set_equal_width ( frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ) Adjusts the width of the frames to be equal based on their maximum width. Parameters: frame1 ( Frame ) \u2013 The first frame to be resized. frame2 ( Frame ) \u2013 The second frame to be resized. frame3 ( Frame ) \u2013 The third frame to be resized. frame4 ( Frame ) \u2013 The fourth frame to be resized. frame5 ( Frame ) \u2013 The fifth frame to be resized. frame6 ( Frame ) \u2013 The sixth frame to be resized. Source code in modules/GUI_modules.py 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 def set_equal_width ( frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ): \"\"\" Adjusts the width of the frames to be equal based on their maximum width. Parameters ---------- frame1 : ttk.Frame The first frame to be resized. frame2 : ttk.Frame The second frame to be resized. frame3 : ttk.Frame The third frame to be resized. frame4 : ttk.Frame The fourth frame to be resized. frame5 : ttk.Frame The fifth frame to be resized. frame6 : ttk.Frame The sixth frame to be resized. \"\"\" # Initialisation of the list of widths widths = [] for frame in [ frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ]: # Update the frame sizes frame . update_idletasks () # Get the current width of all frames widths . append ( frame . winfo_width ()) # Set all frames to the maximum width for frame in [ frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ]: for i in range ( 6 ): frame . grid_columnconfigure ( i , minsize = max ( widths ) / 5.5 ) # Set minimum width of all column to max_width / 5 value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ) This function checks the integrity of the values entered by the user and returns an empty tuple if they are not valid. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in modules/GUI_modules.py 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 def value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function checks the integrity of the values entered by the user and returns an empty tuple if they are not valid. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # The values entered by the user are checked for compliance if choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Temperatures' , message = 'Negative temperatures do not exist in the Kelvin scale.' ) choices . clear () return if choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () > 5.0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () > 5.0 : messagebox . showerror ( title = 'Desired pressures' , message = 'Desired pressure should be positive and bellow 5.0 ' 'bars.' ) choices . clear () return if choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () < 1 or \\ choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () > 5 or \\ choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () < 1 or \\ choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () > 5 : messagebox . showerror ( title = 'Stoichiometric ratios' , message = 'The stoichiometric ratios Sa and Sc should be ' 'between 1 and 5.' ) choices . clear () return if choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () > 1 or \\ choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Desired humidity' , message = 'The desired humidities should be between 0 and 1.' ) choices . clear () return if choice_operating_conditions [ 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Anode inlet H2 ratio' , message = 'The anode inlet H2 ratio should be between 0 and 1.' ) choices . clear () return if choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Active area' , message = 'Negative active area is impossible.' ) choices . clear () return if choice_accessible_parameters [ 'Number of cells - nb_cell' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Number of cells' , message = 'Negative number of cells is impossible.' ) choices . clear () return if choice_accessible_parameters [ 'Exhaust anode manifold throttle \\n area - A_T_a (cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Exhaust cathode manifold throttle \\n area - A_T_c (cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Supply anode manifold \\n volume - Vasm (cm\u00b3)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Supply cathode manifold \\n volume - Vcsm (cm\u00b3)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Exhaust anode manifold \\n volume - Vaem (cm\u00b3)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Exhaust cathode manifold \\n volume - Vcem (cm\u00b3)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Manifold parameters' , message = 'Negative volumes or area are impossible.' ) choices . clear () return if choice_accessible_parameters [ 'Anode gas channel \\n thickness - Hagc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'Anode gas channel \\n thickness - Hagc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'Anode gas channel \\n width - Wagc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'Anode gas channel \\n width - Wagc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'Cathode gas channel \\n width - Wcgc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'Cathode gas channel \\n width - Wcgc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'Gas channel \\n length - Lgc (m)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Gas channel \\n length - Lgc (m)' ][ 'value' ] . get () > 1000 or \\ choice_accessible_parameters [ 'Distributor length - L_dist (mm)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Manifold length - Lm (mm)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Manifold-GC connection length - L_man_gc (mm)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'GC distances' , message = 'GC generally have a thickness and a width between 10\u00b5m and ' '10mm. Also, GC length is generally between 0 and 1000mm' ) choices . clear () return if ( choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () > 1000 or choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () > 1000 ): messagebox . showerror ( title = 'MEA thickness' , message = 'All MEA components generally have a thickness between ' '1\u00b5m and 1mm.' ) choices . clear () return if choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () < 0.4 or \\ choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () > 0.95 : messagebox . showerror ( title = 'GDL porosity' , message = 'GDL porosity should be between 0.4 and 0.95.' ) choices . clear () return if choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () < 0.12 or \\ choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () > 0.60 : messagebox . showerror ( title = 'GDL porosity' , message = 'CL porosity should be between 0.12 and 0.60.' ) choices . clear () return if choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () < 0.30 or \\ choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () > 0.70 : messagebox . showerror ( title = 'MPL porosity' , message = 'MPL porosity should be between 0.30 and 0.70.' ) choices . clear () return if choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Ionomer volume fraction' , message = 'Ionomer volume fraction should be between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Compression ratio' , message = 'The compression ratio should be between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () < 3 or choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () > 5 : messagebox . showerror ( title = 'Capillary exponent' , message = 'The capillary exponent should be between 3 and 5 and ' 'being an integer.' ) choices . clear () return if choice_undetermined_parameters [ 'Electron conduction \\n resistance - Re (\u03a9.mm\u00b2)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Electron conduction resistance' , message = 'Re should be positive.' ) choices . clear () return if choice_undetermined_parameters [ 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' ][ 'value' ] . get () < 0.001 or \\ choice_undetermined_parameters [ 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' ][ 'value' ] . get () > 100 or \\ choice_undetermined_parameters [ 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' ][ 'value' ] . get () < 0.001 or \\ choice_undetermined_parameters [ 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Referenced exchange current densities' , message = 'The referenced exchange current ' 'densities are generally between 0.001 ' 'and 100 A.m-2.' ) choices . clear () return if choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () < 0.01 or \\ choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Crossover correction coefficient' , message = 'The crossover correction coefficient is' ' generally between 0.01 and 100 ' 'mol.m-1.s-1.Pa-1.' ) choices . clear () return if choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Overpotential correction exponent' , message = 'The overpotential correction exponent ' 'is generally between 0 and 100.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Slop of slim function' , message = 'The slop of slim function is generally between 0 ' 'and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Intercept of slim function' , message = 'The intercept of slim function is generally ' 'between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Slop of switch function' , message = 'The slop of switch function is generally between' ' 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () < 5 or \\ choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Double layer capacitance' , message = 'I have not settled yet a range for C_scl.' ) choices . clear () return if choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_step (min)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_step (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_step (min)' ][ 'value' ] . get () < 0 or \\ choice_computing_parameters [ 'Time for dynamic \\n display - \u0394t_dyn_step (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_pola (min)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_pola (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_pola (min)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Times' , message = 'The times should be positive, t0_step < tf_step and ' 'delta_t_load_step < (tf_step - t0_step).' ) choices . clear () return if choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Static current \\n - i_EIS (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () > \\ choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get (): messagebox . showerror ( title = 'Current densities' , message = 'The current densities should be positive, ' 'delta_i_pola < i_max_pola and ' 'i_ini_step < i_final_step.' ) choices . clear () return if choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () > 20 : messagebox . showerror ( title = 'Ratio EIS' , message = 'Ratio EIS is a percentage of i_EIS and should be between 0 ' 'and 20 for plotting correct EIS.' ) choices . clear () return if choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get () < 0 or \\ type ( choice_current_density_parameters [ 'Power of the \\n initial frequency \\n - f_power_min_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Power of the \\n final frequency \\n - f_power_max_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'f EIS' , message = 'f_EIS parameters should be integer and number of points should ' 'be positive.' ) choices . clear () return if choice_computing_parameters [ 'Purge time - t_purge (s)' ][ 'value' ] . get () < 0 or \\ choice_computing_parameters [ 'Time between two purges \\n - \u0394t_purge (s)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Purge times' , message = 'Negative times does not characterise purges.' ) choices . clear () return if choice_computing_parameters [ 'Number of GC nodes - nb_gc' ][ 'value' ] . get () < 1 or \\ type ( choice_computing_parameters [ 'Number of GC nodes - nb_gc' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'nb_gc' , message = 'The nb_gc value should be an integer bigger or equal to 1.' ) choices . clear () return if choice_computing_parameters [ 'Number of GDL nodes - nb_gdl' ][ 'value' ] . get () < 1 or \\ type ( choice_computing_parameters [ 'Number of GDL nodes - nb_gdl' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'nb_gdl' , message = 'The nb_gdl value should be an integer bigger or equal to 1.' ) choices . clear () return if choice_computing_parameters [ 'Number of MPL nodes - nb_mpl' ][ 'value' ] . get () < 1 or \\ type ( choice_computing_parameters [ 'Number of MPL nodes - nb_mpl' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'nb_mpl' , message = 'The nb_mpl value should be an integer bigger or equal to 1.' ) choices . clear () return if choice_computing_parameters [ 'Solver relative tolerance - rtol' ][ 'value' ] . get () > 1e-3 or \\ choice_computing_parameters [ 'Solver absolute tolerance - atol' ][ 'value' ] . get () > 1e-3 : messagebox . showerror ( title = 'Solver tolerance' , message = 'rtol and atol should be lower than 1e-3 to limit the' ' numerical errors.' ) choices . clear () return if current_button == 0 and choice_buttons [ 'type_display' ][ 'value' ] . get () == 2 \\ and choice_buttons [ 'type_plot' ][ 'value' ] . get () == 1 : messagebox . showerror ( title = 'n gdl' , message = 'dynamic plot is not thought to be used with step current and ' 'multiple display. There would be too much plots to handle.' ) choices . clear () return","title":"GUI modules"},{"location":"functions/modules/GUI_modules/#gui-modules","text":"This module contains some of the required functions for the GUI.py file.","title":"GUI modules"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.changeValue","text":"This function is called when the user selects a specific option from a dropdown menu for the type of fuel cell. Depending on the selected option, it either hides or displays specific input fields (labels or entry widgets) on the GUI. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choices_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def changeValue ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ): \"\"\"This function is called when the user selects a specific option from a dropdown menu for the type of fuel cell. Depending on the selected option, it either hides or displays specific input fields (labels or entry widgets) on the GUI. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choices_buttons : dict A dictionary containing the button information. \"\"\" if choices_buttons [ 'type_fuel_cell' ][ 'value' ] . get () != 'Enter your specifications' : # Recovers the new settings recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choices_buttons ) # Display the labels for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Label ( operating_conditions_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Label ( accessible_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Label ( undetermined_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Label ( current_density_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Label ( computing_parameters_frame , width = 7 , anchor = 'w' , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) else : # choices_buttons['type_fuel_cell']['value'].get() == 'Enter your specifications': # Saves and displays the user entries for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Entry ( operating_conditions_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Entry ( accessible_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Entry ( undetermined_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Entry ( current_density_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Entry ( computing_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 )","title":"changeValue"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.display_parameter_labels","text":"This function displays labels on the GUI, representing operating conditions and physical parameters, without their actual values. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. Source code in modules/GUI_modules.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def display_parameter_labels ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ): \"\"\"This function displays labels on the GUI, representing operating conditions and physical parameters, without their actual values. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. \"\"\" # Display the titles ttk . Label ( operating_conditions_frame , text = 'Operating conditions' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 1 , column = 0 , columnspan = 6 , ipady = 15 ) ttk . Label ( accessible_parameters_frame , text = 'Accessible physical parameters' , font = ( 'cmr10' , 12 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 6 , ipady = 15 ) # Display the labels for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Label ( operating_conditions_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Label ( accessible_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Label ( undetermined_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # current density parameters ttk . Label ( current_density_parameters_frame , text = 'Step current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 0 , column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Label ( current_density_parameters_frame , text = 'Polarization current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 2 , column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Label ( current_density_parameters_frame , text = 'EIS current parameters' , font = ( 'cmr10' , 10 , 'bold' )) . \\ grid ( row = 5 , column = 0 , columnspan = 2 , sticky = \"w\" ) for k , v in choice_current_density_parameters . items (): ttk . Label ( current_density_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Label ( computing_parameters_frame , text = k , font = ( 'cmr10' , 10 )) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ] - 1 , sticky = \"w\" )","title":"display_parameter_labels"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.display_parameters_value","text":"This function displays entry widgets on the GUI. There, the user can enter values for operating conditions and physical parameters. Parameters: operating_conditions_frame ( Frame ) \u2013 The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame ( Frame ) \u2013 The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. Source code in modules/GUI_modules.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def display_parameters_value ( operating_conditions_frame , accessible_parameters_frame , undetermined_parameters_frame , current_density_parameters_frame , computing_parameters_frame , choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters ): \"\"\"This function displays entry widgets on the GUI. There, the user can enter values for operating conditions and physical parameters. Parameters ---------- operating_conditions_frame : ttk.Frame The frame where the graphical elements for the operating condition and the choice of fuel cell are placed. accessible_parameters_frame : ttk.Frame The frame where the graphical elements for the accessible physical parameters are placed. undetermined_parameters_frame : ttk.Frame The frame where the graphical elements for the undetermined physical parameters are placed. current_density_parameters_frame : ttk.Frame The frame where the graphical elements for the current density parameters are placed. computing_parameters_frame : ttk.Frame The frame where the graphical elements for the computing parameters are placed. choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. \"\"\" # Display the value for ... # operating conditions for k , v in choice_operating_conditions . items (): ttk . Entry ( operating_conditions_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # accessible physical parameters for k , v in choice_accessible_parameters . items (): ttk . Entry ( accessible_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # undetermined physical parameters for k , v in choice_undetermined_parameters . items (): ttk . Entry ( undetermined_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # current density parameters for k , v in choice_current_density_parameters . items (): ttk . Entry ( current_density_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 ) # computing parameters for k , v in choice_computing_parameters . items (): ttk . Entry ( computing_parameters_frame , width = 7 , textvariable = v [ 'value' ]) . \\ grid ( row = v [ 'label_row' ], column = v [ 'label_column' ], padx = 5 )","title":"display_parameters_value"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.display_radiobuttons","text":"This function displays radiobuttons on the GUI, allowing the user to make choices for control, results display, plot style, etc. Parameters: model_possibilities_frame ( Frame ) \u2013 The frame where the graphical elements for the model possibilities and the choice of current density are placed. choices_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def display_radiobuttons ( model_possibilities_frame , choices_buttons ): \"\"\"This function displays radiobuttons on the GUI, allowing the user to make choices for control, results display, plot style, etc. Parameters ---------- model_possibilities_frame : ttk.Frame The frame where the graphical elements for the model possibilities and the choice of current density are placed. choices_buttons : dict A dictionary containing the button information. \"\"\" ttk . Label ( model_possibilities_frame , text = 'Model possibilities' , font = ( 'cmr10' , 12 , 'bold' )) \\ . grid ( row = 0 , column = 0 , columnspan = 6 , ipady = 15 ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Auxiliaries: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 0 , columnspan = 1 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No auxiliaries' , value = 0 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Forced-convective cathode \\n with anodic recirculation' , value = 1 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Forced-convective cathode \\n with flow-through anode' , value = 2 , variable = choices_buttons [ 'type_auxiliary' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_auxiliary' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Voltage zone: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'voltage_zone' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Full' , value = 0 , variable = choices_buttons [ 'voltage_zone' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'voltage_zone' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Before voltage drop' , value = 1 , variable = choices_buttons [ 'voltage_zone' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'voltage_zone' ][ 'label_row' ], column = 3 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Control: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No control' , value = 0 , variable = choices_buttons [ 'type_control' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Humidity' , value = 1 , variable = choices_buttons [ 'type_control' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_control' ][ 'label_row' ], column = 3 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Purge: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No purge' , value = 0 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Periodic' , value = 1 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Constant' , value = 2 , variable = choices_buttons [ 'type_purge' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_purge' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Display: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'No display' , value = 0 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Synthetic' , value = 1 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 3 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Multiple' , value = 2 , variable = choices_buttons [ 'type_display' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_display' ][ 'label_row' ], column = 4 , sticky = \"w\" ) # Ask the user to choose an option and save it ttk . Label ( model_possibilities_frame , text = 'Plot: ' , font = ( 'cmr10' , 12 )) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 0 , columnspan = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Fixed' , value = 0 , variable = choices_buttons [ 'type_plot' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 2 , sticky = \"w\" ) ttk . Radiobutton ( model_possibilities_frame , text = 'Dynamic' , value = 1 , variable = choices_buttons [ 'type_plot' ][ 'value' ]) . \\ grid ( row = choices_buttons [ 'type_plot' ][ 'label_row' ], column = 3 , sticky = \"w\" )","title":"display_radiobuttons"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.launch_AlphaPEM_for_EIS_current","text":"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 def launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None t0_EIS , t_new_start , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = current_parameters [ 't_EIS' ] f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = current_parameters [ 'f_EIS' ] # These are used for EIS max_step # actualization. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested. n = len ( t_new_start ) # It is the plot update number. time_interval = [ 0 , t0_EIS ] # It is the initial time interval. # A preliminary simulation run is necessary to equilibrate the internal variables of the cell at i_EIS # prior to initiating the EIS. Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization t0_EIS_temp = t0_EIS # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ 0 ] + delta_t_break_EIS [ 0 ] + delta_t_measurement_EIS [ 0 ] # It is the final time for # 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which has been # made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) if computing_parameters [ 'type_display' ] == \"multiple\" : print ( \"A display bug prevents the dynamic updating of the graphs, as it appears that too much data is \" \"involved. However, the data is correctly calculated, and the appropriate plots are saved in the \" \"'results' folder. This display bug does not occur when using a 'synthetic' type_display.\" ) # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_EIS_temp = Simulator . variables [ 't' ][ - 1 ] # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ i + 1 ] + delta_t_break_EIS [ i + 1 ] + delta_t_measurement_EIS [ i + 1 ] # It # is the final time for 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which # has been made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # It is the time interval for 1 EIS point. # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_EIS_current"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.launch_AlphaPEM_for_polarization_current","text":"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 def launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_load_pola' ] # (s). delta_t_break_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_t_break_pola' ] # (s). delta_i_pola = current_parameters [ 'pola_current_parameters' ][ 'delta_i_pola' ] # (A.m-2). i_max_pola = current_parameters [ 'pola_current_parameters' ][ 'i_max_pola' ] # (A.m-2). # Calculation delta_t_pola = delta_t_load_pola + delta_t_break_pola # s. It is the time of one load. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * delta_t_pola # s. It is the polarization current duration. n = int ( tf / delta_t_pola ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola + delta_t_pola ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola + ( i + 2 ) * delta_t_pola time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_polarization_current"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.launch_AlphaPEM_for_step_current","text":"Launch the AlphaPEM simulator for a step current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). Source code in modules/GUI_modules.py 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 def launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a step current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. It contains: - current_density : function Current density evolution over time (operating input). It is a function of time and parameters dictionary. - T_des : float Desired fuel cell temperature in Kelvin (operating input). - Pa_des : float Desired anode pressure in Pascal (operating input). - Pc_des : float Desired cathode pressure in Pascal (operating input). - Sa : float Stoichiometric ratio of hydrogen (operating input). - Sc : float Stoichiometric ratio of oxygen (operating input). - Phi_a_des : float Desired anode relative humidity (operating input). - Phi_c_des : float Desired cathode relative humidity (operating input). current_parameters : dict Dictionary containing the current parameters for the simulation. It contains: - step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. - pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. - pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. - i_EIS : float Current for which a ratio_EIS perturbation is added (current parameter). - ratio_EIS : float Value of the perturbation on the current density for building the EIS curve (current parameter). - t_EIS : tuple EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters (current parameters). It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. It contains: - Aact : float Active area of the cell in m\u00b2 (accessible physical parameter). - nb_cell : int Number of cells in the stack (accessible physical parameter). - Hagc : float Thickness of the anode gas channel in m (accessible physical parameter). - Hcgc : float Thickness of the cathode gas channel in m (accessible physical parameter). - Wagc : float Width of the anode gas channel in m (accessible physical parameter). - Wcgc : float Width of the cathode gas channel in m (accessible physical parameter). - Lgc : float Length of the gas channel in m (accessible physical parameter). - Lm : float Length of the manifold in m (accessible physical parameter). - L_endplate : float Length of the endplate in m (accessible physical parameter). - L_man_gc : float Length connecting the manifold and the gas channel in m (accessible physical parameter). - A_T_a : float Exhaust anode manifold throttle area in m\u00b2 (accessible physical parameter). - A_T_c : float Exhaust cathode manifold throttle area in m\u00b2 (accessible physical parameter). - Vasm : float Supply anode manifold volume in m\u00b3 (accessible physical parameter). - Vcsm : float Supply cathode manifold volume in m\u00b3 (accessible physical parameter). - Vaem : float Exhaust anode manifold volume in m\u00b3 (accessible physical parameter). - Vcem : float Exhaust cathode manifold volume in m\u00b3 (accessible physical parameter). - V_endplate_a : float Anode endplate volume in m\u00b3 (accessible physical parameter). - V_endplate_c : float Cathode endplate volume in m\u00b3 (accessible physical parameter). undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. It contains: - Hgdl : float Thickness of the gas diffusion layer in m (undetermined physical parameter). - Hmem : float Thickness of the membrane in m (undetermined physical parameter). - Hacl : float Thickness of the anode catalyst layer in m (undetermined physical parameter). - Hccl : float Thickness of the cathode catalyst layer in m (undetermined physical parameter). - epsilon_gdl : float Anode/cathode GDL porosity (undetermined physical parameter). - epsilon_cl : float Anode/cathode CL porosity (undetermined physical parameter). - epsilon_mc : float Volume fraction of ionomer in the CL (undetermined physical parameter). - epsilon_c : float Compression ratio of the GDL (undetermined physical parameter). - e : float Capillary exponent (undetermined physical parameter). - Re : float Electron conduction resistance in \u03a9.m2 (undetermined physical parameter). - i0_d_c_ref : float Dry reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - i0_h_c_ref : float Humid reference exchange current density at the cathode in A.m-2 (undetermined physical parameter). - kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter). - kappa_c : float Overpotential correction exponent (undetermined physical parameter). - a_slim : float One of the limit liquid saturation coefficients: the slop of slim function (undetermined physical parameter). - b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function (undetermined physical parameter). - a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function (undetermined physical parameter). - C_scl : float Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter). computing_parameters : dict Dictionary containing the computing parameters for the simulation. It contains: - Htl : float Thickness of the transition layers in meters (computing parameter). - nb_gdl : int Number of points considered in the GDL (computing parameter). - nb_mpl : int Number of points considered in the MPL (computing parameter). - nb_tl : int Number of points considered in the transitory layer (computing parameter). - t_purge : tuple Time parameters for purging the system (computing parameter). It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. - rtol : float Relative tolerance for the solver (computing parameter). - atol : float Absolute tolerance for the solver (computing parameter). - type_fuel_cell : str Type of fuel cell configuration (computing parameter). - type_current : str Type of current density function (computing parameter). - voltage_zone : str Zone of interest for the polarization curve (computing parameter). - type_auxiliary : str Type of auxiliary system (computing parameter). - type_control : str Type of control system (computing parameter). - type_purge : str Type of purge system (computing parameter). - type_display : str Type of display (computing parameter). - type_plot : str Type of plot (computing parameter). \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Check if the type_fuel_cell and type_current are valid if computing_parameters [ 'type_current' ] == \"step\" and computing_parameters [ 'type_display' ] == \"multiple\" : raise ValueError ( 'dynamic plot is not thought to be used with step current and multiple display.' + 'There would be too much plots to handle.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters tf_step = ( current_parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_break_step' ]) # (s). delta_t_dyn_step = current_parameters [ 'step_current_parameters' ][ 'delta_t_dyn_step' ] # (s). # Calculation n = int ( tf_step / delta_t_dyn_step ) # It is the plot update number. time_interval = [ 0 , delta_t_dyn_step ] # (s). It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = ( i + 2 ) * delta_t_dyn_step time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time )","title":"launch_AlphaPEM_for_step_current"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.recover_for_display_operating_inputs_and_physical_parameters","text":"This function retrieves parameter values for predefined stacks (e.g., \"EH-31 1.5 bar (2021)\", \"Biao Xie 1.0 bar (2015)\", etc.) and converts them to appropriate units for display on the GUI. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def recover_for_display_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ): \"\"\"This function retrieves parameter values for predefined stacks (e.g., \"EH-31 1.5 bar (2021)\", \"Biao Xie 1.0 bar (2015)\", etc.) and converts them to appropriate units for display on the GUI. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. \"\"\" # type_fuel_cell recovery if choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 1.5 bar (2021)\" : type_fuel_cell = \"EH-31_1.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.0 bar (2021)\" : type_fuel_cell = \"EH-31_2.0\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.25 bar (2021)\" : type_fuel_cell = \"EH-31_2.25\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.5 bar (2021)\" : type_fuel_cell = \"EH-31_2.5\" if choice_buttons [ 'voltage_zone' ][ 'value' ] . get () == 0 : voltage_zone = \"full\" else : voltage_zone = \"before_voltage_drop\" ( step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , current_density ) = calculate_current_density_parameters () T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , i_max_pola = stored_operating_inputs ( type_fuel_cell , voltage_zone ) ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , nb_channel_in_gc , Ldist , Lm , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , Aact , nb_cell , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl ) = stored_physical_parameters ( type_fuel_cell ) nb_gc , nb_gdl , nb_mpl , t_purge , rtol , atol = calculate_computing_parameters ( step_current_parameters , Hgdl , Hmpl , Hacl ) # operating conditions recovery choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . set ( round ( T_des - 273.15 , 4 )) # \u00b0C choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . set ( round ( Pa_des / 1e5 , 4 )) # bar choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . set ( round ( Pc_des / 1e5 , 4 )) # bar choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . set ( round ( Sa , 4 )) choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . set ( round ( Sc , 4 )) choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . set ( round ( Phi_a_des , 4 )) choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . set ( round ( Phi_c_des , 4 )) choice_operating_conditions [ 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' ][ 'value' ] . set ( round ( y_H2_in , 4 )) # accessible physical parameters recovery choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . set ( round ( Aact * 1e4 , 4 )) # cm\u00b2 choice_accessible_parameters [ 'Number of cells - nb_cell' ][ 'value' ] . set ( int ( nb_cell )) choice_accessible_parameters [ 'Anode gas channel \\n thickness - Hagc (\u00b5m)' ][ 'value' ] . set ( round ( Hagc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' ][ 'value' ] . set ( round ( Hcgc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'Anode gas channel \\n width - Wagc (\u00b5m)' ][ 'value' ] . set ( round ( Wagc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'Cathode gas channel \\n width - Wcgc (\u00b5m)' ][ 'value' ] . set ( round ( Wcgc * 1e6 , 4 )) # \u00b5m choice_accessible_parameters [ 'Gas channel \\n length - Lgc (m)' ][ 'value' ] . set ( round ( Lgc * 1e3 , 4 )) # mm choice_accessible_parameters [ 'Number of channels inside the \\n gas channel - nb_channel_in_gc' ][ 'value' ] . set ( int ( nb_channel_in_gc )) choice_accessible_parameters [ 'Distributor length - L_dist (mm)' ][ 'value' ] . set ( round ( Ldist * 1e3 , 4 )) # mm choice_accessible_parameters [ 'Manifold length - Lm (mm)' ][ 'value' ] . set ( round ( Lm * 1e3 , 4 )) # mm choice_accessible_parameters [ 'Exhaust anode manifold throttle \\n area - A_T_a (cm\u00b2)' ][ 'value' ] . set ( round ( A_T_a * 1e4 , 4 )) # cm\u00b2 choice_accessible_parameters [ 'Exhaust cathode manifold throttle \\n area - A_T_c (cm\u00b2)' ][ 'value' ] . set ( round ( A_T_c * 1e4 , 4 )) # cm\u00b2 choice_accessible_parameters [ 'Supply anode manifold \\n volume - Vasm (cm\u00b3)' ][ 'value' ] . set ( round ( Vasm * 1e6 , 4 )) # cm\u00b3 choice_accessible_parameters [ 'Supply cathode manifold \\n volume - Vcsm (cm\u00b3)' ][ 'value' ] . set ( round ( Vcsm * 1e6 , 4 )) # cm\u00b3 choice_accessible_parameters [ 'Exhaust anode manifold \\n volume - Vaem (cm\u00b3)' ][ 'value' ] . set ( round ( Vaem * 1e6 , 4 )) # cm\u00b3 choice_accessible_parameters [ 'Exhaust cathode manifold \\n volume - Vcem (cm\u00b3)' ][ 'value' ] . set ( round ( Vcem * 1e6 , 4 )) # cm\u00b3 # undetermined physical parameters recovery choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . set ( round ( Hgdl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer) \\n (without the transition layer)' ][ 'value' ] . set ( round ( Hmpl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . set ( round ( Hacl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . set ( round ( Hccl * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . set ( round ( Hmem * 1e6 , 4 )) # \u00b5m choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . set ( round ( epsilon_gdl , 4 )) choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . set ( round ( epsilon_cl , 4 )) choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . set ( round ( epsilon_mpl , 4 )) choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . set ( round ( epsilon_mc , 4 )) choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . set ( round ( epsilon_c , 4 )) choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . set ( e ) choice_undetermined_parameters [ 'Electron conduction \\n resistance - Re (\u03a9.mm\u00b2)' ][ 'value' ] . set ( round ( Re * 1e6 , 4 )) # A.mm-2 choice_undetermined_parameters [ 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' ][ 'value' ] . set ( round ( i0_d_c_ref , 4 )) # A.m-2 choice_undetermined_parameters [ 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' ][ 'value' ] . set ( round ( i0_h_c_ref , 4 )) # A.m-2 choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . set ( round ( kappa_co , 4 )) # mol.m-1.s-1.Pa-1 choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . set ( round ( kappa_c , 4 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . set ( round ( a_slim , 7 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . set ( round ( b_slim , 7 )) choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . set ( round ( a_switch , 7 )) choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . set ( round ( C_scl * 1e-6 , 4 )) # F.cm-3 # i_max_pola recovery choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . set ( round ( i_max_pola / 1e4 , 4 )) # A/cm\u00b2 # computing parameters recovery choice_computing_parameters [ 'Number of GC nodes - nb_gc' ][ 'value' ] . set ( nb_gc ) choice_computing_parameters [ 'Number of GDL nodes - nb_gdl' ][ 'value' ] . set ( nb_gdl ) choice_computing_parameters [ 'Number of MPL nodes - nb_mpl' ][ 'value' ] . set ( nb_mpl ) choice_computing_parameters [ 'Solver relative tolerance - rtol' ][ 'value' ] . set ( rtol ) choice_computing_parameters [ 'Solver absolute tolerance - atol' ][ 'value' ] . set ( atol )","title":"recover_for_display_operating_inputs_and_physical_parameters"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.recover_for_use_operating_inputs_and_physical_parameters","text":"This function retrieves and converts the parameter values from the GUI into standard units for further calculations. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. Source code in modules/GUI_modules.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def recover_for_use_operating_inputs_and_physical_parameters ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons ): \"\"\"This function retrieves and converts the parameter values from the GUI into standard units for further calculations. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. \"\"\" # operating conditions T_des = choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . get () + 273.15 # K Pa_des = choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . get () * 1e5 # Pa Pc_des = choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () * 1e5 # Pa Sa = choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () Sc = choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () Phi_a_des = choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () Phi_c_des = choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () y_H2_in = choice_operating_conditions [ 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' ][ 'value' ] . get () # accessible physical parameters Aact = choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . get () * 1e-4 # m\u00b2 nb_cell = int ( choice_accessible_parameters [ 'Number of cells - nb_cell' ][ 'value' ] . get ()) Hagc = choice_accessible_parameters [ 'Anode gas channel \\n thickness - Hagc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hcgc = choice_accessible_parameters [ 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Wagc = choice_accessible_parameters [ 'Anode gas channel \\n width - Wagc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Wcgc = choice_accessible_parameters [ 'Cathode gas channel \\n width - Wcgc (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Lgc = choice_accessible_parameters [ 'Gas channel \\n length - Lgc (m)' ][ 'value' ] . get () * 1e-3 # m Lm = choice_accessible_parameters [ 'Manifold length - Lm (mm)' ][ 'value' ] . get () * 1e-3 # m Ldist = choice_accessible_parameters [ 'Distributor length - Ldist (mm)' ][ 'value' ] . get () * 1e-3 # m L_man_gc = choice_accessible_parameters [ 'Manifold-GC connection length - L_man_gc (mm)' ][ 'value' ] . get () * 1e-3 # m A_T_a = choice_accessible_parameters [ 'Exhaust anode manifold throttle \\n area - A_T_a (cm\u00b2)' ][ 'value' ] . get () * 1e-4 # m\u00b2 A_T_c = choice_accessible_parameters [ 'Exhaust cathode manifold throttle \\n area - A_T_c (cm\u00b2)' ][ 'value' ] . get () * 1e-4 # m\u00b2 Vasm = choice_accessible_parameters [ 'Supply anode manifold \\n volume - Vasm (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 Vcsm = choice_accessible_parameters [ 'Supply cathode manifold \\n volume - Vcsm (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 Vaem = choice_accessible_parameters [ 'Exhaust anode manifold \\n volume - Vaem (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 Vcem = choice_accessible_parameters [ 'Exhaust cathode manifold \\n volume - Vcem (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 V_endplate_a = choice_accessible_parameters [ 'Anode endplate volume - V_endplate_c (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 V_endplate_c = choice_accessible_parameters [ 'Cathode endplate volume - V_endplate_c (cm\u00b3)' ][ 'value' ] . get () * 1e-6 # m\u00b3 # undetermined physical parameters Hgdl = choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () * 1e-6 # m Hmpl = choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () * 1e-6 # m Hacl = choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hccl = choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m Hmem = choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () * 1e-6 # m epsilon_gdl = choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () epsilon_cl = choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () epsilon_mpl = choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () epsilon_mc = choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () epsilon_c = choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () e = choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () Re = choice_undetermined_parameters [ 'Electron conduction \\n resistance - Re (\u03a9.mm\u00b2)' ][ 'value' ] . get () * 1e-6 # \u03a9.m\u00b2 i0_d_c_ref = choice_undetermined_parameters [ 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' ][ 'value' ] . get () # A.m-2 i0_h_c_ref = choice_undetermined_parameters [ 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' ][ 'value' ] . get () # A.m-2 kappa_co = choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () # mol.m-1.s-1.Pa-1 kappa_c = choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () a_slim = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () b_slim = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () a_switch = choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () C_scl = choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () * 1e6 # F.m-3 # current density parameters delta_t_ini_step = choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_step (min)' ][ 'value' ] . get () * 60 #s delta_t_load_step = choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_step (s)' ][ 'value' ] . get () #s delta_t_break_step = choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_step (min)' ][ 'value' ] . get () * 60 #s i_step = choice_current_density_parameters [ 'Current density step \\n - i_step (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 delta_t_dyn_step = choice_computing_parameters [ 'Time for dynamic \\n display - \u0394t_dyn_step (s)' ][ 'value' ] . get () #s step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step , 'delta_t_dyn_step' : delta_t_dyn_step } delta_t_ini_pola = choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_pola (min)' ][ 'value' ] . get () * 60 #s delta_t_load_pola = choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_pola (s)' ][ 'value' ] . get () #s delta_t_break_pola = choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_pola (min)' ][ 'value' ] . get () * 60 #s delta_i_pola = choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 i_max_pola = choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # A.m-2 pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola , 'i_max_pola' : i_max_pola } pola_current_for_cali_parameters = None # Calibration is not implemented in the GUI. i_EIS = choice_current_density_parameters [ 'Static current \\n - i_EIS (A/cm\u00b2)' ][ 'value' ] . get () * 1e4 # (A.m-2) ratio_EIS = choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () / 100 f_EIS = ( choice_current_density_parameters [ 'Power of the \\n initial frequency \\n - f_power_min_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Power of the \\n final frequency \\n - f_power_max_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get (), choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get ()) t_EIS = EIS_parameters ( f_EIS ) # Time parameters for the EIS_current density function. # computing parameters t_purge = choice_computing_parameters [ 'Purge time - t_purge (s)' ][ 'value' ] . get () # s delta_t_purge = choice_computing_parameters [ 'Time between two purges \\n - \u0394t_purge (s)' ][ 'value' ] . get () # s nb_gc = choice_computing_parameters [ 'Number of GC nodes - nb_gc' ][ 'value' ] . get () nb_gdl = choice_computing_parameters [ 'Number of GDL nodes - nb_gdl' ][ 'value' ] . get () nb_mpl = choice_computing_parameters [ 'Number of MPL nodes - nb_mpl' ][ 'value' ] . get () rtol = choice_computing_parameters [ 'Solver relative tolerance - rtol' ][ 'value' ] . get () atol = choice_computing_parameters [ 'Solver absolute tolerance - atol' ][ 'value' ] . get () if choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 1.5 bar (2021)\" : type_fuel_cell = \"EH-31_1.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.0 bar (2021)\" : type_fuel_cell = \"EH-31_2.0\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.25 bar (2021)\" : type_fuel_cell = \"EH-31_2.25\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"EH-31 2.5 bar (2021)\" : type_fuel_cell = \"EH-31_2.5\" elif choice_buttons [ 'type_fuel_cell' ][ 'value' ] . get () == \"Enter your specifications\" : type_fuel_cell = \"manual_setup\" if choice_buttons [ 'type_auxiliary' ][ 'value' ] . get () == 0 : type_auxiliary = \"no_auxiliary\" elif choice_buttons [ 'type_auxiliary' ][ 'value' ] . get () == 1 : type_auxiliary = \"forced-convective_cathode_with_anodic_recirculation\" else : type_auxiliary = \"forced-convective_cathode_with_flow-through_anode\" if choice_buttons [ 'voltage_zone' ][ 'value' ] . get () == 0 : voltage_zone = \"full\" else : voltage_zone = \"before_voltage_drop\" if choice_buttons [ 'type_control' ][ 'value' ] . get () == 0 : type_control = \"no_control\" else : type_control = \"Phi_des\" if choice_buttons [ 'type_purge' ][ 'value' ] . get () == 0 : type_purge = \"no_purge\" elif choice_buttons [ 'type_purge' ][ 'value' ] . get () == 1 : type_purge = \"periodic_purge\" else : type_purge = \"constant_purge\" if choice_buttons [ 'type_display' ][ 'value' ] . get () == 0 : type_display = \"no_display\" elif choice_buttons [ 'type_display' ][ 'value' ] . get () == 1 : type_display = \"synthetic\" else : type_display = \"multiple\" if choice_buttons [ 'type_plot' ][ 'value' ] . get () == 0 : type_plot = \"fixed\" else : type_plot = \"dynamic\" return ( T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , Aact , nb_cell , Hgdl , Hmpl , Hacl , Hccl , Hmem , Hagc , Hcgc , Wagc , Wcgc , Lgc , Ldist , Lm , L_man_gc , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , V_endplate_a , V_endplate_c , epsilon_gdl , epsilon_cl , epsilon_mpl , epsilon_mc , epsilon_c , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl , step_current_parameters , pola_current_parameters , pola_current_for_cali_parameters , i_EIS , ratio_EIS , f_EIS , t_EIS , t_purge , delta_t_purge , nb_gdl , nb_mpl , nb_tl , rtol , atol , type_fuel_cell , voltage_zone , type_auxiliary , type_control , type_purge , type_display , type_plot )","title":"recover_for_use_operating_inputs_and_physical_parameters"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.set_equal_width","text":"Adjusts the width of the frames to be equal based on their maximum width. Parameters: frame1 ( Frame ) \u2013 The first frame to be resized. frame2 ( Frame ) \u2013 The second frame to be resized. frame3 ( Frame ) \u2013 The third frame to be resized. frame4 ( Frame ) \u2013 The fourth frame to be resized. frame5 ( Frame ) \u2013 The fifth frame to be resized. frame6 ( Frame ) \u2013 The sixth frame to be resized. Source code in modules/GUI_modules.py 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 def set_equal_width ( frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ): \"\"\" Adjusts the width of the frames to be equal based on their maximum width. Parameters ---------- frame1 : ttk.Frame The first frame to be resized. frame2 : ttk.Frame The second frame to be resized. frame3 : ttk.Frame The third frame to be resized. frame4 : ttk.Frame The fourth frame to be resized. frame5 : ttk.Frame The fifth frame to be resized. frame6 : ttk.Frame The sixth frame to be resized. \"\"\" # Initialisation of the list of widths widths = [] for frame in [ frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ]: # Update the frame sizes frame . update_idletasks () # Get the current width of all frames widths . append ( frame . winfo_width ()) # Set all frames to the maximum width for frame in [ frame1 , frame2 , frame3 , frame4 , frame5 , frame6 ]: for i in range ( 6 ): frame . grid_columnconfigure ( i , minsize = max ( widths ) / 5.5 ) # Set minimum width of all column to max_width / 5","title":"set_equal_width"},{"location":"functions/modules/GUI_modules/#modules.GUI_modules.value_control","text":"This function checks the integrity of the values entered by the user and returns an empty tuple if they are not valid. Parameters: choice_operating_conditions ( dict ) \u2013 A dictionary containing the operating condition information. choice_accessible_parameters ( dict ) \u2013 A dictionary containing the accessible physical parameter information. choice_undetermined_parameters ( dict ) \u2013 A dictionary containing the undetermined physical parameter information. choice_current_density_parameters ( dict ) \u2013 A dictionary containing the current density parameter information. choice_computing_parameters ( dict ) \u2013 A dictionary containing the computing parameter information. choice_buttons ( dict ) \u2013 A dictionary containing the button information. current_button ( dict ) \u2013 A dictionary representing the clicked button. Source code in modules/GUI_modules.py 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 def value_control ( choice_operating_conditions , choice_accessible_parameters , choice_undetermined_parameters , choice_current_density_parameters , choice_computing_parameters , choice_buttons , current_button ): \"\"\"This function checks the integrity of the values entered by the user and returns an empty tuple if they are not valid. Parameters ---------- choice_operating_conditions : dict A dictionary containing the operating condition information. choice_accessible_parameters : dict A dictionary containing the accessible physical parameter information. choice_undetermined_parameters : dict A dictionary containing the undetermined physical parameter information. choice_current_density_parameters : dict A dictionary containing the current density parameter information. choice_computing_parameters : dict A dictionary containing the computing parameter information. choice_buttons : dict A dictionary containing the button information. current_button : dict A dictionary representing the clicked button. \"\"\" # The values entered by the user are checked for compliance if choice_operating_conditions [ 'Temperature - Tfc (\u00b0C)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Temperatures' , message = 'Negative temperatures do not exist in the Kelvin scale.' ) choices . clear () return if choice_operating_conditions [ 'Anode pressure - Pa (bar)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () > 5.0 or \\ choice_operating_conditions [ 'Cathode pressure - Pc (bar)' ][ 'value' ] . get () > 5.0 : messagebox . showerror ( title = 'Desired pressures' , message = 'Desired pressure should be positive and bellow 5.0 ' 'bars.' ) choices . clear () return if choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () < 1 or \\ choice_operating_conditions [ 'Anode stoichiometry - Sa' ][ 'value' ] . get () > 5 or \\ choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () < 1 or \\ choice_operating_conditions [ 'Cathode stoichiometry - Sc' ][ 'value' ] . get () > 5 : messagebox . showerror ( title = 'Stoichiometric ratios' , message = 'The stoichiometric ratios Sa and Sc should be ' 'between 1 and 5.' ) choices . clear () return if choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Anode humidity - \u03a6a' ][ 'value' ] . get () > 1 or \\ choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Cathode humidity - \u03a6c' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Desired humidity' , message = 'The desired humidities should be between 0 and 1.' ) choices . clear () return if choice_operating_conditions [ 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' ][ 'value' ] . get () < 0 or \\ choice_operating_conditions [ 'Anode inlet H2 ratio - y_H2_in \\n (flow-through anode only)' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Anode inlet H2 ratio' , message = 'The anode inlet H2 ratio should be between 0 and 1.' ) choices . clear () return if choice_accessible_parameters [ 'Active area - Aact (cm\u00b2)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Active area' , message = 'Negative active area is impossible.' ) choices . clear () return if choice_accessible_parameters [ 'Number of cells - nb_cell' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Number of cells' , message = 'Negative number of cells is impossible.' ) choices . clear () return if choice_accessible_parameters [ 'Exhaust anode manifold throttle \\n area - A_T_a (cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Exhaust cathode manifold throttle \\n area - A_T_c (cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Supply anode manifold \\n volume - Vasm (cm\u00b3)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Supply cathode manifold \\n volume - Vcsm (cm\u00b3)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Exhaust anode manifold \\n volume - Vaem (cm\u00b3)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Exhaust cathode manifold \\n volume - Vcem (cm\u00b3)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Manifold parameters' , message = 'Negative volumes or area are impossible.' ) choices . clear () return if choice_accessible_parameters [ 'Anode gas channel \\n thickness - Hagc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'Anode gas channel \\n thickness - Hagc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'Cathode gas channel \\n thickness - Hcgc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'Anode gas channel \\n width - Wagc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'Anode gas channel \\n width - Wagc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'Cathode gas channel \\n width - Wcgc (\u00b5m)' ][ 'value' ] . get () < 10 or \\ choice_accessible_parameters [ 'Cathode gas channel \\n width - Wcgc (\u00b5m)' ][ 'value' ] . get () > 10000 or \\ choice_accessible_parameters [ 'Gas channel \\n length - Lgc (m)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Gas channel \\n length - Lgc (m)' ][ 'value' ] . get () > 1000 or \\ choice_accessible_parameters [ 'Distributor length - L_dist (mm)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Manifold length - Lm (mm)' ][ 'value' ] . get () < 0 or \\ choice_accessible_parameters [ 'Manifold-GC connection length - L_man_gc (mm)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'GC distances' , message = 'GC generally have a thickness and a width between 10\u00b5m and ' '10mm. Also, GC length is generally between 0 and 1000mm' ) choices . clear () return if ( choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'GDL thickness - Hgdl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'MPL thickness - Hmpl (\u00b5m) \\n (without the transition layer)' ][ 'value' ] . get () > 1000 or choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'ACL thickness - Hacl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'CCL thickness - Hccl (\u00b5m)' ][ 'value' ] . get () > 1000 or \\ choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () < 1 or \\ choice_undetermined_parameters [ 'Membrane thickness - Hmem (\u00b5m)' ][ 'value' ] . get () > 1000 ): messagebox . showerror ( title = 'MEA thickness' , message = 'All MEA components generally have a thickness between ' '1\u00b5m and 1mm.' ) choices . clear () return if choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () < 0.4 or \\ choice_undetermined_parameters [ 'GDL porosity - \u03b5_gdl' ][ 'value' ] . get () > 0.95 : messagebox . showerror ( title = 'GDL porosity' , message = 'GDL porosity should be between 0.4 and 0.95.' ) choices . clear () return if choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () < 0.12 or \\ choice_undetermined_parameters [ 'CL porosity - \u03b5_cl' ][ 'value' ] . get () > 0.60 : messagebox . showerror ( title = 'GDL porosity' , message = 'CL porosity should be between 0.12 and 0.60.' ) choices . clear () return if choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () < 0.30 or \\ choice_undetermined_parameters [ 'MPL porosity - \u03b5_mpl' ][ 'value' ] . get () > 0.70 : messagebox . showerror ( title = 'MPL porosity' , message = 'MPL porosity should be between 0.30 and 0.70.' ) choices . clear () return if choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Ionomer volume fraction - \u03b5_mc' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Ionomer volume fraction' , message = 'Ionomer volume fraction should be between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Compression ratio - \u03b5_c' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Compression ratio' , message = 'The compression ratio should be between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () < 3 or choice_undetermined_parameters [ 'Capillary exponent - e' ][ 'value' ] . get () > 5 : messagebox . showerror ( title = 'Capillary exponent' , message = 'The capillary exponent should be between 3 and 5 and ' 'being an integer.' ) choices . clear () return if choice_undetermined_parameters [ 'Electron conduction \\n resistance - Re (\u03a9.mm\u00b2)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Electron conduction resistance' , message = 'Re should be positive.' ) choices . clear () return if choice_undetermined_parameters [ 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' ][ 'value' ] . get () < 0.001 or \\ choice_undetermined_parameters [ 'Dry reference exchange current \\n density - i0_d_c_ref (A/m\u00b2)' ][ 'value' ] . get () > 100 or \\ choice_undetermined_parameters [ 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' ][ 'value' ] . get () < 0.001 or \\ choice_undetermined_parameters [ 'Humid reference exchange current \\n density - i0_h_c_ref (A/m\u00b2)' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Referenced exchange current densities' , message = 'The referenced exchange current ' 'densities are generally between 0.001 ' 'and 100 A.m-2.' ) choices . clear () return if choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () < 0.01 or \\ choice_undetermined_parameters [ 'Crossover correction coefficient \\n - \u03ba_co (mol/(m.s.Pa))' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Crossover correction coefficient' , message = 'The crossover correction coefficient is' ' generally between 0.01 and 100 ' 'mol.m-1.s-1.Pa-1.' ) choices . clear () return if choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Overpotential correction \\n exponent - \u03ba_c' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Overpotential correction exponent' , message = 'The overpotential correction exponent ' 'is generally between 0 and 100.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_slim' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Slop of slim function' , message = 'The slop of slim function is generally between 0 ' 'and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - b_slim' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Intercept of slim function' , message = 'The intercept of slim function is generally ' 'between 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () < 0 or \\ choice_undetermined_parameters [ 'Limit liquid saturation \\n coefficient - a_switch' ][ 'value' ] . get () > 1 : messagebox . showerror ( title = 'Slop of switch function' , message = 'The slop of switch function is generally between' ' 0 and 1.' ) choices . clear () return if choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () < 5 or \\ choice_undetermined_parameters [ 'Volumetric space-charge layer \\n capacitance - C_scl (F/cm\u00b3)' ][ 'value' ] . get () > 100 : messagebox . showerror ( title = 'Double layer capacitance' , message = 'I have not settled yet a range for C_scl.' ) choices . clear () return if choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_step (min)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_step (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_step (min)' ][ 'value' ] . get () < 0 or \\ choice_computing_parameters [ 'Time for dynamic \\n display - \u0394t_dyn_step (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Stabilisation time \\n - \u0394t_ini_pola (min)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Loading time \\n - \u0394t_load_pola (s)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Breaking time \\n - \u0394t_break_pola (min)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Times' , message = 'The times should be positive, t0_step < tf_step and ' 'delta_t_load_step < (tf_step - t0_step).' ) choices . clear () return if choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Static current \\n - i_EIS (A/cm\u00b2)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current density step \\n - \u0394i_pola (A/cm\u00b2)' ][ 'value' ] . get () > \\ choice_current_density_parameters [ 'Maximum current density \\n - i_max_pola (A/cm\u00b2)' ][ 'value' ] . get (): messagebox . showerror ( title = 'Current densities' , message = 'The current densities should be positive, ' 'delta_i_pola < i_max_pola and ' 'i_ini_step < i_final_step.' ) choices . clear () return if choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Current ratio \\n - ratio_EIS (%)' ][ 'value' ] . get () > 20 : messagebox . showerror ( title = 'Ratio EIS' , message = 'Ratio EIS is a percentage of i_EIS and should be between 0 ' 'and 20 for plotting correct EIS.' ) choices . clear () return if choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get () < 0 or \\ choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get () < 0 or \\ type ( choice_current_density_parameters [ 'Power of the \\n initial frequency \\n - f_power_min_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Power of the \\n final frequency \\n - f_power_max_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Number of frequencies \\n tested - nb_f_EIS' ][ 'value' ] . get ()) != int or \\ type ( choice_current_density_parameters [ 'Number of points \\n calculated - nb_points_EIS' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'f EIS' , message = 'f_EIS parameters should be integer and number of points should ' 'be positive.' ) choices . clear () return if choice_computing_parameters [ 'Purge time - t_purge (s)' ][ 'value' ] . get () < 0 or \\ choice_computing_parameters [ 'Time between two purges \\n - \u0394t_purge (s)' ][ 'value' ] . get () < 0 : messagebox . showerror ( title = 'Purge times' , message = 'Negative times does not characterise purges.' ) choices . clear () return if choice_computing_parameters [ 'Number of GC nodes - nb_gc' ][ 'value' ] . get () < 1 or \\ type ( choice_computing_parameters [ 'Number of GC nodes - nb_gc' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'nb_gc' , message = 'The nb_gc value should be an integer bigger or equal to 1.' ) choices . clear () return if choice_computing_parameters [ 'Number of GDL nodes - nb_gdl' ][ 'value' ] . get () < 1 or \\ type ( choice_computing_parameters [ 'Number of GDL nodes - nb_gdl' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'nb_gdl' , message = 'The nb_gdl value should be an integer bigger or equal to 1.' ) choices . clear () return if choice_computing_parameters [ 'Number of MPL nodes - nb_mpl' ][ 'value' ] . get () < 1 or \\ type ( choice_computing_parameters [ 'Number of MPL nodes - nb_mpl' ][ 'value' ] . get ()) != int : messagebox . showerror ( title = 'nb_mpl' , message = 'The nb_mpl value should be an integer bigger or equal to 1.' ) choices . clear () return if choice_computing_parameters [ 'Solver relative tolerance - rtol' ][ 'value' ] . get () > 1e-3 or \\ choice_computing_parameters [ 'Solver absolute tolerance - atol' ][ 'value' ] . get () > 1e-3 : messagebox . showerror ( title = 'Solver tolerance' , message = 'rtol and atol should be lower than 1e-3 to limit the' ' numerical errors.' ) choices . clear () return if current_button == 0 and choice_buttons [ 'type_display' ][ 'value' ] . get () == 2 \\ and choice_buttons [ 'type_plot' ][ 'value' ] . get () == 1 : messagebox . showerror ( title = 'n gdl' , message = 'dynamic plot is not thought to be used with step current and ' 'multiple display. There would be too much plots to handle.' ) choices . clear () return","title":"value_control"},{"location":"functions/modules/auxiliaries_modules/","text":"Auxiliaries modules This module is used to calculate intermediate values for the auxiliaries flows calculation. auxiliaries_int_values_which_are_commun_with_dif_eq ( t , sv , operating_inputs , parameters ) This functions calculates intermediate values for the auxiliaries flows calculation. Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell model. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: k_purge ( float ) \u2013 Purge coefficient. It is equal to 1 if the purge is active and 0 otherwise. Abp_a ( float ) \u2013 Area of the back pressure valve in the anode external manifold (m\u00b2). Abp_c ( float ) \u2013 Area of the back pressure valve in the cathode external manifold (m\u00b2). Source code in modules/auxiliaries_modules.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def auxiliaries_int_values_which_are_commun_with_dif_eq ( t , sv , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the auxiliaries flows calculation. Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs : dict Operating inputs of the fuel cell model. parameters : dict Parameters of the fuel cell model. Returns ------- k_purge : float Purge coefficient. It is equal to 1 if the purge is active and 0 otherwise. Abp_a : float Area of the back pressure valve in the anode external manifold (m\u00b2). Abp_c : float Area of the back pressure valve in the cathode external manifold (m\u00b2). \"\"\" # Extraction of the variables lambda_mem = sv [ 'lambda_mem' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] Pasm , Paem , Pcsm , Pcem = sv . get ( 'Pasm' , None ), sv . get ( 'Paem' , None ), sv . get ( 'Pcsm' , None ), sv . get ( 'Pcem' , None ) Phi_asm , Phi_aem = sv . get ( 'Phi_asm' , None ), sv . get ( 'Phi_aem' , None ) Phi_csm , Phi_cem = sv . get ( 'Phi_csm' , None ), sv . get ( 'Phi_cem' , None ) Abp_a , Abp_c = sv . get ( 'Abp_a' , None ), sv . get ( 'Abp_c' , None ) # Extraction of the operating inputs and the parameters T_des , y_H2_in , Pa_des = operating_inputs [ 'T_des' ], operating_inputs [ 'y_H2_in' ], operating_inputs [ 'Pa_des' ] Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] Lgc , A_T_a , A_T_c = parameters [ 'Lgc' ], parameters [ 'A_T_a' ], parameters [ 'A_T_c' ] kappa_co , nb_gc , t_purge , type_purge = parameters [ 'kappa_co' ], parameters [ 'nb_gc' ], parameters [ 't_purge' ], parameters [ 'type_purge' ] # Physical quantities outside the stack # Molar masses M = {} M [ 'ext' ] = Phi_ext * Psat ( Text ) / Pext * M_H2O + \\ y_O2_ext * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_O2 + \\ ( 1 - y_O2_ext ) * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_N2 M [ 'H2_N2_in' ] = y_H2_in * M_H2 + ( 1 - y_H2_in ) * M_N2 # Physical quantities inside the stack # Pressures P = {} for i in range ( 1 , nb_gc + 1 ): P [ f 'agc_ { i } ' ] = ( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) * R * sv [ f 'T_agc_ { i } ' ] P [ f 'cgc_ { i } ' ] = ( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) * R * sv [ f 'T_cgc_ { i } ' ] # Humidities Phi = {} for i in range ( 1 , nb_gc + 1 ): Phi [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] / C_v_sat ( sv [ f 'T_agc_ { i } ' ]) Phi [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] / C_v_sat ( sv [ f 'T_cgc_ { i } ' ]) # H2/O2 ratio in the dry anode/cathode gas mixture (H2/N2 or O2/N2) at the GC y_O2 = {} y_H2 = {} for i in range ( 1 , nb_gc + 1 ): y_H2 [ f 'agc_ { i } ' ] = sv [ f 'C_H2_agc_ { i } ' ] / ( sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) y_O2 [ f 'cgc_ { i } ' ] = sv [ f 'C_O2_cgc_ { i } ' ] / ( sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) # Molar masses for i in range ( 1 , nb_gc + 1 ): M [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_H2O + \\ sv [ f 'C_H2_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_H2 + \\ sv [ f 'C_N2_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_N2 M [ f 'cgc_ { i } ' ] = Phi [ f 'cgc_ { i } ' ] * Psat ( T_des ) / P [ f 'cgc_ { i } ' ] * M_H2O + \\ y_O2 [ f 'cgc_ { i } ' ] * ( 1 - Phi [ f 'cgc_ { i } ' ] * Psat ( T_des ) / P [ f 'cgc_ { i } ' ]) * M_O2 + \\ ( 1 - y_O2 [ f 'cgc_ { i } ' ]) * ( 1 - Phi [ f 'cgc_ { i } ' ] * Psat ( T_des ) / P [ f 'cgc_ { i } ' ]) * M_N2 # Density of the gas mixture. rho = {} for i in range ( 1 , nb_gc + 1 ): rho [ f 'agc_ { i } ' ] = P [ f 'agc_ { i } ' ] / ( R * sv [ f 'T_agc_ { i } ' ]) * M [ f 'agc_ { i } ' ] rho [ f 'cgc_ { i } ' ] = P [ f 'cgc_ { i } ' ] / ( R * sv [ f 'T_cgc_ { i } ' ]) * M [ f 'cgc_ { i } ' ] # Vapor ratio over the gas mixture. x_H2O_v = {} for i in range ( 1 , nb_gc + 1 ): x_H2O_v [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] / ( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 ): x_H2O_v [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] / ( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) # Dynamic viscosity of the gas mixture. mu_gaz = {} for i in range ( 1 , nb_gc + 1 ): mu_gaz [ f 'agc_ { i } ' ] = mu_mixture_gases ([ 'H2O_v' , 'H2' ], [ x_H2O_v [ f 'agc_ { i } ' ], 1 - x_H2O_v [ f 'agc_ { i } ' ]], sv [ f 'T_agc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 ): mu_gaz [ f 'cgc_ { i } ' ] = mu_mixture_gases ([ 'H2O_v' , 'O2' , 'N2' ], [ x_H2O_v [ f 'cgc_ { i } ' ], y_O2 [ f 'cgc_ { i } ' ] * ( 1 - x_H2O_v [ f 'cgc_ { i } ' ]), ( 1 - y_O2 [ f 'cgc_ { i } ' ]) * ( 1 - x_H2O_v [ f 'cgc_ { i } ' ])], sv [ f 'T_cgc_ { i } ' ]) # The crossover current density i_n T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # Physical quantities in the auxiliary system if parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_anodic_recirculation\" or \\ parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_flow-through_anode\" : pass # # H2/O2 ratio in the dry anode/cathode gas mixture (H2/N2 or O2/N2) at the EM # y_H2_aem = (Paem - Phi_aem * Psat(T_des) - C_N2_a * R * T_des) / (Paem - Phi_aem * Psat(T_des)) # y_O2_cem = (Pcem - Phi_cem * Psat(T_cgc) - C_N2_c * R * T_cgc) / (Pcem - Phi_cem * Psat(T_cgc)) # # # Molar masses # if parameters[\"type_auxiliary\"] == \"forced-convective_cathode_with_anodic_recirculation\": # Masm = Phi_asm * Psat(T_des) / Pasm * M_H2O + \\ # (1 - Phi_asm * Psat(T_des) / Pasm) * M_H2 # Maem = Phi_aem * Psat(T_des) / Paem * M_H2O + \\ # (1 - Phi_aem * Psat(T_des) / Paem) * M_H2 # else: # parameters[\"type_auxiliary\"] == \"forced-convective_cathode_with_flow-through_anode\": # Masm = Phi_asm * Psat(T_des) / Pasm * M_H2O + \\ # y_H2_in * (1 - Phi_asm * Psat(T_des) / Pasm) * M_H2 + \\ # (1 - y_H2_in) * (1 - Phi_asm * Psat(T_des) / Pasm) * M_N2 # Maem = Phi_aem * Psat(T_des) / Paem * M_H2O + \\ # y_H2_aem * (1 - Phi_aem * Psat(T_des) / Paem) * M_H2 + \\ # (1 - y_H2_aem) * (1 - Phi_aem * Psat(T_des) / Paem) * M_N2 # # Molar masses at the cathode side # Mcsm = Phi_csm * Psat(T_des) / Pcsm * M_H2O + \\ # y_O2_ext * (1 - Phi_csm * Psat(T_des) / Pcsm) * M_O2 + \\ # (1 - y_O2_ext) * (1 - Phi_csm * Psat(T_des) / Pcsm) * M_N2 # Mcem = Phi_cem * Psat(T_des) / Pcem * M_H2O + \\ # y_O2_cem * (1 - Phi_cem * Psat(T_des) / Pcem) * M_O2 + \\ # (1 - y_O2_cem) * (1 - Phi_cem * Psat(T_des) / Pcem) * M_N2 # # # Density of the gas mixture. # rho_asm = Pasm / (R * T_des) * Masm # rho_aem = Paem / (R * T_des) * Maem # rho_csm = Pcsm / (R * T_des) * Mcsm # rho_cgc = Pcgc / (R * T_cgc) * Mcgc # rho_cem = Pcem / (R * T_cgc) * Mcem # # # Purge # if type_purge == \"no_purge\": # k_purge = 0 # elif type_purge == \"constant_purge\": # k_purge = 1 # elif type_purge == \"periodic_purge\": # purge_time, delta_purge = t_purge # if (t - int(t / (purge_time + delta_purge)) * (purge_time + delta_purge)) <= purge_time: # k_purge = 1 # else: # k_purge = 0 # else: # raise ValueError(\"The type_purge variable should be correctly referenced.\") # # Back pressure valve area # if Abp_a > A_T_a: # Abp_a = A_T_a # elif Abp_a < 0: # Abp_a = 0 # if Abp_c > A_T_c: # Abp_c = A_T_c # elif Abp_c < 0: # Abp_c = 0 else : # parameters[\"type_auxiliary\"] == \"no_auxiliary\" k_purge , Abp_a , Abp_c = [ None ] * 3 return P , Phi , y_H2 , y_O2 , M , rho , k_purge , Abp_a , Abp_c , mu_gaz , i_n","title":"Auxiliaries modules"},{"location":"functions/modules/auxiliaries_modules/#auxiliaries-modules","text":"This module is used to calculate intermediate values for the auxiliaries flows calculation.","title":"Auxiliaries modules"},{"location":"functions/modules/auxiliaries_modules/#modules.auxiliaries_modules.auxiliaries_int_values_which_are_commun_with_dif_eq","text":"This functions calculates intermediate values for the auxiliaries flows calculation. Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell model. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: k_purge ( float ) \u2013 Purge coefficient. It is equal to 1 if the purge is active and 0 otherwise. Abp_a ( float ) \u2013 Area of the back pressure valve in the anode external manifold (m\u00b2). Abp_c ( float ) \u2013 Area of the back pressure valve in the cathode external manifold (m\u00b2). Source code in modules/auxiliaries_modules.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def auxiliaries_int_values_which_are_commun_with_dif_eq ( t , sv , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the auxiliaries flows calculation. Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. operating_inputs : dict Operating inputs of the fuel cell model. parameters : dict Parameters of the fuel cell model. Returns ------- k_purge : float Purge coefficient. It is equal to 1 if the purge is active and 0 otherwise. Abp_a : float Area of the back pressure valve in the anode external manifold (m\u00b2). Abp_c : float Area of the back pressure valve in the cathode external manifold (m\u00b2). \"\"\" # Extraction of the variables lambda_mem = sv [ 'lambda_mem' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] Pasm , Paem , Pcsm , Pcem = sv . get ( 'Pasm' , None ), sv . get ( 'Paem' , None ), sv . get ( 'Pcsm' , None ), sv . get ( 'Pcem' , None ) Phi_asm , Phi_aem = sv . get ( 'Phi_asm' , None ), sv . get ( 'Phi_aem' , None ) Phi_csm , Phi_cem = sv . get ( 'Phi_csm' , None ), sv . get ( 'Phi_cem' , None ) Abp_a , Abp_c = sv . get ( 'Abp_a' , None ), sv . get ( 'Abp_c' , None ) # Extraction of the operating inputs and the parameters T_des , y_H2_in , Pa_des = operating_inputs [ 'T_des' ], operating_inputs [ 'y_H2_in' ], operating_inputs [ 'Pa_des' ] Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] Lgc , A_T_a , A_T_c = parameters [ 'Lgc' ], parameters [ 'A_T_a' ], parameters [ 'A_T_c' ] kappa_co , nb_gc , t_purge , type_purge = parameters [ 'kappa_co' ], parameters [ 'nb_gc' ], parameters [ 't_purge' ], parameters [ 'type_purge' ] # Physical quantities outside the stack # Molar masses M = {} M [ 'ext' ] = Phi_ext * Psat ( Text ) / Pext * M_H2O + \\ y_O2_ext * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_O2 + \\ ( 1 - y_O2_ext ) * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_N2 M [ 'H2_N2_in' ] = y_H2_in * M_H2 + ( 1 - y_H2_in ) * M_N2 # Physical quantities inside the stack # Pressures P = {} for i in range ( 1 , nb_gc + 1 ): P [ f 'agc_ { i } ' ] = ( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) * R * sv [ f 'T_agc_ { i } ' ] P [ f 'cgc_ { i } ' ] = ( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) * R * sv [ f 'T_cgc_ { i } ' ] # Humidities Phi = {} for i in range ( 1 , nb_gc + 1 ): Phi [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] / C_v_sat ( sv [ f 'T_agc_ { i } ' ]) Phi [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] / C_v_sat ( sv [ f 'T_cgc_ { i } ' ]) # H2/O2 ratio in the dry anode/cathode gas mixture (H2/N2 or O2/N2) at the GC y_O2 = {} y_H2 = {} for i in range ( 1 , nb_gc + 1 ): y_H2 [ f 'agc_ { i } ' ] = sv [ f 'C_H2_agc_ { i } ' ] / ( sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) y_O2 [ f 'cgc_ { i } ' ] = sv [ f 'C_O2_cgc_ { i } ' ] / ( sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) # Molar masses for i in range ( 1 , nb_gc + 1 ): M [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_H2O + \\ sv [ f 'C_H2_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_H2 + \\ sv [ f 'C_N2_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_N2 M [ f 'cgc_ { i } ' ] = Phi [ f 'cgc_ { i } ' ] * Psat ( T_des ) / P [ f 'cgc_ { i } ' ] * M_H2O + \\ y_O2 [ f 'cgc_ { i } ' ] * ( 1 - Phi [ f 'cgc_ { i } ' ] * Psat ( T_des ) / P [ f 'cgc_ { i } ' ]) * M_O2 + \\ ( 1 - y_O2 [ f 'cgc_ { i } ' ]) * ( 1 - Phi [ f 'cgc_ { i } ' ] * Psat ( T_des ) / P [ f 'cgc_ { i } ' ]) * M_N2 # Density of the gas mixture. rho = {} for i in range ( 1 , nb_gc + 1 ): rho [ f 'agc_ { i } ' ] = P [ f 'agc_ { i } ' ] / ( R * sv [ f 'T_agc_ { i } ' ]) * M [ f 'agc_ { i } ' ] rho [ f 'cgc_ { i } ' ] = P [ f 'cgc_ { i } ' ] / ( R * sv [ f 'T_cgc_ { i } ' ]) * M [ f 'cgc_ { i } ' ] # Vapor ratio over the gas mixture. x_H2O_v = {} for i in range ( 1 , nb_gc + 1 ): x_H2O_v [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] / ( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 ): x_H2O_v [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] / ( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) # Dynamic viscosity of the gas mixture. mu_gaz = {} for i in range ( 1 , nb_gc + 1 ): mu_gaz [ f 'agc_ { i } ' ] = mu_mixture_gases ([ 'H2O_v' , 'H2' ], [ x_H2O_v [ f 'agc_ { i } ' ], 1 - x_H2O_v [ f 'agc_ { i } ' ]], sv [ f 'T_agc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 ): mu_gaz [ f 'cgc_ { i } ' ] = mu_mixture_gases ([ 'H2O_v' , 'O2' , 'N2' ], [ x_H2O_v [ f 'cgc_ { i } ' ], y_O2 [ f 'cgc_ { i } ' ] * ( 1 - x_H2O_v [ f 'cgc_ { i } ' ]), ( 1 - y_O2 [ f 'cgc_ { i } ' ]) * ( 1 - x_H2O_v [ f 'cgc_ { i } ' ])], sv [ f 'T_cgc_ { i } ' ]) # The crossover current density i_n T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # Physical quantities in the auxiliary system if parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_anodic_recirculation\" or \\ parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_flow-through_anode\" : pass # # H2/O2 ratio in the dry anode/cathode gas mixture (H2/N2 or O2/N2) at the EM # y_H2_aem = (Paem - Phi_aem * Psat(T_des) - C_N2_a * R * T_des) / (Paem - Phi_aem * Psat(T_des)) # y_O2_cem = (Pcem - Phi_cem * Psat(T_cgc) - C_N2_c * R * T_cgc) / (Pcem - Phi_cem * Psat(T_cgc)) # # # Molar masses # if parameters[\"type_auxiliary\"] == \"forced-convective_cathode_with_anodic_recirculation\": # Masm = Phi_asm * Psat(T_des) / Pasm * M_H2O + \\ # (1 - Phi_asm * Psat(T_des) / Pasm) * M_H2 # Maem = Phi_aem * Psat(T_des) / Paem * M_H2O + \\ # (1 - Phi_aem * Psat(T_des) / Paem) * M_H2 # else: # parameters[\"type_auxiliary\"] == \"forced-convective_cathode_with_flow-through_anode\": # Masm = Phi_asm * Psat(T_des) / Pasm * M_H2O + \\ # y_H2_in * (1 - Phi_asm * Psat(T_des) / Pasm) * M_H2 + \\ # (1 - y_H2_in) * (1 - Phi_asm * Psat(T_des) / Pasm) * M_N2 # Maem = Phi_aem * Psat(T_des) / Paem * M_H2O + \\ # y_H2_aem * (1 - Phi_aem * Psat(T_des) / Paem) * M_H2 + \\ # (1 - y_H2_aem) * (1 - Phi_aem * Psat(T_des) / Paem) * M_N2 # # Molar masses at the cathode side # Mcsm = Phi_csm * Psat(T_des) / Pcsm * M_H2O + \\ # y_O2_ext * (1 - Phi_csm * Psat(T_des) / Pcsm) * M_O2 + \\ # (1 - y_O2_ext) * (1 - Phi_csm * Psat(T_des) / Pcsm) * M_N2 # Mcem = Phi_cem * Psat(T_des) / Pcem * M_H2O + \\ # y_O2_cem * (1 - Phi_cem * Psat(T_des) / Pcem) * M_O2 + \\ # (1 - y_O2_cem) * (1 - Phi_cem * Psat(T_des) / Pcem) * M_N2 # # # Density of the gas mixture. # rho_asm = Pasm / (R * T_des) * Masm # rho_aem = Paem / (R * T_des) * Maem # rho_csm = Pcsm / (R * T_des) * Mcsm # rho_cgc = Pcgc / (R * T_cgc) * Mcgc # rho_cem = Pcem / (R * T_cgc) * Mcem # # # Purge # if type_purge == \"no_purge\": # k_purge = 0 # elif type_purge == \"constant_purge\": # k_purge = 1 # elif type_purge == \"periodic_purge\": # purge_time, delta_purge = t_purge # if (t - int(t / (purge_time + delta_purge)) * (purge_time + delta_purge)) <= purge_time: # k_purge = 1 # else: # k_purge = 0 # else: # raise ValueError(\"The type_purge variable should be correctly referenced.\") # # Back pressure valve area # if Abp_a > A_T_a: # Abp_a = A_T_a # elif Abp_a < 0: # Abp_a = 0 # if Abp_c > A_T_c: # Abp_c = A_T_c # elif Abp_c < 0: # Abp_c = 0 else : # parameters[\"type_auxiliary\"] == \"no_auxiliary\" k_purge , Abp_a , Abp_c = [ None ] * 3 return P , Phi , y_H2 , y_O2 , M , rho , k_purge , Abp_a , Abp_c , mu_gaz , i_n","title":"auxiliaries_int_values_which_are_commun_with_dif_eq"},{"location":"functions/modules/calibration_modules/","text":"Calibration modules This module contains some of the functions required for the parameter calibration. calculate_simulation_error ( Simulator_1 , U_exp_1 , i_exp_1 , Simulator_2 , U_exp_2 , i_exp_2 ) This function is used to calculate the simulation maximal error between the experimental and the simulated polarization curves. Two simulations on different operating conditions and on the same stack, and so two set of experimental data, are considered as it is the minimum amount of data which is required for the calibration. Parameters: Simulator_1 ( AlphaPEM object ) \u2013 PEM simulator which contains the simulation results for the first simulation. U_exp_1 ( ndarray ) \u2013 Experimental values of the voltage for the first simulation. i_exp_1 ( ndarray ) \u2013 Experimental values of the current density for the first simulation. Simulator_2 ( AlphaPEM object ) \u2013 PEM simulator which contains the simulation results for the second simulation. U_exp_2 ( ndarray ) \u2013 Experimental values of the voltage for the second simulation. i_exp_2 ( ndarray ) \u2013 Experimental values of the current density for the second simulation. Returns: sim_error ( float ) \u2013 Maximum error between the experimental and the simulated polarization curves in percentage. Source code in modules/calibration_modules.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 def calculate_simulation_error ( Simulator_1 , U_exp_1 , i_exp_1 , Simulator_2 , U_exp_2 , i_exp_2 ): \"\"\"This function is used to calculate the simulation maximal error between the experimental and the simulated polarization curves. Two simulations on different operating conditions and on the same stack, and so two set of experimental data, are considered as it is the minimum amount of data which is required for the calibration. Parameters ---------- Simulator_1 : AlphaPEM object PEM simulator which contains the simulation results for the first simulation. U_exp_1 : numpy.ndarray Experimental values of the voltage for the first simulation. i_exp_1 : numpy.ndarray Experimental values of the current density for the first simulation. Simulator_2 : AlphaPEM object PEM simulator which contains the simulation results for the second simulation. U_exp_2 : numpy.ndarray Experimental values of the voltage for the second simulation. i_exp_2 : numpy.ndarray Experimental values of the current density for the second simulation. Returns ------- sim_error : float Maximum error between the experimental and the simulated polarization curves in percentage. \"\"\" # Recovery of ifc_1 t1 = np . array ( Simulator_1 . variables [ 't' ]) n1 = len ( t1 ) ifc_t_1 = np . zeros ( n1 ) for i in range ( n1 ): # Creation of ifc_t ifc_t_1 [ i ] = Simulator_1 . operating_inputs [ 'current_density' ]( t1 [ i ], Simulator_1 . parameters ) # Recovery of ifc_2 t2 = np . array ( Simulator_2 . variables [ 't' ]) n2 = len ( t2 ) ifc_t_2 = np . zeros ( n2 ) for i in range ( n2 ): # Creation of ifc_t ifc_t_2 [ i ] = Simulator_2 . operating_inputs [ 'current_density' ]( t2 [ i ], Simulator_2 . parameters ) # Polarisation curve point recovery after stack stabilisation for Simulator1 # Extraction of the parameters # The initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # The loading time for one step current of the polarisation current density function. delta_t_load_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # The breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). # Calculation nb_loads1 = len ( i_exp_1 ) # Number of load which are made delta_t_cali_1 = delta_t_load_pola_cali_1 + delta_t_break_pola_cali_1 # s. It is the time of one load. ifc_discretized1 = np . zeros ( nb_loads1 ) Ucell_discretized1 = np . zeros ( nb_loads1 ) for i in range ( nb_loads1 ): t_load_1 = delta_t_ini_pola_cali_1 + ( i + 1 ) * delta_t_cali_1 # time for measurement idx1 = ( np . abs ( t1 - t_load_1 )) . argmin () # the corresponding index ifc_discretized1 [ i ] = ifc_t_1 [ idx1 ] # the last value at the end of each load Ucell_discretized1 [ i ] = Simulator_1 . variables [ 'Ucell' ][ idx1 ] # the last value at the end of each load # Polarisation curve point recovery after stack stabilisation for Simulator2 # Extraction of the parameters # The initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # The loading time for one step current of the polarisation current density function. delta_t_load_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # The breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). # Calculation nb_loads2 = len ( i_exp_2 ) # Number of load which are made delta_t_cali_2 = delta_t_load_pola_cali_2 + delta_t_break_pola_cali_2 # s. It is the time of one load. ifc_discretized2 = np . zeros ( nb_loads2 ) Ucell_discretized2 = np . zeros ( nb_loads2 ) for i in range ( nb_loads2 ): t_load_2 = delta_t_ini_pola_cali_2 + ( i + 1 ) * delta_t_cali_2 # time for measurement idx2 = ( np . abs ( t2 - t_load_2 )) . argmin () # the corresponding index ifc_discretized2 [ i ] = ifc_t_2 [ idx2 ] # the last value at the end of each load Ucell_discretized2 [ i ] = Simulator_2 . variables [ 'Ucell' ][ idx2 ] # the last value at the end of each load # Distance between the simulated and the experimental polarization curves. sim_error = ( np . max ( np . abs ( Ucell_discretized1 - U_exp_1 ) / U_exp_1 * 100 ) + np . max ( np . abs ( Ucell_discretized2 - U_exp_2 ) / U_exp_2 * 100 )) / 2 # in %. return sim_error parameter_bounds_for_calibration ( type_fuel_cell , voltage_zone , operating_inputs_1 , operating_inputs_2 ) This function is used to determine the parameter bounds of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters type_fuel_cell : str Type of fuel cell configuration. voltage_zone : str Zone of calibration: \"before_voltage_drop\", \"full\". operating_inputs_1 : dict Operating inputs for the first fuel cell configuration. operating_inputs_2 : dict Operating inputs for the second fuel cell configuration. Returns varbound : list List of the bounds on the parameters to calibrate. Each element is a list containing the minimum and maximum values of the parameter, and the type of the parameter ('real' or 'int'). gene_space : list List of dictionaries used to define the bounds of the undetermined parameters for pygad. Each dictionary contains the 'low' and 'high' values for the parameter, and optionally a 'step' value for integer parameters. Source code in modules/calibration_modules.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def parameter_bounds_for_calibration ( type_fuel_cell , voltage_zone , operating_inputs_1 , operating_inputs_2 ): \"\"\"This function is used to determine the parameter bounds of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. voltage_zone : str Zone of calibration: \"before_voltage_drop\", \"full\". operating_inputs_1 : dict Operating inputs for the first fuel cell configuration. operating_inputs_2 : dict Operating inputs for the second fuel cell configuration. Returns ------- varbound : list List of the bounds on the parameters to calibrate. Each element is a list containing the minimum and maximum values of the parameter, and the type of the parameter ('real' or 'int'). gene_space : list List of dictionaries used to define the bounds of the undetermined parameters for pygad. Each dictionary contains the 'low' and 'high' values for the parameter, and optionally a 'step' value for integer parameters. \"\"\" Pc_des_1 , Pc_des_2 = operating_inputs_1 [ 'Pc_des' ], operating_inputs_2 [ 'Pc_des' ] if type_fuel_cell == \"ZSW-GenStack\" or type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" or type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" or type_fuel_cell == \"ZSW-GenStack_T_62\" or \\ type_fuel_cell == \"ZSW-GenStack_T_76\" or type_fuel_cell == \"ZSW-GenStack_T_84\" : # Fuel cell physical parameters Hacl_min , Hacl_max = 6e-6 , 10e-6 # m. It is the thickness of the ACL. Hccl_min , Hccl_max = 10e-6 , 20e-6 # m. It is the thickness of the CCL. Hmem_min , Hmem_max = 10e-6 , 20e-6 # m. It is the thickness of the membrane. epsilon_gdl_min , epsilon_gdl_max = 0.696 , 0.880 # It is the anode/cathode GDL porosity, without units. epsilon_mpl_min , epsilon_mpl_max = 0.32 , 0.54 # It is the anode/cathode MPL porosity, without units. epsilon_cl_min , epsilon_cl_max = 0.40 , 0.60 # It is the anode/cathode MPL porosity, without units. epsilon_mc_min , epsilon_mc_max = 0.15 , 0.40 # It is the volume fraction of ionomer in the CL. # Constants based on the interaction between water and the structure e_min , e_max = 3 , 5 # It is the capillary exponent, and should be an int number. # Voltage polarization Re_min , Re_max = 5e-7 , 5e-6 # \u03a9.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref_min , i0_d_c_ref_max = 1e-1 , 100 # A.m-2.It is the dry reference exchange current density at the cathode. i0_h_c_ref_min , i0_h_c_ref_max = 1e-2 , 10 # A.m-2.It is the humid reference exchange current density at the cathode. kappa_co_min , kappa_co_max = 0.01 , 40 # A.m-2. It is the crossover correction coefficient. kappa_c_min , kappa_c_max = 0.25 , 4 # It is the overpotential correction exponent. # The bounds on liquid saturation coefficients are constrained to facilitate calibration. a_slim_min , a_slim_max = 0.0 , 0.25 / min ( Pc_des_1 / 1e5 , Pc_des_2 / 1e5 ) # It is one of the limit liquid saturation coefficients. b_slim_min , b_slim_max = 0.05 , 0.3 # It is one of the limit liquid saturation coefficients. a_switch_min , a_switch_max = 0.5 , 0.95 # It is one of the limit liquid saturation coefficients. # Undetermined parameter which is not considered yet (require the use of EIS curves to be calibrated) C_scl_min , C_sl_max = 2e7 , 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Bounds gathering and type if voltage_zone == \"before_voltage_drop\" : varbound = [[ 'Hacl' , Hacl_min , Hacl_max , 'real' ], [ 'Hccl' , Hccl_min , Hccl_max , 'real' ], [ 'Hmem' , Hmem_min , Hmem_max , 'real' ], [ 'epsilon_gdl' , epsilon_gdl_min , epsilon_gdl_max , 'real' ], [ 'epsilon_mc' , epsilon_mc_min , epsilon_mc_max , 'real' ], [ 'e' , e_min , e_max , 'int' ], [ 'Re' , Re_min , Re_max , 'real' ], [ 'i0_d_c_ref' , i0_d_c_ref_min , i0_d_c_ref_max , 'real' ], [ 'kappa_co' , kappa_co_min , kappa_co_max , 'real' ], [ 'kappa_c' , kappa_c_min , kappa_c_max , 'real' ]] else : # voltage_zone == \"full\" varbound = [[ 'i0_h_c_ref' , i0_h_c_ref_min , i0_h_c_ref_max , 'real' ], [ 'a_slim' , a_slim_min , a_slim_max , 'real' ], [ 'b_slim' , b_slim_min , b_slim_max , 'real' ], [ 'a_switch' , a_switch_min , a_switch_max , 'real' ]] gene_space = [] # List used to define the bounds of the undetermined parameters for pygad. for i in range ( len ( varbound )): name , min_val , max_val , type_val = varbound [ i ] if type_val == 'int' : gene_space . append ({ 'low' : min_val , 'high' : max_val , 'step' : 1 }) else : gene_space . append ({ 'low' : min_val , 'high' : max_val }) elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Fuel cell physical parameters Hacl_min , Hacl_max = 8e-6 , 20e-6 # m. It is the thickness of the ACL. Hmem_min , Hmem_max = 15e-6 , 50e-6 # m. It is the thickness of the membrane. epsilon_gdl_min , epsilon_gdl_max = 0.40 , 0.95 # It is the anode/cathode GDL porosity, without units. epsilon_mpl_min , epsilon_mpl_max = 0.30 , 0.60 # It is the anode/cathode MPL porosity, without units. epsilon_cl_min , epsilon_cl_max = 0.12 , 0.50 # It is the anode/cathode MPL porosity, without units. epsilon_mc_min , epsilon_mc_max = 0.15 , 0.40 # It is the volume fraction of ionomer in the CL. epsilon_c_min , epsilon_c_max = 0.15 , 0.30 # It is the compression ratio of the GDL. # Constants based on the interaction between water and the structure e_min , e_max = 3 , 5 # It is the capillary exponent, and should be an int number. # Voltage polarization Re_min , Re_max = 5e-7 , 5e-6 # \u03a9.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref_min , i0_d_c_ref_max = 1e-1 , 100 # A.m-2.It is the dry reference exchange current density at the cathode. i0_h_c_ref_min , i0_h_c_ref_max = 1e-2 , 10 # A.m-2.It is the humid reference exchange current density at the cathode. kappa_co_min , kappa_co_max = 0.01 , 40 # A.m-2. It is the crossover correction coefficient. kappa_c_min , kappa_c_max = 0.25 , 4 # It is the overpotential correction exponent. # The bounds on liquid saturation coefficients are constrained to facilitate calibration. a_slim_min , a_slim_max = 0.0 , 0.25 / min ( Pc_des_1 / 1e5 , Pc_des_2 / 1e5 ) # It is one of the limit liquid saturation coefficients. b_slim_min , b_slim_max = 0.05 , 0.3 # It is one of the limit liquid saturation coefficients. a_switch_min , a_switch_max = 0.5 , 0.95 # It is one of the limit liquid saturation coefficients. # Undetermined parameter which is not considered yet (require the use of EIS curves to be calibrated) C_scl_min , C_sl_max = 2e7 , 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Bounds gathering and type if voltage_zone == \"before_voltage_drop\" : varbound = [[ 'Hacl' , Hacl_min , Hacl_max , 'real' ], [ 'Hmem' , Hmem_min , Hmem_max , 'real' ], [ 'epsilon_gdl' , epsilon_gdl_min , epsilon_gdl_max , 'real' ], [ 'epsilon_mc' , epsilon_mc_min , epsilon_mc_max , 'real' ], [ 'e' , e_min , e_max , 'int' ], [ 'Re' , Re_min , Re_max , 'real' ], [ 'i0_d_c_ref' , i0_d_c_ref_min , i0_d_c_ref_max , 'real' ], [ 'kappa_co' , kappa_co_min , kappa_co_max , 'real' ], [ 'kappa_c' , kappa_c_min , kappa_c_max , 'real' ]] else : # voltage_zone == \"full\" varbound = [[ 'epsilon_c' , epsilon_c_min , epsilon_c_max , 'real' ], [ 'i0_h_c_ref' , i0_h_c_ref_min , i0_h_c_ref_max , 'real' ], [ 'a_slim' , a_slim_min , a_slim_max , 'real' ], [ 'b_slim' , b_slim_min , b_slim_max , 'real' ], [ 'a_switch' , a_switch_min , a_switch_max , 'real' ]] gene_space = [] # List used to define the bounds of the undetermined parameters for pygad. for i in range ( len ( varbound )): name , min_val , max_val , type_val = varbound [ i ] if type_val == 'int' : gene_space . append ({ 'low' : min_val , 'high' : max_val , 'step' : 1 }) else : gene_space . append ({ 'low' : min_val , 'high' : max_val }) else : raise ValueError ( \"A correct type_fuel_cell should be given.\" ) return varbound , gene_space parameters_for_calibration ( type_fuel_cell , voltage_zone ) This function is used to determine the parameters of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. i_max_pola ( float ) \u2013 Maximum current density for the polarization curve. Aact ( float ) \u2013 Active area of the cell in m\u00b2. Hmem ( float ) \u2013 Thickness of the membrane in m. Hacl ( float ) \u2013 Thickness of the anode catalyst layer in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer in m. Hagc ( float ) \u2013 Thickness of the anode gas channel in m. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in m. Wagc ( float ) \u2013 Width of the gas anode channel in m. Wcgc ( float ) \u2013 Width of the gas cathode channel in m. Lgc ( float ) \u2013 Length of the gas channel in m. type_auxiliary ( str ) \u2013 Type of auxiliary system. type_control ( str ) \u2013 Type of control system. type_purge ( str ) \u2013 Type of purge system. type_display ( str ) \u2013 Type of display. type_plot ( str ) \u2013 Type of plot. type_current ( str ) \u2013 Type of current density function. current_density ( function ) \u2013 Current density evolution over time. It is a function of time and parameters dictionary. step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters ( dict ) \u2013 Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS ( float ) \u2013 Current for which a ratio_EIS perturbation is added. ratio_EIS ( float ) \u2013 Value of the perturbation on the current density for building the EIS curve. t_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min': f_min = 10**f_power_min, the power of the final frequency 'f_power_max', the number of frequencies tested 'nb_f' and the number of points calculated per specific period 'nb_points'. t_purge ( tuple ) \u2013 Time parameters for purging the system. It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. n_gdl ( int ) \u2013 Number of points considered in the GDL. i_exp ( ndarray ) \u2013 Experimental values of the current density. U_exp ( ndarray ) \u2013 Experimental values of the voltage. Source code in modules/calibration_modules.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def parameters_for_calibration ( type_fuel_cell , voltage_zone ): \"\"\"This function is used to determine the parameters of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. i_max_pola : float Maximum current density for the polarization curve. Aact : float Active area of the cell in m\u00b2. Hmem : float Thickness of the membrane in m. Hacl : float Thickness of the anode catalyst layer in m. Hccl : float Thickness of the cathode catalyst layer in m. Hagc : float Thickness of the anode gas channel in m. Hcgc : float Thickness of the cathode gas channel in m. Wagc : float Width of the gas anode channel in m. Wcgc : float Width of the gas cathode channel in m. Lgc : float Length of the gas channel in m. type_auxiliary : str Type of auxiliary system. type_control : str Type of control system. type_purge : str Type of purge system. type_display : str Type of display. type_plot : str Type of plot. type_current : str Type of current density function. current_density : function Current density evolution over time. It is a function of time and parameters dictionary. step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS : float Current for which a ratio_EIS perturbation is added. ratio_EIS : float Value of the perturbation on the current density for building the EIS curve. t_EIS : tuple EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min': f_min = 10**f_power_min, the power of the final frequency 'f_power_max', the number of frequencies tested 'nb_f' and the number of points calculated per specific period 'nb_points'. t_purge : tuple Time parameters for purging the system. It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. n_gdl : int Number of points considered in the GDL. i_exp : numpy.ndarray Experimental values of the current density. U_exp : numpy.ndarray Experimental values of the voltage. \"\"\" # Algorithm parameters for polarization curve generation type_auxiliary = \"no_auxiliary\" # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! This should be changed in the future to \"forced-convective_cathode_with_flow-through_anode\". type_control = \"no_control\" type_purge = \"no_purge\" type_display = \"no_display\" type_plot = \"fixed\" type_current = \"polarization_for_cali\" current_density = polarization_current_for_calibration delta_t_ini_step = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states (standard value). delta_t_load_step = 1e-15 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 0 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 1.0e4 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } delta_t_ini_pola = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola } delta_t_ini_pola_cali = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } i_EIS , ratio_EIS = np . nan , np . nan # (A/m\u00b2, ). i_EIS is the current for which a ratio_EIS perturbation is added. f_EIS , t_EIS = np . nan , np . nan # It is the EIS parameters. t_purge = 0.6 , 15 # s It is the purge time and the distance between two purges. rtol = 1e-3 # Relative tolerance for the system of ODEs solver. atol = 1e-6 # Absolute tolerance for the system of ODEs solver. if type_fuel_cell == \"ZSW-GenStack\" or type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" or type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" or type_fuel_cell == \"ZSW-GenStack_T_62\" or \\ type_fuel_cell == \"ZSW-GenStack_T_76\" or type_fuel_cell == \"ZSW-GenStack_T_84\" : # Given values by the author # Operating inputs if type_fuel_cell == \"ZSW-GenStack_T_62\" : T_des = 62 + 273.15 # K. It is the temperature of the fuel cell. elif type_fuel_cell == \"ZSW-GenStack_T_76\" : T_des = 76 + 273.15 # K. It is the temperature of the fuel cell. elif type_fuel_cell == \"ZSW-GenStack_T_84\" : T_des = 84 + 273.15 # K. It is the temperature of the fuel cell. else : T_des = 68 + 273.15 # K. It is the temperature of the fuel cell. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. if type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : Pa_des , Pc_des = 1.61e5 , 1.41e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : Pa_des , Pc_des = 2.01e5 , 1.81e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : Pa_des , Pc_des = 2.4e5 , 2.2e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : Pa_des , Pc_des = 2.8e5 , 2.6e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). else : Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == 'full' : i_max_pola = 2.5e4 # (A.m-2). It is the maximum current density for the polarization curve. else : # voltage_zone == 'before_voltage_drop' i_max_pola = 1.9e4 pola_current_parameters . update ({ 'i_max_pola' : i_max_pola }) # Fuel cell physical parameters Aact = 283.87e-4 # m\u00b2. It is the active area of the catalyst layer. nb_cell = 26 # . It is the number of cell in the stack. Hagc = 2.3e-4 # m. It is the thickness of the anode gas channel. Hcgc = 3e-4 # m. It is the thickness of the cathode gas channel. Wagc = 4.3e-4 # m. It is the width of the anode gas channel. Wcgc = 5.32e-4 # m. It is the width of the cathode gas channel. Lgc = 246.2e-3 # m. It is the length of the gas channel. nb_channel_in_gc = 105 # . It is the number of channels in the bipolar plate. Ldist = 7.11e-2 # m. It is the length of the distributor, which is the volume between the gas channel and the manifold. Lm = 25.8e-3 # m. It is the length of the manifold. L_endplate = 46.8e-3 # m. It is the length of the endplate. L_man_gc = 8.74e-3 # m. It is the length of the volume connecting the manifold to the gas channel. A_T_a = 9.01e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = 22.61e-4 # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = Lm * A_T_a , Lm * A_T_c # m3. It is the supply manifold volume. Vaem , Vcem = Vasm , Vcsm # m-3. It is the exhaust manifold volume. V_endplate_a = L_man_gc * A_T_a # m3. It is the anode endplate volume. V_endplate_c = L_man_gc * A_T_c # m3. It is the cathode endplate volume. V_man_agc = L_man_gc * Hagc * Wagc # m3. It is the volume of the volume connecting the anode manifold to the gas channel. V_man_cgc = L_man_gc * Hcgc * Wcgc # m3. It is the volume of the volume connecting the cathode manifold to the gas channel. # Fuel cell undetermined physical parameters. Hgdl = 1.27e-4 # m. It is the thickness of the gas diffusion layer. Hmpl = 7e-5 # m. It is the thickness of the microporous layer. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Estimated undetermined parameters for the initialisation # Gas diffusion layer epsilon_gdl = 0.788 # It is the anode/cathode GDL porosity. epsilon_mpl = 0.425 # It is the porosity of the microporous layer. # Catalyst layer Hacl = 8e-6 # m. It is the thickness of the anode catalyst layer. Hccl = 17e-6 # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.5 # It is the porosity of the microporous layer. epsilon_mc = 0.5 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 1.5e-5 # m. It is the thickness of the membrane. # Interaction parameters between water and PEMFC structure e = 3.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # ohm.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.86 # A.m-2.It is the dry reference exchange current density at the cathode. i0_h_c_ref = 1.0 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 1 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.6386 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Computing parameters nb_gc = 1 # It is the number of model points placed inside each gas channel. nb_gdl = max ( 1 , int ( Hgdl / Hacl / 4 )) # It is the number of model points placed inside each GDL. nb_mpl = max ( 1 , int ( Hmpl / Hacl / 3 )) # It is the number of model points placed inside each MPL. elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Given values by the author # Operating inputs T_des = 74 + 273.15 # K. It is the temperature of the fuel cell. Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. if type_fuel_cell == \"EH-31_1.5\" : Pa_des , Pc_des = 1.5e5 , 1.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). elif type_fuel_cell == \"EH-31_2.0\" : Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). elif type_fuel_cell == \"EH-31_2.25\" : Pa_des , Pc_des = 2.25e5 , 2.25e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). else : # type_fuel_cell == \"EH-31_2.5\": Pa_des , Pc_des = 2.5e5 , 2.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == 'full' : i_max_pola = 3.0e4 # (A.m-2). It is the maximum current density for the polarization curve. else : # voltage_zone == 'before_voltage_drop' i_max_pola = 1.7e4 pola_current_parameters . update ({ 'i_max_pola' : i_max_pola }) # Fuel cell physical parameters Aact = 85e-4 # m\u00b2. It is the active area of the catalyst layer. Wagc = 450e-6 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 144e-3 # m. It is the length of one channel in the bipolar plate. nb_channel_in_gc = 67 # . It is the number of channels in the bipolar plate. # Extrapolated physical parameters nb_cell = 1 # . It is the number of cell in the stack. Hgdl = 200e-6 # m. It is the thickness of the gas diffusion layer. Hmpl = 30e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. Hagc = 500e-6 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Ldist = 5e-2 # m. It is the estimated length of the distributor, which is the volume between the gas channel and the manifold. Lm = 2.03e-3 # m. It is the length of the manifold. L_endplate = 46.8e-3 # m. It is the length of the endplate. L_man_gc = 8.74e-3 # m. It is the length of the volume connecting the manifold to the gas channel. A_T_a = 11.8e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = 34.4e-4 # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = Lm * A_T_a , Lm * A_T_c # m3. It is the supply manifold volume. Vaem , Vcem = Vasm , Vcsm # m-3. It is the exhaust manifold volume. V_endplate_a = L_man_gc * A_T_a # m3. It is the anode endplate volume. V_endplate_c = L_man_gc * A_T_c # m3. It is the cathode endplate volume. V_man_agc = L_man_gc * Hagc * Wagc # m3. It is the volume of the volume connecting the anode manifold to the gas channel. V_man_cgc = L_man_gc * Hcgc * Wcgc # m3. It is the volume of the volume connecting the cathode manifold to the gas channel. # Estimated undetermined parameters for the initialisation # Gas diffusion layer epsilon_gdl = 0.5002 # It is the anode/cathode GDL porosity. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Catalyst layer Hacl = 8.593e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_mc = 0.3986 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 16.06e-6 # m. It is the thickness of the membrane. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # ohm.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.43 # A.m-2.It is the reference exchange current density at the cathode. i0_h_c_ref = 1.0 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 30.42 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.4152 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 20e6 # F.m-3. It is the volumetric space-charge layer capacitance. # Computing parameters nb_gc = 1 # It is the number of model points placed inside each gas channel. nb_gdl = max ( 1 , int ( Hgdl / Hacl / 4 )) # It is the number of model points placed inside each GDL. nb_mpl = max ( 1 , int ( Hmpl / Hacl / 3 )) # It is the number of model points placed inside each MPL. else : ValueError ( \"A correct type_fuel_cell should be given.\" ) # Initialize the operating inputs and parameters dictionaries. operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des , 'y_H2_in' : y_H2_in } current_parameters = { 'step_current_parameters' : step_current_parameters , 'pola_current_parameters' : pola_current_parameters , 'pola_current_for_cali_parameters' : pola_current_for_cali_parameters , 'i_EIS' : i_EIS , 'ratio_EIS' : ratio_EIS , 't_EIS' : t_EIS , 'f_EIS' : f_EIS } accessible_physical_parameters = { 'Aact' : Aact , 'nb_cell' : nb_cell , 'Hagc' : Hagc , 'Hcgc' : Hcgc , 'Wagc' : Wagc , 'Wcgc' : Wcgc , 'Lgc' : Lgc , 'nb_channel_in_gc' : nb_channel_in_gc , 'Ldist' : Ldist , 'Lm' : Lm , 'A_T_a' : A_T_a , 'A_T_c' : A_T_c , 'Vasm' : Vasm , 'Vcsm' : Vcsm , 'Vaem' : Vaem , 'Vcem' : Vcem } undetermined_physical_parameters = { 'Hgdl' : Hgdl , 'Hmpl' : Hmpl , 'Hmem' : Hmem , 'Hacl' : Hacl , 'Hccl' : Hccl , 'epsilon_gdl' : epsilon_gdl , 'epsilon_cl' : epsilon_cl , 'epsilon_mpl' : epsilon_mpl , 'epsilon_mc' : epsilon_mc , 'epsilon_c' : epsilon_c , 'e' : e , 'Re' : Re , 'i0_d_c_ref' : i0_d_c_ref , 'i0_h_c_ref' : i0_h_c_ref , 'kappa_co' : kappa_co , 'kappa_c' : kappa_c , 'a_slim' : a_slim , 'b_slim' : b_slim , 'a_switch' : a_switch , 'C_scl' : C_scl } computing_parameters = { 'nb_gc' : nb_gc , 'nb_gdl' : nb_gdl , 'nb_mpl' : nb_mpl , 't_purge' : t_purge , 'rtol' : rtol , 'atol' : atol , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'voltage_zone' : voltage_zone , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } # Characteristic points of the experimental polarization curve i_exp , U_exp = pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) return ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , i_exp , U_exp ) print_calibration_results ( convergence , ga_instance , solution , varbound , sim_error ) This function prints the calibration results by associating each optimized value with its parameter name. Parameters: convergence ( dict ) \u2013 Dictionary containing the convergence information of the genetic algorithm. ga_instance ( PyGAD object ) \u2013 Instance of PyGAD used for optimization. solution ( list ) \u2013 List of optimized parameter values. varbound ( list ) \u2013 List of parameter bounds and names. sim_error ( float ) \u2013 Maximum simulation error in percentage. Source code in modules/calibration_modules.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def print_calibration_results ( convergence , ga_instance , solution , varbound , sim_error ): \"\"\" This function prints the calibration results by associating each optimized value with its parameter name. Parameters ---------- convergence : dict Dictionary containing the convergence information of the genetic algorithm. ga_instance : PyGAD object Instance of PyGAD used for optimization. solution : list List of optimized parameter values. varbound : list List of parameter bounds and names. sim_error : float Maximum simulation error in percentage. \"\"\" print ( \"Convergence: \\n \" , convergence ) for idx , val in enumerate ( solution ): param_name = varbound [ idx ][ 0 ] print ( f \"Optimized parameter { param_name } : { val } \" ) print ( Fore . RED + \" \\n Max simulation error: \" , sim_error , \"%\" ) print ( Style . RESET_ALL ) if ga_instance . best_solution_generation != - 1 : print ( f \"Best fitness value reached after { ga_instance . best_solution_generation } generations.\" ) save_calibration_results ( convergence , ga_instance , solution , varbound , sim_error , type_fuel_cell ) This function saves the calibration results in a text file and a PyGAD file. The optimized values are retrieved from the solution list and associated with their names via varbound. Parameters: convergence ( dict ) \u2013 Convergence information from the genetic algorithm. ga_instance ( PyGAD object ) \u2013 Instance of PyGAD used for optimization. solution ( list ) \u2013 List of optimized parameter values. varbound ( list ) \u2013 List of parameter bounds and names. sim_error ( float ) \u2013 Maximum simulation error in percentage. type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: None \u2013 Source code in modules/calibration_modules.py 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def save_calibration_results ( convergence , ga_instance , solution , varbound , sim_error , type_fuel_cell ): \"\"\" This function saves the calibration results in a text file and a PyGAD file. The optimized values are retrieved from the solution list and associated with their names via varbound. Parameters ---------- convergence : dict Convergence information from the genetic algorithm. ga_instance : PyGAD object Instance of PyGAD used for optimization. solution : list List of optimized parameter values. varbound : list List of parameter bounds and names. sim_error : float Maximum simulation error in percentage. type_fuel_cell : str Type of fuel cell configuration. Returns ------- None \"\"\" root_folder , filename = \"results\" , \"parameter_calibration_1.txt\" subfolder_name = type_fuel_cell [: type_fuel_cell . find ( '_' )] if type_fuel_cell . find ( '_' ) != - 1 else type_fuel_cell counter = 1 folder_name = os . path . join ( root_folder , subfolder_name ) # Create the folder if necessary if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the file without erasing the previous ones while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 filename = \"parameter_calibration_\" + str ( counter ) + \".txt\" file_path = os . path . join ( folder_name , filename ) # Write information with open ( file_path , \"w\" ) as file : file . write ( \"Convergence: \" + str ( convergence )) for idx , val in enumerate ( solution ): param_name = varbound [ idx ][ 0 ] file . write ( f \" \\n Optimized parameter { param_name } : { val } \" ) file . write ( \" \\n Max simulation error: \" + str ( sim_error ) + \"%\" ) file . write ( \" \\n Algorithm works with \" + type_fuel_cell + \".\" ) if ga_instance . best_solution_generation != - 1 : file . write ( f \" \\n Best fitness value reached after { ga_instance . best_solution_generation } generations.\" ) ga_instance . save ( filename = os . path . join ( folder_name , \"parameter_calibration_\" + str ( counter ))) if os . path . isfile ( 'parameter_calibration_ongoing.pkl' ): os . remove ( 'parameter_calibration_ongoing.pkl' ) update_undetermined_parameters ( type_fuel_cell , solution , varbound , undetermined_physical_parameters ) Update the undetermined physical parameters dictionary with values from the solution. Parameters: solution ( list ) \u2013 List of parameter values obtained from the optimization algorithm. varbound ( list ) \u2013 List of parameter bounds and names. Each element contains the parameter name at index 0. undetermined_physical_parameters ( dict ) \u2013 Dictionary of undetermined physical parameters to be updated. Returns: dict \u2013 Updated dictionary of undetermined physical parameters. Source code in modules/calibration_modules.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 def update_undetermined_parameters ( type_fuel_cell , solution , varbound , undetermined_physical_parameters ): \"\"\" Update the undetermined physical parameters dictionary with values from the solution. Parameters ---------- solution : list List of parameter values obtained from the optimization algorithm. varbound : list List of parameter bounds and names. Each element contains the parameter name at index 0. undetermined_physical_parameters : dict Dictionary of undetermined physical parameters to be updated. Returns ------- dict Updated dictionary of undetermined physical parameters. \"\"\" for i in range ( len ( solution )): param_name = varbound [ i ][ 0 ] if param_name in undetermined_physical_parameters : undetermined_physical_parameters [ param_name ] = solution [ i ] if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : undetermined_physical_parameters [ 'Hccl' ] = undetermined_physical_parameters [ 'Hacl' ] return undetermined_physical_parameters","title":"Calibration modules"},{"location":"functions/modules/calibration_modules/#calibration-modules","text":"This module contains some of the functions required for the parameter calibration.","title":"Calibration modules"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.calculate_simulation_error","text":"This function is used to calculate the simulation maximal error between the experimental and the simulated polarization curves. Two simulations on different operating conditions and on the same stack, and so two set of experimental data, are considered as it is the minimum amount of data which is required for the calibration. Parameters: Simulator_1 ( AlphaPEM object ) \u2013 PEM simulator which contains the simulation results for the first simulation. U_exp_1 ( ndarray ) \u2013 Experimental values of the voltage for the first simulation. i_exp_1 ( ndarray ) \u2013 Experimental values of the current density for the first simulation. Simulator_2 ( AlphaPEM object ) \u2013 PEM simulator which contains the simulation results for the second simulation. U_exp_2 ( ndarray ) \u2013 Experimental values of the voltage for the second simulation. i_exp_2 ( ndarray ) \u2013 Experimental values of the current density for the second simulation. Returns: sim_error ( float ) \u2013 Maximum error between the experimental and the simulated polarization curves in percentage. Source code in modules/calibration_modules.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 def calculate_simulation_error ( Simulator_1 , U_exp_1 , i_exp_1 , Simulator_2 , U_exp_2 , i_exp_2 ): \"\"\"This function is used to calculate the simulation maximal error between the experimental and the simulated polarization curves. Two simulations on different operating conditions and on the same stack, and so two set of experimental data, are considered as it is the minimum amount of data which is required for the calibration. Parameters ---------- Simulator_1 : AlphaPEM object PEM simulator which contains the simulation results for the first simulation. U_exp_1 : numpy.ndarray Experimental values of the voltage for the first simulation. i_exp_1 : numpy.ndarray Experimental values of the current density for the first simulation. Simulator_2 : AlphaPEM object PEM simulator which contains the simulation results for the second simulation. U_exp_2 : numpy.ndarray Experimental values of the voltage for the second simulation. i_exp_2 : numpy.ndarray Experimental values of the current density for the second simulation. Returns ------- sim_error : float Maximum error between the experimental and the simulated polarization curves in percentage. \"\"\" # Recovery of ifc_1 t1 = np . array ( Simulator_1 . variables [ 't' ]) n1 = len ( t1 ) ifc_t_1 = np . zeros ( n1 ) for i in range ( n1 ): # Creation of ifc_t ifc_t_1 [ i ] = Simulator_1 . operating_inputs [ 'current_density' ]( t1 [ i ], Simulator_1 . parameters ) # Recovery of ifc_2 t2 = np . array ( Simulator_2 . variables [ 't' ]) n2 = len ( t2 ) ifc_t_2 = np . zeros ( n2 ) for i in range ( n2 ): # Creation of ifc_t ifc_t_2 [ i ] = Simulator_2 . operating_inputs [ 'current_density' ]( t2 [ i ], Simulator_2 . parameters ) # Polarisation curve point recovery after stack stabilisation for Simulator1 # Extraction of the parameters # The initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # The loading time for one step current of the polarisation current density function. delta_t_load_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # The breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali_1 = Simulator_1 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). # Calculation nb_loads1 = len ( i_exp_1 ) # Number of load which are made delta_t_cali_1 = delta_t_load_pola_cali_1 + delta_t_break_pola_cali_1 # s. It is the time of one load. ifc_discretized1 = np . zeros ( nb_loads1 ) Ucell_discretized1 = np . zeros ( nb_loads1 ) for i in range ( nb_loads1 ): t_load_1 = delta_t_ini_pola_cali_1 + ( i + 1 ) * delta_t_cali_1 # time for measurement idx1 = ( np . abs ( t1 - t_load_1 )) . argmin () # the corresponding index ifc_discretized1 [ i ] = ifc_t_1 [ idx1 ] # the last value at the end of each load Ucell_discretized1 [ i ] = Simulator_1 . variables [ 'Ucell' ][ idx1 ] # the last value at the end of each load # Polarisation curve point recovery after stack stabilisation for Simulator2 # Extraction of the parameters # The initial time at zero current density for the stabilisation of the internal states. delta_t_ini_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] # (s). # The loading time for one step current of the polarisation current density function. delta_t_load_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_load_pola_cali' ] # (s). # The breaking time for one step current, for the stabilisation of the internal states. delta_t_break_pola_cali_2 = Simulator_2 . parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_break_pola_cali' ] # (s). # Calculation nb_loads2 = len ( i_exp_2 ) # Number of load which are made delta_t_cali_2 = delta_t_load_pola_cali_2 + delta_t_break_pola_cali_2 # s. It is the time of one load. ifc_discretized2 = np . zeros ( nb_loads2 ) Ucell_discretized2 = np . zeros ( nb_loads2 ) for i in range ( nb_loads2 ): t_load_2 = delta_t_ini_pola_cali_2 + ( i + 1 ) * delta_t_cali_2 # time for measurement idx2 = ( np . abs ( t2 - t_load_2 )) . argmin () # the corresponding index ifc_discretized2 [ i ] = ifc_t_2 [ idx2 ] # the last value at the end of each load Ucell_discretized2 [ i ] = Simulator_2 . variables [ 'Ucell' ][ idx2 ] # the last value at the end of each load # Distance between the simulated and the experimental polarization curves. sim_error = ( np . max ( np . abs ( Ucell_discretized1 - U_exp_1 ) / U_exp_1 * 100 ) + np . max ( np . abs ( Ucell_discretized2 - U_exp_2 ) / U_exp_2 * 100 )) / 2 # in %. return sim_error","title":"calculate_simulation_error"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.parameter_bounds_for_calibration","text":"This function is used to determine the parameter bounds of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters type_fuel_cell : str Type of fuel cell configuration. voltage_zone : str Zone of calibration: \"before_voltage_drop\", \"full\". operating_inputs_1 : dict Operating inputs for the first fuel cell configuration. operating_inputs_2 : dict Operating inputs for the second fuel cell configuration. Returns varbound : list List of the bounds on the parameters to calibrate. Each element is a list containing the minimum and maximum values of the parameter, and the type of the parameter ('real' or 'int'). gene_space : list List of dictionaries used to define the bounds of the undetermined parameters for pygad. Each dictionary contains the 'low' and 'high' values for the parameter, and optionally a 'step' value for integer parameters. Source code in modules/calibration_modules.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def parameter_bounds_for_calibration ( type_fuel_cell , voltage_zone , operating_inputs_1 , operating_inputs_2 ): \"\"\"This function is used to determine the parameter bounds of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. voltage_zone : str Zone of calibration: \"before_voltage_drop\", \"full\". operating_inputs_1 : dict Operating inputs for the first fuel cell configuration. operating_inputs_2 : dict Operating inputs for the second fuel cell configuration. Returns ------- varbound : list List of the bounds on the parameters to calibrate. Each element is a list containing the minimum and maximum values of the parameter, and the type of the parameter ('real' or 'int'). gene_space : list List of dictionaries used to define the bounds of the undetermined parameters for pygad. Each dictionary contains the 'low' and 'high' values for the parameter, and optionally a 'step' value for integer parameters. \"\"\" Pc_des_1 , Pc_des_2 = operating_inputs_1 [ 'Pc_des' ], operating_inputs_2 [ 'Pc_des' ] if type_fuel_cell == \"ZSW-GenStack\" or type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" or type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" or type_fuel_cell == \"ZSW-GenStack_T_62\" or \\ type_fuel_cell == \"ZSW-GenStack_T_76\" or type_fuel_cell == \"ZSW-GenStack_T_84\" : # Fuel cell physical parameters Hacl_min , Hacl_max = 6e-6 , 10e-6 # m. It is the thickness of the ACL. Hccl_min , Hccl_max = 10e-6 , 20e-6 # m. It is the thickness of the CCL. Hmem_min , Hmem_max = 10e-6 , 20e-6 # m. It is the thickness of the membrane. epsilon_gdl_min , epsilon_gdl_max = 0.696 , 0.880 # It is the anode/cathode GDL porosity, without units. epsilon_mpl_min , epsilon_mpl_max = 0.32 , 0.54 # It is the anode/cathode MPL porosity, without units. epsilon_cl_min , epsilon_cl_max = 0.40 , 0.60 # It is the anode/cathode MPL porosity, without units. epsilon_mc_min , epsilon_mc_max = 0.15 , 0.40 # It is the volume fraction of ionomer in the CL. # Constants based on the interaction between water and the structure e_min , e_max = 3 , 5 # It is the capillary exponent, and should be an int number. # Voltage polarization Re_min , Re_max = 5e-7 , 5e-6 # \u03a9.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref_min , i0_d_c_ref_max = 1e-1 , 100 # A.m-2.It is the dry reference exchange current density at the cathode. i0_h_c_ref_min , i0_h_c_ref_max = 1e-2 , 10 # A.m-2.It is the humid reference exchange current density at the cathode. kappa_co_min , kappa_co_max = 0.01 , 40 # A.m-2. It is the crossover correction coefficient. kappa_c_min , kappa_c_max = 0.25 , 4 # It is the overpotential correction exponent. # The bounds on liquid saturation coefficients are constrained to facilitate calibration. a_slim_min , a_slim_max = 0.0 , 0.25 / min ( Pc_des_1 / 1e5 , Pc_des_2 / 1e5 ) # It is one of the limit liquid saturation coefficients. b_slim_min , b_slim_max = 0.05 , 0.3 # It is one of the limit liquid saturation coefficients. a_switch_min , a_switch_max = 0.5 , 0.95 # It is one of the limit liquid saturation coefficients. # Undetermined parameter which is not considered yet (require the use of EIS curves to be calibrated) C_scl_min , C_sl_max = 2e7 , 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Bounds gathering and type if voltage_zone == \"before_voltage_drop\" : varbound = [[ 'Hacl' , Hacl_min , Hacl_max , 'real' ], [ 'Hccl' , Hccl_min , Hccl_max , 'real' ], [ 'Hmem' , Hmem_min , Hmem_max , 'real' ], [ 'epsilon_gdl' , epsilon_gdl_min , epsilon_gdl_max , 'real' ], [ 'epsilon_mc' , epsilon_mc_min , epsilon_mc_max , 'real' ], [ 'e' , e_min , e_max , 'int' ], [ 'Re' , Re_min , Re_max , 'real' ], [ 'i0_d_c_ref' , i0_d_c_ref_min , i0_d_c_ref_max , 'real' ], [ 'kappa_co' , kappa_co_min , kappa_co_max , 'real' ], [ 'kappa_c' , kappa_c_min , kappa_c_max , 'real' ]] else : # voltage_zone == \"full\" varbound = [[ 'i0_h_c_ref' , i0_h_c_ref_min , i0_h_c_ref_max , 'real' ], [ 'a_slim' , a_slim_min , a_slim_max , 'real' ], [ 'b_slim' , b_slim_min , b_slim_max , 'real' ], [ 'a_switch' , a_switch_min , a_switch_max , 'real' ]] gene_space = [] # List used to define the bounds of the undetermined parameters for pygad. for i in range ( len ( varbound )): name , min_val , max_val , type_val = varbound [ i ] if type_val == 'int' : gene_space . append ({ 'low' : min_val , 'high' : max_val , 'step' : 1 }) else : gene_space . append ({ 'low' : min_val , 'high' : max_val }) elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Fuel cell physical parameters Hacl_min , Hacl_max = 8e-6 , 20e-6 # m. It is the thickness of the ACL. Hmem_min , Hmem_max = 15e-6 , 50e-6 # m. It is the thickness of the membrane. epsilon_gdl_min , epsilon_gdl_max = 0.40 , 0.95 # It is the anode/cathode GDL porosity, without units. epsilon_mpl_min , epsilon_mpl_max = 0.30 , 0.60 # It is the anode/cathode MPL porosity, without units. epsilon_cl_min , epsilon_cl_max = 0.12 , 0.50 # It is the anode/cathode MPL porosity, without units. epsilon_mc_min , epsilon_mc_max = 0.15 , 0.40 # It is the volume fraction of ionomer in the CL. epsilon_c_min , epsilon_c_max = 0.15 , 0.30 # It is the compression ratio of the GDL. # Constants based on the interaction between water and the structure e_min , e_max = 3 , 5 # It is the capillary exponent, and should be an int number. # Voltage polarization Re_min , Re_max = 5e-7 , 5e-6 # \u03a9.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref_min , i0_d_c_ref_max = 1e-1 , 100 # A.m-2.It is the dry reference exchange current density at the cathode. i0_h_c_ref_min , i0_h_c_ref_max = 1e-2 , 10 # A.m-2.It is the humid reference exchange current density at the cathode. kappa_co_min , kappa_co_max = 0.01 , 40 # A.m-2. It is the crossover correction coefficient. kappa_c_min , kappa_c_max = 0.25 , 4 # It is the overpotential correction exponent. # The bounds on liquid saturation coefficients are constrained to facilitate calibration. a_slim_min , a_slim_max = 0.0 , 0.25 / min ( Pc_des_1 / 1e5 , Pc_des_2 / 1e5 ) # It is one of the limit liquid saturation coefficients. b_slim_min , b_slim_max = 0.05 , 0.3 # It is one of the limit liquid saturation coefficients. a_switch_min , a_switch_max = 0.5 , 0.95 # It is one of the limit liquid saturation coefficients. # Undetermined parameter which is not considered yet (require the use of EIS curves to be calibrated) C_scl_min , C_sl_max = 2e7 , 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Bounds gathering and type if voltage_zone == \"before_voltage_drop\" : varbound = [[ 'Hacl' , Hacl_min , Hacl_max , 'real' ], [ 'Hmem' , Hmem_min , Hmem_max , 'real' ], [ 'epsilon_gdl' , epsilon_gdl_min , epsilon_gdl_max , 'real' ], [ 'epsilon_mc' , epsilon_mc_min , epsilon_mc_max , 'real' ], [ 'e' , e_min , e_max , 'int' ], [ 'Re' , Re_min , Re_max , 'real' ], [ 'i0_d_c_ref' , i0_d_c_ref_min , i0_d_c_ref_max , 'real' ], [ 'kappa_co' , kappa_co_min , kappa_co_max , 'real' ], [ 'kappa_c' , kappa_c_min , kappa_c_max , 'real' ]] else : # voltage_zone == \"full\" varbound = [[ 'epsilon_c' , epsilon_c_min , epsilon_c_max , 'real' ], [ 'i0_h_c_ref' , i0_h_c_ref_min , i0_h_c_ref_max , 'real' ], [ 'a_slim' , a_slim_min , a_slim_max , 'real' ], [ 'b_slim' , b_slim_min , b_slim_max , 'real' ], [ 'a_switch' , a_switch_min , a_switch_max , 'real' ]] gene_space = [] # List used to define the bounds of the undetermined parameters for pygad. for i in range ( len ( varbound )): name , min_val , max_val , type_val = varbound [ i ] if type_val == 'int' : gene_space . append ({ 'low' : min_val , 'high' : max_val , 'step' : 1 }) else : gene_space . append ({ 'low' : min_val , 'high' : max_val }) else : raise ValueError ( \"A correct type_fuel_cell should be given.\" ) return varbound , gene_space","title":"parameter_bounds_for_calibration"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.parameters_for_calibration","text":"This function is used to determine the parameters of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. i_max_pola ( float ) \u2013 Maximum current density for the polarization curve. Aact ( float ) \u2013 Active area of the cell in m\u00b2. Hmem ( float ) \u2013 Thickness of the membrane in m. Hacl ( float ) \u2013 Thickness of the anode catalyst layer in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer in m. Hagc ( float ) \u2013 Thickness of the anode gas channel in m. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in m. Wagc ( float ) \u2013 Width of the gas anode channel in m. Wcgc ( float ) \u2013 Width of the gas cathode channel in m. Lgc ( float ) \u2013 Length of the gas channel in m. type_auxiliary ( str ) \u2013 Type of auxiliary system. type_control ( str ) \u2013 Type of control system. type_purge ( str ) \u2013 Type of purge system. type_display ( str ) \u2013 Type of display. type_plot ( str ) \u2013 Type of plot. type_current ( str ) \u2013 Type of current density function. current_density ( function ) \u2013 Current density evolution over time. It is a function of time and parameters dictionary. step_current_parameters ( dict ) \u2013 Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters ( dict ) \u2013 Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters ( dict ) \u2013 Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS ( float ) \u2013 Current for which a ratio_EIS perturbation is added. ratio_EIS ( float ) \u2013 Value of the perturbation on the current density for building the EIS curve. t_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min': f_min = 10**f_power_min, the power of the final frequency 'f_power_max', the number of frequencies tested 'nb_f' and the number of points calculated per specific period 'nb_points'. t_purge ( tuple ) \u2013 Time parameters for purging the system. It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. n_gdl ( int ) \u2013 Number of points considered in the GDL. i_exp ( ndarray ) \u2013 Experimental values of the current density. U_exp ( ndarray ) \u2013 Experimental values of the voltage. Source code in modules/calibration_modules.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def parameters_for_calibration ( type_fuel_cell , voltage_zone ): \"\"\"This function is used to determine the parameters of the fuel cell model for the calibration when a registered type_fuel_cell is considered. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. i_max_pola : float Maximum current density for the polarization curve. Aact : float Active area of the cell in m\u00b2. Hmem : float Thickness of the membrane in m. Hacl : float Thickness of the anode catalyst layer in m. Hccl : float Thickness of the cathode catalyst layer in m. Hagc : float Thickness of the anode gas channel in m. Hcgc : float Thickness of the cathode gas channel in m. Wagc : float Width of the gas anode channel in m. Wcgc : float Width of the gas cathode channel in m. Lgc : float Length of the gas channel in m. type_auxiliary : str Type of auxiliary system. type_control : str Type of control system. type_purge : str Type of purge system. type_display : str Type of display. type_plot : str Type of plot. type_current : str Type of current density function. current_density : function Current density evolution over time. It is a function of time and parameters dictionary. step_current_parameters : dict Parameters for the step current density. It is a dictionary containing: - 'delta_t_ini_step': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_step': the loading time (in seconds) for the step current density function, from 0 to i_step, - 'delta_t_break_step': the time (in seconds) at i_step current density for the stabilisation of the internal states, - 'i_step': the current density (in A.m-2) for the step current density function, - 'delta_t_dyn_step': the time (in seconds) for dynamic display of the step current density function. pola_current_parameters : dict Parameters for the polarization current density. It is a dictionary containing: - 'delta_t_ini_pola': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola': the breaking time (in seconds) for one step current, for the stabilisation of the internal states, - 'delta_i_pola': the current density step (in A.m-2) for the polarisation current density function. - 'i_max_pola': the maximum current density (in A.m-2) for the polarization curve. pola_current_for_cali_parameters : dict Parameters for the polarization current density for calibration. It is a dictionary containing: - 'delta_t_ini_pola_cali': the initial time (in seconds) at zero current density for the stabilisation of the internal states, - 'delta_t_load_pola_cali': the loading time (in seconds) for one step current of the polarisation current density function, - 'delta_t_break_pola_cali': the breaking time (in seconds) for one step current, for the stabilisation of the internal states. i_EIS : float Current for which a ratio_EIS perturbation is added. ratio_EIS : float Value of the perturbation on the current density for building the EIS curve. t_EIS : tuple EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. f_EIS : tuple EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min': f_min = 10**f_power_min, the power of the final frequency 'f_power_max', the number of frequencies tested 'nb_f' and the number of points calculated per specific period 'nb_points'. t_purge : tuple Time parameters for purging the system. It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'. n_gdl : int Number of points considered in the GDL. i_exp : numpy.ndarray Experimental values of the current density. U_exp : numpy.ndarray Experimental values of the voltage. \"\"\" # Algorithm parameters for polarization curve generation type_auxiliary = \"no_auxiliary\" # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! This should be changed in the future to \"forced-convective_cathode_with_flow-through_anode\". type_control = \"no_control\" type_purge = \"no_purge\" type_display = \"no_display\" type_plot = \"fixed\" type_current = \"polarization_for_cali\" current_density = polarization_current_for_calibration delta_t_ini_step = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states (standard value). delta_t_load_step = 1e-15 # (s). Loading time for the step current density function, from 0 to i_step. delta_t_break_step = 0 # (s). Time at i_step current density for the stabilisation of the internal states. i_step = 1.0e4 # (A.m-2). Current density for the step current density function. step_current_parameters = { 'delta_t_ini_step' : delta_t_ini_step , 'delta_t_load_step' : delta_t_load_step , 'delta_t_break_step' : delta_t_break_step , 'i_step' : i_step } delta_t_ini_pola = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. delta_i_pola = 0.05e4 # (A.m-2). Current density step for the polarisation current density function. pola_current_parameters = { 'delta_t_ini_pola' : delta_t_ini_pola , 'delta_t_load_pola' : delta_t_load_pola , 'delta_t_break_pola' : delta_t_break_pola , 'delta_i_pola' : delta_i_pola } delta_t_ini_pola_cali = 30 * 60 # (s). Initial time at zero current density for the stabilisation of the internal states. delta_t_load_pola_cali = 30 # (s). Loading time for one step current of the polarisation current density function. delta_t_break_pola_cali = 15 * 60 # (s). Breaking time for one step current, for the stabilisation of the internal states. pola_current_for_cali_parameters = { 'delta_t_ini_pola_cali' : delta_t_ini_pola_cali , 'delta_t_load_pola_cali' : delta_t_load_pola_cali , 'delta_t_break_pola_cali' : delta_t_break_pola_cali } i_EIS , ratio_EIS = np . nan , np . nan # (A/m\u00b2, ). i_EIS is the current for which a ratio_EIS perturbation is added. f_EIS , t_EIS = np . nan , np . nan # It is the EIS parameters. t_purge = 0.6 , 15 # s It is the purge time and the distance between two purges. rtol = 1e-3 # Relative tolerance for the system of ODEs solver. atol = 1e-6 # Absolute tolerance for the system of ODEs solver. if type_fuel_cell == \"ZSW-GenStack\" or type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" or type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" or type_fuel_cell == \"ZSW-GenStack_T_62\" or \\ type_fuel_cell == \"ZSW-GenStack_T_76\" or type_fuel_cell == \"ZSW-GenStack_T_84\" : # Given values by the author # Operating inputs if type_fuel_cell == \"ZSW-GenStack_T_62\" : T_des = 62 + 273.15 # K. It is the temperature of the fuel cell. elif type_fuel_cell == \"ZSW-GenStack_T_76\" : T_des = 76 + 273.15 # K. It is the temperature of the fuel cell. elif type_fuel_cell == \"ZSW-GenStack_T_84\" : T_des = 84 + 273.15 # K. It is the temperature of the fuel cell. else : T_des = 68 + 273.15 # K. It is the temperature of the fuel cell. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. if type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : Pa_des , Pc_des = 1.61e5 , 1.41e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : Pa_des , Pc_des = 2.01e5 , 1.81e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : Pa_des , Pc_des = 2.4e5 , 2.2e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : Pa_des , Pc_des = 2.8e5 , 2.6e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). else : Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressure of the inlet fuel gas (at the anode/cathode). y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == 'full' : i_max_pola = 2.5e4 # (A.m-2). It is the maximum current density for the polarization curve. else : # voltage_zone == 'before_voltage_drop' i_max_pola = 1.9e4 pola_current_parameters . update ({ 'i_max_pola' : i_max_pola }) # Fuel cell physical parameters Aact = 283.87e-4 # m\u00b2. It is the active area of the catalyst layer. nb_cell = 26 # . It is the number of cell in the stack. Hagc = 2.3e-4 # m. It is the thickness of the anode gas channel. Hcgc = 3e-4 # m. It is the thickness of the cathode gas channel. Wagc = 4.3e-4 # m. It is the width of the anode gas channel. Wcgc = 5.32e-4 # m. It is the width of the cathode gas channel. Lgc = 246.2e-3 # m. It is the length of the gas channel. nb_channel_in_gc = 105 # . It is the number of channels in the bipolar plate. Ldist = 7.11e-2 # m. It is the length of the distributor, which is the volume between the gas channel and the manifold. Lm = 25.8e-3 # m. It is the length of the manifold. L_endplate = 46.8e-3 # m. It is the length of the endplate. L_man_gc = 8.74e-3 # m. It is the length of the volume connecting the manifold to the gas channel. A_T_a = 9.01e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = 22.61e-4 # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = Lm * A_T_a , Lm * A_T_c # m3. It is the supply manifold volume. Vaem , Vcem = Vasm , Vcsm # m-3. It is the exhaust manifold volume. V_endplate_a = L_man_gc * A_T_a # m3. It is the anode endplate volume. V_endplate_c = L_man_gc * A_T_c # m3. It is the cathode endplate volume. V_man_agc = L_man_gc * Hagc * Wagc # m3. It is the volume of the volume connecting the anode manifold to the gas channel. V_man_cgc = L_man_gc * Hcgc * Wcgc # m3. It is the volume of the volume connecting the cathode manifold to the gas channel. # Fuel cell undetermined physical parameters. Hgdl = 1.27e-4 # m. It is the thickness of the gas diffusion layer. Hmpl = 7e-5 # m. It is the thickness of the microporous layer. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Estimated undetermined parameters for the initialisation # Gas diffusion layer epsilon_gdl = 0.788 # It is the anode/cathode GDL porosity. epsilon_mpl = 0.425 # It is the porosity of the microporous layer. # Catalyst layer Hacl = 8e-6 # m. It is the thickness of the anode catalyst layer. Hccl = 17e-6 # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.5 # It is the porosity of the microporous layer. epsilon_mc = 0.5 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 1.5e-5 # m. It is the thickness of the membrane. # Interaction parameters between water and PEMFC structure e = 3.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # ohm.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.86 # A.m-2.It is the dry reference exchange current density at the cathode. i0_h_c_ref = 1.0 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 1 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.6386 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # Computing parameters nb_gc = 1 # It is the number of model points placed inside each gas channel. nb_gdl = max ( 1 , int ( Hgdl / Hacl / 4 )) # It is the number of model points placed inside each GDL. nb_mpl = max ( 1 , int ( Hmpl / Hacl / 3 )) # It is the number of model points placed inside each MPL. elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Given values by the author # Operating inputs T_des = 74 + 273.15 # K. It is the temperature of the fuel cell. Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. if type_fuel_cell == \"EH-31_1.5\" : Pa_des , Pc_des = 1.5e5 , 1.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). elif type_fuel_cell == \"EH-31_2.0\" : Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). elif type_fuel_cell == \"EH-31_2.25\" : Pa_des , Pc_des = 2.25e5 , 2.25e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). else : # type_fuel_cell == \"EH-31_2.5\": Pa_des , Pc_des = 2.5e5 , 2.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == 'full' : i_max_pola = 3.0e4 # (A.m-2). It is the maximum current density for the polarization curve. else : # voltage_zone == 'before_voltage_drop' i_max_pola = 1.7e4 pola_current_parameters . update ({ 'i_max_pola' : i_max_pola }) # Fuel cell physical parameters Aact = 85e-4 # m\u00b2. It is the active area of the catalyst layer. Wagc = 450e-6 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 144e-3 # m. It is the length of one channel in the bipolar plate. nb_channel_in_gc = 67 # . It is the number of channels in the bipolar plate. # Extrapolated physical parameters nb_cell = 1 # . It is the number of cell in the stack. Hgdl = 200e-6 # m. It is the thickness of the gas diffusion layer. Hmpl = 30e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. Hagc = 500e-6 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Ldist = 5e-2 # m. It is the estimated length of the distributor, which is the volume between the gas channel and the manifold. Lm = 2.03e-3 # m. It is the length of the manifold. L_endplate = 46.8e-3 # m. It is the length of the endplate. L_man_gc = 8.74e-3 # m. It is the length of the volume connecting the manifold to the gas channel. A_T_a = 11.8e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = 34.4e-4 # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = Lm * A_T_a , Lm * A_T_c # m3. It is the supply manifold volume. Vaem , Vcem = Vasm , Vcsm # m-3. It is the exhaust manifold volume. V_endplate_a = L_man_gc * A_T_a # m3. It is the anode endplate volume. V_endplate_c = L_man_gc * A_T_c # m3. It is the cathode endplate volume. V_man_agc = L_man_gc * Hagc * Wagc # m3. It is the volume of the volume connecting the anode manifold to the gas channel. V_man_cgc = L_man_gc * Hcgc * Wcgc # m3. It is the volume of the volume connecting the cathode manifold to the gas channel. # Estimated undetermined parameters for the initialisation # Gas diffusion layer epsilon_gdl = 0.5002 # It is the anode/cathode GDL porosity. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Catalyst layer Hacl = 8.593e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_mc = 0.3986 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 16.06e-6 # m. It is the thickness of the membrane. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # ohm.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.43 # A.m-2.It is the reference exchange current density at the cathode. i0_h_c_ref = 1.0 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 30.42 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.4152 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 20e6 # F.m-3. It is the volumetric space-charge layer capacitance. # Computing parameters nb_gc = 1 # It is the number of model points placed inside each gas channel. nb_gdl = max ( 1 , int ( Hgdl / Hacl / 4 )) # It is the number of model points placed inside each GDL. nb_mpl = max ( 1 , int ( Hmpl / Hacl / 3 )) # It is the number of model points placed inside each MPL. else : ValueError ( \"A correct type_fuel_cell should be given.\" ) # Initialize the operating inputs and parameters dictionaries. operating_inputs = { 'current_density' : current_density , 'T_des' : T_des , 'Pa_des' : Pa_des , 'Pc_des' : Pc_des , 'Sa' : Sa , 'Sc' : Sc , 'Phi_a_des' : Phi_a_des , 'Phi_c_des' : Phi_c_des , 'y_H2_in' : y_H2_in } current_parameters = { 'step_current_parameters' : step_current_parameters , 'pola_current_parameters' : pola_current_parameters , 'pola_current_for_cali_parameters' : pola_current_for_cali_parameters , 'i_EIS' : i_EIS , 'ratio_EIS' : ratio_EIS , 't_EIS' : t_EIS , 'f_EIS' : f_EIS } accessible_physical_parameters = { 'Aact' : Aact , 'nb_cell' : nb_cell , 'Hagc' : Hagc , 'Hcgc' : Hcgc , 'Wagc' : Wagc , 'Wcgc' : Wcgc , 'Lgc' : Lgc , 'nb_channel_in_gc' : nb_channel_in_gc , 'Ldist' : Ldist , 'Lm' : Lm , 'A_T_a' : A_T_a , 'A_T_c' : A_T_c , 'Vasm' : Vasm , 'Vcsm' : Vcsm , 'Vaem' : Vaem , 'Vcem' : Vcem } undetermined_physical_parameters = { 'Hgdl' : Hgdl , 'Hmpl' : Hmpl , 'Hmem' : Hmem , 'Hacl' : Hacl , 'Hccl' : Hccl , 'epsilon_gdl' : epsilon_gdl , 'epsilon_cl' : epsilon_cl , 'epsilon_mpl' : epsilon_mpl , 'epsilon_mc' : epsilon_mc , 'epsilon_c' : epsilon_c , 'e' : e , 'Re' : Re , 'i0_d_c_ref' : i0_d_c_ref , 'i0_h_c_ref' : i0_h_c_ref , 'kappa_co' : kappa_co , 'kappa_c' : kappa_c , 'a_slim' : a_slim , 'b_slim' : b_slim , 'a_switch' : a_switch , 'C_scl' : C_scl } computing_parameters = { 'nb_gc' : nb_gc , 'nb_gdl' : nb_gdl , 'nb_mpl' : nb_mpl , 't_purge' : t_purge , 'rtol' : rtol , 'atol' : atol , 'type_fuel_cell' : type_fuel_cell , 'type_current' : type_current , 'voltage_zone' : voltage_zone , 'type_auxiliary' : type_auxiliary , 'type_control' : type_control , 'type_purge' : type_purge , 'type_display' : type_display , 'type_plot' : type_plot } # Characteristic points of the experimental polarization curve i_exp , U_exp = pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) return ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , i_exp , U_exp )","title":"parameters_for_calibration"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.print_calibration_results","text":"This function prints the calibration results by associating each optimized value with its parameter name. Parameters: convergence ( dict ) \u2013 Dictionary containing the convergence information of the genetic algorithm. ga_instance ( PyGAD object ) \u2013 Instance of PyGAD used for optimization. solution ( list ) \u2013 List of optimized parameter values. varbound ( list ) \u2013 List of parameter bounds and names. sim_error ( float ) \u2013 Maximum simulation error in percentage. Source code in modules/calibration_modules.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def print_calibration_results ( convergence , ga_instance , solution , varbound , sim_error ): \"\"\" This function prints the calibration results by associating each optimized value with its parameter name. Parameters ---------- convergence : dict Dictionary containing the convergence information of the genetic algorithm. ga_instance : PyGAD object Instance of PyGAD used for optimization. solution : list List of optimized parameter values. varbound : list List of parameter bounds and names. sim_error : float Maximum simulation error in percentage. \"\"\" print ( \"Convergence: \\n \" , convergence ) for idx , val in enumerate ( solution ): param_name = varbound [ idx ][ 0 ] print ( f \"Optimized parameter { param_name } : { val } \" ) print ( Fore . RED + \" \\n Max simulation error: \" , sim_error , \"%\" ) print ( Style . RESET_ALL ) if ga_instance . best_solution_generation != - 1 : print ( f \"Best fitness value reached after { ga_instance . best_solution_generation } generations.\" )","title":"print_calibration_results"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.save_calibration_results","text":"This function saves the calibration results in a text file and a PyGAD file. The optimized values are retrieved from the solution list and associated with their names via varbound. Parameters: convergence ( dict ) \u2013 Convergence information from the genetic algorithm. ga_instance ( PyGAD object ) \u2013 Instance of PyGAD used for optimization. solution ( list ) \u2013 List of optimized parameter values. varbound ( list ) \u2013 List of parameter bounds and names. sim_error ( float ) \u2013 Maximum simulation error in percentage. type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: None \u2013 Source code in modules/calibration_modules.py 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def save_calibration_results ( convergence , ga_instance , solution , varbound , sim_error , type_fuel_cell ): \"\"\" This function saves the calibration results in a text file and a PyGAD file. The optimized values are retrieved from the solution list and associated with their names via varbound. Parameters ---------- convergence : dict Convergence information from the genetic algorithm. ga_instance : PyGAD object Instance of PyGAD used for optimization. solution : list List of optimized parameter values. varbound : list List of parameter bounds and names. sim_error : float Maximum simulation error in percentage. type_fuel_cell : str Type of fuel cell configuration. Returns ------- None \"\"\" root_folder , filename = \"results\" , \"parameter_calibration_1.txt\" subfolder_name = type_fuel_cell [: type_fuel_cell . find ( '_' )] if type_fuel_cell . find ( '_' ) != - 1 else type_fuel_cell counter = 1 folder_name = os . path . join ( root_folder , subfolder_name ) # Create the folder if necessary if not os . path . exists ( folder_name ): os . makedirs ( folder_name ) # Create the file without erasing the previous ones while os . path . isfile ( os . path . join ( folder_name , filename )): counter += 1 filename = \"parameter_calibration_\" + str ( counter ) + \".txt\" file_path = os . path . join ( folder_name , filename ) # Write information with open ( file_path , \"w\" ) as file : file . write ( \"Convergence: \" + str ( convergence )) for idx , val in enumerate ( solution ): param_name = varbound [ idx ][ 0 ] file . write ( f \" \\n Optimized parameter { param_name } : { val } \" ) file . write ( \" \\n Max simulation error: \" + str ( sim_error ) + \"%\" ) file . write ( \" \\n Algorithm works with \" + type_fuel_cell + \".\" ) if ga_instance . best_solution_generation != - 1 : file . write ( f \" \\n Best fitness value reached after { ga_instance . best_solution_generation } generations.\" ) ga_instance . save ( filename = os . path . join ( folder_name , \"parameter_calibration_\" + str ( counter ))) if os . path . isfile ( 'parameter_calibration_ongoing.pkl' ): os . remove ( 'parameter_calibration_ongoing.pkl' )","title":"save_calibration_results"},{"location":"functions/modules/calibration_modules/#modules.calibration_modules.update_undetermined_parameters","text":"Update the undetermined physical parameters dictionary with values from the solution. Parameters: solution ( list ) \u2013 List of parameter values obtained from the optimization algorithm. varbound ( list ) \u2013 List of parameter bounds and names. Each element contains the parameter name at index 0. undetermined_physical_parameters ( dict ) \u2013 Dictionary of undetermined physical parameters to be updated. Returns: dict \u2013 Updated dictionary of undetermined physical parameters. Source code in modules/calibration_modules.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 def update_undetermined_parameters ( type_fuel_cell , solution , varbound , undetermined_physical_parameters ): \"\"\" Update the undetermined physical parameters dictionary with values from the solution. Parameters ---------- solution : list List of parameter values obtained from the optimization algorithm. varbound : list List of parameter bounds and names. Each element contains the parameter name at index 0. undetermined_physical_parameters : dict Dictionary of undetermined physical parameters to be updated. Returns ------- dict Updated dictionary of undetermined physical parameters. \"\"\" for i in range ( len ( solution )): param_name = varbound [ i ][ 0 ] if param_name in undetermined_physical_parameters : undetermined_physical_parameters [ param_name ] = solution [ i ] if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : undetermined_physical_parameters [ 'Hccl' ] = undetermined_physical_parameters [ 'Hacl' ] return undetermined_physical_parameters","title":"update_undetermined_parameters"},{"location":"functions/modules/dif_eq_modules/","text":"Differential equations modules This module is used to determine intermediate values for the calculation of the differential equations and to implement integration events. calculate_dif_eq_int_values ( t , sv , control_variables , operating_inputs , parameters ) This functions calculates intermediate values for the calculation of the differential equations Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables ( dict ) \u2013 Variables controlled by the user. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Mext ( float ) \u2013 Molar mass of the ambient air outside the stack (kg/mol). M_H2_N2_in ( float ) \u2013 Molar mass of the inlet gas at the anode side (H2/N2 mixture) (kg/mol). i_n ( float ) \u2013 Internal current density (A/m\u00b2). Masm ( float ) \u2013 Molar mass of all the gas species in the anode supply manifold (kg/mol). Maem ( float ) \u2013 Molar mass of all the gas species in the anode external manifold (kg/mol). Mcsm ( float ) \u2013 Molar mass of all the gas species in the cathode supply manifold (kg/mol). Mcem ( float ) \u2013 Molar mass of all the gas species in the cathode external manifold (kg/mol). rho_Cp0 ( dict ) \u2013 Volumetric heat capacity of each component in the stack (J.m-3.K-1). Source code in modules/dif_eq_modules.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def calculate_dif_eq_int_values ( t , sv , control_variables , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the calculation of the differential equations Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables : dict Variables controlled by the user. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- Mext : float Molar mass of the ambient air outside the stack (kg/mol). M_H2_N2_in : float Molar mass of the inlet gas at the anode side (H2/N2 mixture) (kg/mol). i_n : float Internal current density (A/m\u00b2). Masm : float Molar mass of all the gas species in the anode supply manifold (kg/mol). Maem : float Molar mass of all the gas species in the anode external manifold (kg/mol). Mcsm : float Molar mass of all the gas species in the cathode supply manifold (kg/mol). Mcem : float Molar mass of all the gas species in the cathode external manifold (kg/mol). rho_Cp0 : dict Volumetric heat capacity of each component in the stack (J.m-3.K-1). \"\"\" # Extraction of the variables C_v_acl , C_v_ccl = sv [ 'C_v_acl' ], sv [ 'C_v_ccl' ] s_acl , s_ccl = sv [ 's_acl' ], sv [ 's_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] Pasm , Paem , Pcsm , Pcem = sv . get ( 'Pasm' , None ), sv . get ( 'Paem' , None ), sv . get ( 'Pcsm' , None ), sv . get ( 'Pcem' , None ) Phi_asm , Phi_aem = sv . get ( 'Phi_asm' , None ), sv . get ( 'Phi_aem' , None ) Phi_csm , Phi_cem = sv . get ( 'Phi_csm' , None ), sv . get ( 'Phi_cem' , None ) # Extraction of the operating inputs and the parameters T_des , y_H2_in = operating_inputs [ 'T_des' ], operating_inputs [ 'y_H2_in' ] Lgc , nb_channel_in_gc , Lm = parameters [ 'Lgc' ], parameters [ 'nb_channel_in_gc' ], parameters [ 'Lm' ] Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , kappa_co , epsilon_mc = parameters [ 'epsilon_mpl' ], parameters [ 'kappa_co' ], parameters [ 'epsilon_mc' ] nb_gc , nb_gdl , nb_mpl = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] t_purge , type_auxiliary , type_purge = parameters [ 't_purge' ], parameters [ 'type_auxiliary' ], parameters [ 'type_purge' ] # Calculation of intermediate values C_N2_a_mean = ( sum ( sv [ f 'C_N2_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) C_N2_c_mean = ( sum ( sv [ f 'C_N2_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) # Physical quantities outside the stack # Molar masses M = {} M [ 'ext' ] = Phi_ext * Psat ( Text ) / Pext * M_H2O + \\ y_O2_ext * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_O2 + \\ ( 1 - y_O2_ext ) * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_N2 M [ 'H2_N2_in' ] = y_H2_in * M_H2 + ( 1 - y_H2_in ) * M_N2 # Physical quantities inside the stack # Pressures P = {} for i in range ( 1 , nb_gc + 1 ): P [ f 'agc_ { i } ' ] = ( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) * R * sv [ f 'T_agc_ { i } ' ] P [ f 'cgc_ { i } ' ] = ( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) * R * sv [ f 'T_cgc_ { i } ' ] # Total concentration C_tot = {} for i in range ( 1 , nb_gc + 1 ): C_tot [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ] C_tot [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ] # Humidities Phi = {} for i in range ( 1 , nb_gc + 1 ): Phi [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] / C_v_sat ( sv [ f 'T_cgc_ { i } ' ]) # H2/O2 ratio in the dry anode/cathode gas mixture (H2/N2 or O2/N2) at the GC y_O2 = {} for i in range ( 1 , nb_gc + 1 ): y_O2 [ f 'cgc_ { i } ' ] = sv [ f 'C_O2_cgc_ { i } ' ] / ( sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) # Molar masses for i in range ( 1 , nb_gc + 1 ): M [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_H2O + \\ sv [ f 'C_H2_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_H2 + \\ sv [ f 'C_N2_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_N2 M [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] * R * T_des / P [ f 'cgc_ { i } ' ] * M_H2O + \\ sv [ f 'C_O2_cgc_ { i } ' ] * R * T_des / P [ f 'cgc_ { i } ' ] * M_O2 + \\ sv [ f 'C_N2_cgc_ { i } ' ] * R * T_des / P [ f 'cgc_ { i } ' ] * M_N2 # Density of the gas mixture. rho = {} for i in range ( 1 , nb_gc + 1 ): rho [ f 'agc_ { i } ' ] = P [ f 'agc_ { i } ' ] / ( R * sv [ f 'T_agc_ { i } ' ]) * M [ f 'agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 ): rho [ f 'cgc_ { i } ' ] = P [ f 'cgc_ { i } ' ] / ( R * sv [ f 'T_cgc_ { i } ' ]) * M [ f 'cgc_ { i } ' ] # Vapor ratio over the gas mixture. x_H2O_v = {} for i in range ( 1 , nb_gc + 1 ): x_H2O_v [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] / ( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 ): x_H2O_v [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] / ( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) # Dynamic viscosity of the gas mixture. mu_gaz = {} for i in range ( 1 , nb_gc + 1 ): mu_gaz [ f 'agc_ { i } ' ] = mu_mixture_gases ([ 'H2O_v' , 'H2' ], [ x_H2O_v [ f 'agc_ { i } ' ], 1 - x_H2O_v [ f 'agc_ { i } ' ]], sv [ f 'T_agc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 ): mu_gaz [ f 'cgc_ { i } ' ] = mu_mixture_gases ([ 'H2O_v' , 'O2' , 'N2' ], [ x_H2O_v [ f 'cgc_ { i } ' ], y_O2 [ f 'cgc_ { i } ' ] * ( 1 - x_H2O_v [ f 'cgc_ { i } ' ]), ( 1 - y_O2 [ f 'cgc_ { i } ' ]) * ( 1 - x_H2O_v [ f 'cgc_ { i } ' ])], sv [ f 'T_cgc_ { i } ' ]) # Volumetric heat capacity (J.m-3.K-1) rho_Cp0 = { ** { f 'agdl_ { i } ' : calculate_rho_Cp0 ( 'agdl' , sv [ f 'T_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], s = sv [ f 's_agdl_ { i } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl ) for i in range ( 1 , nb_gdl + 1 )}, ** { f 'ampl_ { i } ' : calculate_rho_Cp0 ( 'ampl' , sv [ f 'T_ampl_ { i } ' ], C_v = sv [ f 'C_v_ampl_ { i } ' ], s = sv [ f 's_ampl_ { i } ' ], C_H2 = sv [ f 'C_H2_ampl_ { i } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )}, 'acl' : calculate_rho_Cp0 ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_N2 = C_N2_a_mean , C_H2 = C_H2_acl , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), 'mem' : calculate_rho_Cp0 ( 'mem' , T_mem , lambdaa = lambda_mem ), 'ccl' : calculate_rho_Cp0 ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2_c_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), ** { f 'cmpl_ { i } ' : calculate_rho_Cp0 ( 'cmpl' , sv [ f 'T_cmpl_ { i } ' ], C_v = sv [ f 'C_v_cmpl_ { i } ' ], s = sv [ f 's_cmpl_ { i } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { i } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )}, ** { f 'cgdl_ { i } ' : calculate_rho_Cp0 ( 'cgdl' , sv [ f 'T_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], s = sv [ f 's_cgdl_ { i } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl ) for i in range ( 1 , nb_gdl + 1 )} } # The crossover current density i_n T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # Physical quantities inside the auxiliary system if parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_anodic_recirculation\" or \\ parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_flow-through_anode\" : pass # # Purge # if type_purge == \"no_purge\": # k_purge = 0 # elif type_purge == \"constant_purge\": # k_purge = 1 # elif type_purge == \"periodic_purge\": # purge_time, delta_purge = t_purge # if (t - int(t / (purge_time + delta_purge)) * (purge_time + delta_purge)) <= purge_time: # k_purge = 1 # else: # k_purge = 0 # else: # raise ValueError(\"The type_purge variable should be correctly referenced.\") # # # H2/O2 ratio in the dry anode/cathode gas mixture (H2/N2 or O2/N2) at the EM # y_H2_aem = (Paem - Phi_aem * Psat(T_des) - C_N2_a * R * T_des) / (Paem - Phi_aem * Psat(T_des)) # y_O2_cem = (Pcem - Phi_cem * Psat(T_cgc) - C_N2_c * R * T_cgc) / (Pcem - Phi_cem * Psat(T_cgc)) # # # Molar masses at the anode side # if parameters[\"type_auxiliary\"] == \"forced-convective_cathode_with_anodic_recirculation\": # M['asm'] = Phi_asm * Psat(T_des) / Pasm * M_H2O + \\ # (1 - Phi_asm * Psat(T_des) / Pasm) * M_H2 # M['aem'] = Phi_aem * Psat(T_des) / Paem * M_H2O + \\ # (1 - Phi_aem * Psat(T_des) / Paem) * M_H2 # else: #parameters[\"type_auxiliary\"] == \"forced-convective_cathode_with_flow-through_anode\": # M['asm'] = Phi_asm * Psat(T_des) / Pasm * M_H2O + \\ # y_H2_in * (1 - Phi_asm * Psat(T_des) / Pasm) * M_H2 + \\ # (1 - y_H2_in) * (1 - Phi_asm * Psat(T_des) / Pasm) * M_N2 # M['aem'] = Phi_aem * Psat(T_des) / Paem * M_H2O + \\ # y_H2_aem * (1 - Phi_aem * Psat(T_des) / Paem) * M_H2 + \\ # (1 - y_H2_aem) * (1 - Phi_aem * Psat(T_des) / Paem) * M_N2 # # Molar masses at the cathode side # M['csm'] = Phi_csm * Psat(T_des) / Pcsm * M_H2O + \\ # y_O2_ext * (1 - Phi_csm * Psat(T_des) / Pcsm) * M_O2 + \\ # (1 - y_O2_ext) * (1 - Phi_csm * Psat(T_des) / Pcsm) * M_N2 # M['cem'] = Phi_cem * Psat(T_des) / Pcem * M_H2O + \\ # y_O2_cem * (1 - Phi_cem * Psat(T_des) / Pcem) * M_O2 + \\ # (1 - y_O2_cem) * (1 - Phi_cem * Psat(T_des) / Pcem) * M_N2 # # # Density/concentration of the gas mixture. # C_tot_a_in = Pasm_in / (R * T_des) # rho_asm = Pasm / (R * T_des) * Masm # rho_agc = P[f'agc_{i}'] / (R * sv[f'T_agc_{i}']) * Magc # rho_aem = Paem / (R * T_des) * Maem # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # rho_asm_in_re = Pasm_in_re / (R * T_des) * Masm_in_re # rho_aem_out_re = Paem_out_re / (R * T_des) * Maem_out_re # else: # rho_asm_in_re, rho_aem_out_re = None, None # rho_a_ext = Pext / (R * T_des) * Maem_out # C_tot_a_ext = Pext / (R * T_des) # Boundary condition: at the exit, pressure and temperature are fixed. So, the total concentration is fixed. # C_tot_c_in = Pcsm_in / (R * T_des) # rho_csm = Pcsm / (R * T_des) * Mcsm # rho_cgc = P[f'cgc_{i}'] / (R * sv[f'T_cgc_{i}']) * Mcgc # rho_cem = Pcem / (R * T_cgc) * Mcem # rho_c_ext = Pext / (R * T_des) * Mcem_out # C_tot_c_ext = Pext * Mcem_out / (R * T_des) # Boundary condition: at the exit, pressure and temperature are fixed. So, the total concentration is fixed. # # # Vapor ratio over the gas mixture. # x_H2O_v_asm = Phi_asm * Psat(T_des) / Pasm # x_H2O_v_agc = C_v_agc / (C_v_agc + C_H2_agc + C_N2_a) # x_H2O_v_aem = Phi_aem * Psat(T_des) / Paem # x_H2O_v_a_ext = Phi_a_ext * Psat(T_des) / Pext # x_H2O_v_csm = Phi_csm * Psat(T_des) / Pcsm # x_H2O_v_cgc = C_v_cgc / (C_v_cgc + C_O2_cgc + C_N2_c) # x_H2O_v_cem = Phi_cem * Psat(T_des) / Pcem # x_H2O_v_c_ext = Phi_c_ext * Psat(T_des) / Pext # # # Molar fraction of H2 in the dry gas mixture (H2/N2) # y_H2_agc = C_H2_agc / (C_H2_agc + C_N2_a) # y_O2_cgc = C_O2_cgc / (C_O2_cgc + C_N2_c) # # # Dynamic viscosity of the gas mixture at the anode side. # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # mu_gaz_asm = mu_mixture_gases(['H2O_v', 'H2'], [x_H2O_v_asm, 1 - x_H2O_v_asm], T_des) # mu_gaz_agc = mu_mixture_gases(['H2O_v', 'H2'], [x_H2O_v_agc, 1 - x_H2O_v_agc], T_agc) # mu_gaz_aem = mu_mixture_gases(['H2O_v', 'H2'], [x_H2O_v_aem, 1 - x_H2O_v_aem], T_des) # mu_gaz_a_ext = mu_mixture_gases(['H2O_v', 'H2'], [x_H2O_v_a_ext, 1 - x_H2O_v_a_ext], T_des) # else: # type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" # mu_gaz_asm = mu_mixture_gases(['H2O_v', 'H2', 'N2'], # [x_H2O_v_asm, y_H2_in * (1 - x_H2O_v_asm), (1 - y_H2_in) * (1 - x_H2O_v_asm)], # T_des) # mu_gaz_agc = mu_mixture_gases(['H2O_v', 'H2', 'N2'], # [x_H2O_v_agc, y_H2_agc * (1 - x_H2O_v_agc), # (1 - y_H2_agc) * (1 - x_H2O_v_agc)], T_agc) # mu_gaz_aem = mu_mixture_gases(['H2O_v', 'H2', 'N2'], # [x_H2O_v_aem, y_H2_aem * (1 - x_H2O_v_aem), # (1 - y_H2_aem) * (1 - x_H2O_v_aem)], T_des) # mu_gaz_a_ext = mu_mixture_gases(['H2O_v', 'H2', 'N2'], # [x_H2O_v_a_ext, y_H2_aem_out * (1 - x_H2O_v_a_ext), (1 - y_H2_aem_out) * (1 - x_H2O_v_a_ext)], # T_des) # # Dynamic viscosity of the gas mixture at the cathode side. # mu_gaz_csm = mu_mixture_gases(['H2O_v', 'O2', 'N2'], # [x_H2O_v_csm, y_O2_ext * (1 - x_H2O_v_csm), (1 - y_O2_ext) * (1 - x_H2O_v_csm)], # T_des) # mu_gaz_cgc = mu_mixture_gases(['H2O_v', 'O2', 'N2'], # [x_H2O_v_cgc, y_O2_cgc * (1 - x_H2O_v_cgc), (1 - y_O2_cgc) * (1 - x_H2O_v_cgc)], # T_cgc) # mu_gaz_cem = mu_mixture_gases(['H2O_v', 'O2', 'N2'], # [x_H2O_v_cem, y_O2_cem * (1 - x_H2O_v_cem), (1 - y_O2_cem) * (1 - x_H2O_v_cem)], # T_des) # mu_gas_c_ext = mu_mixture_gases(['H2O_v', 'O2', 'N2'], # [x_H2O_v_c_ext, y_O2_cem_out * (1 - x_H2O_v_c_ext), # (1 - y_O2_cem_out) * (1 - x_H2O_v_c_ext)], # T_des) # # # Boundary velocities # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # v_re = Ware / rho_aem_out_re / A_T_a # else: # type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" # v_re = None else : # parameters[\"type_auxiliary\"] == \"no_auxiliary\" # Set to None the variables not used when \"no_auxiliary\" system is considered v_re , Lman_to_endplate , Lman_to_man_gc , k_purge = [ None ] * 4 return { 'rho_Cp0' : rho_Cp0 , 'v_re' : v_re , 'k_purge' : k_purge , 'rho' : rho , 'C_tot' : C_tot , 'mu_gaz' : mu_gaz , 'P' : P , 'i_n' : i_n } event_negative ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ) This function creates an event that will be checked at each step of solve_ivp integration. The integration stops if one of the crucial variables (C_v, lambda, C_O2, C_H2) becomes negative (or smaller than 1e-5). Parameters: t ( float ) \u2013 Time (s). y ( ndarray ) \u2013 Numpy list of the solver variables. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. solver_variable_names ( list ) \u2013 Names of the solver variables. control_variables ( dict ) \u2013 Variables controlled by the user. Returns: The difference between the minimum value of the crucial variables and 1e-5. \u2013 Source code in modules/dif_eq_modules.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def event_negative ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ): \"\"\"This function creates an event that will be checked at each step of solve_ivp integration. The integration stops if one of the crucial variables (C_v, lambda, C_O2, C_H2) becomes negative (or smaller than 1e-5). Parameters ---------- t : float Time (s). y : numpy.ndarray Numpy list of the solver variables. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. solver_variable_names : list Names of the solver variables. control_variables : dict Variables controlled by the user. Returns ------- The difference between the minimum value of the crucial variables and 1e-5. \"\"\" negative_solver_variables = {} # Dictionary to store the crucial variables for index , key in enumerate ( solver_variable_names ): if ( key . startswith ( \"C_v_\" )) or ( key . startswith ( \"lambda_\" )) or \\ ( key . startswith ( \"C_O2_\" )) or ( key . startswith ( \"C_H2_\" )): negative_solver_variables [ key ] = y [ index ] return min ( negative_solver_variables . values ()) - 1e-5 # 1e-5 is a control parameter to stop the program before","title":"Differential equations modules"},{"location":"functions/modules/dif_eq_modules/#differential-equations-modules","text":"This module is used to determine intermediate values for the calculation of the differential equations and to implement integration events.","title":"Differential equations modules"},{"location":"functions/modules/dif_eq_modules/#modules.dif_eq_modules.calculate_dif_eq_int_values","text":"This functions calculates intermediate values for the calculation of the differential equations Parameters: t ( float ) \u2013 Time (s). sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables ( dict ) \u2013 Variables controlled by the user. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Mext ( float ) \u2013 Molar mass of the ambient air outside the stack (kg/mol). M_H2_N2_in ( float ) \u2013 Molar mass of the inlet gas at the anode side (H2/N2 mixture) (kg/mol). i_n ( float ) \u2013 Internal current density (A/m\u00b2). Masm ( float ) \u2013 Molar mass of all the gas species in the anode supply manifold (kg/mol). Maem ( float ) \u2013 Molar mass of all the gas species in the anode external manifold (kg/mol). Mcsm ( float ) \u2013 Molar mass of all the gas species in the cathode supply manifold (kg/mol). Mcem ( float ) \u2013 Molar mass of all the gas species in the cathode external manifold (kg/mol). rho_Cp0 ( dict ) \u2013 Volumetric heat capacity of each component in the stack (J.m-3.K-1). Source code in modules/dif_eq_modules.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def calculate_dif_eq_int_values ( t , sv , control_variables , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the calculation of the differential equations Parameters ---------- t : float Time (s). sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. control_variables : dict Variables controlled by the user. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- Mext : float Molar mass of the ambient air outside the stack (kg/mol). M_H2_N2_in : float Molar mass of the inlet gas at the anode side (H2/N2 mixture) (kg/mol). i_n : float Internal current density (A/m\u00b2). Masm : float Molar mass of all the gas species in the anode supply manifold (kg/mol). Maem : float Molar mass of all the gas species in the anode external manifold (kg/mol). Mcsm : float Molar mass of all the gas species in the cathode supply manifold (kg/mol). Mcem : float Molar mass of all the gas species in the cathode external manifold (kg/mol). rho_Cp0 : dict Volumetric heat capacity of each component in the stack (J.m-3.K-1). \"\"\" # Extraction of the variables C_v_acl , C_v_ccl = sv [ 'C_v_acl' ], sv [ 'C_v_ccl' ] s_acl , s_ccl = sv [ 's_acl' ], sv [ 's_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] Pasm , Paem , Pcsm , Pcem = sv . get ( 'Pasm' , None ), sv . get ( 'Paem' , None ), sv . get ( 'Pcsm' , None ), sv . get ( 'Pcem' , None ) Phi_asm , Phi_aem = sv . get ( 'Phi_asm' , None ), sv . get ( 'Phi_aem' , None ) Phi_csm , Phi_cem = sv . get ( 'Phi_csm' , None ), sv . get ( 'Phi_cem' , None ) # Extraction of the operating inputs and the parameters T_des , y_H2_in = operating_inputs [ 'T_des' ], operating_inputs [ 'y_H2_in' ] Lgc , nb_channel_in_gc , Lm = parameters [ 'Lgc' ], parameters [ 'nb_channel_in_gc' ], parameters [ 'Lm' ] Hmem , Hacl , Hccl = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , kappa_co , epsilon_mc = parameters [ 'epsilon_mpl' ], parameters [ 'kappa_co' ], parameters [ 'epsilon_mc' ] nb_gc , nb_gdl , nb_mpl = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] t_purge , type_auxiliary , type_purge = parameters [ 't_purge' ], parameters [ 'type_auxiliary' ], parameters [ 'type_purge' ] # Calculation of intermediate values C_N2_a_mean = ( sum ( sv [ f 'C_N2_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) C_N2_c_mean = ( sum ( sv [ f 'C_N2_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) # Physical quantities outside the stack # Molar masses M = {} M [ 'ext' ] = Phi_ext * Psat ( Text ) / Pext * M_H2O + \\ y_O2_ext * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_O2 + \\ ( 1 - y_O2_ext ) * ( 1 - Phi_ext * Psat ( Text ) / Pext ) * M_N2 M [ 'H2_N2_in' ] = y_H2_in * M_H2 + ( 1 - y_H2_in ) * M_N2 # Physical quantities inside the stack # Pressures P = {} for i in range ( 1 , nb_gc + 1 ): P [ f 'agc_ { i } ' ] = ( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) * R * sv [ f 'T_agc_ { i } ' ] P [ f 'cgc_ { i } ' ] = ( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) * R * sv [ f 'T_cgc_ { i } ' ] # Total concentration C_tot = {} for i in range ( 1 , nb_gc + 1 ): C_tot [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ] C_tot [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ] # Humidities Phi = {} for i in range ( 1 , nb_gc + 1 ): Phi [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] / C_v_sat ( sv [ f 'T_cgc_ { i } ' ]) # H2/O2 ratio in the dry anode/cathode gas mixture (H2/N2 or O2/N2) at the GC y_O2 = {} for i in range ( 1 , nb_gc + 1 ): y_O2 [ f 'cgc_ { i } ' ] = sv [ f 'C_O2_cgc_ { i } ' ] / ( sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) # Molar masses for i in range ( 1 , nb_gc + 1 ): M [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_H2O + \\ sv [ f 'C_H2_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_H2 + \\ sv [ f 'C_N2_agc_ { i } ' ] * R * T_des / P [ f 'agc_ { i } ' ] * M_N2 M [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] * R * T_des / P [ f 'cgc_ { i } ' ] * M_H2O + \\ sv [ f 'C_O2_cgc_ { i } ' ] * R * T_des / P [ f 'cgc_ { i } ' ] * M_O2 + \\ sv [ f 'C_N2_cgc_ { i } ' ] * R * T_des / P [ f 'cgc_ { i } ' ] * M_N2 # Density of the gas mixture. rho = {} for i in range ( 1 , nb_gc + 1 ): rho [ f 'agc_ { i } ' ] = P [ f 'agc_ { i } ' ] / ( R * sv [ f 'T_agc_ { i } ' ]) * M [ f 'agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 ): rho [ f 'cgc_ { i } ' ] = P [ f 'cgc_ { i } ' ] / ( R * sv [ f 'T_cgc_ { i } ' ]) * M [ f 'cgc_ { i } ' ] # Vapor ratio over the gas mixture. x_H2O_v = {} for i in range ( 1 , nb_gc + 1 ): x_H2O_v [ f 'agc_ { i } ' ] = sv [ f 'C_v_agc_ { i } ' ] / ( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 ): x_H2O_v [ f 'cgc_ { i } ' ] = sv [ f 'C_v_cgc_ { i } ' ] / ( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) # Dynamic viscosity of the gas mixture. mu_gaz = {} for i in range ( 1 , nb_gc + 1 ): mu_gaz [ f 'agc_ { i } ' ] = mu_mixture_gases ([ 'H2O_v' , 'H2' ], [ x_H2O_v [ f 'agc_ { i } ' ], 1 - x_H2O_v [ f 'agc_ { i } ' ]], sv [ f 'T_agc_ { i } ' ]) for i in range ( 1 , nb_gc + 1 ): mu_gaz [ f 'cgc_ { i } ' ] = mu_mixture_gases ([ 'H2O_v' , 'O2' , 'N2' ], [ x_H2O_v [ f 'cgc_ { i } ' ], y_O2 [ f 'cgc_ { i } ' ] * ( 1 - x_H2O_v [ f 'cgc_ { i } ' ]), ( 1 - y_O2 [ f 'cgc_ { i } ' ]) * ( 1 - x_H2O_v [ f 'cgc_ { i } ' ])], sv [ f 'T_cgc_ { i } ' ]) # Volumetric heat capacity (J.m-3.K-1) rho_Cp0 = { ** { f 'agdl_ { i } ' : calculate_rho_Cp0 ( 'agdl' , sv [ f 'T_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], s = sv [ f 's_agdl_ { i } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl ) for i in range ( 1 , nb_gdl + 1 )}, ** { f 'ampl_ { i } ' : calculate_rho_Cp0 ( 'ampl' , sv [ f 'T_ampl_ { i } ' ], C_v = sv [ f 'C_v_ampl_ { i } ' ], s = sv [ f 's_ampl_ { i } ' ], C_H2 = sv [ f 'C_H2_ampl_ { i } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )}, 'acl' : calculate_rho_Cp0 ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_N2 = C_N2_a_mean , C_H2 = C_H2_acl , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), 'mem' : calculate_rho_Cp0 ( 'mem' , T_mem , lambdaa = lambda_mem ), 'ccl' : calculate_rho_Cp0 ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2_c_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), ** { f 'cmpl_ { i } ' : calculate_rho_Cp0 ( 'cmpl' , sv [ f 'T_cmpl_ { i } ' ], C_v = sv [ f 'C_v_cmpl_ { i } ' ], s = sv [ f 's_cmpl_ { i } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { i } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl ) for i in range ( 1 , nb_mpl + 1 )}, ** { f 'cgdl_ { i } ' : calculate_rho_Cp0 ( 'cgdl' , sv [ f 'T_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], s = sv [ f 's_cgdl_ { i } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl ) for i in range ( 1 , nb_gdl + 1 )} } # The crossover current density i_n T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl * k_H2 ( lambda_mem , T_mem , kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl * k_O2 ( lambda_mem , T_mem , kappa_co ) i_n = i_H2 + i_O2 # Physical quantities inside the auxiliary system if parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_anodic_recirculation\" or \\ parameters [ \"type_auxiliary\" ] == \"forced-convective_cathode_with_flow-through_anode\" : pass # # Purge # if type_purge == \"no_purge\": # k_purge = 0 # elif type_purge == \"constant_purge\": # k_purge = 1 # elif type_purge == \"periodic_purge\": # purge_time, delta_purge = t_purge # if (t - int(t / (purge_time + delta_purge)) * (purge_time + delta_purge)) <= purge_time: # k_purge = 1 # else: # k_purge = 0 # else: # raise ValueError(\"The type_purge variable should be correctly referenced.\") # # # H2/O2 ratio in the dry anode/cathode gas mixture (H2/N2 or O2/N2) at the EM # y_H2_aem = (Paem - Phi_aem * Psat(T_des) - C_N2_a * R * T_des) / (Paem - Phi_aem * Psat(T_des)) # y_O2_cem = (Pcem - Phi_cem * Psat(T_cgc) - C_N2_c * R * T_cgc) / (Pcem - Phi_cem * Psat(T_cgc)) # # # Molar masses at the anode side # if parameters[\"type_auxiliary\"] == \"forced-convective_cathode_with_anodic_recirculation\": # M['asm'] = Phi_asm * Psat(T_des) / Pasm * M_H2O + \\ # (1 - Phi_asm * Psat(T_des) / Pasm) * M_H2 # M['aem'] = Phi_aem * Psat(T_des) / Paem * M_H2O + \\ # (1 - Phi_aem * Psat(T_des) / Paem) * M_H2 # else: #parameters[\"type_auxiliary\"] == \"forced-convective_cathode_with_flow-through_anode\": # M['asm'] = Phi_asm * Psat(T_des) / Pasm * M_H2O + \\ # y_H2_in * (1 - Phi_asm * Psat(T_des) / Pasm) * M_H2 + \\ # (1 - y_H2_in) * (1 - Phi_asm * Psat(T_des) / Pasm) * M_N2 # M['aem'] = Phi_aem * Psat(T_des) / Paem * M_H2O + \\ # y_H2_aem * (1 - Phi_aem * Psat(T_des) / Paem) * M_H2 + \\ # (1 - y_H2_aem) * (1 - Phi_aem * Psat(T_des) / Paem) * M_N2 # # Molar masses at the cathode side # M['csm'] = Phi_csm * Psat(T_des) / Pcsm * M_H2O + \\ # y_O2_ext * (1 - Phi_csm * Psat(T_des) / Pcsm) * M_O2 + \\ # (1 - y_O2_ext) * (1 - Phi_csm * Psat(T_des) / Pcsm) * M_N2 # M['cem'] = Phi_cem * Psat(T_des) / Pcem * M_H2O + \\ # y_O2_cem * (1 - Phi_cem * Psat(T_des) / Pcem) * M_O2 + \\ # (1 - y_O2_cem) * (1 - Phi_cem * Psat(T_des) / Pcem) * M_N2 # # # Density/concentration of the gas mixture. # C_tot_a_in = Pasm_in / (R * T_des) # rho_asm = Pasm / (R * T_des) * Masm # rho_agc = P[f'agc_{i}'] / (R * sv[f'T_agc_{i}']) * Magc # rho_aem = Paem / (R * T_des) * Maem # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # rho_asm_in_re = Pasm_in_re / (R * T_des) * Masm_in_re # rho_aem_out_re = Paem_out_re / (R * T_des) * Maem_out_re # else: # rho_asm_in_re, rho_aem_out_re = None, None # rho_a_ext = Pext / (R * T_des) * Maem_out # C_tot_a_ext = Pext / (R * T_des) # Boundary condition: at the exit, pressure and temperature are fixed. So, the total concentration is fixed. # C_tot_c_in = Pcsm_in / (R * T_des) # rho_csm = Pcsm / (R * T_des) * Mcsm # rho_cgc = P[f'cgc_{i}'] / (R * sv[f'T_cgc_{i}']) * Mcgc # rho_cem = Pcem / (R * T_cgc) * Mcem # rho_c_ext = Pext / (R * T_des) * Mcem_out # C_tot_c_ext = Pext * Mcem_out / (R * T_des) # Boundary condition: at the exit, pressure and temperature are fixed. So, the total concentration is fixed. # # # Vapor ratio over the gas mixture. # x_H2O_v_asm = Phi_asm * Psat(T_des) / Pasm # x_H2O_v_agc = C_v_agc / (C_v_agc + C_H2_agc + C_N2_a) # x_H2O_v_aem = Phi_aem * Psat(T_des) / Paem # x_H2O_v_a_ext = Phi_a_ext * Psat(T_des) / Pext # x_H2O_v_csm = Phi_csm * Psat(T_des) / Pcsm # x_H2O_v_cgc = C_v_cgc / (C_v_cgc + C_O2_cgc + C_N2_c) # x_H2O_v_cem = Phi_cem * Psat(T_des) / Pcem # x_H2O_v_c_ext = Phi_c_ext * Psat(T_des) / Pext # # # Molar fraction of H2 in the dry gas mixture (H2/N2) # y_H2_agc = C_H2_agc / (C_H2_agc + C_N2_a) # y_O2_cgc = C_O2_cgc / (C_O2_cgc + C_N2_c) # # # Dynamic viscosity of the gas mixture at the anode side. # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # mu_gaz_asm = mu_mixture_gases(['H2O_v', 'H2'], [x_H2O_v_asm, 1 - x_H2O_v_asm], T_des) # mu_gaz_agc = mu_mixture_gases(['H2O_v', 'H2'], [x_H2O_v_agc, 1 - x_H2O_v_agc], T_agc) # mu_gaz_aem = mu_mixture_gases(['H2O_v', 'H2'], [x_H2O_v_aem, 1 - x_H2O_v_aem], T_des) # mu_gaz_a_ext = mu_mixture_gases(['H2O_v', 'H2'], [x_H2O_v_a_ext, 1 - x_H2O_v_a_ext], T_des) # else: # type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" # mu_gaz_asm = mu_mixture_gases(['H2O_v', 'H2', 'N2'], # [x_H2O_v_asm, y_H2_in * (1 - x_H2O_v_asm), (1 - y_H2_in) * (1 - x_H2O_v_asm)], # T_des) # mu_gaz_agc = mu_mixture_gases(['H2O_v', 'H2', 'N2'], # [x_H2O_v_agc, y_H2_agc * (1 - x_H2O_v_agc), # (1 - y_H2_agc) * (1 - x_H2O_v_agc)], T_agc) # mu_gaz_aem = mu_mixture_gases(['H2O_v', 'H2', 'N2'], # [x_H2O_v_aem, y_H2_aem * (1 - x_H2O_v_aem), # (1 - y_H2_aem) * (1 - x_H2O_v_aem)], T_des) # mu_gaz_a_ext = mu_mixture_gases(['H2O_v', 'H2', 'N2'], # [x_H2O_v_a_ext, y_H2_aem_out * (1 - x_H2O_v_a_ext), (1 - y_H2_aem_out) * (1 - x_H2O_v_a_ext)], # T_des) # # Dynamic viscosity of the gas mixture at the cathode side. # mu_gaz_csm = mu_mixture_gases(['H2O_v', 'O2', 'N2'], # [x_H2O_v_csm, y_O2_ext * (1 - x_H2O_v_csm), (1 - y_O2_ext) * (1 - x_H2O_v_csm)], # T_des) # mu_gaz_cgc = mu_mixture_gases(['H2O_v', 'O2', 'N2'], # [x_H2O_v_cgc, y_O2_cgc * (1 - x_H2O_v_cgc), (1 - y_O2_cgc) * (1 - x_H2O_v_cgc)], # T_cgc) # mu_gaz_cem = mu_mixture_gases(['H2O_v', 'O2', 'N2'], # [x_H2O_v_cem, y_O2_cem * (1 - x_H2O_v_cem), (1 - y_O2_cem) * (1 - x_H2O_v_cem)], # T_des) # mu_gas_c_ext = mu_mixture_gases(['H2O_v', 'O2', 'N2'], # [x_H2O_v_c_ext, y_O2_cem_out * (1 - x_H2O_v_c_ext), # (1 - y_O2_cem_out) * (1 - x_H2O_v_c_ext)], # T_des) # # # Boundary velocities # if type_auxiliary == \"forced-convective_cathode_with_anodic_recirculation\": # v_re = Ware / rho_aem_out_re / A_T_a # else: # type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" # v_re = None else : # parameters[\"type_auxiliary\"] == \"no_auxiliary\" # Set to None the variables not used when \"no_auxiliary\" system is considered v_re , Lman_to_endplate , Lman_to_man_gc , k_purge = [ None ] * 4 return { 'rho_Cp0' : rho_Cp0 , 'v_re' : v_re , 'k_purge' : k_purge , 'rho' : rho , 'C_tot' : C_tot , 'mu_gaz' : mu_gaz , 'P' : P , 'i_n' : i_n }","title":"calculate_dif_eq_int_values"},{"location":"functions/modules/dif_eq_modules/#modules.dif_eq_modules.event_negative","text":"This function creates an event that will be checked at each step of solve_ivp integration. The integration stops if one of the crucial variables (C_v, lambda, C_O2, C_H2) becomes negative (or smaller than 1e-5). Parameters: t ( float ) \u2013 Time (s). y ( ndarray ) \u2013 Numpy list of the solver variables. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. solver_variable_names ( list ) \u2013 Names of the solver variables. control_variables ( dict ) \u2013 Variables controlled by the user. Returns: The difference between the minimum value of the crucial variables and 1e-5. \u2013 Source code in modules/dif_eq_modules.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def event_negative ( t , y , operating_inputs , parameters , solver_variable_names , control_variables ): \"\"\"This function creates an event that will be checked at each step of solve_ivp integration. The integration stops if one of the crucial variables (C_v, lambda, C_O2, C_H2) becomes negative (or smaller than 1e-5). Parameters ---------- t : float Time (s). y : numpy.ndarray Numpy list of the solver variables. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. solver_variable_names : list Names of the solver variables. control_variables : dict Variables controlled by the user. Returns ------- The difference between the minimum value of the crucial variables and 1e-5. \"\"\" negative_solver_variables = {} # Dictionary to store the crucial variables for index , key in enumerate ( solver_variable_names ): if ( key . startswith ( \"C_v_\" )) or ( key . startswith ( \"lambda_\" )) or \\ ( key . startswith ( \"C_O2_\" )) or ( key . startswith ( \"C_H2_\" )): negative_solver_variables [ key ] = y [ index ] return min ( negative_solver_variables . values ()) - 1e-5 # 1e-5 is a control parameter to stop the program before","title":"event_negative"},{"location":"functions/modules/display_modules/","text":"Display modules This module is used to accurately plot the figures. calculate_simulation_error ( Ucell , U_exp_t ) This function calculates the simulation error between the simulated cell voltage and the experimental cell voltage. It is calculated as the maximum relative difference between the two voltages (in %). Parameters: Ucell ( ndarray ) \u2013 Simulated cell voltage. U_exp_t ( ndarray ) \u2013 Experimental cell voltage. Returns: float \u2013 Simulation error between the simulated cell voltage and the experimental cell voltage (in %). Source code in modules/display_modules.py 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 def calculate_simulation_error ( Ucell , U_exp_t ): \"\"\"This function calculates the simulation error between the simulated cell voltage and the experimental cell voltage. It is calculated as the maximum relative difference between the two voltages (in %). Parameters ---------- Ucell : numpy.ndarray Simulated cell voltage. U_exp_t : numpy.ndarray Experimental cell voltage. Returns ------- float Simulation error between the simulated cell voltage and the experimental cell voltage (in %). \"\"\" return np . round ( np . max ( np . abs ( Ucell - U_exp_t ) / U_exp_t * 100 ), 2 ) # in %. make_Fourier_transformation ( variables , operating_inputs , parameters ) This function calculates the Fourier transformation of both cell voltage and current density. It will be used to display the Nyquist and Bode diagrams. To generate it at each frequency change, the cell voltage and the current density are recorded. The time for which these points are captured is determined using the following approach: at the beginning of each frequency change, a delta_t_break_EIS time is observed to ensure the dynamic stability of the stack's variables. Subsequently, a delta_t_measurement_EIS time is needed to record the cell voltage and the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: dict \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. Source code in modules/display_modules.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def make_Fourier_transformation ( variables , operating_inputs , parameters ): \"\"\" This function calculates the Fourier transformation of both cell voltage and current density. It will be used to display the Nyquist and Bode diagrams. To generate it at each frequency change, the cell voltage and the current density are recorded. The time for which these points are captured is determined using the following approach: at the beginning of each frequency change, a delta_t_break_EIS time is observed to ensure the dynamic stability of the stack's variables. Subsequently, a delta_t_measurement_EIS time is needed to record the cell voltage and the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] t_EIS = parameters [ 't_EIS' ] # Creation of ifc ifc_t = np . zeros ( len ( t )) for i in range ( len ( t )): ifc_t [ i ] = current_density ( t [ i ], parameters ) # Identify the areas where Ucell and ifc can be measured for the EIS: after equilibrium and at each frequency change t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = t_EIS n_inf = np . where ( t_new_start_EIS <= t [ 0 ])[ 0 ][ - 1 ] # The number of frequency changes which has been mad so far. Ucell_EIS_measured = Ucell_t [ np . where (( t > ( t [ 0 ] + delta_t_break_EIS [ n_inf ])) & ( t < ( t [ 0 ] + delta_t_break_EIS [ n_inf ] + delta_t_measurement_EIS [ n_inf ])))] ifc_EIS_measured = ifc_t [ np . where (( t > ( t [ 0 ] + delta_t_break_EIS [ n_inf ])) & ( t < ( t [ 0 ] + delta_t_break_EIS [ n_inf ] + delta_t_measurement_EIS [ n_inf ])))] # Determination of the Fourier transformation N = Ucell_EIS_measured . size # Number of points used for the Fourier transformation Ucell_Fourier = fft ( Ucell_EIS_measured ) # Ucell Fourier transformation ifc_Fourier = fft ( ifc_EIS_measured ) # ifc Fourier transformation A_period_t = np . concatenate ( ([ np . abs ( Ucell_Fourier )[ 0 ] / N ], np . abs ( Ucell_Fourier [ 1 : N // 2 ]) * 2 / N )) # Recovery of # all amplitude values calculated by fft A = max ( A_period_t [ 1 :]) # Amplitude at the frequency of the perturbation freq_t = fftfreq ( N )[: N // 2 ] # Recovery of all frequency values used by fft f = freq_t [ np . argmax ( A_period_t == A )] # Recovery of the studied frequency return { 'Ucell_Fourier' : Ucell_Fourier , 'ifc_Fourier' : ifc_Fourier , 'A_period_t' : A_period_t , 'A' : A , 'freq_t' : freq_t , 'f' : f , 'N' : N } plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax ) This function adds the instructions for amplitude Bode plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 def plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax ): \"\"\"This function adds the instructions for amplitude Bode plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. ax . set_xscale ( 'log' ) # set logarithmic scale for the x-axis # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( LogLocator ( base = 10.0 , numticks = f_power_max_EIS - f_power_min_EIS + 1 )) ax . xaxis . set_minor_locator ( LogLocator ( base = 10.0 , subs = np . arange ( 2 , 10 ) * .1 , numticks = ( f_power_max_EIS - f_power_min_EIS + 1 ) * len ( np . arange ( 2 , 10 )))) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 30 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 30 / 5 )) ax . set_xlim ([ 10 ** f_power_min_EIS , 10 ** f_power_max_EIS ]) plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax ) This function adds the instructions for phase Bode plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 def plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax ): \"\"\"This function adds the instructions for phase Bode plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. ax . set_xscale ( 'log' ) # set logarithmic scale for the x-axis if not ax . yaxis_inverted (): ax . invert_yaxis () # Invert the y-axis # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( LogLocator ( base = 10.0 , numticks = f_power_max_EIS - f_power_min_EIS + 1 )) ax . xaxis . set_minor_locator ( LogLocator ( base = 10.0 , subs = np . arange ( 2 , 10 ) * .1 , numticks = ( f_power_max_EIS - f_power_min_EIS + 1 ) * len ( np . arange ( 2 , 10 )))) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 5 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 5 / 5 )) ax . set_xlim ([ 10 ** f_power_min_EIS , 10 ** f_power_max_EIS ]) plot_C_H2 ( variables , parameters , ax ) This function plots the hydrogen concentration at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the hydrogen concentration will be plotted. Source code in modules/display_modules.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 def plot_C_H2 ( variables , parameters , ax ): \"\"\"This function plots the hydrogen concentration at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the hydrogen concentration will be plotted. \"\"\" # Extraction of the parameters nb_gc , nb_gdl , nb_mpl , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_H2_agc_t = np . array ( variables [ f 'C_H2_agc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] C_H2_agdl_t = np . array ( variables [ f 'C_H2_agdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] C_H2_ampl_t = np . array ( variables [ f 'C_H2_ampl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] C_H2_acl_t = np . array ( variables [ 'C_H2_acl' ])[ mask ] # Plot the hydrogen concentration at different spatial localisations: C_H2 ax . plot ( t , C_H2_agc_t , color = colors ( 0 )) ax . plot ( t , C_H2_agdl_t , color = colors ( 1 )) ax . plot ( t , C_H2_ampl_t , color = colors ( 2 )) ax . plot ( t , C_H2_acl_t , color = colors ( 3 )) ax . legend ([ r '$\\mathregular{C_{H_ {2} ,agc}}$' , r '$\\mathregular{C_{H_ {2} ,agdl}}$' , r '$\\mathregular{C_{H_ {2} ,ampl}}$' , r '$\\mathregular{C_{H_ {2} ,acl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Hydrogen} $ $\\mathbf {concentration} $ $\\mathbf{C_{H_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_C_N2 ( variables , parameters , ax ) This function plots the nitrogen concentration as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the nitrogen concentration will be plotted. Source code in modules/display_modules.py 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 def plot_C_N2 ( variables , parameters , ax ): \"\"\"This function plots the nitrogen concentration as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the nitrogen concentration will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_N2_a_t = np . array ( variables [ 'C_N2_a' ])[ mask ] C_N2_c_t = np . array ( variables [ 'C_N2_c' ])[ mask ] # Plot C_N2 ax . plot ( t , C_N2_a_t , color = colors ( 6 )) ax . plot ( t , C_N2_c_t , color = colors ( 6 )) ax . legend ([ r '$\\mathregular{C_{N_ {2} ,a}}$' , r '$\\mathregular{C_{N_ {2} ,c}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Nitrogen} $ $\\mathbf {concentration} $ $\\mathbf{C_{N_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_C_O2 ( variables , parameters , ax ) This function plots the oxygen concentration at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the oxygen concentration will be plotted. Source code in modules/display_modules.py 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 def plot_C_O2 ( variables , parameters , ax ): \"\"\"This function plots the oxygen concentration at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the oxygen concentration will be plotted. \"\"\" # Extraction of the parameters nb_gc , nb_gdl , nb_mpl , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_O2_ccl_t = np . array ( variables [ 'C_O2_ccl' ])[ mask ] C_O2_cmpl_t = np . array ( variables [ f 'C_O2_cmpl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] C_O2_cgdl_t = np . array ( variables [ f 'C_O2_cgdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] C_O2_cgc_t = np . array ( variables [ f 'C_O2_cgc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] # Plot the oxygen concentration at different spatial localisations: C_O2 ax . plot ( t , C_O2_ccl_t , color = colors ( 5 )) ax . plot ( t , C_O2_cmpl_t , color = colors ( 6 )) ax . plot ( t , C_O2_cgdl_t , color = colors ( 7 )) ax . plot ( t , C_O2_cgc_t , color = colors ( 8 )) ax . legend ([ r '$\\mathregular{C_{O_ {2} ,ccl}}$' , r '$\\mathregular{C_{O_ {2} ,cmpl}}$' , r '$\\mathregular{C_{O_ {2} ,cgdl}}$' , r '$\\mathregular{C_{O_ {2} ,cgc}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Oxygen} $ $\\mathbf {concentration} $ $\\mathbf{C_{O_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_C_v ( variables , parameters , ax ) This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the vapor concentration will be plotted. Source code in modules/display_modules.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 def plot_C_v ( variables , parameters , ax ): \"\"\"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the vapor concentration will be plotted. \"\"\" # Extraction of the parameter nb_gc , nb_gdl , nb_mpl , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_agc_t = np . array ( variables [ f 'C_v_agc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] C_v_agdl_t = np . array ( variables [ f 'C_v_agdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] C_v_ampl_t = np . array ( variables [ f 'C_v_ampl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] C_v_acl_t = np . array ( variables [ 'C_v_acl' ])[ mask ] C_v_ccl_t = np . array ( variables [ 'C_v_ccl' ])[ mask ] C_v_cmpl_t = np . array ( variables [ f 'C_v_cmpl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] C_v_cgdl_t = np . array ( variables [ f 'C_v_cgdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] C_v_cgc_t = np . array ( variables [ f 'C_v_cgc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] T_ccl = np . array ( variables [ 'T_ccl' ])[ mask ] # Plot the vapor concentrations at different spatial localisations Cv C_v_sat_ccl_t = np . array ([ C_v_sat ( T ) for T in T_ccl ]) ax . plot ( t , C_v_agc_t , color = colors ( 0 )) ax . plot ( t , C_v_agdl_t , color = colors ( 1 )) ax . plot ( t , C_v_ampl_t , color = colors ( 2 )) ax . plot ( t , C_v_acl_t , color = colors ( 3 )) ax . plot ( t , C_v_ccl_t , color = colors ( 5 )) ax . plot ( t , C_v_cmpl_t , color = colors ( 6 )) ax . plot ( t , C_v_cgdl_t , color = colors ( 7 )) ax . plot ( t , C_v_cgc_t , color = colors ( 8 )) ax . plot ( t , C_v_sat_ccl_t , color = 'k' ) ax . legend ([ r '$\\mathregular{C_{v,agc}}$' , r '$\\mathregular{C_{v,agdl}}$' , r '$\\mathregular{C_{v,ampl}}$' , r '$\\mathregular{C_{v,acl}}$' , r '$\\mathregular{C_{v,ccl}}$' , r '$\\mathregular{C_{v,cmpl}}$' , r '$\\mathregular{C_{v,cgdl}}$' , r '$\\mathregular{C_{v,cgc}}$' , r '$\\mathregular{C_{v,sat,ccl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r \"$\\mathbf {Vapor} $ $\\mathbf {concentration} $ $\\mathbf{C_ {v} }$ $\\mathbf{\\left( mol.m^{-3} \\right)}$\" , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , x , y , ax ) This function adds the instructions for EIS plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. f_Fourier ( ndarray ) \u2013 Frequency at which the EIS is simulated. x ( ndarray ) \u2013 x-axis values for plotting the annotation. y ( ndarray ) \u2013 y-axis values for plotting the annotation. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 def plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , x , y , ax ): \"\"\"This function adds the instructions for EIS plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. f_Fourier : numpy.ndarray Frequency at which the EIS is simulated. x : numpy.ndarray x-axis values for plotting the annotation. y : numpy.ndarray y-axis values for plotting the annotation. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions ax . set_aspect ( 'equal' , adjustable = 'box' ) # Set orthonormal axis. # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : # Double charge transfer if ( f_Fourier >= 70 and f_Fourier <= 80 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , - 40 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) # Auxiliary system if ( f_Fourier >= 0.14 and f_Fourier <= 0.16 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 7 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 1.2 and f_Fourier <= 1.4 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 10 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) # Diffusion if ( f_Fourier >= 0.015 and f_Fourier <= 0.020 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 30 , 0 ), ha = 'center' , fontsize = 14 , rotation = 0 , weight = 'bold' ) if ( f_Fourier >= 0.9 and f_Fourier <= 1.1 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 10 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 70 and f_Fourier <= 90 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , - 40 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 10000 and f_Fourier <= 12000 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 35 , 0 ), ha = 'center' , fontsize = 14 , rotation = 0 , weight = 'bold' ) ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 20 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 20 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 10 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 10 / 5 )) ax . set_xlim ( 30 , 200 ) ax . set_ylim ( - 25 , 55 ) plot_EIS_curve_Bode_amplitude ( parameters , Fourier_results , ax ) This function is used to plot the amplitude Bode diagram of the EIS curves. Parameters: parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the amplitude Bode diagram will be plotted. Source code in modules/display_modules.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def plot_EIS_curve_Bode_amplitude ( parameters , Fourier_results , ax ): \"\"\"This function is used to plot the amplitude Bode diagram of the EIS curves. Parameters ---------- parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the amplitude Bode diagram will be plotted. \"\"\" # Extraction of the parameters i_EIS , ratio_EIS , f_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ], parameters [ 'f_EIS' ] type_fuel_cell = parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results A , f = Fourier_results [ 'A' ], Fourier_results [ 'f' ] # Calculation of the impedance of the perturbation Z0 = A / ( ratio_EIS * ( - i_EIS )) * 1e7 # in m\u03a9.cm\u00b2. The sign of i is inverted to comply with the standards of EIS, # which measure a device under load rather than a current source. # Plot the amplitude Bode diagram ax . plot ( f , np . abs ( Z0 ), 'o' , color = colors ( 1 ), label = 'Amplitude Bode diagram' ) ax . set_xlabel ( r '$\\mathbf {Frequency} $ $\\mathbf{(Hz,}$ $\\mathbf {logarithmic} $ $\\mathbf{scale)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Impedance} $ $\\mathbf {amplitude} $ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) # Plot instructions plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax ) plot_EIS_curve_Bode_angle ( parameters , Fourier_results , ax ) This function is used to plot the angle Bode diagram. It only works with an entry signal made with a cosinus (not a sinus). Parameters: Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the angle Bode diagram will be plotted. Source code in modules/display_modules.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def plot_EIS_curve_Bode_angle ( parameters , Fourier_results , ax ): \"\"\"This function is used to plot the angle Bode diagram. It only works with an entry signal made with a cosinus (not a sinus). Parameters ---------- Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the angle Bode diagram will be plotted. \"\"\" # Extraction of the parameters f_EIS , type_fuel_cell = parameters [ 'f_EIS' ], parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] A_period_t , A = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ] f , N = Fourier_results [ 'f' ], Fourier_results [ 'N' ] # Calculation of the dephasing values at the frequency of the perturbation theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) + np . pi # Recovery of all dephasing values calculated by fft. # An angle of pi is added to comply with the standards of EIS, # which measure a device under load rather than a current source. theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation phi_U_i = (( theta_U - theta_i ) * 180 / np . pi ) % 360 # Dephasing between Ucell and ifc with a value between 0 and 360 if phi_U_i > 180 : phi_U_i -= 360 # To have a value between -180 and 180 # Plot the angle Bode diagram ax . plot ( f , phi_U_i , 'o' , color = colors ( 2 ), label = 'Angle Bode diagram' ) ax . set_xlabel ( r '$\\mathbf {Frequency} $ $\\mathbf{(Hz,}$ $\\mathbf {logarithmic} $ $\\mathbf{scale)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Phase} $ $\\mathbf{(^\\circ)}$' , labelpad = 3 ) # Plot instructions plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax ) plot_EIS_curve_Nyquist ( parameters , Fourier_results , ax ) This function is used to plot the Nyquist diagram of the EIS curves. Parameters: parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the Nyquist diagram will be plotted. Source code in modules/display_modules.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def plot_EIS_curve_Nyquist ( parameters , Fourier_results , ax ): \"\"\" This function is used to plot the Nyquist diagram of the EIS curves. Parameters ---------- parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the Nyquist diagram will be plotted. \"\"\" # Extraction of the parameters i_EIS , ratio_EIS , type_fuel_cell = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ], parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] f_Fourier = Fourier_results [ 'f' ] A_period_t , A , N = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ], Fourier_results [ 'N' ] # Calculation of the real and imaginary component of the impedance for each period Z0 = A / ( ratio_EIS * ( - i_EIS )) * 1e7 # Impedance of the perturbation in m\u03a9.cm\u00b2. The sign of i is inverted to # comply with the standards of EIS, which measure a device under load rather than a current source. theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation Z_real = Z0 * np . cos ( theta_U - theta_i ) # Real component of the impedance for each period Z_imag = Z0 * np . sin ( theta_U - theta_i ) # Imaginary component of the impedance for each period # Plot the Nyquist diagram ax . plot ( Z_real , - Z_imag , 'o' , color = colors ( 0 ), label = 'Nyquist diagram' ) ax . set_xlabel ( r '$\\mathbf{Z_ {real} }$ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf{-Z_ {imag} }$ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) # Plot instructions plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , Z_real , - Z_imag , ax ) plot_EIS_curve_tests ( variables , operating_inputs , parameters , Fourier_results ) This function is used to test the accuracy of the EIS results. It compares the reconstructed Ucell_Fourier(t) from the Fourier transformation with the current density ifc(t), and displays Ucell(t) given by the model with the reconstructed Ucell_Fourier(t). Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. Source code in modules/display_modules.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def plot_EIS_curve_tests ( variables , operating_inputs , parameters , Fourier_results ): \"\"\"This function is used to test the accuracy of the EIS results. It compares the reconstructed Ucell_Fourier(t) from the Fourier transformation with the current density ifc(t), and displays Ucell(t) given by the model with the reconstructed Ucell_Fourier(t). Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), variables [ 'Ucell' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] i_EIS , ratio_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ] t_EIS , f_EIS = parameters [ 't_EIS' ], parameters [ 'f_EIS' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] A_period_t , A = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ] f , N = Fourier_results [ 'f' ], Fourier_results [ 'N' ] # Reconstructed Ucell with a cosinus form, and comparison of its form with the current density one. t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = t_EIS f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS n_inf = np . where ( t_new_start_EIS <= t [ 0 ])[ 0 ][ - 1 ] # The number of frequency changes which has been made. f_current = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation print ( \"Ucell:\" , round ( A_period_t [ 0 ], 4 ), ' + ' , round ( A , 6 ), \" * np.cos(2*np.pi*\" , round ( f , 4 ), \"*t + \" , round ( theta_U , 4 ), \"). \" ) print ( \"Current:\" , i_EIS , ' + ' , ratio_EIS * i_EIS , \" * np.cos(2*np.pi*\" , round ( f_current [ n_inf ], 4 ), \"*t + \" , round ( theta_i , 4 ), \"). \\n \" ) # Display ifc(t) plt . figure ( 3 ) plt . subplot ( 2 , 1 , 1 ) # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Conversion in A/cm\u00b2 ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Plot of ifc_t plt . plot ( t , ifc_t , color = 'blue' , label = 'ifc' ) plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Current density (A/cm\u00b2)' ) plt . title ( 'The current density \\n behaviour over time' ) # Display Ucell(t) and compare it with the reconstructed Ucell_Fourier(t) from the Fourier transformation plt . subplot ( 2 , 1 , 2 ) Ucell_Fourier = A_period_t [ 0 ] + A * np . cos ( 2 * np . pi * f * t + theta_U ) plt . plot ( t , Ucell_t , color = 'blue' , label = 'Ucell' ) plt . plot ( t , Ucell_Fourier , color = 'black' , label = 'Ucell_Fourier' ) plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Cell voltage (V)' ) plt . title ( 'The cell voltage \\n behaviour over time' ) plot_J ( variables , parameters , ax ) This function plots the sorption and dissolved water flows as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the flows will be plotted. Source code in modules/display_modules.py 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 def plot_J ( variables , parameters , ax ): \"\"\"This function plots the sorption and dissolved water flows as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the flows will be plotted. \"\"\" # Extraction of the operating inputs and the parameters Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] S_abs_acl_t = np . array ( variables [ 'S_abs_acl' ])[ mask ] S_abs_ccl_t = np . array ( variables [ 'S_abs_ccl' ])[ mask ] J_lambda_acl_mem_t = np . array ( variables [ 'J_lambda_acl_mem' ])[ mask ] J_lambda_mem_ccl_t = np . array ( variables [ 'J_lambda_mem_ccl' ])[ mask ] # Plot the sorption and dissolved water flows: J J_abs_acl , J_abs_ccl = S_abs_acl_t * Hacl , S_abs_ccl_t * Hccl # Conversion in mol.m\u207b\u00b2.s\u207b\u00b9 for comparison ax . plot ( t , J_abs_acl , color = colors ( 2 )) ax . plot ( t , J_lambda_acl_mem_t , color = colors ( 3 )) ax . plot ( t , J_abs_ccl , color = colors ( 4 )) ax . plot ( t , J_lambda_mem_ccl_t , color = colors ( 7 )) ax . legend ([ r '$\\mathregular{J_{abs,acl}}$' , r '$\\mathregular{J_{\\lambda,mem,acl}}$' , r '$\\mathregular{J_{abs,ccl}}$' , r '$\\mathregular{J_{\\lambda,mem,ccl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Flows} $ $\\mathbf {J} $ $\\mathbf{\\left( mol.m^{-2}.s^{-1} \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax ) plot_P ( variables , operating_inputs , parameters , ax ) This function plots the pressure at different spatial localisations as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the pressure will be plotted. Source code in modules/display_modules.py 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 def plot_P ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the pressure at different spatial localisations as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the pressure will be plotted. \"\"\" # Extraction of the parameters Pa_des , Pc_des = operating_inputs [ 'Pa_des' ], operating_inputs [ 'Pc_des' ] nb_gc , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ]) nb_gc_mid = int ( np . ceil ( nb_gc / 2 )) C_v_agc = np . array ( variables [ f 'C_v_agc_ { nb_gc_mid } ' ]) C_H2_agc = np . array ( variables [ f 'C_H2_agc_ { nb_gc_mid } ' ]) C_N2_agc = np . array ( variables [ f 'C_N2_agc_ { nb_gc_mid } ' ]) T_agc = np . array ( variables [ f 'T_agc_ { nb_gc_mid } ' ]) C_v_cgc = np . array ( variables [ f 'C_v_cgc_ { nb_gc_mid } ' ]) C_O2_cgc = np . array ( variables [ f 'C_O2_cgc_ { nb_gc_mid } ' ]) C_N2_cgc = np . array ( variables [ f 'C_N2_cgc_ { nb_gc_mid } ' ]) T_cgc = np . array ( variables [ f 'T_cgc_ { nb_gc_mid } ' ]) Pagc_t = ( C_v_agc + C_H2_agc + C_N2_agc ) * R * T_agc / 1e5 # Conversion in bar Pcgc_t = ( C_v_cgc + C_O2_cgc + C_N2_cgc ) * R * T_cgc / 1e5 # Conversion in bar if parameters [ 'type_auxiliary' ] != 'no_auxiliary' : Pasm_t = np . array ( variables [ 'Pasm' ])[ mask ] / 1e5 # Conversion in bar Paem_t = np . array ( variables [ 'Paem' ])[ mask ] / 1e5 # Conversion in bar Pcsm_t = np . array ( variables [ 'Pcsm' ])[ mask ] / 1e5 # Conversion in bar Pcem_t = np . array ( variables [ 'Pcem' ])[ mask ] / 1e5 # Conversion in bar else : # parameters['type_auxiliary'] == 'no_auxiliary' Pa_in_t = np . array ( variables [ 'Pa_in' ]) / 1e5 # Conversion in bar Pa_out_t = np . array ([ Pa_des ] * len ( t )) / 1e5 # Conversion in bar Pc_in_t = np . array ( variables [ 'Pc_in' ]) / 1e5 # Conversion in bar Pc_out_t = np . array ([ Pc_des ] * len ( t )) / 1e5 # Conversion in bar # Plot the pressure at different spatial localisations: P ax . plot ( t , Pagc_t , color = colors ( 0 )) ax . plot ( t , Pcgc_t , color = colors ( 6 )) if parameters [ 'type_auxiliary' ] != 'no_auxiliary' : ax . plot ( t , Pasm_t , color = colors ( 7 )) ax . plot ( t , Paem_t , color = colors ( 8 )) ax . plot ( t , Pcsm_t , color = colors ( 9 )) ax . plot ( t , Pcem_t , color = colors ( 10 )) else : # parameters['type_auxiliary'] == 'no_auxiliary' ax . plot ( t , Pa_in_t , color = colors ( 7 )) ax . plot ( t , Pa_out_t , color = colors ( 8 )) ax . plot ( t , Pc_in_t , color = colors ( 9 )) ax . plot ( t , Pc_out_t , color = colors ( 10 )) if parameters [ 'type_auxiliary' ] != 'no_auxiliary' : ax . legend ([ r '$\\mathregular{P_ {agc} }$' , r '$\\mathregular{P_ {cgc} }$' , r '$\\mathregular{P_ {asm} }$' , r '$\\mathregular{P_ {aem} }$' , r '$\\mathregular{P_ {csm} }$' , r '$\\mathregular{P_ {cem} }$' ], loc = 'best' ) else : # parameters['type_auxiliary'] == 'no_auxiliary' ax . legend ([ r '$\\mathregular{P_ {agc} }$' , r '$\\mathregular{P_ {cgc} }$' , r '$\\mathregular{P_{a,in}}$' , r '$\\mathregular{P_{a,out}}$' , r '$\\mathregular{P_{c,in}}$' , r '$\\mathregular{P_{c,out}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Pressure} $ $\\mathbf {P} $ $\\mathbf{\\left( bar \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax ) plot_Phi_a ( variables , operating_inputs , parameters , ax ) This function plots the humidity at the anode side, at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. ax ( Axes ) \u2013 Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 def plot_Phi_a ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the humidity at the anode side, at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and parameters Phi_a_des = operating_inputs [ 'Phi_a_des' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_agc_t = np . array ( variables [ 'C_v_agc' ])[ mask ] T_agc_t = np . array ( variables [ 'T_agc' ])[ mask ] Phi_asm_t = np . array ( variables [ 'Phi_asm' ])[ mask ] Phi_aem_t = np . array ( variables [ 'Phi_aem' ])[ mask ] # Calculate the humidity Phi Phi_agc_t = C_v_agc_t * R * T_agc_t / Psat ( T_agc_t ) # Plot the humidity at different spatial localisations: Phi ax . plot ( t , Phi_agc_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_ {agc} }$' ) ax . plot ( t , Phi_asm_t , color = colors ( 1 ), label = r '$\\mathregular{\\Phi_ {asm} }$' ) ax . plot ( t , Phi_aem_t , color = colors ( 2 ), label = r '$\\mathregular{\\Phi_ {aem} }$' ) ax . plot ( t , np . array ([ Phi_a_des ] * len ( t )), color = 'black' , label = r '$\\mathregular{\\Phi_{a,des}}$' ) ax . legend ( loc = 'center right' , bbox_to_anchor = ( 1 , 0.67 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Humidity} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf {anode} $ $\\mathbf {side} $ $\\mathbf{\\Phi}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_Phi_c ( variables , operating_inputs , parameters , ax ) This function plots the humidity, at the cathode side, at different spatial localisations as a function of time. Parameters: ax \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. ax ( Axes ) \u2013 Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 def plot_Phi_c ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the humidity, at the cathode side, at different spatial localisations as a function of time. Parameters ---------- ax.plot(t, np.array([Phi_a_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{a,des}}$') Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and parameters Phi_c_des = operating_inputs [ 'Phi_c_des' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_cgc_t = np . array ( variables [ 'C_v_cgc' ])[ mask ] T_cgc_t = np . array ( variables [ 'T_cgc' ])[ mask ] Phi_csm_t = np . array ( variables [ 'Phi_csm' ])[ mask ] Phi_cem_t = np . array ( variables [ 'Phi_cem' ])[ mask ] # Calculate the humidity Phi Phi_cgc_t = C_v_cgc_t * R * T_cgc_t / Psat ( T_cgc_t ) # Plot the humidity at different spatial localisations: Phi ax . plot ( t , Phi_cgc_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_ {cgc} }$' ) ax . plot ( t , Phi_csm_t , color = colors ( 1 ), label = r '$\\mathregular{\\Phi_ {csm} }$' ) ax . plot ( t , Phi_cem_t , color = colors ( 2 ), label = r '$\\mathregular{\\Phi_ {cem} }$' ) ax . plot ( t , np . array ([ Phi_c_des ] * len ( t )), color = 'black' , label = r '$\\mathregular{\\Phi_{c,des}}$' ) ax . legend ( loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Humidity} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf {cathode} $ $\\mathbf {side} $ $\\mathbf{\\Phi}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_Phi_des ( variables , operating_inputs , parameters , ax ) This function plots the controlled or uncontrolled desired humidity at the anode and cathode as a function of the current density. Parameters ax.plot(t, np.array([Phi_c_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{c,des}}$') variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def plot_Phi_des ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the controlled or uncontrolled desired humidity at the anode and cathode as a function of the current density. Parameters ax.plot(t, np.array([Phi_c_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{c,des}}$') variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] if parameters [ 'type_control' ] == \"Phi_des\" : Phi_a_des_t = variables [ 'Phi_a_des' ][ mask ] Phi_c_des_t = variables [ 'Phi_c_des' ][ mask ] ax . set_ylabel ( r '$\\mathbf {Controlled} $ $\\mathbf {inlet} $ $\\mathbf {humidity} $ $\\mathbf{\\Phi_ {des} }$' , labelpad = 3 ) else : Phi_a_des_t = np . array ([ operating_inputs [ 'Phi_a_des' ]] * len ( t )) Phi_c_des_t = np . array ([ operating_inputs [ 'Phi_c_des' ]] * len ( t )) ax . set_ylabel ( r '$\\mathbf {Uncontrolled} $ $\\mathbf {inlet} $ $\\mathbf {humidity} $ $\\mathbf{\\Phi_ {des} }$' , labelpad = 3 ) # Plot Phi_des n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of ifc_t ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) Phi_a_des_discretized_t , Phi_c_des_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load Phi_a_des_discretized_t [ i ] = Phi_a_des_t [ idx ] # the last value at the end of each load Phi_c_des_discretized_t [ i ] = Phi_c_des_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , Phi_c_des_discretized_t , color = colors ( 6 ), label = r '$\\mathregular{\\Phi_{c,des}}$' ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) if parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" or \\ parameters [ 'type_auxiliary' ] == \"no_auxiliary\" : ax . scatter ( ifc_discretized_t , Phi_a_des_discretized_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_{a,des}}$' ) ax . legend ([ r '$\\mathregular{\\Phi_{a,des}}$' , r '$\\mathregular{\\Phi_{c,des}}$' ], loc = 'best' ) else : ax . legend ([ r '$\\mathregular{\\Phi_{c,des}}$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_Re_nb ( variables , parameters , ax ) This function plots the Reynold number at the center of the AGC and the CGC as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the pressure will be plotted. Source code in modules/display_modules.py 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 def plot_Re_nb ( variables , parameters , ax ): \"\"\"This function plots the Reynold number at the center of the AGC and the CGC as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the pressure will be plotted. \"\"\" # Extraction of the parameters Hcgc , Wcgc = parameters [ 'Hcgc' ], parameters [ 'Wcgc' ] nb_gc , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ]) v_a_in_t = np . array ( variables [ 'v_a_in' ]) v_c_in_t = np . array ( variables [ 'v_c_in' ]) C_v_agc_t = np . array ( variables [ 'C_v_agc_1' ]) C_v_cgc_t = np . array ( variables [ 'C_v_cgc_1' ]) C_H2_agc_t = np . array ( variables [ 'C_H2_agc_1' ]) C_O2_cgc_t = np . array ( variables [ 'C_O2_cgc_1' ]) C_N2_agc_t = np . array ( variables [ 'C_N2_agc_1' ]) C_N2_cgc_t = np . array ( variables [ 'C_N2_cgc_1' ]) T_agc_t = np . array ( variables [ 'T_agc_1' ]) T_cgc_t = np . array ( variables [ 'T_cgc_1' ]) # Calculation of the Reynold Number d_pipe = np . sqrt ( 4 * Hcgc * Wcgc / np . pi ) P_agc = ( C_v_agc_t + C_H2_agc_t + C_N2_agc_t ) * R * T_agc_t P_cgc = ( C_v_cgc_t + C_O2_cgc_t + C_N2_cgc_t ) * R * T_cgc_t M_agc = C_v_agc_t * R * T_agc_t / P_agc * M_H2O + \\ C_H2_agc_t * R * T_agc_t / P_agc * M_H2 + \\ C_N2_agc_t * R * T_agc_t / P_agc * M_N2 M_cgc = C_v_cgc_t * R * T_cgc_t / P_cgc * M_H2O + \\ C_O2_cgc_t * R * T_cgc_t / P_cgc * M_O2 + \\ C_N2_cgc_t * R * T_cgc_t / P_cgc * M_N2 rho_agc = P_agc / ( R * T_agc_t ) * M_agc rho_cgc = P_cgc / ( R * T_cgc_t ) * M_cgc x_H2O_v_agc = C_v_agc_t / ( C_v_agc_t + C_H2_agc_t + C_N2_agc_t ) x_H2O_v_cgc = C_v_cgc_t / ( C_v_cgc_t + C_O2_cgc_t + C_N2_cgc_t ) y_H2_agc = C_H2_agc_t / ( C_H2_agc_t + C_N2_agc_t ) y_O2_cgc = C_O2_cgc_t / ( C_O2_cgc_t + C_N2_cgc_t ) mu_agc = mu_mixture_gases ([ 'H2O_v' , 'H2' , 'N2' ], [ x_H2O_v_agc , y_H2_agc * ( 1 - x_H2O_v_agc ), ( 1 - y_H2_agc ) * ( 1 - x_H2O_v_agc )], T_agc_t ) mu_cgc = mu_mixture_gases ([ 'H2O_v' , 'O2' , 'N2' ], [ x_H2O_v_cgc , y_O2_cgc * ( 1 - x_H2O_v_cgc ), ( 1 - y_O2_cgc ) * ( 1 - x_H2O_v_cgc )], T_cgc_t ) Re_nb_a_t = ( rho_agc * v_a_in_t * d_pipe ) / mu_agc # Reynolds number at the anode side Re_nb_c_t = ( rho_cgc * v_c_in_t * d_pipe ) / mu_cgc # Reynolds number at the anode side # Plot the pressure at different spatial localisations: P ax . plot ( t , Re_nb_a_t , color = colors ( 0 )) ax . plot ( t , Re_nb_c_t , color = colors ( 6 )) ax . legend ([ r '$\\mathregular{Re_ {a} }$' , r '$\\mathregular{Re_ {c} }$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Reynold} $ $\\mathbf {number} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf{inlet,}$ $\\mathbf {Re} $' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax ) plot_T ( variables , operating_inputs , parameters , ax ) This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the vapor concentration will be plotted. Source code in modules/display_modules.py 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 def plot_T ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the vapor concentration will be plotted. \"\"\" # Extraction of the operating inputs and parameters current_density = operating_inputs [ 'current_density' ] T_des = operating_inputs [ 'T_des' ] nb_gc , nb_gdl , nb_mpl = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables and the operating inputs if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] T_agc_t = np . array ( variables [ f 'T_agc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_agdl_t = np . array ( variables [ f 'T_agdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_ampl_t = np . array ( variables [ f 'T_ampl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_acl_t = np . array ( variables [ 'T_acl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_mem_t = np . array ( variables [ 'T_mem' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_ccl_t = np . array ( variables [ 'T_ccl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cmpl_t = np . array ( variables [ f 'T_cmpl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cgdl_t = np . array ( variables [ f 'T_cgdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cgc_t = np . array ( variables [ f 'T_cgc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. # Plot the temperature at different spatial localisations if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) T_agc_discretized_t , T_agdl_discretized_t , T_ampl_discretized_t , T_acl_discretized_t = [ np . zeros ( nb_loads )] * 4 T_mem_discretized_t , T_ccl_discretized_t , T_cmpl_discretized_t , T_cgdl_discretized_t = [ np . zeros ( nb_loads )] * 4 T_cgc_discretized_t = np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load T_agc_discretized_t [ i ] = T_agc_t [ idx ] # the last value at the end of each load T_agdl_discretized_t [ i ] = T_agdl_t [ idx ] # the last value at the end of each load T_ampl_discretized_t [ i ] = T_ampl_t [ idx ] # the last value at the end of each load T_acl_discretized_t [ i ] = T_acl_t [ idx ] # the last value at the end of each load T_mem_discretized_t [ i ] = T_mem_t [ idx ] # the last value at the end of each load T_ccl_discretized_t [ i ] = T_ccl_t [ idx ] # the last value at the end of each load T_cmpl_discretized_t [ i ] = T_cmpl_t [ idx ] # the last value at the end of each load T_cgdl_discretized_t [ i ] = T_cgdl_t [ idx ] # the last value at the end of each load T_cgc_discretized_t [ i ] = T_cgc_t [ idx ] # the last value at the end of each load T_des_discretized_t = np . array ([ T_des - 273.15 ] * len ( ifc_discretized_t )) ax . scatter ( ifc_discretized_t , T_agc_discretized_t , marker = 'o' , color = colors ( 0 )) ax . scatter ( ifc_discretized_t , T_agdl_discretized_t , marker = 'o' , color = colors ( 1 )) ax . scatter ( ifc_discretized_t , T_ampl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , T_acl_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , T_mem_discretized_t , marker = 'o' , color = colors ( 4 )) ax . scatter ( ifc_discretized_t , T_ccl_discretized_t , marker = 'o' , color = colors ( 5 )) ax . scatter ( ifc_discretized_t , T_cmpl_discretized_t , marker = 'o' , color = colors ( 6 )) ax . scatter ( ifc_discretized_t , T_cgdl_discretized_t , marker = 'o' , color = colors ( 7 )) ax . scatter ( ifc_discretized_t , T_cgc_discretized_t , marker = 'o' , color = colors ( 8 )) ax . scatter ( ifc_discretized_t , T_des_discretized_t , marker = 'o' , color = 'k' ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : T_des_t = np . array ([ T_des - 273.15 ] * len ( t )) ax . plot ( t , T_agc_t , color = colors ( 0 )) ax . plot ( t , T_agdl_t , color = colors ( 1 )) ax . plot ( t , T_ampl_t , color = colors ( 2 )) ax . plot ( t , T_acl_t , color = colors ( 3 )) ax . plot ( t , T_mem_t , color = colors ( 4 )) ax . plot ( t , T_ccl_t , color = colors ( 5 )) ax . plot ( t , T_cmpl_t , color = colors ( 6 )) ax . plot ( t , T_cgdl_t , color = colors ( 7 )) ax . plot ( t , T_cgc_t , color = colors ( 8 )) ax . plot ( t , T_des_t , color = 'k' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{T_ {agc} }$' , r '$\\mathregular{T_ {agdl} }$' , r '$\\mathregular{T_ {ampl} }$' , r '$\\mathregular{T_ {acl} }$' , r '$\\mathregular{T_ {mem} }$' , r '$\\mathregular{T_ {ccl} }$' , r '$\\mathregular{T_ {cmpl} }$' , r '$\\mathregular{T_ {cgdl} }$' , r '$\\mathregular{T_ {cgc} }$' , r '$\\mathregular{T_ {des} }$' ], loc = 'best' ) ax . set_ylabel ( r \"$\\mathbf {Temperature} $ $\\mathbf {T} $ $\\mathbf{\\left( \u00b0C \\right)}$\" , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax ) plot_Ucell ( variables , parameters , ax ) This function plots the cell voltage as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the cell voltage will be plotted. Source code in modules/display_modules.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def plot_Ucell ( variables , parameters , ax ): \"\"\"This function plots the cell voltage as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the cell voltage will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] Ucell_t = np . array ( variables [ 'Ucell' ])[ mask ] # Plot the cell voltage: Ucell ax . plot ( t , Ucell_t , color = colors ( 0 ), label = r '$\\mathregular{U_ {cell} }$' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{U_ {cell} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_cell_efficiency ( variables , operating_inputs , parameters , n , ax ) This function plots the fuel cell efficiency eta_fc as a function of the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the fuel cell efficiency. ax ( Axes ) \u2013 Axes on which the fuel cell efficiency will be plotted. Source code in modules/display_modules.py 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 def plot_cell_efficiency ( variables , operating_inputs , parameters , n , ax ): \"\"\"This function plots the fuel cell efficiency eta_fc as a function of the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the fuel cell efficiency. ax : matplotlib.axes.Axes Axes on which the fuel cell efficiency will be plotted. \"\"\" # Extraction of the variables t , Ucell_t , lambda_mem_t = variables [ 't' ], variables [ 'Ucell' ], variables [ 'lambda_mem' ] C_H2_acl_t , C_O2_ccl_t = variables [ 'C_H2_acl' ], variables [ 'C_O2_ccl' ] T_acl_t , T_mem_t , T_ccl_t = variables [ 'T_acl' ], variables [ 'T_mem' ], variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] Hmem , Hacl , Hccl , kappa_co = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'kappa_co' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] # Creation of the fuel cell efficiency: eta_fc ifc_t , Pfc_t , eta_fc_t = np . zeros ( n ), np . zeros ( n ), np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 Pfc_t [ i ] = Ucell_t [ i ] * ifc_t [ i ] Ueq = E0 - 8.5e-4 * ( T_ccl_t [ i ] - 298.15 ) + \\ R * T_ccl_t [ i ] / ( 2 * F ) * ( np . log ( R * T_acl_t [ i ] * C_H2_acl_t [ i ] / Pref ) + 0.5 * np . log ( R * T_ccl_t [ i ] * C_O2_ccl_t [ i ] / Pref )) T_acl_mem_ccl = average ([ T_acl_t [ i ], T_mem_t [ i ], T_ccl_t [ i ]], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl_t [ i ] * k_H2 ( lambda_mem_t [ i ], T_mem_t [ i ], kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl_t [ i ] * k_O2 ( lambda_mem_t [ i ], T_mem_t [ i ], kappa_co ) i_n = ( i_H2 + i_O2 ) / 1e4 # Conversion in A/cm\u00b2 eta_fc_t [ i ] = Pfc_t [ i ] / ( Ueq * ( ifc_t [ i ] + i_n )) # Plot of the fuel cell efficiency: eta_fc plot_specific_line ( ifc_t , eta_fc_t , type_fuel_cell , type_current , type_auxiliary , type_control , None , ax ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 0 ) ax . set_ylabel ( r '$\\mathbf {Fuel} $ $\\mathbf {cell} $ $\\mathbf {efficiency} $ $\\mathbf{\\eta_ {fc} }$' , labelpad = 0 ) ax . legend ( loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_general_instructions ( ax , set_y = True ) This function adds the common instructions for all the plots displayed by AlphaPEM to the ax object. Parameters: ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 def plot_general_instructions ( ax , set_y = True ): \"\"\"This function adds the common instructions for all the plots displayed by AlphaPEM to the ax object. Parameters ---------- ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Get the current x-axis and y-axis limits x_min , x_max = ax . get_xlim () y_min , y_max = ax . get_ylim () # Calculate the major step for the x-axis and y-axis ticks major_step_x = ( x_max - x_min ) / 5 major_step_y = ( y_max - y_min ) / 5 major_step_x_rounded = round_nice ( major_step_x ) major_step_y_rounded = round_nice ( major_step_y ) # Set the major and minor locators for the x-axis and y-axis ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( major_step_x_rounded )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( major_step_x_rounded / 5 )) if set_y : ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( major_step_y_rounded )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( major_step_y_rounded / 5 )) # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure plot_ifc ( variables , operating_inputs , parameters , ax ) This function plots the current density as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the current density will be plotted. Source code in modules/display_modules.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 def plot_ifc ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the current density as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the current density will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] # Plot the current density: ifc n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of ifc_t ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 ax . plot ( t , ifc_t , color = colors ( 0 ), label = r '$\\mathregular{i_ {fc} }$' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{i_ {fc} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_lambda ( variables , operating_inputs , parameters , ax ) This function plots the water content at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the water content will be plotted. Source code in modules/display_modules.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def plot_lambda ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the water content at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the water content will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters , type_current = parameters [ 'pola_current_parameters' ], parameters [ 'type_current' ] type_plot = parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] lambda_acl_t = np . array ( variables [ 'lambda_acl' ])[ mask ] lambda_mem_t = np . array ( variables [ 'lambda_mem' ])[ mask ] lambda_ccl_t = np . array ( variables [ 'lambda_ccl' ])[ mask ] # Plot the water content at different spatial localisations: lambda if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads which are made ifc_discretized_t , lambda_acl_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) lambda_mem_discretized_t , lambda_ccl_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load lambda_acl_discretized_t [ i ] = lambda_acl_t [ idx ] # the last value at the end of each load lambda_mem_discretized_t [ i ] = lambda_mem_t [ idx ] # the last value at the end of each load lambda_ccl_discretized_t [ i ] = lambda_ccl_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , lambda_acl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , lambda_mem_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , lambda_ccl_discretized_t , marker = 'o' , color = colors ( 4 )) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : ax . plot ( t , lambda_acl_t , color = colors ( 3 )) ax . plot ( t , lambda_mem_t , color = colors ( 4 )) ax . plot ( t , lambda_ccl_t , color = colors ( 5 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Water} $ $\\mathbf {content} $ $\\mathbf{\\lambda}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{\\lambda_ {acl} }$' , r '$\\mathregular{\\lambda_ {mem} }$' , r '$\\mathregular{\\lambda_ {ccl} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_pola_instructions ( type_fuel_cell , ax , show = True ) This function adds the specific instructions for polarisation plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. show ( bool , default: True ) \u2013 If True, the figure will be displayed. Default is True. Source code in modules/display_modules.py 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 def plot_pola_instructions ( type_fuel_cell , ax , show = True ): \"\"\"This function adds the specific instructions for polarisation plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. show : bool, optional If True, the figure will be displayed. Default is True. \"\"\" # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.5 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.5 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.1 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.1 / 5 )) ax . set_xlim ( 0 , 3.0 ) ax . set_ylim ( 0.4 , 1.04 ) # For other fuel cell else : pass # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure if show : plt . show () # Show the figure plot_polarisation_curve ( variables , operating_inputs , parameters , ax , show = True ) This function plots the model polarisation curve, and compare it to the experimental one (if it exists). The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the polarisation curve will be plotted. show ( bool , default: True ) \u2013 If True, the polarisation curve will be displayed. If False, it will not be displayed. Source code in modules/display_modules.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def plot_polarisation_curve ( variables , operating_inputs , parameters , ax , show = True ): \"\"\" This function plots the model polarisation curve, and compare it to the experimental one (if it exists). The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the polarisation curve will be plotted. show : bool, optional If True, the polarisation curve will be displayed. If False, it will not be displayed. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] delta_i_pola , i_max_pola = pola_current_parameters [ 'delta_i_pola' ], pola_current_parameters [ 'i_max_pola' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] voltage_zone , type_auxiliary = parameters [ 'voltage_zone' ], parameters [ 'type_auxiliary' ] type_control , type_plot = parameters [ 'type_control' ], parameters [ 'type_plot' ] # Extraction of the experimental current density and voltage values. i_exp_t , U_exp_t = pola_exp_values ( type_fuel_cell , voltage_zone ) # (A.m-2, V). if type_plot == \"fixed\" : # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of ifc and Ucell from the model after each stack stabilisation nb_loads = int ( i_max_pola / delta_i_pola ) # Number of loads which are made ifc_discretized = np . zeros ( nb_loads + 1 ) # One point is taken at ifc = 0, before the first load. Ucell_discretized = np . zeros ( nb_loads + 1 ) # One point is taken at ifc = 0, before the first load. for i in range ( nb_loads + 1 ): t_load = delta_t_ini_pola + i * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized [ i ] = ifc_t [ idx ] # the last value at the end of each load Ucell_discretized [ i ] = Ucell_t [ idx ] # the last value at the end of each load # Plot the experimental polarization curve and calculate the simulation error compared with experimental data if type_fuel_cell != \"manual_setup\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): # Experimental points are accessible # Plot of the experimental polarization curve i_exp_t = i_exp_t / 1e4 # Conversion in A/cm\u00b2 plot_experimental_polarisation_curve ( type_fuel_cell , i_exp_t , U_exp_t , ax ) # Calculate the simulation error compared with experimental data # Experimental points are interpolated to correspond to the model points Ucell_interpolated = interp1d ( ifc_discretized , Ucell_discretized , kind = 'linear' )( i_exp_t ) sim_error = calculate_simulation_error ( Ucell_interpolated , U_exp_t ) else : sim_error = None # Plot the model polarisation curve plot_specific_line ( ifc_discretized , Ucell_discretized , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) plot_pola_instructions ( type_fuel_cell , ax , show ) else : # type_plot == \"dynamic\" # Plot of the polarisation curve produced by the model idx = ( np . abs ( t - t [ - 1 ])) . argmin () # index for polarisation measurement ifc = np . array ( current_density ( t [ idx ], parameters ) / 1e4 ) # time for polarisation measurement Ucell = np . array ( Ucell_t [ idx ]) # voltage measurement ax . plot ( ifc , Ucell , 'og' , markersize = 2 ) # Add the common instructions for the plot ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) if type_plot == \"fixed\" : ax . legend ( loc = 'best' ) plot_polarisation_curve_for_cali ( variables , operating_inputs , parameters , ax ) This function plots the model polarisation curve, and compare it to the experimental one. The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the polarisation curve will be plotted. Source code in modules/display_modules.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def plot_polarisation_curve_for_cali ( variables , operating_inputs , parameters , ax ): \"\"\" This function plots the model polarisation curve, and compare it to the experimental one. The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the polarisation curve will be plotted. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_for_cali_parameters = parameters [ 'pola_current_for_cali_parameters' ] delta_t_ini_pola_cali = pola_current_for_cali_parameters [ 'delta_t_ini_pola_cali' ] delta_t_load_pola_cali = pola_current_for_cali_parameters [ 'delta_t_load_pola_cali' ] delta_t_break_pola_cali = pola_current_for_cali_parameters [ 'delta_t_break_pola_cali' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] voltage_zone , type_auxiliary = parameters [ 'voltage_zone' ], parameters [ 'type_auxiliary' ] type_control , type_plot = parameters [ 'type_control' ], parameters [ 'type_plot' ] # Extraction of the experimental current density and voltage values for the calibration. i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) # (A.m-2, V). # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of ifc and Ucell from the model after each stack stabilisation nb_loads = len ( i_exp_cali_t ) # Number of loads which are made delta_t_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. ifc_discretized = np . zeros ( nb_loads ) Ucell_discretized = np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola_cali + ( i + 1 ) * delta_t_cali # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized [ i ] = ifc_t [ idx ] # the last value at the end of each load Ucell_discretized [ i ] = Ucell_t [ idx ] # the last value at the end of each load # Plot the experimental polarization curve i_exp_cali_t = i_exp_cali_t / 1e4 # Conversion in A/cm\u00b2 plot_experimental_polarisation_curve ( type_fuel_cell , i_exp_cali_t , U_exp_cali_t , ax ) # Plot the model polarisation curve sim_error = calculate_simulation_error ( Ucell_discretized , U_exp_cali_t ) # Calculate the simulation error plot_specific_line ( ifc_discretized , Ucell_discretized , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) plot_pola_instructions ( type_fuel_cell , ax ) # Add the common instructions for the plot ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) if type_plot == \"fixed\" : ax . legend ( loc = 'best' ) plot_power_density_curve ( variables , operating_inputs , parameters , n , ax ) This function plots the power density curve Pfc, produced by a cell, as a function of the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the power density curve. ax ( Axes ) \u2013 Axes on which the power density curve will be plotted. Source code in modules/display_modules.py 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 def plot_power_density_curve ( variables , operating_inputs , parameters , n , ax ): \"\"\"This function plots the power density curve Pfc, produced by a cell, as a function of the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the power density curve. ax : matplotlib.axes.Axes Axes on which the power density curve will be plotted. \"\"\" # Extraction of the variables t , Ucell_t = variables [ 't' ], variables [ 'Ucell' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] # Creation of the power density function: Pfc ifc_t , Pfc_t = np . zeros ( n ), np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 Pfc_t [ i ] = Ucell_t [ i ] * ifc_t [ i ] # Plot of the power density function: Pfc plot_specific_line ( ifc_t , Pfc_t , type_fuel_cell , type_current , type_auxiliary , type_control , None , ax ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 0 ) ax . set_ylabel ( r '$\\mathbf {Fuel} $ $\\mathbf {cell} $ $\\mathbf {power} $ $\\mathbf {density} $ $\\mathbf{P_ {fc} }$ $\\mathbf{\\left( W.cm^{-2} \\right)}$' , labelpad = 0 ) ax . legend ( loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_s ( variables , operating_inputs , parameters , ax ) This function plots the liquid water saturation at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the liquid water saturation will be plotted. Source code in modules/display_modules.py 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 def plot_s ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the liquid water saturation at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the liquid water saturation will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] nb_gdl , nb_mpl , pola_current_parameters = parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ], parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] s_agdl_t = np . array ( variables [ f 's_agdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] s_ampl_t = np . array ( variables [ f 's_ampl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] s_acl_t = np . array ( variables [ 's_acl' ])[ mask ] s_ccl_t = np . array ( variables [ 's_ccl' ])[ mask ] s_cmpl_t = np . array ( variables [ f 's_cmpl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] s_cgdl_t = np . array ( variables [ f 's_cgdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] # Plot the liquid water saturation at different spatial localisations: s if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) s_agdl_discretized_t , s_ampl_discretized_t , s_acl_discretized_t = [ np . zeros ( nb_loads )] * 3 s_ccl_discretized_t , s_cmpl_discretized_t , s_cgdl_discretized_t = [ np . zeros ( nb_loads )] * 3 for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load s_agdl_discretized_t [ i ] = s_agdl_t [ idx ] # the last value at the end of each load s_ampl_discretized_t [ i ] = s_ampl_t [ idx ] # the last value at the end of each load s_acl_discretized_t [ i ] = s_acl_t [ idx ] # the last value at the end of each load s_ccl_discretized_t [ i ] = s_ccl_t [ idx ] # the last value at the end of each load s_cmpl_discretized_t [ i ] = s_cmpl_t [ idx ] # the last value at the end of each load s_cgdl_discretized_t [ i ] = s_cgdl_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , s_agdl_discretized_t , marker = 'o' , color = colors ( 1 )) ax . scatter ( ifc_discretized_t , s_ampl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , s_acl_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , s_ccl_discretized_t , marker = 'o' , color = colors ( 5 )) ax . scatter ( ifc_discretized_t , s_cmpl_discretized_t , marker = 'o' , color = colors ( 6 )) ax . scatter ( ifc_discretized_t , s_cgdl_discretized_t , marker = 'o' , color = colors ( 7 )) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : ax . plot ( t , s_agdl_t , color = colors ( 1 )) ax . plot ( t , s_ampl_t , color = colors ( 2 )) ax . plot ( t , s_acl_t , color = colors ( 3 )) ax . plot ( t , s_ccl_t , color = colors ( 5 )) ax . plot ( t , s_cmpl_t , color = colors ( 6 )) ax . plot ( t , s_cgdl_t , color = colors ( 7 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Liquid} $ $\\mathbf {water} $ $\\mathbf {saturation} $ $\\mathbf {s} $' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{s_ {agdl} }$' , r '$\\mathregular{s_ {ampl} }$' , r '$\\mathregular{s_ {acl} }$' , r '$\\mathregular{s_ {ccl} }$' , r '$\\mathregular{s_ {cmpl} }$' , r '$\\mathregular{s_ {cgdl} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax ) plot_specific_line ( x , y , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) This function adds the appropriate plot configuration according to the type_input to the ax object. Parameters: x ( ndarray ) \u2013 x-axis values. y ( ndarray ) \u2013 y-axis values. type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. type_current ( str ) \u2013 Type of current density. type_auxiliary ( str ) \u2013 Type of auxiliary system. type_control ( str ) \u2013 Type of control system. sim_error ( float ) \u2013 Simulation error between the simulated cell voltage and the experimental cell voltage (in %). ax ( Axes ) \u2013 Axes on which the line will be plotted. Source code in modules/display_modules.py 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 def plot_specific_line ( x , y , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ): \"\"\" This function adds the appropriate plot configuration according to the type_input to the ax object. Parameters ---------- x : numpy.ndarray x-axis values. y : numpy.ndarray y-axis values. type_fuel_cell : str Type of fuel cell configuration. type_current : str Type of current density. type_auxiliary : str Type of auxiliary system. type_control : str Type of control system. sim_error : float Simulation error between the simulated cell voltage and the experimental cell voltage (in %). ax : matplotlib.axes.Axes Axes on which the line will be plotted. \"\"\" # For EH-31 fuel cell if type_current == \"polarization\" : # ZSW fuel cell if type_fuel_cell == \"ZSW-GenStack\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 0 ), label = 'Sim. - nominal operating conditions' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - nominal operating conditions' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 1 ), label = 'Sim. - P$_a$ = 1.61 bar - P$_c$ = 1.41 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 1 ), label = 'Sim. - P$_a$ = 1.61 bar - P$_c$ = 1.41 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 2 ), label = 'Sim. - P$_a$ = 2.01 bar - P$_c$ = 1.81 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 2 ), label = 'Sim. - P$_a$ = 2.01 bar - P$_c$ = 1.81 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 3 ), label = 'Sim. - P$_a$ = 2.4 bar - P$_c$ = 2.2 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 3 ), label = 'Sim. - P$_a$ = 2.4 bar - P$_c$ = 2.2 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 4 ), label = 'Sim. - P$_a$ = 2.8 bar - P$_c$ = 2.6 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 4 ), label = 'Sim. - P$_a$ = 2.8 bar - P$_c$ = 2.6 bar' ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 5 ), label = 'Sim. - T = 62 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 5 ), label = 'Sim. - T = 62 \u00b0C' ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 6 ), label = 'Sim. - T = 76 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 6 ), label = 'Sim. - T = 76 \u00b0C' ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 7 ), label = 'Sim. - T = 84 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 7 ), label = 'Sim. - T = 84 \u00b0C' ) # EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_1.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' ) elif type_fuel_cell == \"EH-31_2.0\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 1 ), label = 'Sim. - P = 2.0 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : if type_control == \"Phi_des\" : ax . plot ( x , y , color = colors ( 5 ), label = r 'Sim. - P = 2.0 bar - controlled $\\mathregular{\\Phi_ {des} }$' ) else : ax . plot ( x , y , color = colors ( 1 ), label = r 'Sim. - P = 2.0 bar - uncontrolled $\\mathregular{\\Phi_ {des} }$' ) elif type_fuel_cell == \"EH-31_2.25\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' ) elif type_fuel_cell == \"EH-31_2.5\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' ) # For other fuel cell else : ax . plot ( x , y , color = colors ( 0 ), label = 'Simulation' ) elif type_current == \"polarization_for_cali\" : # ZSW fuel cell if type_fuel_cell == \"ZSW-GenStack\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - nominal operating conditions' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - nominal operating conditions' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = 'Sim. - P$_a$ = 1.61 bar - P$_c$ = 1.41 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = 'Sim. - P$_a$ = 1.61 bar - P$_c$ = 1.41 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P$_a$ = 2.01 bar - P$_c$ = 1.81 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P$_a$ = 2.01 bar - P$_c$ = 1.81 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim. - P$_a$ = 2.4 bar - P$_c$ = 2.2 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim. - P$_a$ = 2.4 bar - P$_c$ = 2.2 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 4 ), label = 'Sim. - P$_a$ = 2.8 bar - P$_c$ = 2.6 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 4 ), label = 'Sim. - P$_a$ = 2.8 bar - P$_c$ = 2.6 bar' ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 5 ), label = 'Sim. - T = 62 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 5 ), label = 'Sim. - T = 62 \u00b0C' ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 6 ), label = 'Sim. - T = 76 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 6 ), label = 'Sim. - T = 76 \u00b0C' ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 7 ), label = 'Sim. - T = 84 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 7 ), label = 'Sim. - T = 84 \u00b0C' ) # EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_1.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' ) elif type_fuel_cell == \"EH-31_2.0\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = 'Sim. - P = 2.0 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : if type_control == \"Phi_des\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 5 ), label = r 'Sim. - P = 2.0 bar - controlled $\\mathregular{\\Phi_ {des} }$' ) else : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = r 'Sim. - P = 2.0 bar - uncontrolled $\\mathregular{\\Phi_ {des} }$' ) elif type_fuel_cell == \"EH-31_2.25\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' ) elif type_fuel_cell == \"EH-31_2.5\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' ) # For other fuel cell else : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Simulation' ) else : raise ValueError ( 'Only \"polarization_current\" and \"polarization_current_for_cali\" are considered here.' ) plot_v ( variables , parameters , ax ) This function plots the velocity at the anode and the cathode as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the pressure will be plotted. Source code in modules/display_modules.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 def plot_v ( variables , parameters , ax ): \"\"\"This function plots the velocity at the anode and the cathode as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters: dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the pressure will be plotted. \"\"\" # Extraction of the parameters nb_gc , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ]) v_a_in_t = np . array ( variables [ 'v_a_in' ]) v_c_in_t = np . array ( variables [ 'v_c_in' ]) # Plot the pressure at different spatial localisations: P ax . plot ( t , v_a_in_t , color = colors ( 0 )) ax . plot ( t , v_c_in_t , color = colors ( 6 )) ax . legend ([ r '$\\mathregular{v_{a,in}}$' , r '$\\mathregular{v_{c,in}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf{Inlet velocities}$ $\\mathbf {v} $ $\\mathbf{\\left( m.s^{-1} \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax ) round_nice ( x ) Round the main step to a \"nice\" number. Parameters: x ( float ) \u2013 The value to be rounded. Returns: float \u2013 The value rounded to a \"nice\" number. Source code in modules/display_modules.py 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 def round_nice ( x ): \"\"\"Round the main step to a \"nice\" number. Parameters ---------- x : float The value to be rounded. Returns ------- float The value rounded to a \"nice\" number. \"\"\" exp = np . floor ( np . log10 ( x )) f = x / 10 ** exp if f < 1.5 : nice = 1 elif f < 3 : nice = 2 elif f < 7 : nice = 5 else : nice = 10 return nice * 10 ** exp","title":"Display modules"},{"location":"functions/modules/display_modules/#display-modules","text":"This module is used to accurately plot the figures.","title":"Display modules"},{"location":"functions/modules/display_modules/#modules.display_modules.calculate_simulation_error","text":"This function calculates the simulation error between the simulated cell voltage and the experimental cell voltage. It is calculated as the maximum relative difference between the two voltages (in %). Parameters: Ucell ( ndarray ) \u2013 Simulated cell voltage. U_exp_t ( ndarray ) \u2013 Experimental cell voltage. Returns: float \u2013 Simulation error between the simulated cell voltage and the experimental cell voltage (in %). Source code in modules/display_modules.py 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 def calculate_simulation_error ( Ucell , U_exp_t ): \"\"\"This function calculates the simulation error between the simulated cell voltage and the experimental cell voltage. It is calculated as the maximum relative difference between the two voltages (in %). Parameters ---------- Ucell : numpy.ndarray Simulated cell voltage. U_exp_t : numpy.ndarray Experimental cell voltage. Returns ------- float Simulation error between the simulated cell voltage and the experimental cell voltage (in %). \"\"\" return np . round ( np . max ( np . abs ( Ucell - U_exp_t ) / U_exp_t * 100 ), 2 ) # in %.","title":"calculate_simulation_error"},{"location":"functions/modules/display_modules/#modules.display_modules.make_Fourier_transformation","text":"This function calculates the Fourier transformation of both cell voltage and current density. It will be used to display the Nyquist and Bode diagrams. To generate it at each frequency change, the cell voltage and the current density are recorded. The time for which these points are captured is determined using the following approach: at the beginning of each frequency change, a delta_t_break_EIS time is observed to ensure the dynamic stability of the stack's variables. Subsequently, a delta_t_measurement_EIS time is needed to record the cell voltage and the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: dict \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. Source code in modules/display_modules.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def make_Fourier_transformation ( variables , operating_inputs , parameters ): \"\"\" This function calculates the Fourier transformation of both cell voltage and current density. It will be used to display the Nyquist and Bode diagrams. To generate it at each frequency change, the cell voltage and the current density are recorded. The time for which these points are captured is determined using the following approach: at the beginning of each frequency change, a delta_t_break_EIS time is observed to ensure the dynamic stability of the stack's variables. Subsequently, a delta_t_measurement_EIS time is needed to record the cell voltage and the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Returns ------- dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] t_EIS = parameters [ 't_EIS' ] # Creation of ifc ifc_t = np . zeros ( len ( t )) for i in range ( len ( t )): ifc_t [ i ] = current_density ( t [ i ], parameters ) # Identify the areas where Ucell and ifc can be measured for the EIS: after equilibrium and at each frequency change t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = t_EIS n_inf = np . where ( t_new_start_EIS <= t [ 0 ])[ 0 ][ - 1 ] # The number of frequency changes which has been mad so far. Ucell_EIS_measured = Ucell_t [ np . where (( t > ( t [ 0 ] + delta_t_break_EIS [ n_inf ])) & ( t < ( t [ 0 ] + delta_t_break_EIS [ n_inf ] + delta_t_measurement_EIS [ n_inf ])))] ifc_EIS_measured = ifc_t [ np . where (( t > ( t [ 0 ] + delta_t_break_EIS [ n_inf ])) & ( t < ( t [ 0 ] + delta_t_break_EIS [ n_inf ] + delta_t_measurement_EIS [ n_inf ])))] # Determination of the Fourier transformation N = Ucell_EIS_measured . size # Number of points used for the Fourier transformation Ucell_Fourier = fft ( Ucell_EIS_measured ) # Ucell Fourier transformation ifc_Fourier = fft ( ifc_EIS_measured ) # ifc Fourier transformation A_period_t = np . concatenate ( ([ np . abs ( Ucell_Fourier )[ 0 ] / N ], np . abs ( Ucell_Fourier [ 1 : N // 2 ]) * 2 / N )) # Recovery of # all amplitude values calculated by fft A = max ( A_period_t [ 1 :]) # Amplitude at the frequency of the perturbation freq_t = fftfreq ( N )[: N // 2 ] # Recovery of all frequency values used by fft f = freq_t [ np . argmax ( A_period_t == A )] # Recovery of the studied frequency return { 'Ucell_Fourier' : Ucell_Fourier , 'ifc_Fourier' : ifc_Fourier , 'A_period_t' : A_period_t , 'A' : A , 'freq_t' : freq_t , 'f' : f , 'N' : N }","title":"make_Fourier_transformation"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Bode_amplitude_instructions","text":"This function adds the instructions for amplitude Bode plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 def plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax ): \"\"\"This function adds the instructions for amplitude Bode plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. ax . set_xscale ( 'log' ) # set logarithmic scale for the x-axis # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( LogLocator ( base = 10.0 , numticks = f_power_max_EIS - f_power_min_EIS + 1 )) ax . xaxis . set_minor_locator ( LogLocator ( base = 10.0 , subs = np . arange ( 2 , 10 ) * .1 , numticks = ( f_power_max_EIS - f_power_min_EIS + 1 ) * len ( np . arange ( 2 , 10 )))) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 30 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 30 / 5 )) ax . set_xlim ([ 10 ** f_power_min_EIS , 10 ** f_power_max_EIS ])","title":"plot_Bode_amplitude_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Bode_phase_instructions","text":"This function adds the instructions for phase Bode plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 def plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax ): \"\"\"This function adds the instructions for phase Bode plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. ax . set_xscale ( 'log' ) # set logarithmic scale for the x-axis if not ax . yaxis_inverted (): ax . invert_yaxis () # Invert the y-axis # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( LogLocator ( base = 10.0 , numticks = f_power_max_EIS - f_power_min_EIS + 1 )) ax . xaxis . set_minor_locator ( LogLocator ( base = 10.0 , subs = np . arange ( 2 , 10 ) * .1 , numticks = ( f_power_max_EIS - f_power_min_EIS + 1 ) * len ( np . arange ( 2 , 10 )))) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 5 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 5 / 5 )) ax . set_xlim ([ 10 ** f_power_min_EIS , 10 ** f_power_max_EIS ])","title":"plot_Bode_phase_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_C_H2","text":"This function plots the hydrogen concentration at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the hydrogen concentration will be plotted. Source code in modules/display_modules.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 def plot_C_H2 ( variables , parameters , ax ): \"\"\"This function plots the hydrogen concentration at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the hydrogen concentration will be plotted. \"\"\" # Extraction of the parameters nb_gc , nb_gdl , nb_mpl , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_H2_agc_t = np . array ( variables [ f 'C_H2_agc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] C_H2_agdl_t = np . array ( variables [ f 'C_H2_agdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] C_H2_ampl_t = np . array ( variables [ f 'C_H2_ampl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] C_H2_acl_t = np . array ( variables [ 'C_H2_acl' ])[ mask ] # Plot the hydrogen concentration at different spatial localisations: C_H2 ax . plot ( t , C_H2_agc_t , color = colors ( 0 )) ax . plot ( t , C_H2_agdl_t , color = colors ( 1 )) ax . plot ( t , C_H2_ampl_t , color = colors ( 2 )) ax . plot ( t , C_H2_acl_t , color = colors ( 3 )) ax . legend ([ r '$\\mathregular{C_{H_ {2} ,agc}}$' , r '$\\mathregular{C_{H_ {2} ,agdl}}$' , r '$\\mathregular{C_{H_ {2} ,ampl}}$' , r '$\\mathregular{C_{H_ {2} ,acl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Hydrogen} $ $\\mathbf {concentration} $ $\\mathbf{C_{H_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_C_H2"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_C_N2","text":"This function plots the nitrogen concentration as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the nitrogen concentration will be plotted. Source code in modules/display_modules.py 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 def plot_C_N2 ( variables , parameters , ax ): \"\"\"This function plots the nitrogen concentration as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the nitrogen concentration will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_N2_a_t = np . array ( variables [ 'C_N2_a' ])[ mask ] C_N2_c_t = np . array ( variables [ 'C_N2_c' ])[ mask ] # Plot C_N2 ax . plot ( t , C_N2_a_t , color = colors ( 6 )) ax . plot ( t , C_N2_c_t , color = colors ( 6 )) ax . legend ([ r '$\\mathregular{C_{N_ {2} ,a}}$' , r '$\\mathregular{C_{N_ {2} ,c}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Nitrogen} $ $\\mathbf {concentration} $ $\\mathbf{C_{N_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_C_N2"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_C_O2","text":"This function plots the oxygen concentration at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the oxygen concentration will be plotted. Source code in modules/display_modules.py 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 def plot_C_O2 ( variables , parameters , ax ): \"\"\"This function plots the oxygen concentration at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the oxygen concentration will be plotted. \"\"\" # Extraction of the parameters nb_gc , nb_gdl , nb_mpl , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_O2_ccl_t = np . array ( variables [ 'C_O2_ccl' ])[ mask ] C_O2_cmpl_t = np . array ( variables [ f 'C_O2_cmpl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] C_O2_cgdl_t = np . array ( variables [ f 'C_O2_cgdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] C_O2_cgc_t = np . array ( variables [ f 'C_O2_cgc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] # Plot the oxygen concentration at different spatial localisations: C_O2 ax . plot ( t , C_O2_ccl_t , color = colors ( 5 )) ax . plot ( t , C_O2_cmpl_t , color = colors ( 6 )) ax . plot ( t , C_O2_cgdl_t , color = colors ( 7 )) ax . plot ( t , C_O2_cgc_t , color = colors ( 8 )) ax . legend ([ r '$\\mathregular{C_{O_ {2} ,ccl}}$' , r '$\\mathregular{C_{O_ {2} ,cmpl}}$' , r '$\\mathregular{C_{O_ {2} ,cgdl}}$' , r '$\\mathregular{C_{O_ {2} ,cgc}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Oxygen} $ $\\mathbf {concentration} $ $\\mathbf{C_{O_ {2} }}$ $\\mathbf{\\left( mol.m^{-3} \\right)}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_C_O2"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_C_v","text":"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the vapor concentration will be plotted. Source code in modules/display_modules.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 def plot_C_v ( variables , parameters , ax ): \"\"\"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the vapor concentration will be plotted. \"\"\" # Extraction of the parameter nb_gc , nb_gdl , nb_mpl , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_agc_t = np . array ( variables [ f 'C_v_agc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] C_v_agdl_t = np . array ( variables [ f 'C_v_agdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] C_v_ampl_t = np . array ( variables [ f 'C_v_ampl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] C_v_acl_t = np . array ( variables [ 'C_v_acl' ])[ mask ] C_v_ccl_t = np . array ( variables [ 'C_v_ccl' ])[ mask ] C_v_cmpl_t = np . array ( variables [ f 'C_v_cmpl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] C_v_cgdl_t = np . array ( variables [ f 'C_v_cgdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] C_v_cgc_t = np . array ( variables [ f 'C_v_cgc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] T_ccl = np . array ( variables [ 'T_ccl' ])[ mask ] # Plot the vapor concentrations at different spatial localisations Cv C_v_sat_ccl_t = np . array ([ C_v_sat ( T ) for T in T_ccl ]) ax . plot ( t , C_v_agc_t , color = colors ( 0 )) ax . plot ( t , C_v_agdl_t , color = colors ( 1 )) ax . plot ( t , C_v_ampl_t , color = colors ( 2 )) ax . plot ( t , C_v_acl_t , color = colors ( 3 )) ax . plot ( t , C_v_ccl_t , color = colors ( 5 )) ax . plot ( t , C_v_cmpl_t , color = colors ( 6 )) ax . plot ( t , C_v_cgdl_t , color = colors ( 7 )) ax . plot ( t , C_v_cgc_t , color = colors ( 8 )) ax . plot ( t , C_v_sat_ccl_t , color = 'k' ) ax . legend ([ r '$\\mathregular{C_{v,agc}}$' , r '$\\mathregular{C_{v,agdl}}$' , r '$\\mathregular{C_{v,ampl}}$' , r '$\\mathregular{C_{v,acl}}$' , r '$\\mathregular{C_{v,ccl}}$' , r '$\\mathregular{C_{v,cmpl}}$' , r '$\\mathregular{C_{v,cgdl}}$' , r '$\\mathregular{C_{v,cgc}}$' , r '$\\mathregular{C_{v,sat,ccl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r \"$\\mathbf {Vapor} $ $\\mathbf {concentration} $ $\\mathbf{C_ {v} }$ $\\mathbf{\\left( mol.m^{-3} \\right)}$\" , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_C_v"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_Nyquist_instructions","text":"This function adds the instructions for EIS plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. f_Fourier ( ndarray ) \u2013 Frequency at which the EIS is simulated. x ( ndarray ) \u2013 x-axis values for plotting the annotation. y ( ndarray ) \u2013 y-axis values for plotting the annotation. ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 def plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , x , y , ax ): \"\"\"This function adds the instructions for EIS plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. f_Fourier : numpy.ndarray Frequency at which the EIS is simulated. x : numpy.ndarray x-axis values for plotting the annotation. y : numpy.ndarray y-axis values for plotting the annotation. ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Commun instructions ax . set_aspect ( 'equal' , adjustable = 'box' ) # Set orthonormal axis. # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : # Double charge transfer if ( f_Fourier >= 70 and f_Fourier <= 80 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , - 40 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) # Auxiliary system if ( f_Fourier >= 0.14 and f_Fourier <= 0.16 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 7 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 1.2 and f_Fourier <= 1.4 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 10 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) # Diffusion if ( f_Fourier >= 0.015 and f_Fourier <= 0.020 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 30 , 0 ), ha = 'center' , fontsize = 14 , rotation = 0 , weight = 'bold' ) if ( f_Fourier >= 0.9 and f_Fourier <= 1.1 ): freq_str = f ' { f_Fourier : .2g } Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , 10 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 70 and f_Fourier <= 90 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 0 , - 40 ), ha = 'center' , fontsize = 14 , rotation = 90 , weight = 'bold' ) if ( f_Fourier >= 10000 and f_Fourier <= 12000 ): freq_str = str ( int ( f_Fourier )) + ' Hz' # Frequency annotation. ax . annotate ( freq_str , ( x , y ), textcoords = \"offset points\" , xytext = ( 35 , 0 ), ha = 'center' , fontsize = 14 , rotation = 0 , weight = 'bold' ) ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 20 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 20 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 10 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 10 / 5 )) ax . set_xlim ( 30 , 200 ) ax . set_ylim ( - 25 , 55 )","title":"plot_EIS_Nyquist_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_curve_Bode_amplitude","text":"This function is used to plot the amplitude Bode diagram of the EIS curves. Parameters: parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the amplitude Bode diagram will be plotted. Source code in modules/display_modules.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def plot_EIS_curve_Bode_amplitude ( parameters , Fourier_results , ax ): \"\"\"This function is used to plot the amplitude Bode diagram of the EIS curves. Parameters ---------- parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the amplitude Bode diagram will be plotted. \"\"\" # Extraction of the parameters i_EIS , ratio_EIS , f_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ], parameters [ 'f_EIS' ] type_fuel_cell = parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results A , f = Fourier_results [ 'A' ], Fourier_results [ 'f' ] # Calculation of the impedance of the perturbation Z0 = A / ( ratio_EIS * ( - i_EIS )) * 1e7 # in m\u03a9.cm\u00b2. The sign of i is inverted to comply with the standards of EIS, # which measure a device under load rather than a current source. # Plot the amplitude Bode diagram ax . plot ( f , np . abs ( Z0 ), 'o' , color = colors ( 1 ), label = 'Amplitude Bode diagram' ) ax . set_xlabel ( r '$\\mathbf {Frequency} $ $\\mathbf{(Hz,}$ $\\mathbf {logarithmic} $ $\\mathbf{scale)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Impedance} $ $\\mathbf {amplitude} $ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) # Plot instructions plot_Bode_amplitude_instructions ( f_EIS , type_fuel_cell , ax )","title":"plot_EIS_curve_Bode_amplitude"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_curve_Bode_angle","text":"This function is used to plot the angle Bode diagram. It only works with an entry signal made with a cosinus (not a sinus). Parameters: Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the angle Bode diagram will be plotted. Source code in modules/display_modules.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 def plot_EIS_curve_Bode_angle ( parameters , Fourier_results , ax ): \"\"\"This function is used to plot the angle Bode diagram. It only works with an entry signal made with a cosinus (not a sinus). Parameters ---------- Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the angle Bode diagram will be plotted. \"\"\" # Extraction of the parameters f_EIS , type_fuel_cell = parameters [ 'f_EIS' ], parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] A_period_t , A = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ] f , N = Fourier_results [ 'f' ], Fourier_results [ 'N' ] # Calculation of the dephasing values at the frequency of the perturbation theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) + np . pi # Recovery of all dephasing values calculated by fft. # An angle of pi is added to comply with the standards of EIS, # which measure a device under load rather than a current source. theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation phi_U_i = (( theta_U - theta_i ) * 180 / np . pi ) % 360 # Dephasing between Ucell and ifc with a value between 0 and 360 if phi_U_i > 180 : phi_U_i -= 360 # To have a value between -180 and 180 # Plot the angle Bode diagram ax . plot ( f , phi_U_i , 'o' , color = colors ( 2 ), label = 'Angle Bode diagram' ) ax . set_xlabel ( r '$\\mathbf {Frequency} $ $\\mathbf{(Hz,}$ $\\mathbf {logarithmic} $ $\\mathbf{scale)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Phase} $ $\\mathbf{(^\\circ)}$' , labelpad = 3 ) # Plot instructions plot_Bode_phase_instructions ( f_EIS , type_fuel_cell , ax )","title":"plot_EIS_curve_Bode_angle"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_curve_Nyquist","text":"This function is used to plot the Nyquist diagram of the EIS curves. Parameters: parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax ( Axes ) \u2013 Axes on which the Nyquist diagram will be plotted. Source code in modules/display_modules.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def plot_EIS_curve_Nyquist ( parameters , Fourier_results , ax ): \"\"\" This function is used to plot the Nyquist diagram of the EIS curves. Parameters ---------- parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. ax : matplotlib.axes.Axes Axes on which the Nyquist diagram will be plotted. \"\"\" # Extraction of the parameters i_EIS , ratio_EIS , type_fuel_cell = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ], parameters [ 'type_fuel_cell' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] f_Fourier = Fourier_results [ 'f' ] A_period_t , A , N = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ], Fourier_results [ 'N' ] # Calculation of the real and imaginary component of the impedance for each period Z0 = A / ( ratio_EIS * ( - i_EIS )) * 1e7 # Impedance of the perturbation in m\u03a9.cm\u00b2. The sign of i is inverted to # comply with the standards of EIS, which measure a device under load rather than a current source. theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation Z_real = Z0 * np . cos ( theta_U - theta_i ) # Real component of the impedance for each period Z_imag = Z0 * np . sin ( theta_U - theta_i ) # Imaginary component of the impedance for each period # Plot the Nyquist diagram ax . plot ( Z_real , - Z_imag , 'o' , color = colors ( 0 ), label = 'Nyquist diagram' ) ax . set_xlabel ( r '$\\mathbf{Z_ {real} }$ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf{-Z_ {imag} }$ $\\mathbf{(m\\Omega.cm^ {2} )}$' , labelpad = 3 ) # Plot instructions plot_EIS_Nyquist_instructions ( type_fuel_cell , f_Fourier , Z_real , - Z_imag , ax )","title":"plot_EIS_curve_Nyquist"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_EIS_curve_tests","text":"This function is used to test the accuracy of the EIS results. It compares the reconstructed Ucell_Fourier(t) from the Fourier transformation with the current density ifc(t), and displays Ucell(t) given by the model with the reconstructed Ucell_Fourier(t). Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. Fourier_results ( dict ) \u2013 Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. Source code in modules/display_modules.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def plot_EIS_curve_tests ( variables , operating_inputs , parameters , Fourier_results ): \"\"\"This function is used to test the accuracy of the EIS results. It compares the reconstructed Ucell_Fourier(t) from the Fourier transformation with the current density ifc(t), and displays Ucell(t) given by the model with the reconstructed Ucell_Fourier(t). Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. Fourier_results : dict Dictionary containing the Fourier transformation (FT) of the cell voltage and the current density, all amplitude values of the cell voltage calculated by the FT, the amplitude of the cell voltage at the frequency of the perturbation, all frequency values used vy the FT, the frequency of the perturbation, and the number of points used in the FT. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), variables [ 'Ucell' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] i_EIS , ratio_EIS = parameters [ 'i_EIS' ], parameters [ 'ratio_EIS' ] t_EIS , f_EIS = parameters [ 't_EIS' ], parameters [ 'f_EIS' ] # Extraction of the Fourier results Ucell_Fourier , ifc_Fourier = Fourier_results [ 'Ucell_Fourier' ], Fourier_results [ 'ifc_Fourier' ] A_period_t , A = Fourier_results [ 'A_period_t' ], Fourier_results [ 'A' ] f , N = Fourier_results [ 'f' ], Fourier_results [ 'N' ] # Reconstructed Ucell with a cosinus form, and comparison of its form with the current density one. t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = t_EIS f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS n_inf = np . where ( t_new_start_EIS <= t [ 0 ])[ 0 ][ - 1 ] # The number of frequency changes which has been made. f_current = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) theta_U_t = np . angle ( Ucell_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_i_t = np . angle ( ifc_Fourier [ 0 : N // 2 ]) # Recovery of all dephasing values calculated by fft theta_U = theta_U_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation theta_i = theta_i_t [ np . argmax ( A_period_t == A )] # Dephasing at the frequency of the perturbation print ( \"Ucell:\" , round ( A_period_t [ 0 ], 4 ), ' + ' , round ( A , 6 ), \" * np.cos(2*np.pi*\" , round ( f , 4 ), \"*t + \" , round ( theta_U , 4 ), \"). \" ) print ( \"Current:\" , i_EIS , ' + ' , ratio_EIS * i_EIS , \" * np.cos(2*np.pi*\" , round ( f_current [ n_inf ], 4 ), \"*t + \" , round ( theta_i , 4 ), \"). \\n \" ) # Display ifc(t) plt . figure ( 3 ) plt . subplot ( 2 , 1 , 1 ) # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Conversion in A/cm\u00b2 ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Plot of ifc_t plt . plot ( t , ifc_t , color = 'blue' , label = 'ifc' ) plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Current density (A/cm\u00b2)' ) plt . title ( 'The current density \\n behaviour over time' ) # Display Ucell(t) and compare it with the reconstructed Ucell_Fourier(t) from the Fourier transformation plt . subplot ( 2 , 1 , 2 ) Ucell_Fourier = A_period_t [ 0 ] + A * np . cos ( 2 * np . pi * f * t + theta_U ) plt . plot ( t , Ucell_t , color = 'blue' , label = 'Ucell' ) plt . plot ( t , Ucell_Fourier , color = 'black' , label = 'Ucell_Fourier' ) plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Cell voltage (V)' ) plt . title ( 'The cell voltage \\n behaviour over time' )","title":"plot_EIS_curve_tests"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_J","text":"This function plots the sorption and dissolved water flows as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the flows will be plotted. Source code in modules/display_modules.py 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 def plot_J ( variables , parameters , ax ): \"\"\"This function plots the sorption and dissolved water flows as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the flows will be plotted. \"\"\" # Extraction of the operating inputs and the parameters Hacl , Hccl = parameters [ 'Hacl' ], parameters [ 'Hccl' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] S_abs_acl_t = np . array ( variables [ 'S_abs_acl' ])[ mask ] S_abs_ccl_t = np . array ( variables [ 'S_abs_ccl' ])[ mask ] J_lambda_acl_mem_t = np . array ( variables [ 'J_lambda_acl_mem' ])[ mask ] J_lambda_mem_ccl_t = np . array ( variables [ 'J_lambda_mem_ccl' ])[ mask ] # Plot the sorption and dissolved water flows: J J_abs_acl , J_abs_ccl = S_abs_acl_t * Hacl , S_abs_ccl_t * Hccl # Conversion in mol.m\u207b\u00b2.s\u207b\u00b9 for comparison ax . plot ( t , J_abs_acl , color = colors ( 2 )) ax . plot ( t , J_lambda_acl_mem_t , color = colors ( 3 )) ax . plot ( t , J_abs_ccl , color = colors ( 4 )) ax . plot ( t , J_lambda_mem_ccl_t , color = colors ( 7 )) ax . legend ([ r '$\\mathregular{J_{abs,acl}}$' , r '$\\mathregular{J_{\\lambda,mem,acl}}$' , r '$\\mathregular{J_{abs,ccl}}$' , r '$\\mathregular{J_{\\lambda,mem,ccl}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Flows} $ $\\mathbf {J} $ $\\mathbf{\\left( mol.m^{-2}.s^{-1} \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax )","title":"plot_J"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_P","text":"This function plots the pressure at different spatial localisations as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the pressure will be plotted. Source code in modules/display_modules.py 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 def plot_P ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the pressure at different spatial localisations as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the pressure will be plotted. \"\"\" # Extraction of the parameters Pa_des , Pc_des = operating_inputs [ 'Pa_des' ], operating_inputs [ 'Pc_des' ] nb_gc , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ]) nb_gc_mid = int ( np . ceil ( nb_gc / 2 )) C_v_agc = np . array ( variables [ f 'C_v_agc_ { nb_gc_mid } ' ]) C_H2_agc = np . array ( variables [ f 'C_H2_agc_ { nb_gc_mid } ' ]) C_N2_agc = np . array ( variables [ f 'C_N2_agc_ { nb_gc_mid } ' ]) T_agc = np . array ( variables [ f 'T_agc_ { nb_gc_mid } ' ]) C_v_cgc = np . array ( variables [ f 'C_v_cgc_ { nb_gc_mid } ' ]) C_O2_cgc = np . array ( variables [ f 'C_O2_cgc_ { nb_gc_mid } ' ]) C_N2_cgc = np . array ( variables [ f 'C_N2_cgc_ { nb_gc_mid } ' ]) T_cgc = np . array ( variables [ f 'T_cgc_ { nb_gc_mid } ' ]) Pagc_t = ( C_v_agc + C_H2_agc + C_N2_agc ) * R * T_agc / 1e5 # Conversion in bar Pcgc_t = ( C_v_cgc + C_O2_cgc + C_N2_cgc ) * R * T_cgc / 1e5 # Conversion in bar if parameters [ 'type_auxiliary' ] != 'no_auxiliary' : Pasm_t = np . array ( variables [ 'Pasm' ])[ mask ] / 1e5 # Conversion in bar Paem_t = np . array ( variables [ 'Paem' ])[ mask ] / 1e5 # Conversion in bar Pcsm_t = np . array ( variables [ 'Pcsm' ])[ mask ] / 1e5 # Conversion in bar Pcem_t = np . array ( variables [ 'Pcem' ])[ mask ] / 1e5 # Conversion in bar else : # parameters['type_auxiliary'] == 'no_auxiliary' Pa_in_t = np . array ( variables [ 'Pa_in' ]) / 1e5 # Conversion in bar Pa_out_t = np . array ([ Pa_des ] * len ( t )) / 1e5 # Conversion in bar Pc_in_t = np . array ( variables [ 'Pc_in' ]) / 1e5 # Conversion in bar Pc_out_t = np . array ([ Pc_des ] * len ( t )) / 1e5 # Conversion in bar # Plot the pressure at different spatial localisations: P ax . plot ( t , Pagc_t , color = colors ( 0 )) ax . plot ( t , Pcgc_t , color = colors ( 6 )) if parameters [ 'type_auxiliary' ] != 'no_auxiliary' : ax . plot ( t , Pasm_t , color = colors ( 7 )) ax . plot ( t , Paem_t , color = colors ( 8 )) ax . plot ( t , Pcsm_t , color = colors ( 9 )) ax . plot ( t , Pcem_t , color = colors ( 10 )) else : # parameters['type_auxiliary'] == 'no_auxiliary' ax . plot ( t , Pa_in_t , color = colors ( 7 )) ax . plot ( t , Pa_out_t , color = colors ( 8 )) ax . plot ( t , Pc_in_t , color = colors ( 9 )) ax . plot ( t , Pc_out_t , color = colors ( 10 )) if parameters [ 'type_auxiliary' ] != 'no_auxiliary' : ax . legend ([ r '$\\mathregular{P_ {agc} }$' , r '$\\mathregular{P_ {cgc} }$' , r '$\\mathregular{P_ {asm} }$' , r '$\\mathregular{P_ {aem} }$' , r '$\\mathregular{P_ {csm} }$' , r '$\\mathregular{P_ {cem} }$' ], loc = 'best' ) else : # parameters['type_auxiliary'] == 'no_auxiliary' ax . legend ([ r '$\\mathregular{P_ {agc} }$' , r '$\\mathregular{P_ {cgc} }$' , r '$\\mathregular{P_{a,in}}$' , r '$\\mathregular{P_{a,out}}$' , r '$\\mathregular{P_{c,in}}$' , r '$\\mathregular{P_{c,out}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Pressure} $ $\\mathbf {P} $ $\\mathbf{\\left( bar \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax )","title":"plot_P"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Phi_a","text":"This function plots the humidity at the anode side, at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. ax ( Axes ) \u2013 Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 def plot_Phi_a ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the humidity at the anode side, at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and parameters Phi_a_des = operating_inputs [ 'Phi_a_des' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_agc_t = np . array ( variables [ 'C_v_agc' ])[ mask ] T_agc_t = np . array ( variables [ 'T_agc' ])[ mask ] Phi_asm_t = np . array ( variables [ 'Phi_asm' ])[ mask ] Phi_aem_t = np . array ( variables [ 'Phi_aem' ])[ mask ] # Calculate the humidity Phi Phi_agc_t = C_v_agc_t * R * T_agc_t / Psat ( T_agc_t ) # Plot the humidity at different spatial localisations: Phi ax . plot ( t , Phi_agc_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_ {agc} }$' ) ax . plot ( t , Phi_asm_t , color = colors ( 1 ), label = r '$\\mathregular{\\Phi_ {asm} }$' ) ax . plot ( t , Phi_aem_t , color = colors ( 2 ), label = r '$\\mathregular{\\Phi_ {aem} }$' ) ax . plot ( t , np . array ([ Phi_a_des ] * len ( t )), color = 'black' , label = r '$\\mathregular{\\Phi_{a,des}}$' ) ax . legend ( loc = 'center right' , bbox_to_anchor = ( 1 , 0.67 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Humidity} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf {anode} $ $\\mathbf {side} $ $\\mathbf{\\Phi}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_Phi_a"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Phi_c","text":"This function plots the humidity, at the cathode side, at different spatial localisations as a function of time. Parameters: ax \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. ax ( Axes ) \u2013 Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 def plot_Phi_c ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the humidity, at the cathode side, at different spatial localisations as a function of time. Parameters ---------- ax.plot(t, np.array([Phi_a_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{a,des}}$') Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and parameters Phi_c_des = operating_inputs [ 'Phi_c_des' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] C_v_cgc_t = np . array ( variables [ 'C_v_cgc' ])[ mask ] T_cgc_t = np . array ( variables [ 'T_cgc' ])[ mask ] Phi_csm_t = np . array ( variables [ 'Phi_csm' ])[ mask ] Phi_cem_t = np . array ( variables [ 'Phi_cem' ])[ mask ] # Calculate the humidity Phi Phi_cgc_t = C_v_cgc_t * R * T_cgc_t / Psat ( T_cgc_t ) # Plot the humidity at different spatial localisations: Phi ax . plot ( t , Phi_cgc_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_ {cgc} }$' ) ax . plot ( t , Phi_csm_t , color = colors ( 1 ), label = r '$\\mathregular{\\Phi_ {csm} }$' ) ax . plot ( t , Phi_cem_t , color = colors ( 2 ), label = r '$\\mathregular{\\Phi_ {cem} }$' ) ax . plot ( t , np . array ([ Phi_c_des ] * len ( t )), color = 'black' , label = r '$\\mathregular{\\Phi_{c,des}}$' ) ax . legend ( loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Humidity} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf {cathode} $ $\\mathbf {side} $ $\\mathbf{\\Phi}$' , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_Phi_c"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Phi_des","text":"This function plots the controlled or uncontrolled desired humidity at the anode and cathode as a function of the current density. Parameters ax.plot(t, np.array([Phi_c_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{c,des}}$') variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. Source code in modules/display_modules.py 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def plot_Phi_des ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the controlled or uncontrolled desired humidity at the anode and cathode as a function of the current density. Parameters ax.plot(t, np.array([Phi_c_des]*len(t)), color='black', label=r'$\\mathregular{\\Phi_{c,des}}$') variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the humidity will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] if parameters [ 'type_control' ] == \"Phi_des\" : Phi_a_des_t = variables [ 'Phi_a_des' ][ mask ] Phi_c_des_t = variables [ 'Phi_c_des' ][ mask ] ax . set_ylabel ( r '$\\mathbf {Controlled} $ $\\mathbf {inlet} $ $\\mathbf {humidity} $ $\\mathbf{\\Phi_ {des} }$' , labelpad = 3 ) else : Phi_a_des_t = np . array ([ operating_inputs [ 'Phi_a_des' ]] * len ( t )) Phi_c_des_t = np . array ([ operating_inputs [ 'Phi_c_des' ]] * len ( t )) ax . set_ylabel ( r '$\\mathbf {Uncontrolled} $ $\\mathbf {inlet} $ $\\mathbf {humidity} $ $\\mathbf{\\Phi_ {des} }$' , labelpad = 3 ) # Plot Phi_des n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of ifc_t ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) Phi_a_des_discretized_t , Phi_c_des_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load Phi_a_des_discretized_t [ i ] = Phi_a_des_t [ idx ] # the last value at the end of each load Phi_c_des_discretized_t [ i ] = Phi_c_des_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , Phi_c_des_discretized_t , color = colors ( 6 ), label = r '$\\mathregular{\\Phi_{c,des}}$' ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) if parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" or \\ parameters [ 'type_auxiliary' ] == \"no_auxiliary\" : ax . scatter ( ifc_discretized_t , Phi_a_des_discretized_t , color = colors ( 0 ), label = r '$\\mathregular{\\Phi_{a,des}}$' ) ax . legend ([ r '$\\mathregular{\\Phi_{a,des}}$' , r '$\\mathregular{\\Phi_{c,des}}$' ], loc = 'best' ) else : ax . legend ([ r '$\\mathregular{\\Phi_{c,des}}$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_Phi_des"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Re_nb","text":"This function plots the Reynold number at the center of the AGC and the CGC as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the pressure will be plotted. Source code in modules/display_modules.py 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 def plot_Re_nb ( variables , parameters , ax ): \"\"\"This function plots the Reynold number at the center of the AGC and the CGC as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the pressure will be plotted. \"\"\" # Extraction of the parameters Hcgc , Wcgc = parameters [ 'Hcgc' ], parameters [ 'Wcgc' ] nb_gc , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ]) v_a_in_t = np . array ( variables [ 'v_a_in' ]) v_c_in_t = np . array ( variables [ 'v_c_in' ]) C_v_agc_t = np . array ( variables [ 'C_v_agc_1' ]) C_v_cgc_t = np . array ( variables [ 'C_v_cgc_1' ]) C_H2_agc_t = np . array ( variables [ 'C_H2_agc_1' ]) C_O2_cgc_t = np . array ( variables [ 'C_O2_cgc_1' ]) C_N2_agc_t = np . array ( variables [ 'C_N2_agc_1' ]) C_N2_cgc_t = np . array ( variables [ 'C_N2_cgc_1' ]) T_agc_t = np . array ( variables [ 'T_agc_1' ]) T_cgc_t = np . array ( variables [ 'T_cgc_1' ]) # Calculation of the Reynold Number d_pipe = np . sqrt ( 4 * Hcgc * Wcgc / np . pi ) P_agc = ( C_v_agc_t + C_H2_agc_t + C_N2_agc_t ) * R * T_agc_t P_cgc = ( C_v_cgc_t + C_O2_cgc_t + C_N2_cgc_t ) * R * T_cgc_t M_agc = C_v_agc_t * R * T_agc_t / P_agc * M_H2O + \\ C_H2_agc_t * R * T_agc_t / P_agc * M_H2 + \\ C_N2_agc_t * R * T_agc_t / P_agc * M_N2 M_cgc = C_v_cgc_t * R * T_cgc_t / P_cgc * M_H2O + \\ C_O2_cgc_t * R * T_cgc_t / P_cgc * M_O2 + \\ C_N2_cgc_t * R * T_cgc_t / P_cgc * M_N2 rho_agc = P_agc / ( R * T_agc_t ) * M_agc rho_cgc = P_cgc / ( R * T_cgc_t ) * M_cgc x_H2O_v_agc = C_v_agc_t / ( C_v_agc_t + C_H2_agc_t + C_N2_agc_t ) x_H2O_v_cgc = C_v_cgc_t / ( C_v_cgc_t + C_O2_cgc_t + C_N2_cgc_t ) y_H2_agc = C_H2_agc_t / ( C_H2_agc_t + C_N2_agc_t ) y_O2_cgc = C_O2_cgc_t / ( C_O2_cgc_t + C_N2_cgc_t ) mu_agc = mu_mixture_gases ([ 'H2O_v' , 'H2' , 'N2' ], [ x_H2O_v_agc , y_H2_agc * ( 1 - x_H2O_v_agc ), ( 1 - y_H2_agc ) * ( 1 - x_H2O_v_agc )], T_agc_t ) mu_cgc = mu_mixture_gases ([ 'H2O_v' , 'O2' , 'N2' ], [ x_H2O_v_cgc , y_O2_cgc * ( 1 - x_H2O_v_cgc ), ( 1 - y_O2_cgc ) * ( 1 - x_H2O_v_cgc )], T_cgc_t ) Re_nb_a_t = ( rho_agc * v_a_in_t * d_pipe ) / mu_agc # Reynolds number at the anode side Re_nb_c_t = ( rho_cgc * v_c_in_t * d_pipe ) / mu_cgc # Reynolds number at the anode side # Plot the pressure at different spatial localisations: P ax . plot ( t , Re_nb_a_t , color = colors ( 0 )) ax . plot ( t , Re_nb_c_t , color = colors ( 6 )) ax . legend ([ r '$\\mathregular{Re_ {a} }$' , r '$\\mathregular{Re_ {c} }$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Reynold} $ $\\mathbf {number} $ $\\mathbf {at} $ $\\mathbf {the} $ $\\mathbf{inlet,}$ $\\mathbf {Re} $' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax )","title":"plot_Re_nb"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_T","text":"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the vapor concentration will be plotted. Source code in modules/display_modules.py 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 def plot_T ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the vapor concentrations at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the vapor concentration will be plotted. \"\"\" # Extraction of the operating inputs and parameters current_density = operating_inputs [ 'current_density' ] T_des = operating_inputs [ 'T_des' ] nb_gc , nb_gdl , nb_mpl = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables and the operating inputs if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] T_agc_t = np . array ( variables [ f 'T_agc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_agdl_t = np . array ( variables [ f 'T_agdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_ampl_t = np . array ( variables [ f 'T_ampl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_acl_t = np . array ( variables [ 'T_acl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_mem_t = np . array ( variables [ 'T_mem' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_ccl_t = np . array ( variables [ 'T_ccl' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cmpl_t = np . array ( variables [ f 'T_cmpl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cgdl_t = np . array ( variables [ f 'T_cgdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. T_cgc_t = np . array ( variables [ f 'T_cgc_ { int ( np . ceil ( nb_gc / 2 )) } ' ])[ mask ] - 273.15 # Conversion in \u00b0C. # Plot the temperature at different spatial localisations if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) T_agc_discretized_t , T_agdl_discretized_t , T_ampl_discretized_t , T_acl_discretized_t = [ np . zeros ( nb_loads )] * 4 T_mem_discretized_t , T_ccl_discretized_t , T_cmpl_discretized_t , T_cgdl_discretized_t = [ np . zeros ( nb_loads )] * 4 T_cgc_discretized_t = np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load T_agc_discretized_t [ i ] = T_agc_t [ idx ] # the last value at the end of each load T_agdl_discretized_t [ i ] = T_agdl_t [ idx ] # the last value at the end of each load T_ampl_discretized_t [ i ] = T_ampl_t [ idx ] # the last value at the end of each load T_acl_discretized_t [ i ] = T_acl_t [ idx ] # the last value at the end of each load T_mem_discretized_t [ i ] = T_mem_t [ idx ] # the last value at the end of each load T_ccl_discretized_t [ i ] = T_ccl_t [ idx ] # the last value at the end of each load T_cmpl_discretized_t [ i ] = T_cmpl_t [ idx ] # the last value at the end of each load T_cgdl_discretized_t [ i ] = T_cgdl_t [ idx ] # the last value at the end of each load T_cgc_discretized_t [ i ] = T_cgc_t [ idx ] # the last value at the end of each load T_des_discretized_t = np . array ([ T_des - 273.15 ] * len ( ifc_discretized_t )) ax . scatter ( ifc_discretized_t , T_agc_discretized_t , marker = 'o' , color = colors ( 0 )) ax . scatter ( ifc_discretized_t , T_agdl_discretized_t , marker = 'o' , color = colors ( 1 )) ax . scatter ( ifc_discretized_t , T_ampl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , T_acl_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , T_mem_discretized_t , marker = 'o' , color = colors ( 4 )) ax . scatter ( ifc_discretized_t , T_ccl_discretized_t , marker = 'o' , color = colors ( 5 )) ax . scatter ( ifc_discretized_t , T_cmpl_discretized_t , marker = 'o' , color = colors ( 6 )) ax . scatter ( ifc_discretized_t , T_cgdl_discretized_t , marker = 'o' , color = colors ( 7 )) ax . scatter ( ifc_discretized_t , T_cgc_discretized_t , marker = 'o' , color = colors ( 8 )) ax . scatter ( ifc_discretized_t , T_des_discretized_t , marker = 'o' , color = 'k' ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : T_des_t = np . array ([ T_des - 273.15 ] * len ( t )) ax . plot ( t , T_agc_t , color = colors ( 0 )) ax . plot ( t , T_agdl_t , color = colors ( 1 )) ax . plot ( t , T_ampl_t , color = colors ( 2 )) ax . plot ( t , T_acl_t , color = colors ( 3 )) ax . plot ( t , T_mem_t , color = colors ( 4 )) ax . plot ( t , T_ccl_t , color = colors ( 5 )) ax . plot ( t , T_cmpl_t , color = colors ( 6 )) ax . plot ( t , T_cgdl_t , color = colors ( 7 )) ax . plot ( t , T_cgc_t , color = colors ( 8 )) ax . plot ( t , T_des_t , color = 'k' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{T_ {agc} }$' , r '$\\mathregular{T_ {agdl} }$' , r '$\\mathregular{T_ {ampl} }$' , r '$\\mathregular{T_ {acl} }$' , r '$\\mathregular{T_ {mem} }$' , r '$\\mathregular{T_ {ccl} }$' , r '$\\mathregular{T_ {cmpl} }$' , r '$\\mathregular{T_ {cgdl} }$' , r '$\\mathregular{T_ {cgc} }$' , r '$\\mathregular{T_ {des} }$' ], loc = 'best' ) ax . set_ylabel ( r \"$\\mathbf {Temperature} $ $\\mathbf {T} $ $\\mathbf{\\left( \u00b0C \\right)}$\" , labelpad = 3 ) # Plot instructions plot_general_instructions ( ax )","title":"plot_T"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_Ucell","text":"This function plots the cell voltage as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. ax ( Axes ) \u2013 Axes on which the cell voltage will be plotted. Source code in modules/display_modules.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def plot_Ucell ( variables , parameters , ax ): \"\"\"This function plots the cell voltage as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. ax : matplotlib.axes.Axes Axes on which the cell voltage will be plotted. \"\"\" # Extraction of the parameters type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] Ucell_t = np . array ( variables [ 'Ucell' ])[ mask ] # Plot the cell voltage: Ucell ax . plot ( t , Ucell_t , color = colors ( 0 ), label = r '$\\mathregular{U_ {cell} }$' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{U_ {cell} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_Ucell"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_cell_efficiency","text":"This function plots the fuel cell efficiency eta_fc as a function of the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the fuel cell efficiency. ax ( Axes ) \u2013 Axes on which the fuel cell efficiency will be plotted. Source code in modules/display_modules.py 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 def plot_cell_efficiency ( variables , operating_inputs , parameters , n , ax ): \"\"\"This function plots the fuel cell efficiency eta_fc as a function of the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the fuel cell efficiency. ax : matplotlib.axes.Axes Axes on which the fuel cell efficiency will be plotted. \"\"\" # Extraction of the variables t , Ucell_t , lambda_mem_t = variables [ 't' ], variables [ 'Ucell' ], variables [ 'lambda_mem' ] C_H2_acl_t , C_O2_ccl_t = variables [ 'C_H2_acl' ], variables [ 'C_O2_ccl' ] T_acl_t , T_mem_t , T_ccl_t = variables [ 'T_acl' ], variables [ 'T_mem' ], variables [ 'T_ccl' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] Hmem , Hacl , Hccl , kappa_co = parameters [ 'Hmem' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'kappa_co' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] # Creation of the fuel cell efficiency: eta_fc ifc_t , Pfc_t , eta_fc_t = np . zeros ( n ), np . zeros ( n ), np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 Pfc_t [ i ] = Ucell_t [ i ] * ifc_t [ i ] Ueq = E0 - 8.5e-4 * ( T_ccl_t [ i ] - 298.15 ) + \\ R * T_ccl_t [ i ] / ( 2 * F ) * ( np . log ( R * T_acl_t [ i ] * C_H2_acl_t [ i ] / Pref ) + 0.5 * np . log ( R * T_ccl_t [ i ] * C_O2_ccl_t [ i ] / Pref )) T_acl_mem_ccl = average ([ T_acl_t [ i ], T_mem_t [ i ], T_ccl_t [ i ]], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) i_H2 = 2 * F * R * T_acl_mem_ccl / Hmem * C_H2_acl_t [ i ] * k_H2 ( lambda_mem_t [ i ], T_mem_t [ i ], kappa_co ) i_O2 = 4 * F * R * T_acl_mem_ccl / Hmem * C_O2_ccl_t [ i ] * k_O2 ( lambda_mem_t [ i ], T_mem_t [ i ], kappa_co ) i_n = ( i_H2 + i_O2 ) / 1e4 # Conversion in A/cm\u00b2 eta_fc_t [ i ] = Pfc_t [ i ] / ( Ueq * ( ifc_t [ i ] + i_n )) # Plot of the fuel cell efficiency: eta_fc plot_specific_line ( ifc_t , eta_fc_t , type_fuel_cell , type_current , type_auxiliary , type_control , None , ax ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 0 ) ax . set_ylabel ( r '$\\mathbf {Fuel} $ $\\mathbf {cell} $ $\\mathbf {efficiency} $ $\\mathbf{\\eta_ {fc} }$' , labelpad = 0 ) ax . legend ( loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_cell_efficiency"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_general_instructions","text":"This function adds the common instructions for all the plots displayed by AlphaPEM to the ax object. Parameters: ax ( Axes ) \u2013 Axes on which the instructions will be added. Source code in modules/display_modules.py 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 def plot_general_instructions ( ax , set_y = True ): \"\"\"This function adds the common instructions for all the plots displayed by AlphaPEM to the ax object. Parameters ---------- ax : matplotlib.axes.Axes Axes on which the instructions will be added. \"\"\" # Get the current x-axis and y-axis limits x_min , x_max = ax . get_xlim () y_min , y_max = ax . get_ylim () # Calculate the major step for the x-axis and y-axis ticks major_step_x = ( x_max - x_min ) / 5 major_step_y = ( y_max - y_min ) / 5 major_step_x_rounded = round_nice ( major_step_x ) major_step_y_rounded = round_nice ( major_step_y ) # Set the major and minor locators for the x-axis and y-axis ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( major_step_x_rounded )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( major_step_x_rounded / 5 )) if set_y : ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( major_step_y_rounded )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( major_step_y_rounded / 5 )) # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure plt . show () # Show the figure","title":"plot_general_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_ifc","text":"This function plots the current density as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the current density will be plotted. Source code in modules/display_modules.py 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 def plot_ifc ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the current density as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the current density will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] # Plot the current density: ifc n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of ifc_t ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 ax . plot ( t , ifc_t , color = colors ( 0 ), label = r '$\\mathregular{i_ {fc} }$' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{i_ {fc} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_ifc"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_lambda","text":"This function plots the water content at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the water content will be plotted. Source code in modules/display_modules.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def plot_lambda ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the water content at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the water content will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters , type_current = parameters [ 'pola_current_parameters' ], parameters [ 'type_current' ] type_plot = parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] lambda_acl_t = np . array ( variables [ 'lambda_acl' ])[ mask ] lambda_mem_t = np . array ( variables [ 'lambda_mem' ])[ mask ] lambda_ccl_t = np . array ( variables [ 'lambda_ccl' ])[ mask ] # Plot the water content at different spatial localisations: lambda if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads which are made ifc_discretized_t , lambda_acl_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) lambda_mem_discretized_t , lambda_ccl_discretized_t = np . zeros ( nb_loads ), np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load lambda_acl_discretized_t [ i ] = lambda_acl_t [ idx ] # the last value at the end of each load lambda_mem_discretized_t [ i ] = lambda_mem_t [ idx ] # the last value at the end of each load lambda_ccl_discretized_t [ i ] = lambda_ccl_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , lambda_acl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , lambda_mem_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , lambda_ccl_discretized_t , marker = 'o' , color = colors ( 4 )) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : ax . plot ( t , lambda_acl_t , color = colors ( 3 )) ax . plot ( t , lambda_mem_t , color = colors ( 4 )) ax . plot ( t , lambda_ccl_t , color = colors ( 5 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Water} $ $\\mathbf {content} $ $\\mathbf{\\lambda}$' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{\\lambda_ {acl} }$' , r '$\\mathregular{\\lambda_ {mem} }$' , r '$\\mathregular{\\lambda_ {ccl} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_lambda"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_pola_instructions","text":"This function adds the specific instructions for polarisation plots according to the type_input to the ax object. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. ax ( Axes ) \u2013 Axes on which the instructions will be added. show ( bool , default: True ) \u2013 If True, the figure will be displayed. Default is True. Source code in modules/display_modules.py 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 def plot_pola_instructions ( type_fuel_cell , ax , show = True ): \"\"\"This function adds the specific instructions for polarisation plots according to the type_input to the ax object. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. ax : matplotlib.axes.Axes Axes on which the instructions will be added. show : bool, optional If True, the figure will be displayed. Default is True. \"\"\" # For EH-31 fuel cell if type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or \\ type_fuel_cell == \"EH-31_2.25\" or type_fuel_cell == \"EH-31_2.5\" : ax . xaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.5 )) ax . xaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.5 / 5 )) ax . yaxis . set_major_locator ( mpl . ticker . MultipleLocator ( 0.1 )) ax . yaxis . set_minor_locator ( mpl . ticker . MultipleLocator ( 0.1 / 5 )) ax . set_xlim ( 0 , 3.0 ) ax . set_ylim ( 0.4 , 1.04 ) # For other fuel cell else : pass # Configure the appearance of major and minor ticks ax . tick_params ( axis = 'both' , which = 'major' , size = 10 , width = 1.5 , direction = 'out' ) ax . tick_params ( axis = 'both' , which = 'minor' , size = 5 , width = 1.5 , direction = 'out' ) plt . tight_layout () # Adjust layout to prevent overlap between labels and the figure if show : plt . show () # Show the figure","title":"plot_pola_instructions"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_polarisation_curve","text":"This function plots the model polarisation curve, and compare it to the experimental one (if it exists). The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the polarisation curve will be plotted. show ( bool , default: True ) \u2013 If True, the polarisation curve will be displayed. If False, it will not be displayed. Source code in modules/display_modules.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def plot_polarisation_curve ( variables , operating_inputs , parameters , ax , show = True ): \"\"\" This function plots the model polarisation curve, and compare it to the experimental one (if it exists). The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the polarisation curve will be plotted. show : bool, optional If True, the polarisation curve will be displayed. If False, it will not be displayed. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_parameters = parameters [ 'pola_current_parameters' ] delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] delta_i_pola , i_max_pola = pola_current_parameters [ 'delta_i_pola' ], pola_current_parameters [ 'i_max_pola' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] voltage_zone , type_auxiliary = parameters [ 'voltage_zone' ], parameters [ 'type_auxiliary' ] type_control , type_plot = parameters [ 'type_control' ], parameters [ 'type_plot' ] # Extraction of the experimental current density and voltage values. i_exp_t , U_exp_t = pola_exp_values ( type_fuel_cell , voltage_zone ) # (A.m-2, V). if type_plot == \"fixed\" : # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of ifc and Ucell from the model after each stack stabilisation nb_loads = int ( i_max_pola / delta_i_pola ) # Number of loads which are made ifc_discretized = np . zeros ( nb_loads + 1 ) # One point is taken at ifc = 0, before the first load. Ucell_discretized = np . zeros ( nb_loads + 1 ) # One point is taken at ifc = 0, before the first load. for i in range ( nb_loads + 1 ): t_load = delta_t_ini_pola + i * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized [ i ] = ifc_t [ idx ] # the last value at the end of each load Ucell_discretized [ i ] = Ucell_t [ idx ] # the last value at the end of each load # Plot the experimental polarization curve and calculate the simulation error compared with experimental data if type_fuel_cell != \"manual_setup\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): # Experimental points are accessible # Plot of the experimental polarization curve i_exp_t = i_exp_t / 1e4 # Conversion in A/cm\u00b2 plot_experimental_polarisation_curve ( type_fuel_cell , i_exp_t , U_exp_t , ax ) # Calculate the simulation error compared with experimental data # Experimental points are interpolated to correspond to the model points Ucell_interpolated = interp1d ( ifc_discretized , Ucell_discretized , kind = 'linear' )( i_exp_t ) sim_error = calculate_simulation_error ( Ucell_interpolated , U_exp_t ) else : sim_error = None # Plot the model polarisation curve plot_specific_line ( ifc_discretized , Ucell_discretized , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) plot_pola_instructions ( type_fuel_cell , ax , show ) else : # type_plot == \"dynamic\" # Plot of the polarisation curve produced by the model idx = ( np . abs ( t - t [ - 1 ])) . argmin () # index for polarisation measurement ifc = np . array ( current_density ( t [ idx ], parameters ) / 1e4 ) # time for polarisation measurement Ucell = np . array ( Ucell_t [ idx ]) # voltage measurement ax . plot ( ifc , Ucell , 'og' , markersize = 2 ) # Add the common instructions for the plot ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) if type_plot == \"fixed\" : ax . legend ( loc = 'best' )","title":"plot_polarisation_curve"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_polarisation_curve_for_cali","text":"This function plots the model polarisation curve, and compare it to the experimental one. The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the polarisation curve will be plotted. Source code in modules/display_modules.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def plot_polarisation_curve_for_cali ( variables , operating_inputs , parameters , ax ): \"\"\" This function plots the model polarisation curve, and compare it to the experimental one. The polarisation curve is a classical representation of the cell performances, showing the cell voltage as a function of the current density. To generate it, the current density is increased step by step, and the cell voltage is recorded at each step. The time for which this point is captured is determined using the following approach: at the beginning of each load, a delta_t_load_pola time is needed to raise the current density to its next value. Subsequently, a delta_t_break_pola time is observed to ensure the dynamic stability of the stack's variables before initiating a new load. Finally, each polarisation point is recorded at the end of each delta_t_break_pola time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the polarisation curve will be plotted. \"\"\" # Extraction of the variables t , Ucell_t = np . array ( variables [ 't' ]), np . array ( variables [ 'Ucell' ]) # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] pola_current_for_cali_parameters = parameters [ 'pola_current_for_cali_parameters' ] delta_t_ini_pola_cali = pola_current_for_cali_parameters [ 'delta_t_ini_pola_cali' ] delta_t_load_pola_cali = pola_current_for_cali_parameters [ 'delta_t_load_pola_cali' ] delta_t_break_pola_cali = pola_current_for_cali_parameters [ 'delta_t_break_pola_cali' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] voltage_zone , type_auxiliary = parameters [ 'voltage_zone' ], parameters [ 'type_auxiliary' ] type_control , type_plot = parameters [ 'type_control' ], parameters [ 'type_plot' ] # Extraction of the experimental current density and voltage values for the calibration. i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( type_fuel_cell , voltage_zone ) # (A.m-2, V). # Creation of ifc_t n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of ifc and Ucell from the model after each stack stabilisation nb_loads = len ( i_exp_cali_t ) # Number of loads which are made delta_t_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. ifc_discretized = np . zeros ( nb_loads ) Ucell_discretized = np . zeros ( nb_loads ) for i in range ( nb_loads ): t_load = delta_t_ini_pola_cali + ( i + 1 ) * delta_t_cali # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized [ i ] = ifc_t [ idx ] # the last value at the end of each load Ucell_discretized [ i ] = Ucell_t [ idx ] # the last value at the end of each load # Plot the experimental polarization curve i_exp_cali_t = i_exp_cali_t / 1e4 # Conversion in A/cm\u00b2 plot_experimental_polarisation_curve ( type_fuel_cell , i_exp_cali_t , U_exp_cali_t , ax ) # Plot the model polarisation curve sim_error = calculate_simulation_error ( Ucell_discretized , U_exp_cali_t ) # Calculate the simulation error plot_specific_line ( ifc_discretized , Ucell_discretized , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ) plot_pola_instructions ( type_fuel_cell , ax ) # Add the common instructions for the plot ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Cell} $ $\\mathbf {voltage} $ $\\mathbf{U_ {cell} }$ $\\mathbf{\\left( V \\right)}$' , labelpad = 3 ) if type_plot == \"fixed\" : ax . legend ( loc = 'best' )","title":"plot_polarisation_curve_for_cali"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_power_density_curve","text":"This function plots the power density curve Pfc, produced by a cell, as a function of the current density. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. n ( int ) \u2013 Number of points used to plot the power density curve. ax ( Axes ) \u2013 Axes on which the power density curve will be plotted. Source code in modules/display_modules.py 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 def plot_power_density_curve ( variables , operating_inputs , parameters , n , ax ): \"\"\"This function plots the power density curve Pfc, produced by a cell, as a function of the current density. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. n : int Number of points used to plot the power density curve. ax : matplotlib.axes.Axes Axes on which the power density curve will be plotted. \"\"\" # Extraction of the variables t , Ucell_t = variables [ 't' ], variables [ 'Ucell' ] # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] type_fuel_cell , type_current = parameters [ 'type_fuel_cell' ], parameters [ 'type_current' ] type_auxiliary , type_control = parameters [ 'type_auxiliary' ], parameters [ 'type_control' ] # Creation of the power density function: Pfc ifc_t , Pfc_t = np . zeros ( n ), np . zeros ( n ) for i in range ( n ): ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 Pfc_t [ i ] = Ucell_t [ i ] * ifc_t [ i ] # Plot of the power density function: Pfc plot_specific_line ( ifc_t , Pfc_t , type_fuel_cell , type_current , type_auxiliary , type_control , None , ax ) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 0 ) ax . set_ylabel ( r '$\\mathbf {Fuel} $ $\\mathbf {cell} $ $\\mathbf {power} $ $\\mathbf {density} $ $\\mathbf{P_ {fc} }$ $\\mathbf{\\left( W.cm^{-2} \\right)}$' , labelpad = 0 ) ax . legend ( loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_power_density_curve"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_s","text":"This function plots the liquid water saturation at different spatial localisations, as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs ( dict ) \u2013 Operating inputs of the fuel cell. parameters ( dict ) \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the liquid water saturation will be plotted. Source code in modules/display_modules.py 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 def plot_s ( variables , operating_inputs , parameters , ax ): \"\"\"This function plots the liquid water saturation at different spatial localisations, as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. operating_inputs : dict Operating inputs of the fuel cell. parameters : dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the liquid water saturation will be plotted. \"\"\" # Extraction of the operating inputs and the parameters current_density = operating_inputs [ 'current_density' ] nb_gdl , nb_mpl , pola_current_parameters = parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ], parameters [ 'pola_current_parameters' ] type_current , type_plot = parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ])[ mask ] s_agdl_t = np . array ( variables [ f 's_agdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] s_ampl_t = np . array ( variables [ f 's_ampl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] s_acl_t = np . array ( variables [ 's_acl' ])[ mask ] s_ccl_t = np . array ( variables [ 's_ccl' ])[ mask ] s_cmpl_t = np . array ( variables [ f 's_cmpl_ { int ( np . ceil ( nb_mpl / 2 )) } ' ])[ mask ] s_cgdl_t = np . array ( variables [ f 's_cgdl_ { int ( np . ceil ( nb_gdl / 2 )) } ' ])[ mask ] # Plot the liquid water saturation at different spatial localisations: s if type_current == \"polarization\" : n = len ( t ) ifc_t = np . zeros ( n ) for i in range ( n ): # Creation of i_fc ifc_t [ i ] = current_density ( t [ i ], parameters ) / 1e4 # Conversion in A/cm\u00b2 # Recovery of the internal states from the model after each stack stabilisation delta_t_ini_pola = pola_current_parameters [ 'delta_t_ini_pola' ] delta_t_load_pola = pola_current_parameters [ 'delta_t_load_pola' ] delta_t_break_pola = pola_current_parameters [ 'delta_t_break_pola' ] nb_loads = int ( pola_current_parameters [ 'i_max_pola' ] / pola_current_parameters [ 'delta_i_pola' ]) # Number of loads ifc_discretized_t = np . zeros ( nb_loads ) s_agdl_discretized_t , s_ampl_discretized_t , s_acl_discretized_t = [ np . zeros ( nb_loads )] * 3 s_ccl_discretized_t , s_cmpl_discretized_t , s_cgdl_discretized_t = [ np . zeros ( nb_loads )] * 3 for i in range ( nb_loads ): t_load = delta_t_ini_pola + ( i + 1 ) * ( delta_t_load_pola + delta_t_break_pola ) # time for measurement idx = ( np . abs ( t - t_load )) . argmin () # the corresponding index ifc_discretized_t [ i ] = ifc_t [ idx ] # the last value at the end of each load s_agdl_discretized_t [ i ] = s_agdl_t [ idx ] # the last value at the end of each load s_ampl_discretized_t [ i ] = s_ampl_t [ idx ] # the last value at the end of each load s_acl_discretized_t [ i ] = s_acl_t [ idx ] # the last value at the end of each load s_ccl_discretized_t [ i ] = s_ccl_t [ idx ] # the last value at the end of each load s_cmpl_discretized_t [ i ] = s_cmpl_t [ idx ] # the last value at the end of each load s_cgdl_discretized_t [ i ] = s_cgdl_t [ idx ] # the last value at the end of each load ax . scatter ( ifc_discretized_t , s_agdl_discretized_t , marker = 'o' , color = colors ( 1 )) ax . scatter ( ifc_discretized_t , s_ampl_discretized_t , marker = 'o' , color = colors ( 2 )) ax . scatter ( ifc_discretized_t , s_acl_discretized_t , marker = 'o' , color = colors ( 3 )) ax . scatter ( ifc_discretized_t , s_ccl_discretized_t , marker = 'o' , color = colors ( 5 )) ax . scatter ( ifc_discretized_t , s_cmpl_discretized_t , marker = 'o' , color = colors ( 6 )) ax . scatter ( ifc_discretized_t , s_cgdl_discretized_t , marker = 'o' , color = colors ( 7 )) ax . set_xlabel ( r '$\\mathbf {Current} $ $\\mathbf {density} $ $\\mathbf{i_ {fc} }$ $\\mathbf{\\left( A.cm^{-2} \\right)}$' , labelpad = 3 ) else : ax . plot ( t , s_agdl_t , color = colors ( 1 )) ax . plot ( t , s_ampl_t , color = colors ( 2 )) ax . plot ( t , s_acl_t , color = colors ( 3 )) ax . plot ( t , s_ccl_t , color = colors ( 5 )) ax . plot ( t , s_cmpl_t , color = colors ( 6 )) ax . plot ( t , s_cgdl_t , color = colors ( 7 )) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf {Liquid} $ $\\mathbf {water} $ $\\mathbf {saturation} $ $\\mathbf {s} $' , labelpad = 3 ) ax . legend ([ r '$\\mathregular{s_ {agdl} }$' , r '$\\mathregular{s_ {ampl} }$' , r '$\\mathregular{s_ {acl} }$' , r '$\\mathregular{s_ {ccl} }$' , r '$\\mathregular{s_ {cmpl} }$' , r '$\\mathregular{s_ {cgdl} }$' ], loc = 'best' ) # Plot instructions plot_general_instructions ( ax )","title":"plot_s"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_specific_line","text":"This function adds the appropriate plot configuration according to the type_input to the ax object. Parameters: x ( ndarray ) \u2013 x-axis values. y ( ndarray ) \u2013 y-axis values. type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. type_current ( str ) \u2013 Type of current density. type_auxiliary ( str ) \u2013 Type of auxiliary system. type_control ( str ) \u2013 Type of control system. sim_error ( float ) \u2013 Simulation error between the simulated cell voltage and the experimental cell voltage (in %). ax ( Axes ) \u2013 Axes on which the line will be plotted. Source code in modules/display_modules.py 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 def plot_specific_line ( x , y , type_fuel_cell , type_current , type_auxiliary , type_control , sim_error , ax ): \"\"\" This function adds the appropriate plot configuration according to the type_input to the ax object. Parameters ---------- x : numpy.ndarray x-axis values. y : numpy.ndarray y-axis values. type_fuel_cell : str Type of fuel cell configuration. type_current : str Type of current density. type_auxiliary : str Type of auxiliary system. type_control : str Type of control system. sim_error : float Simulation error between the simulated cell voltage and the experimental cell voltage (in %). ax : matplotlib.axes.Axes Axes on which the line will be plotted. \"\"\" # For EH-31 fuel cell if type_current == \"polarization\" : # ZSW fuel cell if type_fuel_cell == \"ZSW-GenStack\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 0 ), label = 'Sim. - nominal operating conditions' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - nominal operating conditions' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 1 ), label = 'Sim. - P$_a$ = 1.61 bar - P$_c$ = 1.41 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 1 ), label = 'Sim. - P$_a$ = 1.61 bar - P$_c$ = 1.41 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 2 ), label = 'Sim. - P$_a$ = 2.01 bar - P$_c$ = 1.81 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 2 ), label = 'Sim. - P$_a$ = 2.01 bar - P$_c$ = 1.81 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 3 ), label = 'Sim. - P$_a$ = 2.4 bar - P$_c$ = 2.2 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 3 ), label = 'Sim. - P$_a$ = 2.4 bar - P$_c$ = 2.2 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 4 ), label = 'Sim. - P$_a$ = 2.8 bar - P$_c$ = 2.6 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 4 ), label = 'Sim. - P$_a$ = 2.8 bar - P$_c$ = 2.6 bar' ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 5 ), label = 'Sim. - T = 62 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 5 ), label = 'Sim. - T = 62 \u00b0C' ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 6 ), label = 'Sim. - T = 76 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 6 ), label = 'Sim. - T = 76 \u00b0C' ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 7 ), label = 'Sim. - T = 84 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 7 ), label = 'Sim. - T = 84 \u00b0C' ) # EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_1.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' ) elif type_fuel_cell == \"EH-31_2.0\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 1 ), label = 'Sim. - P = 2.0 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : if type_control == \"Phi_des\" : ax . plot ( x , y , color = colors ( 5 ), label = r 'Sim. - P = 2.0 bar - controlled $\\mathregular{\\Phi_ {des} }$' ) else : ax . plot ( x , y , color = colors ( 1 ), label = r 'Sim. - P = 2.0 bar - uncontrolled $\\mathregular{\\Phi_ {des} }$' ) elif type_fuel_cell == \"EH-31_2.25\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , '--' , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' ) elif type_fuel_cell == \"EH-31_2.5\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . plot ( x , y , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . plot ( x , y , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' ) # For other fuel cell else : ax . plot ( x , y , color = colors ( 0 ), label = 'Simulation' ) elif type_current == \"polarization_for_cali\" : # ZSW fuel cell if type_fuel_cell == \"ZSW-GenStack\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - nominal operating conditions' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - nominal operating conditions' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = 'Sim. - P$_a$ = 1.61 bar - P$_c$ = 1.41 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = 'Sim. - P$_a$ = 1.61 bar - P$_c$ = 1.41 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P$_a$ = 2.01 bar - P$_c$ = 1.81 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P$_a$ = 2.01 bar - P$_c$ = 1.81 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim. - P$_a$ = 2.4 bar - P$_c$ = 2.2 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim. - P$_a$ = 2.4 bar - P$_c$ = 2.2 bar' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 4 ), label = 'Sim. - P$_a$ = 2.8 bar - P$_c$ = 2.6 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 4 ), label = 'Sim. - P$_a$ = 2.8 bar - P$_c$ = 2.6 bar' ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 5 ), label = 'Sim. - T = 62 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_62\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 5 ), label = 'Sim. - T = 62 \u00b0C' ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 6 ), label = 'Sim. - T = 76 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_76\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 6 ), label = 'Sim. - T = 76 \u00b0C' ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 7 ), label = 'Sim. - T = 84 \u00b0C' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"ZSW-GenStack_T_84\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 7 ), label = 'Sim. - T = 84 \u00b0C' ) # EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_1.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Sim. - P = 1.5 bar' ) elif type_fuel_cell == \"EH-31_2.0\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = 'Sim. - P = 2.0 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.0\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : if type_control == \"Phi_des\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 5 ), label = r 'Sim. - P = 2.0 bar - controlled $\\mathregular{\\Phi_ {des} }$' ) else : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 1 ), label = r 'Sim. - P = 2.0 bar - uncontrolled $\\mathregular{\\Phi_ {des} }$' ) elif type_fuel_cell == \"EH-31_2.25\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.25\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 2 ), label = 'Sim. - P = 2.25 bar' ) elif type_fuel_cell == \"EH-31_2.5\" and ( type_auxiliary == \"forced-convective_cathode_with_flow-through_anode\" or type_auxiliary == \"no_auxiliary\" ): ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' + r ' - $\u0394U_ {max} $ =' f ' { sim_error } %' ) elif type_fuel_cell == \"EH-31_2.5\" and type_auxiliary != \"forced-convective_cathode_with_flow-through_anode\" and type_auxiliary != \"no_auxiliary\" : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 3 ), label = 'Sim - P = 2.5 bar' ) # For other fuel cell else : ax . scatter ( x , y , marker = 'o' , linewidths = 1.5 , color = colors ( 0 ), label = 'Simulation' ) else : raise ValueError ( 'Only \"polarization_current\" and \"polarization_current_for_cali\" are considered here.' )","title":"plot_specific_line"},{"location":"functions/modules/display_modules/#modules.display_modules.plot_v","text":"This function plots the velocity at the anode and the cathode as a function of time. Parameters: variables ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. parameters \u2013 Parameters of the fuel cell model. ax ( Axes ) \u2013 Axes on which the pressure will be plotted. Source code in modules/display_modules.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 def plot_v ( variables , parameters , ax ): \"\"\"This function plots the velocity at the anode and the cathode as a function of time. Parameters ---------- variables : dict Variables calculated by the solver. They correspond to the fuel cell internal states. parameters: dict Parameters of the fuel cell model. ax : matplotlib.axes.Axes Axes on which the pressure will be plotted. \"\"\" # Extraction of the parameters nb_gc , type_current , type_plot = parameters [ 'nb_gc' ], parameters [ 'type_current' ], parameters [ 'type_plot' ] if type_current == 'step' : delta_t_ini = parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] elif type_current == 'polarization' : delta_t_ini = parameters [ 'pola_current_parameters' ][ 'delta_t_ini_pola' ] elif type_current == 'polarization_for_cali' : delta_t_ini = parameters [ 'pola_current_for_cali_parameters' ][ 'delta_t_ini_pola_cali' ] else : delta_t_ini = 0 # Extraction of the variables if type_plot == \"fixed\" : mask = np . array ( variables [ 't' ]) >= 0.9 * delta_t_ini # select the time after 0.9*delta_t_ini else : # type_plot == \"dynamic\" mask = np . ones_like ( variables [ 't' ], dtype = bool ) t = np . array ( variables [ 't' ]) v_a_in_t = np . array ( variables [ 'v_a_in' ]) v_c_in_t = np . array ( variables [ 'v_c_in' ]) # Plot the pressure at different spatial localisations: P ax . plot ( t , v_a_in_t , color = colors ( 0 )) ax . plot ( t , v_c_in_t , color = colors ( 6 )) ax . legend ([ r '$\\mathregular{v_{a,in}}$' , r '$\\mathregular{v_{c,in}}$' ], loc = 'best' ) ax . set_xlabel ( r '$\\mathbf {Time} $ $\\mathbf {t} $ $\\mathbf{\\left( s \\right)}$' , labelpad = 3 ) ax . set_ylabel ( r '$\\mathbf{Inlet velocities}$ $\\mathbf {v} $ $\\mathbf{\\left( m.s^{-1} \\right)}$' , labelpad = 3 ) ax . ticklabel_format ( style = 'scientific' , axis = 'y' , scilimits = ( 0 , 0 )) # Plot instructions plot_general_instructions ( ax )","title":"plot_v"},{"location":"functions/modules/display_modules/#modules.display_modules.round_nice","text":"Round the main step to a \"nice\" number. Parameters: x ( float ) \u2013 The value to be rounded. Returns: float \u2013 The value rounded to a \"nice\" number. Source code in modules/display_modules.py 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 def round_nice ( x ): \"\"\"Round the main step to a \"nice\" number. Parameters ---------- x : float The value to be rounded. Returns ------- float The value rounded to a \"nice\" number. \"\"\" exp = np . floor ( np . log10 ( x )) f = x / 10 ** exp if f < 1.5 : nice = 1 elif f < 3 : nice = 2 elif f < 7 : nice = 5 else : nice = 10 return nice * 10 ** exp","title":"round_nice"},{"location":"functions/modules/flows_modules/","text":"Flows modules This module is used to calculate intermediate values for the flows calculation. flows_int_values ( sv , i_fc , operating_inputs , parameters ) This functions calculates intermediate values for the flows calculation. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc ( float ) \u2013 Current density of the fuel cell (A/m\u00b2). parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Pagc ( float ) \u2013 Global pressure in the anode gas channel (Pa). Pcgc ( float ) \u2013 Global pressure in the cathode gas channel (Pa). lambda_acl_mem ( float ) \u2013 Water content in the ACL and the membrane (kg/kg). Source code in modules/flows_modules.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def flows_int_values ( sv , i_fc , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the flows calculation. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc : float Current density of the fuel cell (A/m\u00b2). parameters : dict Parameters of the fuel cell model. Returns ------- Pagc : float Global pressure in the anode gas channel (Pa). Pcgc : float Global pressure in the cathode gas channel (Pa). lambda_acl_mem : float Water content in the ACL and the membrane (kg/kg). \"\"\" # Extraction of the variables C_v_acl , C_v_ccl = sv [ 'C_v_acl' ], sv [ 'C_v_ccl' ] s_acl , s_ccl = sv [ 's_acl' ], sv [ 's_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] # Extraction of the operating inputs and the parameters T_des = operating_inputs [ 'T_des' ] epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] e , Hacl , Hccl , Hmem = parameters [ 'e' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'Hmem' ] Hgdl , Hmpl , Wagc , Wcgc = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Wagc' ], parameters [ 'Wcgc' ] nb_gc , nb_gdl , nb_mpl = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] # Transitory parameter H_gdl_node = Hgdl / nb_gdl H_mpl_node = Hmpl / nb_mpl C_N2_a_mean = ( sum ( sv [ f 'C_N2_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) C_N2_c_mean = ( sum ( sv [ f 'C_N2_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) # Pressures in the stack Pagc = [ None ] + [( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) * R * sv [ f 'T_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )] Pagdl = [ None ] + [( sv [ f 'C_v_agdl_ { i } ' ] + sv [ f 'C_H2_agdl_ { i } ' ] + C_N2_a_mean ) * R * sv [ f 'T_agdl_ { i } ' ] for i in range ( 1 , nb_gdl + 1 )] Pampl = [ None ] + [( sv [ f 'C_v_ampl_ { i } ' ] + sv [ f 'C_H2_ampl_ { i } ' ] + C_N2_a_mean ) * R * sv [ f 'T_ampl_ { i } ' ] for i in range ( 1 , nb_mpl + 1 )] Pacl = ( C_v_acl + C_H2_acl + C_N2_a_mean ) * R * T_acl Pccl = ( C_v_ccl + C_O2_ccl + C_N2_c_mean ) * R * T_ccl Pcmpl = [ None ] + [( sv [ f 'C_v_cmpl_ { i } ' ] + sv [ f 'C_O2_cmpl_ { i } ' ] + C_N2_c_mean ) * R * sv [ f 'T_cmpl_ { i } ' ] for i in range ( 1 , nb_mpl + 1 )] Pcgdl = [ None ] + [( sv [ f 'C_v_cgdl_ { i } ' ] + sv [ f 'C_O2_cgdl_ { i } ' ] + C_N2_c_mean ) * R * sv [ f 'T_cgdl_ { i } ' ] for i in range ( 1 , nb_gdl + 1 )] Pcgc = [ None ] + [( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) * R * sv [ f 'T_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )] # Weighted mean values ... # ... of the EOD flow of water in the membrane J_EOD_acl_mem = 2.5 / 22 * i_fc / F * interpolate ([ lambda_acl , lambda_mem ], [ Hacl , Hmem ]) J_EOD_mem_ccl = 2.5 / 22 * i_fc / F * interpolate ([ lambda_mem , lambda_ccl ], [ Hmem , Hccl ]) # ... of the diffusion coefficient of water in the membrane D_acl_mem = hmean ([ D ( lambda_acl ), D ( lambda_mem )], weights = [ Hacl / ( Hacl + Hmem ), Hmem / ( Hacl + Hmem )]) D_mem_ccl = hmean ([ D ( lambda_mem ), D ( lambda_ccl )], weights = [ Hmem / ( Hmem + Hccl ), Hccl / ( Hmem + Hccl )]) # ... of the capillary coefficient D_cap_agdl_agdl = [ None ] + [ hmean ([ Dcap ( 'gdl' , sv [ f 's_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'gdl' , sv [ f 's_agdl_ { i + 1 } ' ], sv [ f 'T_agdl_ { i + 1 } ' ], epsilon_gdl , e , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] D_cap_agdl_ampl = hmean ([ Dcap ( 'gdl' , sv [ f 's_agdl_ { nb_gdl } ' ], sv [ f 'T_agdl_ { nb_gdl } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'mpl' , sv [ 's_ampl_1' ], sv [ 'T_ampl_1' ], epsilon_mpl , e )], weights = [ H_gdl_node / ( H_gdl_node + H_mpl_node ), H_mpl_node / ( H_gdl_node + H_mpl_node )]) D_cap_ampl_ampl = [ None ] + [ hmean ([ Dcap ( 'mpl' , sv [ f 's_ampl_ { i } ' ], sv [ f 'T_ampl_ { i } ' ], epsilon_mpl , e ), Dcap ( 'mpl' , sv [ f 's_ampl_ { i + 1 } ' ], sv [ f 'T_ampl_ { i + 1 } ' ], epsilon_mpl , e )]) for i in range ( 1 , nb_mpl )] D_cap_ampl_acl = hmean ([ Dcap ( 'mpl' , sv [ f 's_ampl_ { nb_mpl } ' ], sv [ f 'T_ampl_ { nb_mpl } ' ], epsilon_mpl , e ), Dcap ( 'cl' , s_acl , T_acl , epsilon_cl , e )], weights = [ H_mpl_node / ( H_mpl_node + Hacl ), Hacl / ( H_mpl_node + Hacl )]) D_cap_ccl_cmpl = hmean ([ Dcap ( 'cl' , s_ccl , T_ccl , epsilon_cl , e ), Dcap ( 'mpl' , sv [ 's_cmpl_1' ], sv [ 'T_cmpl_1' ], epsilon_mpl , e )], weights = [ Hccl / ( Hccl + H_mpl_node ), H_mpl_node / ( Hccl + H_mpl_node )]) D_cap_cmpl_cmpl = [ None ] + [ hmean ([ Dcap ( 'mpl' , sv [ f 's_cmpl_ { i } ' ], sv [ f 'T_cmpl_ { i } ' ], epsilon_mpl , e ), Dcap ( 'mpl' , sv [ f 's_cmpl_ { i + 1 } ' ], sv [ f 'T_cmpl_ { i + 1 } ' ], epsilon_mpl , e )]) for i in range ( 1 , nb_mpl )] D_cap_cmpl_cgdl = hmean ([ Dcap ( 'mpl' , sv [ f 's_cmpl_ { nb_mpl } ' ], sv [ f 'T_cmpl_ { nb_mpl } ' ], epsilon_mpl , e ), Dcap ( 'gdl' , sv [ 's_cgdl_1' ], sv [ 'T_cgdl_1' ], epsilon_gdl , e , epsilon_c = epsilon_c )], weights = [ H_mpl_node / ( H_mpl_node + H_gdl_node ), H_gdl_node / ( H_mpl_node + H_gdl_node )]) D_cap_cgdl_cgdl = [ None ] + [ hmean ([ Dcap ( 'gdl' , sv [ f 's_cgdl_ { i } ' ], sv [ f 'T_cgdl_ { i } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'gdl' , sv [ f 's_cgdl_ { i + 1 } ' ], sv [ f 'T_cgdl_ { i + 1 } ' ], epsilon_gdl , e , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] # ... of the effective diffusion coefficient Da_eff_agdl_agdl = [ None ] + [ hmean ([ Da_eff ( 'gdl' , sv [ f 's_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], Pagdl [ i ], epsilon_gdl , epsilon_c = epsilon_c ), Da_eff ( 'gdl' , sv [ f 's_agdl_ { i + 1 } ' ], sv [ f 'T_agdl_ { i + 1 } ' ], Pagdl [ i + 1 ], epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] Da_eff_agdl_ampl = hmean ([ Da_eff ( 'gdl' , sv [ f 's_agdl_ { nb_gdl } ' ], sv [ f 'T_agdl_ { nb_gdl } ' ], Pagdl [ nb_gdl ], epsilon_gdl , epsilon_c = epsilon_c ), Da_eff ( 'mpl' , sv [ 's_ampl_1' ], sv [ 'T_ampl_1' ], Pampl [ 1 ], epsilon_mpl )], weights = [ H_gdl_node / ( H_gdl_node + H_mpl_node ), H_mpl_node / ( H_gdl_node + H_mpl_node )]) Da_eff_ampl_ampl = [ None ] + [ hmean ([ Da_eff ( 'mpl' , sv [ f 's_ampl_ { i } ' ], sv [ f 'T_ampl_ { i } ' ], Pampl [ i ], epsilon_mpl ), Da_eff ( 'mpl' , sv [ f 's_ampl_ { i + 1 } ' ], sv [ f 'T_ampl_ { i + 1 } ' ], Pampl [ i + 1 ], epsilon_mpl )]) for i in range ( 1 , nb_mpl )] Da_eff_ampl_acl = hmean ([ Da_eff ( 'mpl' , sv [ f 's_ampl_ { nb_mpl } ' ], sv [ f 'T_ampl_ { nb_mpl } ' ], Pampl [ nb_mpl ], epsilon_mpl ), Da_eff ( 'cl' , s_acl , T_acl , Pacl , epsilon_cl )], weights = [ H_mpl_node / ( H_mpl_node + Hacl ), Hacl / ( H_mpl_node + Hacl )]) Dc_eff_ccl_cmpl = hmean ([ Dc_eff ( 'cl' , s_ccl , T_ccl , Pccl , epsilon_cl ), Dc_eff ( 'mpl' , sv [ 's_cmpl_1' ], sv [ 'T_cmpl_1' ], Pcmpl [ 1 ], epsilon_mpl )], weights = [ Hccl / ( H_mpl_node + Hccl ), H_mpl_node / ( H_mpl_node + Hccl )]) Dc_eff_cmpl_cmpl = [ None ] + [ hmean ([ Dc_eff ( 'mpl' , sv [ f 's_cmpl_ { i } ' ], sv [ f 'T_cmpl_ { i } ' ], Pcmpl [ i ], epsilon_mpl ), Dc_eff ( 'mpl' , sv [ f 's_cmpl_ { i + 1 } ' ], sv [ f 'T_cmpl_ { i + 1 } ' ], Pcmpl [ i + 1 ], epsilon_mpl )]) for i in range ( 1 , nb_mpl )] Dc_eff_cmpl_cgdl = hmean ([ Dc_eff ( 'mpl' , sv [ f 's_cmpl_ { nb_mpl } ' ], sv [ f 'T_cmpl_ { nb_mpl } ' ], Pcmpl [ nb_mpl ], epsilon_mpl ), Dc_eff ( 'gdl' , sv [ 's_cgdl_1' ], sv [ 'T_cgdl_1' ], Pcgdl [ 1 ], epsilon_gdl , epsilon_c = epsilon_c )], weights = [ H_mpl_node / ( H_mpl_node + H_gdl_node ), H_gdl_node / ( H_mpl_node + H_gdl_node )]) Dc_eff_cgdl_cgdl = [ None ] + [ hmean ([ Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { i } ' ], sv [ f 'T_cgdl_ { i } ' ], Pcgdl [ i ], epsilon_gdl , epsilon_c = epsilon_c ), Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { i + 1 } ' ], sv [ f 'T_cgdl_ { i + 1 } ' ], Pcgdl [ i + 1 ], epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] # ... of the temperature T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) return ( H_gdl_node , H_mpl_node , Pagc , Pcgc , J_EOD_acl_mem , J_EOD_mem_ccl , D_acl_mem , D_mem_ccl , D_cap_agdl_agdl , D_cap_agdl_ampl , D_cap_ampl_ampl , D_cap_ampl_acl , D_cap_ccl_cmpl , D_cap_cmpl_cmpl , D_cap_cmpl_cgdl , D_cap_cgdl_cgdl , Da_eff_agdl_agdl , Da_eff_agdl_ampl , Da_eff_ampl_ampl , Da_eff_ampl_acl , Dc_eff_ccl_cmpl , Dc_eff_cmpl_cmpl , Dc_eff_cmpl_cgdl , Dc_eff_cgdl_cgdl , T_acl_mem_ccl )","title":"Flows modules"},{"location":"functions/modules/flows_modules/#flows-modules","text":"This module is used to calculate intermediate values for the flows calculation.","title":"Flows modules"},{"location":"functions/modules/flows_modules/#modules.flows_modules.flows_int_values","text":"This functions calculates intermediate values for the flows calculation. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc ( float ) \u2013 Current density of the fuel cell (A/m\u00b2). parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: Pagc ( float ) \u2013 Global pressure in the anode gas channel (Pa). Pcgc ( float ) \u2013 Global pressure in the cathode gas channel (Pa). lambda_acl_mem ( float ) \u2013 Water content in the ACL and the membrane (kg/kg). Source code in modules/flows_modules.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def flows_int_values ( sv , i_fc , operating_inputs , parameters ): \"\"\"This functions calculates intermediate values for the flows calculation. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. i_fc : float Current density of the fuel cell (A/m\u00b2). parameters : dict Parameters of the fuel cell model. Returns ------- Pagc : float Global pressure in the anode gas channel (Pa). Pcgc : float Global pressure in the cathode gas channel (Pa). lambda_acl_mem : float Water content in the ACL and the membrane (kg/kg). \"\"\" # Extraction of the variables C_v_acl , C_v_ccl = sv [ 'C_v_acl' ], sv [ 'C_v_ccl' ] s_acl , s_ccl = sv [ 's_acl' ], sv [ 's_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] # Extraction of the operating inputs and the parameters T_des = operating_inputs [ 'T_des' ] epsilon_gdl , epsilon_cl = parameters [ 'epsilon_gdl' ], parameters [ 'epsilon_cl' ] epsilon_mpl , epsilon_c = parameters [ 'epsilon_mpl' ], parameters [ 'epsilon_c' ] e , Hacl , Hccl , Hmem = parameters [ 'e' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ], parameters [ 'Hmem' ] Hgdl , Hmpl , Wagc , Wcgc = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Wagc' ], parameters [ 'Wcgc' ] nb_gc , nb_gdl , nb_mpl = parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] # Transitory parameter H_gdl_node = Hgdl / nb_gdl H_mpl_node = Hmpl / nb_mpl C_N2_a_mean = ( sum ( sv [ f 'C_N2_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) C_N2_c_mean = ( sum ( sv [ f 'C_N2_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) # Pressures in the stack Pagc = [ None ] + [( sv [ f 'C_v_agc_ { i } ' ] + sv [ f 'C_H2_agc_ { i } ' ] + sv [ f 'C_N2_agc_ { i } ' ]) * R * sv [ f 'T_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )] Pagdl = [ None ] + [( sv [ f 'C_v_agdl_ { i } ' ] + sv [ f 'C_H2_agdl_ { i } ' ] + C_N2_a_mean ) * R * sv [ f 'T_agdl_ { i } ' ] for i in range ( 1 , nb_gdl + 1 )] Pampl = [ None ] + [( sv [ f 'C_v_ampl_ { i } ' ] + sv [ f 'C_H2_ampl_ { i } ' ] + C_N2_a_mean ) * R * sv [ f 'T_ampl_ { i } ' ] for i in range ( 1 , nb_mpl + 1 )] Pacl = ( C_v_acl + C_H2_acl + C_N2_a_mean ) * R * T_acl Pccl = ( C_v_ccl + C_O2_ccl + C_N2_c_mean ) * R * T_ccl Pcmpl = [ None ] + [( sv [ f 'C_v_cmpl_ { i } ' ] + sv [ f 'C_O2_cmpl_ { i } ' ] + C_N2_c_mean ) * R * sv [ f 'T_cmpl_ { i } ' ] for i in range ( 1 , nb_mpl + 1 )] Pcgdl = [ None ] + [( sv [ f 'C_v_cgdl_ { i } ' ] + sv [ f 'C_O2_cgdl_ { i } ' ] + C_N2_c_mean ) * R * sv [ f 'T_cgdl_ { i } ' ] for i in range ( 1 , nb_gdl + 1 )] Pcgc = [ None ] + [( sv [ f 'C_v_cgc_ { i } ' ] + sv [ f 'C_O2_cgc_ { i } ' ] + sv [ f 'C_N2_cgc_ { i } ' ]) * R * sv [ f 'T_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )] # Weighted mean values ... # ... of the EOD flow of water in the membrane J_EOD_acl_mem = 2.5 / 22 * i_fc / F * interpolate ([ lambda_acl , lambda_mem ], [ Hacl , Hmem ]) J_EOD_mem_ccl = 2.5 / 22 * i_fc / F * interpolate ([ lambda_mem , lambda_ccl ], [ Hmem , Hccl ]) # ... of the diffusion coefficient of water in the membrane D_acl_mem = hmean ([ D ( lambda_acl ), D ( lambda_mem )], weights = [ Hacl / ( Hacl + Hmem ), Hmem / ( Hacl + Hmem )]) D_mem_ccl = hmean ([ D ( lambda_mem ), D ( lambda_ccl )], weights = [ Hmem / ( Hmem + Hccl ), Hccl / ( Hmem + Hccl )]) # ... of the capillary coefficient D_cap_agdl_agdl = [ None ] + [ hmean ([ Dcap ( 'gdl' , sv [ f 's_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'gdl' , sv [ f 's_agdl_ { i + 1 } ' ], sv [ f 'T_agdl_ { i + 1 } ' ], epsilon_gdl , e , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] D_cap_agdl_ampl = hmean ([ Dcap ( 'gdl' , sv [ f 's_agdl_ { nb_gdl } ' ], sv [ f 'T_agdl_ { nb_gdl } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'mpl' , sv [ 's_ampl_1' ], sv [ 'T_ampl_1' ], epsilon_mpl , e )], weights = [ H_gdl_node / ( H_gdl_node + H_mpl_node ), H_mpl_node / ( H_gdl_node + H_mpl_node )]) D_cap_ampl_ampl = [ None ] + [ hmean ([ Dcap ( 'mpl' , sv [ f 's_ampl_ { i } ' ], sv [ f 'T_ampl_ { i } ' ], epsilon_mpl , e ), Dcap ( 'mpl' , sv [ f 's_ampl_ { i + 1 } ' ], sv [ f 'T_ampl_ { i + 1 } ' ], epsilon_mpl , e )]) for i in range ( 1 , nb_mpl )] D_cap_ampl_acl = hmean ([ Dcap ( 'mpl' , sv [ f 's_ampl_ { nb_mpl } ' ], sv [ f 'T_ampl_ { nb_mpl } ' ], epsilon_mpl , e ), Dcap ( 'cl' , s_acl , T_acl , epsilon_cl , e )], weights = [ H_mpl_node / ( H_mpl_node + Hacl ), Hacl / ( H_mpl_node + Hacl )]) D_cap_ccl_cmpl = hmean ([ Dcap ( 'cl' , s_ccl , T_ccl , epsilon_cl , e ), Dcap ( 'mpl' , sv [ 's_cmpl_1' ], sv [ 'T_cmpl_1' ], epsilon_mpl , e )], weights = [ Hccl / ( Hccl + H_mpl_node ), H_mpl_node / ( Hccl + H_mpl_node )]) D_cap_cmpl_cmpl = [ None ] + [ hmean ([ Dcap ( 'mpl' , sv [ f 's_cmpl_ { i } ' ], sv [ f 'T_cmpl_ { i } ' ], epsilon_mpl , e ), Dcap ( 'mpl' , sv [ f 's_cmpl_ { i + 1 } ' ], sv [ f 'T_cmpl_ { i + 1 } ' ], epsilon_mpl , e )]) for i in range ( 1 , nb_mpl )] D_cap_cmpl_cgdl = hmean ([ Dcap ( 'mpl' , sv [ f 's_cmpl_ { nb_mpl } ' ], sv [ f 'T_cmpl_ { nb_mpl } ' ], epsilon_mpl , e ), Dcap ( 'gdl' , sv [ 's_cgdl_1' ], sv [ 'T_cgdl_1' ], epsilon_gdl , e , epsilon_c = epsilon_c )], weights = [ H_mpl_node / ( H_mpl_node + H_gdl_node ), H_gdl_node / ( H_mpl_node + H_gdl_node )]) D_cap_cgdl_cgdl = [ None ] + [ hmean ([ Dcap ( 'gdl' , sv [ f 's_cgdl_ { i } ' ], sv [ f 'T_cgdl_ { i } ' ], epsilon_gdl , e , epsilon_c = epsilon_c ), Dcap ( 'gdl' , sv [ f 's_cgdl_ { i + 1 } ' ], sv [ f 'T_cgdl_ { i + 1 } ' ], epsilon_gdl , e , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] # ... of the effective diffusion coefficient Da_eff_agdl_agdl = [ None ] + [ hmean ([ Da_eff ( 'gdl' , sv [ f 's_agdl_ { i } ' ], sv [ f 'T_agdl_ { i } ' ], Pagdl [ i ], epsilon_gdl , epsilon_c = epsilon_c ), Da_eff ( 'gdl' , sv [ f 's_agdl_ { i + 1 } ' ], sv [ f 'T_agdl_ { i + 1 } ' ], Pagdl [ i + 1 ], epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] Da_eff_agdl_ampl = hmean ([ Da_eff ( 'gdl' , sv [ f 's_agdl_ { nb_gdl } ' ], sv [ f 'T_agdl_ { nb_gdl } ' ], Pagdl [ nb_gdl ], epsilon_gdl , epsilon_c = epsilon_c ), Da_eff ( 'mpl' , sv [ 's_ampl_1' ], sv [ 'T_ampl_1' ], Pampl [ 1 ], epsilon_mpl )], weights = [ H_gdl_node / ( H_gdl_node + H_mpl_node ), H_mpl_node / ( H_gdl_node + H_mpl_node )]) Da_eff_ampl_ampl = [ None ] + [ hmean ([ Da_eff ( 'mpl' , sv [ f 's_ampl_ { i } ' ], sv [ f 'T_ampl_ { i } ' ], Pampl [ i ], epsilon_mpl ), Da_eff ( 'mpl' , sv [ f 's_ampl_ { i + 1 } ' ], sv [ f 'T_ampl_ { i + 1 } ' ], Pampl [ i + 1 ], epsilon_mpl )]) for i in range ( 1 , nb_mpl )] Da_eff_ampl_acl = hmean ([ Da_eff ( 'mpl' , sv [ f 's_ampl_ { nb_mpl } ' ], sv [ f 'T_ampl_ { nb_mpl } ' ], Pampl [ nb_mpl ], epsilon_mpl ), Da_eff ( 'cl' , s_acl , T_acl , Pacl , epsilon_cl )], weights = [ H_mpl_node / ( H_mpl_node + Hacl ), Hacl / ( H_mpl_node + Hacl )]) Dc_eff_ccl_cmpl = hmean ([ Dc_eff ( 'cl' , s_ccl , T_ccl , Pccl , epsilon_cl ), Dc_eff ( 'mpl' , sv [ 's_cmpl_1' ], sv [ 'T_cmpl_1' ], Pcmpl [ 1 ], epsilon_mpl )], weights = [ Hccl / ( H_mpl_node + Hccl ), H_mpl_node / ( H_mpl_node + Hccl )]) Dc_eff_cmpl_cmpl = [ None ] + [ hmean ([ Dc_eff ( 'mpl' , sv [ f 's_cmpl_ { i } ' ], sv [ f 'T_cmpl_ { i } ' ], Pcmpl [ i ], epsilon_mpl ), Dc_eff ( 'mpl' , sv [ f 's_cmpl_ { i + 1 } ' ], sv [ f 'T_cmpl_ { i + 1 } ' ], Pcmpl [ i + 1 ], epsilon_mpl )]) for i in range ( 1 , nb_mpl )] Dc_eff_cmpl_cgdl = hmean ([ Dc_eff ( 'mpl' , sv [ f 's_cmpl_ { nb_mpl } ' ], sv [ f 'T_cmpl_ { nb_mpl } ' ], Pcmpl [ nb_mpl ], epsilon_mpl ), Dc_eff ( 'gdl' , sv [ 's_cgdl_1' ], sv [ 'T_cgdl_1' ], Pcgdl [ 1 ], epsilon_gdl , epsilon_c = epsilon_c )], weights = [ H_mpl_node / ( H_mpl_node + H_gdl_node ), H_gdl_node / ( H_mpl_node + H_gdl_node )]) Dc_eff_cgdl_cgdl = [ None ] + [ hmean ([ Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { i } ' ], sv [ f 'T_cgdl_ { i } ' ], Pcgdl [ i ], epsilon_gdl , epsilon_c = epsilon_c ), Dc_eff ( 'gdl' , sv [ f 's_cgdl_ { i + 1 } ' ], sv [ f 'T_cgdl_ { i + 1 } ' ], Pcgdl [ i + 1 ], epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] # ... of the temperature T_acl_mem_ccl = average ([ T_acl , T_mem , T_ccl ], weights = [ Hacl / ( Hacl + Hmem + Hccl ), Hmem / ( Hacl + Hmem + Hccl ), Hccl / ( Hacl + Hmem + Hccl )]) return ( H_gdl_node , H_mpl_node , Pagc , Pcgc , J_EOD_acl_mem , J_EOD_mem_ccl , D_acl_mem , D_mem_ccl , D_cap_agdl_agdl , D_cap_agdl_ampl , D_cap_ampl_ampl , D_cap_ampl_acl , D_cap_ccl_cmpl , D_cap_cmpl_cmpl , D_cap_cmpl_cgdl , D_cap_cgdl_cgdl , Da_eff_agdl_agdl , Da_eff_agdl_ampl , Da_eff_ampl_ampl , Da_eff_ampl_acl , Dc_eff_ccl_cmpl , Dc_eff_cmpl_cmpl , Dc_eff_cmpl_cgdl , Dc_eff_cgdl_cgdl , T_acl_mem_ccl )","title":"flows_int_values"},{"location":"functions/modules/heat_modules/","text":"Heat modules This module is used to calculate intermediate values for the heat transfer calculation. heat_transfer_int_values ( sv , parameters ) This functions calculates intermediate values for the heat calculation. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: k_th_eff_agc_agdl ( float ) \u2013 Effective thermal diffusivity between the AGC and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_agdl_agdl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent GDL layers on the anode side (J.m-1.s-1.K-1). k_th_eff_agdl_atl ( float ) \u2013 Effective thermal diffusivity between the last GDL layer and the anode transport layer (J.m-1.s-1.K-1). k_th_eff_atl_atl ( list ) \u2013 List of effective thermal diffusivities between adjacent transport layers on the anode side (J.m-1.s-1.K-1). k_th_eff_atl_ampl ( float ) \u2013 Effective thermal diffusivity between the anode transport layer and the first microporous layer (J.m-1.s-1.K-1). k_th_eff_ampl_ampl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent microporous layers on the anode side (J.m-1.s-1.K-1). k_th_eff_ampl_acl ( float ) \u2013 Effective thermal diffusivity between the anode microporous layer and the anode catalyst layer (J.m-1.s-1.K-1). k_th_eff_acl_mem ( float ) \u2013 Effective thermal diffusivity between the anode catalyst layer and the membrane (J.m-1.s-1.K-1). k_th_eff_mem_ccl ( float ) \u2013 Effective thermal diffusivity between the membrane and the cathode catalyst layer (J.m-1.s-1.K-1). k_th_eff_ccl_cmpl ( float ) \u2013 Effective thermal diffusivity between the cathode catalyst layer and the cathode microporous layer (J.m-1.s-1.K-1). k_th_eff_cmpl_cmpl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent microporous layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cmpl_ctl ( float ) \u2013 Effective thermal diffusivity between the last microporous layer and the cathode transport layer (J.m-1.s-1.K-1). k_th_eff_ctl_ctl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent transport layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_ctl_cgdl ( float ) \u2013 Effective thermal diffusivity between the cathode transport layer and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_cgdl_cgdl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent GDL layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cgdl_cgc ( float ) \u2013 Effective thermal diffusivity between the last GDL layer and the CGC (J.m-1.s-1.K-1). Source code in modules/heat_modules.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def heat_transfer_int_values ( sv , parameters ): \"\"\"This functions calculates intermediate values for the heat calculation. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. parameters : dict Parameters of the fuel cell model. Returns ------- k_th_eff_agc_agdl : float Effective thermal diffusivity between the AGC and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_agdl_agdl : list of floats List of effective thermal diffusivities between adjacent GDL layers on the anode side (J.m-1.s-1.K-1). k_th_eff_agdl_atl : float Effective thermal diffusivity between the last GDL layer and the anode transport layer (J.m-1.s-1.K-1). k_th_eff_atl_atl : list List of effective thermal diffusivities between adjacent transport layers on the anode side (J.m-1.s-1.K-1). k_th_eff_atl_ampl : float Effective thermal diffusivity between the anode transport layer and the first microporous layer (J.m-1.s-1.K-1). k_th_eff_ampl_ampl : list of floats List of effective thermal diffusivities between adjacent microporous layers on the anode side (J.m-1.s-1.K-1). k_th_eff_ampl_acl : float Effective thermal diffusivity between the anode microporous layer and the anode catalyst layer (J.m-1.s-1.K-1). k_th_eff_acl_mem : float Effective thermal diffusivity between the anode catalyst layer and the membrane (J.m-1.s-1.K-1). k_th_eff_mem_ccl : float Effective thermal diffusivity between the membrane and the cathode catalyst layer (J.m-1.s-1.K-1). k_th_eff_ccl_cmpl : float Effective thermal diffusivity between the cathode catalyst layer and the cathode microporous layer (J.m-1.s-1.K-1). k_th_eff_cmpl_cmpl : list of floats List of effective thermal diffusivities between adjacent microporous layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cmpl_ctl : float Effective thermal diffusivity between the last microporous layer and the cathode transport layer (J.m-1.s-1.K-1). k_th_eff_ctl_ctl : list of floats List of effective thermal diffusivities between adjacent transport layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_ctl_cgdl : float Effective thermal diffusivity between the cathode transport layer and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_cgdl_cgdl : list of floats List of effective thermal diffusivities between adjacent GDL layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cgdl_cgc : float Effective thermal diffusivity between the last GDL layer and the CGC (J.m-1.s-1.K-1). \"\"\" # Extraction of the variables C_v_acl , C_v_ccl = sv [ 'C_v_acl' ], sv [ 'C_v_ccl' ] s_acl , s_ccl = sv [ 's_acl' ], sv [ 's_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] # Extraction of the operating inputs and the parameters Hgdl , Hmpl , Hacl , Hccl = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] Hmem , epsilon_mc , epsilon_gdl = parameters [ 'Hmem' ], parameters [ 'epsilon_mc' ], parameters [ 'epsilon_gdl' ] epsilon_cl , epsilon_mpl = parameters [ 'epsilon_cl' ], parameters [ 'epsilon_mpl' ] epsilon_c , nb_gc , nb_gdl , nb_mpl = parameters [ 'epsilon_c' ], parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] # Calculation of intermediate values C_N2_a_mean = ( sum ( sv [ f 'C_N2_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) C_N2_c_mean = ( sum ( sv [ f 'C_N2_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) Hgdl_node = Hgdl / nb_gdl Hmpl_node = Hmpl / nb_mpl # Weighted harmonic means of the effective thermal diffusivity k_th_eff_agc_agdl = k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { 1 } ' ], C_v = sv [ f 'C_v_agdl_ { 1 } ' ], s = sv [ f 's_agdl_ { 1 } ' ], C_H2 = sv [ f 'C_H2_agdl_ { 1 } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ) k_th_eff_agdl_agdl = [ None ] + [ hmean ([ k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], s = sv [ f 's_agdl_ { i } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { i + 1 } ' ], C_v = sv [ f 'C_v_agdl_ { i + 1 } ' ], s = sv [ f 's_agdl_ { i + 1 } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i + 1 } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] k_th_eff_agdl_ampl = hmean ([ k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { nb_gdl } ' ], C_v = sv [ f 'C_v_agdl_ { nb_gdl } ' ], s = sv [ f 's_agdl_ { nb_gdl } ' ], C_H2 = sv [ f 'C_H2_agdl_ { nb_gdl } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'ampl' , sv [ f 'T_ampl_ { 1 } ' ], C_v = sv [ f 'C_v_ampl_ { 1 } ' ], s = sv [ f 's_ampl_ { 1 } ' ], C_H2 = sv [ f 'C_H2_ampl_ { 1 } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl )], weights = [ Hgdl_node / 2 , Hmpl_node / 2 ]) k_th_eff_ampl_ampl = [ None ] + [ hmean ([ k_th_eff ( 'ampl' , sv [ f 'T_ampl_ { i } ' ], C_v = sv [ f 'C_v_ampl_ { i } ' ], s = sv [ f 's_ampl_ { i } ' ], C_H2 = sv [ f 'C_H2_ampl_ { i } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl ), k_th_eff ( 'ampl' , sv [ f 'T_ampl_ { i + 1 } ' ], C_v = sv [ f 'C_v_ampl_ { i + 1 } ' ], s = sv [ f 's_ampl_ { i + 1 } ' ], C_H2 = sv [ f 'C_H2_ampl_ { i + 1 } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl )]) for i in range ( 1 , nb_mpl )] k_th_eff_ampl_acl = hmean ([ k_th_eff ( 'ampl' , sv [ f 'T_ampl_ { nb_mpl } ' ], C_v = sv [ f 'C_v_ampl_ { nb_mpl } ' ], s = sv [ f 's_ampl_ { nb_mpl } ' ], C_H2 = sv [ f 'C_H2_ampl_ { nb_mpl } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl ), k_th_eff ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , C_N2 = C_N2_a_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc )], weights = [ Hmpl_node / 2 , Hacl / 2 ]) k_th_eff_acl_mem = hmean ([ k_th_eff ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , C_N2 = C_N2_a_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'mem' , T_mem , lambdaa = lambda_mem )], weights = [ Hacl / 2 , Hmem / 2 ]) k_th_eff_mem_ccl = hmean ([ k_th_eff ( 'mem' , T_mem , lambdaa = lambda_mem ), k_th_eff ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2_c_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc )], weights = [ Hmem / 2 , Hccl / 2 ]) k_th_eff_ccl_cmpl = hmean ([ k_th_eff ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2_c_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'cmpl' , sv [ f 'T_cmpl_ { 1 } ' ], C_v = sv [ f 'C_v_cmpl_ { 1 } ' ], s = sv [ f 's_cmpl_ { 1 } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { 1 } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl )], weights = [ Hccl / 2 , Hmpl_node / 2 ]) k_th_eff_cmpl_cmpl = [ None ] + [ hmean ([ k_th_eff ( 'cmpl' , sv [ f 'T_cmpl_ { i } ' ], C_v = sv [ f 'C_v_cmpl_ { i } ' ], s = sv [ f 's_cmpl_ { i } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { i } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl ), k_th_eff ( 'cmpl' , sv [ f 'T_cmpl_ { i + 1 } ' ], C_v = sv [ f 'C_v_cmpl_ { i + 1 } ' ], s = sv [ f 's_cmpl_ { i + 1 } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { i + 1 } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl )]) for i in range ( 1 , nb_mpl )] k_th_eff_cmpl_cgdl = hmean ([ k_th_eff ( 'cmpl' , sv [ f 'T_cmpl_ { nb_mpl } ' ], C_v = sv [ f 'C_v_cmpl_ { nb_mpl } ' ], s = sv [ f 's_cmpl_ { nb_mpl } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { nb_mpl } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl ), k_th_eff ( 'cgdl' , sv [ 'T_cgdl_1' ], C_v = sv [ 'C_v_cgdl_1' ], s = sv [ 's_cgdl_1' ], C_O2 = sv [ f 'C_O2_cgdl_1' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hmpl_node / 2 , Hgdl_node / 2 ]) k_th_eff_cgdl_cgdl = [ None ] + [ hmean ([ k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], s = sv [ f 's_cgdl_ { i } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { i + 1 } ' ], C_v = sv [ f 'C_v_cgdl_ { i + 1 } ' ], s = sv [ f 's_cgdl_ { i + 1 } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i + 1 } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] k_th_eff_cgdl_cgc = k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { nb_gdl } ' ], C_v = sv [ f 'C_v_cgdl_ { nb_gdl } ' ], s = sv [ f 's_cgdl_ { nb_gdl } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { nb_gdl } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ) return ( Hgdl_node , Hmpl_node , k_th_eff_agc_agdl , k_th_eff_agdl_agdl , k_th_eff_agdl_ampl , k_th_eff_ampl_ampl , k_th_eff_ampl_acl , k_th_eff_acl_mem , k_th_eff_mem_ccl , k_th_eff_ccl_cmpl , k_th_eff_cmpl_cmpl , k_th_eff_cmpl_cgdl , k_th_eff_cgdl_cgdl , k_th_eff_cgdl_cgc )","title":"Heat modules"},{"location":"functions/modules/heat_modules/#heat-modules","text":"This module is used to calculate intermediate values for the heat transfer calculation.","title":"Heat modules"},{"location":"functions/modules/heat_modules/#modules.heat_modules.heat_transfer_int_values","text":"This functions calculates intermediate values for the heat calculation. Parameters: sv ( dict ) \u2013 Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. parameters ( dict ) \u2013 Parameters of the fuel cell model. Returns: k_th_eff_agc_agdl ( float ) \u2013 Effective thermal diffusivity between the AGC and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_agdl_agdl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent GDL layers on the anode side (J.m-1.s-1.K-1). k_th_eff_agdl_atl ( float ) \u2013 Effective thermal diffusivity between the last GDL layer and the anode transport layer (J.m-1.s-1.K-1). k_th_eff_atl_atl ( list ) \u2013 List of effective thermal diffusivities between adjacent transport layers on the anode side (J.m-1.s-1.K-1). k_th_eff_atl_ampl ( float ) \u2013 Effective thermal diffusivity between the anode transport layer and the first microporous layer (J.m-1.s-1.K-1). k_th_eff_ampl_ampl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent microporous layers on the anode side (J.m-1.s-1.K-1). k_th_eff_ampl_acl ( float ) \u2013 Effective thermal diffusivity between the anode microporous layer and the anode catalyst layer (J.m-1.s-1.K-1). k_th_eff_acl_mem ( float ) \u2013 Effective thermal diffusivity between the anode catalyst layer and the membrane (J.m-1.s-1.K-1). k_th_eff_mem_ccl ( float ) \u2013 Effective thermal diffusivity between the membrane and the cathode catalyst layer (J.m-1.s-1.K-1). k_th_eff_ccl_cmpl ( float ) \u2013 Effective thermal diffusivity between the cathode catalyst layer and the cathode microporous layer (J.m-1.s-1.K-1). k_th_eff_cmpl_cmpl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent microporous layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cmpl_ctl ( float ) \u2013 Effective thermal diffusivity between the last microporous layer and the cathode transport layer (J.m-1.s-1.K-1). k_th_eff_ctl_ctl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent transport layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_ctl_cgdl ( float ) \u2013 Effective thermal diffusivity between the cathode transport layer and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_cgdl_cgdl ( list of floats ) \u2013 List of effective thermal diffusivities between adjacent GDL layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cgdl_cgc ( float ) \u2013 Effective thermal diffusivity between the last GDL layer and the CGC (J.m-1.s-1.K-1). Source code in modules/heat_modules.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def heat_transfer_int_values ( sv , parameters ): \"\"\"This functions calculates intermediate values for the heat calculation. Parameters ---------- sv : dict Variables calculated by the solver. They correspond to the fuel cell internal states. sv is a contraction of solver_variables for enhanced readability. parameters : dict Parameters of the fuel cell model. Returns ------- k_th_eff_agc_agdl : float Effective thermal diffusivity between the AGC and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_agdl_agdl : list of floats List of effective thermal diffusivities between adjacent GDL layers on the anode side (J.m-1.s-1.K-1). k_th_eff_agdl_atl : float Effective thermal diffusivity between the last GDL layer and the anode transport layer (J.m-1.s-1.K-1). k_th_eff_atl_atl : list List of effective thermal diffusivities between adjacent transport layers on the anode side (J.m-1.s-1.K-1). k_th_eff_atl_ampl : float Effective thermal diffusivity between the anode transport layer and the first microporous layer (J.m-1.s-1.K-1). k_th_eff_ampl_ampl : list of floats List of effective thermal diffusivities between adjacent microporous layers on the anode side (J.m-1.s-1.K-1). k_th_eff_ampl_acl : float Effective thermal diffusivity between the anode microporous layer and the anode catalyst layer (J.m-1.s-1.K-1). k_th_eff_acl_mem : float Effective thermal diffusivity between the anode catalyst layer and the membrane (J.m-1.s-1.K-1). k_th_eff_mem_ccl : float Effective thermal diffusivity between the membrane and the cathode catalyst layer (J.m-1.s-1.K-1). k_th_eff_ccl_cmpl : float Effective thermal diffusivity between the cathode catalyst layer and the cathode microporous layer (J.m-1.s-1.K-1). k_th_eff_cmpl_cmpl : list of floats List of effective thermal diffusivities between adjacent microporous layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cmpl_ctl : float Effective thermal diffusivity between the last microporous layer and the cathode transport layer (J.m-1.s-1.K-1). k_th_eff_ctl_ctl : list of floats List of effective thermal diffusivities between adjacent transport layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_ctl_cgdl : float Effective thermal diffusivity between the cathode transport layer and the first GDL layer (J.m-1.s-1.K-1). k_th_eff_cgdl_cgdl : list of floats List of effective thermal diffusivities between adjacent GDL layers on the cathode side (J.m-1.s-1.K-1). k_th_eff_cgdl_cgc : float Effective thermal diffusivity between the last GDL layer and the CGC (J.m-1.s-1.K-1). \"\"\" # Extraction of the variables C_v_acl , C_v_ccl = sv [ 'C_v_acl' ], sv [ 'C_v_ccl' ] s_acl , s_ccl = sv [ 's_acl' ], sv [ 's_ccl' ] lambda_acl , lambda_mem , lambda_ccl = sv [ 'lambda_acl' ], sv [ 'lambda_mem' ], sv [ 'lambda_ccl' ] C_H2_acl , C_O2_ccl = sv [ 'C_H2_acl' ], sv [ 'C_O2_ccl' ] T_acl , T_mem , T_ccl = sv [ 'T_acl' ], sv [ 'T_mem' ], sv [ 'T_ccl' ] # Extraction of the operating inputs and the parameters Hgdl , Hmpl , Hacl , Hccl = parameters [ 'Hgdl' ], parameters [ 'Hmpl' ], parameters [ 'Hacl' ], parameters [ 'Hccl' ] Hmem , epsilon_mc , epsilon_gdl = parameters [ 'Hmem' ], parameters [ 'epsilon_mc' ], parameters [ 'epsilon_gdl' ] epsilon_cl , epsilon_mpl = parameters [ 'epsilon_cl' ], parameters [ 'epsilon_mpl' ] epsilon_c , nb_gc , nb_gdl , nb_mpl = parameters [ 'epsilon_c' ], parameters [ 'nb_gc' ], parameters [ 'nb_gdl' ], parameters [ 'nb_mpl' ] # Calculation of intermediate values C_N2_a_mean = ( sum ( sv [ f 'C_N2_agc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) C_N2_c_mean = ( sum ( sv [ f 'C_N2_cgc_ { i } ' ] for i in range ( 1 , nb_gc + 1 )) / nb_gc ) Hgdl_node = Hgdl / nb_gdl Hmpl_node = Hmpl / nb_mpl # Weighted harmonic means of the effective thermal diffusivity k_th_eff_agc_agdl = k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { 1 } ' ], C_v = sv [ f 'C_v_agdl_ { 1 } ' ], s = sv [ f 's_agdl_ { 1 } ' ], C_H2 = sv [ f 'C_H2_agdl_ { 1 } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ) k_th_eff_agdl_agdl = [ None ] + [ hmean ([ k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { i } ' ], C_v = sv [ f 'C_v_agdl_ { i } ' ], s = sv [ f 's_agdl_ { i } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { i + 1 } ' ], C_v = sv [ f 'C_v_agdl_ { i + 1 } ' ], s = sv [ f 's_agdl_ { i + 1 } ' ], C_H2 = sv [ f 'C_H2_agdl_ { i + 1 } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] k_th_eff_agdl_ampl = hmean ([ k_th_eff ( 'agdl' , sv [ f 'T_agdl_ { nb_gdl } ' ], C_v = sv [ f 'C_v_agdl_ { nb_gdl } ' ], s = sv [ f 's_agdl_ { nb_gdl } ' ], C_H2 = sv [ f 'C_H2_agdl_ { nb_gdl } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'ampl' , sv [ f 'T_ampl_ { 1 } ' ], C_v = sv [ f 'C_v_ampl_ { 1 } ' ], s = sv [ f 's_ampl_ { 1 } ' ], C_H2 = sv [ f 'C_H2_ampl_ { 1 } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl )], weights = [ Hgdl_node / 2 , Hmpl_node / 2 ]) k_th_eff_ampl_ampl = [ None ] + [ hmean ([ k_th_eff ( 'ampl' , sv [ f 'T_ampl_ { i } ' ], C_v = sv [ f 'C_v_ampl_ { i } ' ], s = sv [ f 's_ampl_ { i } ' ], C_H2 = sv [ f 'C_H2_ampl_ { i } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl ), k_th_eff ( 'ampl' , sv [ f 'T_ampl_ { i + 1 } ' ], C_v = sv [ f 'C_v_ampl_ { i + 1 } ' ], s = sv [ f 's_ampl_ { i + 1 } ' ], C_H2 = sv [ f 'C_H2_ampl_ { i + 1 } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl )]) for i in range ( 1 , nb_mpl )] k_th_eff_ampl_acl = hmean ([ k_th_eff ( 'ampl' , sv [ f 'T_ampl_ { nb_mpl } ' ], C_v = sv [ f 'C_v_ampl_ { nb_mpl } ' ], s = sv [ f 's_ampl_ { nb_mpl } ' ], C_H2 = sv [ f 'C_H2_ampl_ { nb_mpl } ' ], C_N2 = C_N2_a_mean , epsilon = epsilon_mpl ), k_th_eff ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , C_N2 = C_N2_a_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc )], weights = [ Hmpl_node / 2 , Hacl / 2 ]) k_th_eff_acl_mem = hmean ([ k_th_eff ( 'acl' , T_acl , C_v = C_v_acl , s = s_acl , lambdaa = lambda_acl , C_H2 = C_H2_acl , C_N2 = C_N2_a_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'mem' , T_mem , lambdaa = lambda_mem )], weights = [ Hacl / 2 , Hmem / 2 ]) k_th_eff_mem_ccl = hmean ([ k_th_eff ( 'mem' , T_mem , lambdaa = lambda_mem ), k_th_eff ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2_c_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc )], weights = [ Hmem / 2 , Hccl / 2 ]) k_th_eff_ccl_cmpl = hmean ([ k_th_eff ( 'ccl' , T_ccl , C_v = C_v_ccl , s = s_ccl , lambdaa = lambda_ccl , C_O2 = C_O2_ccl , C_N2 = C_N2_c_mean , epsilon = epsilon_cl , epsilon_mc = epsilon_mc ), k_th_eff ( 'cmpl' , sv [ f 'T_cmpl_ { 1 } ' ], C_v = sv [ f 'C_v_cmpl_ { 1 } ' ], s = sv [ f 's_cmpl_ { 1 } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { 1 } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl )], weights = [ Hccl / 2 , Hmpl_node / 2 ]) k_th_eff_cmpl_cmpl = [ None ] + [ hmean ([ k_th_eff ( 'cmpl' , sv [ f 'T_cmpl_ { i } ' ], C_v = sv [ f 'C_v_cmpl_ { i } ' ], s = sv [ f 's_cmpl_ { i } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { i } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl ), k_th_eff ( 'cmpl' , sv [ f 'T_cmpl_ { i + 1 } ' ], C_v = sv [ f 'C_v_cmpl_ { i + 1 } ' ], s = sv [ f 's_cmpl_ { i + 1 } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { i + 1 } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl )]) for i in range ( 1 , nb_mpl )] k_th_eff_cmpl_cgdl = hmean ([ k_th_eff ( 'cmpl' , sv [ f 'T_cmpl_ { nb_mpl } ' ], C_v = sv [ f 'C_v_cmpl_ { nb_mpl } ' ], s = sv [ f 's_cmpl_ { nb_mpl } ' ], C_O2 = sv [ f 'C_O2_cmpl_ { nb_mpl } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_mpl ), k_th_eff ( 'cgdl' , sv [ 'T_cgdl_1' ], C_v = sv [ 'C_v_cgdl_1' ], s = sv [ 's_cgdl_1' ], C_O2 = sv [ f 'C_O2_cgdl_1' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c )], weights = [ Hmpl_node / 2 , Hgdl_node / 2 ]) k_th_eff_cgdl_cgdl = [ None ] + [ hmean ([ k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { i } ' ], C_v = sv [ f 'C_v_cgdl_ { i } ' ], s = sv [ f 's_cgdl_ { i } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ), k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { i + 1 } ' ], C_v = sv [ f 'C_v_cgdl_ { i + 1 } ' ], s = sv [ f 's_cgdl_ { i + 1 } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { i + 1 } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c )]) for i in range ( 1 , nb_gdl )] k_th_eff_cgdl_cgc = k_th_eff ( 'cgdl' , sv [ f 'T_cgdl_ { nb_gdl } ' ], C_v = sv [ f 'C_v_cgdl_ { nb_gdl } ' ], s = sv [ f 's_cgdl_ { nb_gdl } ' ], C_O2 = sv [ f 'C_O2_cgdl_ { nb_gdl } ' ], C_N2 = C_N2_c_mean , epsilon = epsilon_gdl , epsilon_c = epsilon_c ) return ( Hgdl_node , Hmpl_node , k_th_eff_agc_agdl , k_th_eff_agdl_agdl , k_th_eff_agdl_ampl , k_th_eff_ampl_ampl , k_th_eff_ampl_acl , k_th_eff_acl_mem , k_th_eff_mem_ccl , k_th_eff_ccl_cmpl , k_th_eff_cmpl_cmpl , k_th_eff_cmpl_cgdl , k_th_eff_cgdl_cgdl , k_th_eff_cgdl_cgc )","title":"heat_transfer_int_values"},{"location":"functions/modules/main_modules/","text":"Main modules This module contains some of the required functions for the main.py file. figures_preparation ( computing_parameters ) This function create the required figures and axes according to the type_current and type_display. Parameters: computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Returns: fig1 ( Figure ) \u2013 Figure for the first plot. ax1 ( AxesSubplot ) \u2013 Axes for the first plot. fig2 ( Figure ) \u2013 Figure for the second plot. ax2 ( AxesSubplot ) \u2013 Axes for the second plot. Source code in modules/main_modules.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def figures_preparation ( computing_parameters ): \"\"\" This function create the required figures and axes according to the type_current and type_display. Parameters ---------- computing_parameters : dict Dictionary containing the computing parameters for the simulation. Returns ------- fig1 : matplotlib.figure.Figure Figure for the first plot. ax1 : matplotlib.axes._subplots.AxesSubplot Axes for the first plot. fig2 : matplotlib.figure.Figure Figure for the second plot. ax2 : matplotlib.axes._subplots.AxesSubplot Axes for the second plot. \"\"\" mpl . rcParams [ 'font.family' ] = 'cmr10' # 'cmr10' for English characters and 'DejaVu Serif' for French ones mpl . rcParams [ 'axes.formatter.use_mathtext' ] = True # For the scientific notation mpl . rcParams [ 'lines.linewidth' ] = 2.0 mpl . rcParams [ 'lines.markersize' ] = 5.0 if computing_parameters [ 'type_display' ] == \"no_display\" : fig1 , ax1 = None , None fig2 , ax2 = None , None fig3 , ax3 = None , None # For the step current if computing_parameters [ 'type_current' ] == \"step\" : if computing_parameters [ 'type_display' ] == \"multiple\" : # saving instruction is directly implemented within AlphaPEM.Display here. mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = None , None # Here, additional plots are unnecessary fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 13 # Font size for all text fig1 , ax1 = plt . subplots ( 3 , 3 , figsize = ( 14 , 14 )) fig2 , ax2 = plt . subplots ( 1 , 2 , figsize = ( 16 , 8 )) fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) # For the polarization curve elif computing_parameters [ 'type_current' ] == \"polarization\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = plt . subplots ( 1 , 4 , figsize = ( 18.7 , 4.7 )) fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 2 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary # For the polarization curve used for the calibration elif computing_parameters [ 'type_current' ] == \"polarization_for_cali\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary # For the EIS curve elif computing_parameters [ 'type_current' ] == \"EIS\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = plt . subplots ( figsize = ( 8 , 8 )) fig3 , ax3 = plt . subplots ( figsize = ( 8 , 8 )) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 13 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) return fig1 , ax1 , fig2 , ax2 , fig3 , ax3 launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 def launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Check if the computing_parameters['type_current'] is valid if computing_parameters [ 'type_plot' ] != \"dynamic\" : raise ValueError ( 'EIS has to be plot with a dynamic type_plot setting, ' 'because max_step has to be adjusted at each frequency.' ) # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None t0_EIS , t_new_start , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = current_parameters [ 't_EIS' ] f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = current_parameters [ 'f_EIS' ] # These are used for EIS max_step # actualization. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested. n = len ( t_new_start ) # It is the plot update number. time_interval = [ 0 , t0_EIS ] # It is the initial time interval. # A preliminary simulation run is necessary to equilibrate the internal variables of the cell at i_EIS # prior to initiating the EIS. Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization t0_EIS_temp = t0_EIS # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ 0 ] + delta_t_break_EIS [ 0 ] + delta_t_measurement_EIS [ 0 ] # It is the final time for # 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which has been # made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) if computing_parameters [ 'type_display' ] == \"multiple\" : print ( \"A display bug prevents the dynamic updating of the graphs, as it appears that too much data is \" \"involved. However, the data is correctly calculated, and the appropriate plots are saved in the \" \"'results' folder. This display bug does not occur when using a 'synthetic' type_display.\" ) # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_EIS_temp = Simulator . variables [ 't' ][ - 1 ] # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ i + 1 ] + delta_t_break_EIS [ i + 1 ] + delta_t_measurement_EIS [ i + 1 ] # It # is the final time for 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which # has been made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # It is the time interval for 1 EIS point. # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) return Simulator launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Condition to fill for the comparison with experimental values if computing_parameters [ 'type_fuel_cell' ][ 1 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 1 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_1 , U_exp_t_1 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 1 ], computing_parameters [ 'voltage_zone' ]) if current_parameters [ 'pola_current_parameters' ][ 1 ][ 'i_max_pola' ] < i_exp_t_1 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_1 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 2 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_2 , U_exp_t_2 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 2 ], computing_parameters [ 'voltage_zone' ]) if current_parameters [ 'pola_current_parameters' ][ 2 ][ 'i_max_pola' ] < i_exp_t_2 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_2 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 3 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_3 , U_exp_t_3 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 3 ], computing_parameters [ 'voltage_zone' ]) if current_parameters [ 'pola_current_parameters' ][ 3 ][ 'i_max_pola' ] < i_exp_t_3 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_3 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 4 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_4 , U_exp_t_4 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 4 ], computing_parameters [ 'voltage_zone' ]) if current_parameters [ 'pola_current_parameters' ][ 4 ][ 'i_max_pola' ] < i_exp_t_4 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_4 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Certain conditions must be met. if ( computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None ): raise ValueError ( 'dynamic plot is not currently intended for use with different inputs.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_load_pola' ] # (s). delta_t_break_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_break_pola' ] # (s). delta_i_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_i_pola' ] # (A.m-2). i_max_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'i_max_pola' ] # (A.m-2). # Calculation delta_t_pola = delta_t_load_pola + delta_t_break_pola # s. It is the time of one load. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * delta_t_pola # s. It is the polarization current duration. n = int ( tf / delta_t_pola ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola + delta_t_pola ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 ), initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator_1 . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola + ( i + 2 ) * delta_t_pola time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator_1 . solver_variable_names : initial_variable_values . append ( Simulator_1 . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 )) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 = AlphaPEM ( select_nth_elements ( operating_inputs , 2 ), select_nth_elements ( current_parameters , 2 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 2 )) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 = AlphaPEM ( select_nth_elements ( operating_inputs , 3 ), select_nth_elements ( current_parameters , 3 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 3 )) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 = AlphaPEM ( select_nth_elements ( operating_inputs , 4 ), select_nth_elements ( current_parameters , 4 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 4 )) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator_1 . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) return Simulator_1 launch_AlphaPEM_for_polarization_current_for_calibration ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a polarization current density made for the calibration of the undetermined parameters, and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def launch_AlphaPEM_for_polarization_current_for_calibration ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density made for the calibration of the undetermined parameters, and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Certain conditions must be met. if ( computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None ): raise ValueError ( 'dynamic plot is not currently intended for use with different inputs.' ) if computing_parameters [ 'type_current' ] == \"polarization_for_cali\" : raise ValueError ( 'calibration should not use dynamic plot, as it is not intended for real-time display.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_ini_pola_cali' ] # (s). delta_t_load_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_load_pola_cali' ] # (s). delta_t_break_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_break_pola_cali' ] # (s). i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( computing_parameters [ 'type_fuel_cell' ][ 1 ], computing_parameters [ 'voltage_zone' ]) # (A.m-2, V). # Calculation delta_t_pola_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. tf = delta_t_ini_pola_cali + len ( i_exp_cali_t ) * delta_t_pola_cali # s. It is the polarization current duration. n = int ( tf / delta_t_pola_cali ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola_cali + delta_t_pola_cali ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 ), initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator_1 . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola_cali + ( i + 2 ) * delta_t_pola_cali time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator_1 . solver_variable_names : initial_variable_values . append ( Simulator_1 . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Certain conditions must be met. if ( computing_parameters [ 'type_current' ] == \"polarization_for_cali\" and ( computing_parameters [ 'type_fuel_cell' ][ 1 ] == \"manual_setup\" or \\ computing_parameters [ 'type_auxiliary' ] != \"forced-convective_cathode_with_flow-through_anode\" )): raise ValueError ( 'polarization current for calibration should be done with experimental data.' ) # Simulation Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 )) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 = AlphaPEM ( select_nth_elements ( operating_inputs , 2 ), select_nth_elements ( current_parameters , 2 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 2 )) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 = AlphaPEM ( select_nth_elements ( operating_inputs , 3 ), select_nth_elements ( current_parameters , 3 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 3 )) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 = AlphaPEM ( select_nth_elements ( operating_inputs , 4 ), select_nth_elements ( current_parameters , 4 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 4 )) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator_1 . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) return Simulator_1 launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) Launch the AlphaPEM simulator for a step current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a step current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Certain conditions must be met. if computing_parameters [ 'type_display' ] == \"multiple\" : raise ValueError ( 'step current is not thought to be used with step current and multiple display.' + 'There would be too much plots to handle.' ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters tf_step = ( current_parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_break_step' ]) # (s). delta_t_dyn_step = current_parameters [ 'step_current_parameters' ][ 'delta_t_dyn_step' ] # (s). # Calculation n = int ( tf_step / delta_t_dyn_step ) # It is the plot update number. time_interval = [ 0 , delta_t_dyn_step ] # (s). It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = ( i + 2 ) * delta_t_dyn_step time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) return Simulator select_nth_elements ( d , n ) Select the n-th element from each list in a dictionary. Parameters: d ( dict ) \u2013 Dictionary where values are lists or other objects. n ( int ) \u2013 Index of the element to select from each list. Returns: dict \u2013 New dictionary with the n-th element from each list, or the original value if it is not a list or the list is too short. Source code in modules/main_modules.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def select_nth_elements ( d , n ): \"\"\"Select the n-th element from each list in a dictionary. Parameters ---------- d : dict Dictionary where values are lists or other objects. n : int Index of the element to select from each list. Returns ------- dict New dictionary with the n-th element from each list, or the original value if it is not a list or the list is too short. \"\"\" return { k : ( v [ n ] if isinstance ( v , list ) and len ( v ) > n else v ) for k , v in d . items ()}","title":"Main modules"},{"location":"functions/modules/main_modules/#main-modules","text":"This module contains some of the required functions for the main.py file.","title":"Main modules"},{"location":"functions/modules/main_modules/#modules.main_modules.figures_preparation","text":"This function create the required figures and axes according to the type_current and type_display. Parameters: computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Returns: fig1 ( Figure ) \u2013 Figure for the first plot. ax1 ( AxesSubplot ) \u2013 Axes for the first plot. fig2 ( Figure ) \u2013 Figure for the second plot. ax2 ( AxesSubplot ) \u2013 Axes for the second plot. Source code in modules/main_modules.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def figures_preparation ( computing_parameters ): \"\"\" This function create the required figures and axes according to the type_current and type_display. Parameters ---------- computing_parameters : dict Dictionary containing the computing parameters for the simulation. Returns ------- fig1 : matplotlib.figure.Figure Figure for the first plot. ax1 : matplotlib.axes._subplots.AxesSubplot Axes for the first plot. fig2 : matplotlib.figure.Figure Figure for the second plot. ax2 : matplotlib.axes._subplots.AxesSubplot Axes for the second plot. \"\"\" mpl . rcParams [ 'font.family' ] = 'cmr10' # 'cmr10' for English characters and 'DejaVu Serif' for French ones mpl . rcParams [ 'axes.formatter.use_mathtext' ] = True # For the scientific notation mpl . rcParams [ 'lines.linewidth' ] = 2.0 mpl . rcParams [ 'lines.markersize' ] = 5.0 if computing_parameters [ 'type_display' ] == \"no_display\" : fig1 , ax1 = None , None fig2 , ax2 = None , None fig3 , ax3 = None , None # For the step current if computing_parameters [ 'type_current' ] == \"step\" : if computing_parameters [ 'type_display' ] == \"multiple\" : # saving instruction is directly implemented within AlphaPEM.Display here. mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = None , None # Here, additional plots are unnecessary fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 13 # Font size for all text fig1 , ax1 = plt . subplots ( 3 , 3 , figsize = ( 14 , 14 )) fig2 , ax2 = plt . subplots ( 1 , 2 , figsize = ( 16 , 8 )) fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) # For the polarization curve elif computing_parameters [ 'type_current' ] == \"polarization\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = plt . subplots ( 1 , 4 , figsize = ( 18.7 , 4.7 )) fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 2 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary # For the polarization curve used for the calibration elif computing_parameters [ 'type_current' ] == \"polarization_for_cali\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 11 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary # For the EIS curve elif computing_parameters [ 'type_current' ] == \"EIS\" : if computing_parameters [ 'type_display' ] == \"multiple\" : mpl . rcParams [ 'font.size' ] = 18 # Font size for all text fig1 , ax1 = plt . subplots ( figsize = ( 8 , 8 )) fig2 , ax2 = plt . subplots ( figsize = ( 8 , 8 )) fig3 , ax3 = plt . subplots ( figsize = ( 8 , 8 )) elif computing_parameters [ 'type_display' ] == \"synthetic\" : mpl . rcParams [ 'font.size' ] = 13 # Font size for all text fig1 , ax1 = plt . subplots ( 1 , 3 , figsize = ( 14 , 4.7 )) fig2 , ax2 = None , None # Here, additional plots are unnecessary fig3 , ax3 = None , None # Here, additional plots are unnecessary plt . subplots_adjust ( left = 0.04 , right = 0.98 , top = 0.96 , bottom = 0.07 , wspace = 0.2 , hspace = 0.15 ) return fig1 , ax1 , fig2 , ax2 , fig3 , ax3","title":"figures_preparation"},{"location":"functions/modules/main_modules/#modules.main_modules.launch_AlphaPEM_for_EIS_current","text":"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 def launch_AlphaPEM_for_EIS_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for an EIS current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Check if the computing_parameters['type_current'] is valid if computing_parameters [ 'type_plot' ] != \"dynamic\" : raise ValueError ( 'EIS has to be plot with a dynamic type_plot setting, ' 'because max_step has to be adjusted at each frequency.' ) # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None t0_EIS , t_new_start , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS = current_parameters [ 't_EIS' ] f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = current_parameters [ 'f_EIS' ] # These are used for EIS max_step # actualization. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is a list of all the frequency tested. n = len ( t_new_start ) # It is the plot update number. time_interval = [ 0 , t0_EIS ] # It is the initial time interval. # A preliminary simulation run is necessary to equilibrate the internal variables of the cell at i_EIS # prior to initiating the EIS. Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization t0_EIS_temp = t0_EIS # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ 0 ] + delta_t_break_EIS [ 0 ] + delta_t_measurement_EIS [ 0 ] # It is the final time for # 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which has been # made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) if computing_parameters [ 'type_display' ] == \"multiple\" : print ( \"A display bug prevents the dynamic updating of the graphs, as it appears that too much data is \" \"involved. However, the data is correctly calculated, and the appropriate plots are saved in the \" \"'results' folder. This display bug does not occur when using a 'synthetic' type_display.\" ) # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_EIS_temp = Simulator . variables [ 't' ][ - 1 ] # It is the initial time for 1 EIS point. tf_EIS_temp = t_new_start [ i + 1 ] + delta_t_break_EIS [ i + 1 ] + delta_t_measurement_EIS [ i + 1 ] # It # is the final time for 1 EIS point. n_inf = np . where ( t_new_start <= t0_EIS_temp )[ 0 ][ - 1 ] # It is the number of frequency changes which # has been made. time_interval = [ t0_EIS_temp , tf_EIS_temp ] # It is the time interval for 1 EIS point. # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) return Simulator","title":"launch_AlphaPEM_for_EIS_current"},{"location":"functions/modules/main_modules/#modules.main_modules.launch_AlphaPEM_for_polarization_current","text":"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def launch_AlphaPEM_for_polarization_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Condition to fill for the comparison with experimental values if computing_parameters [ 'type_fuel_cell' ][ 1 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 1 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_1 , U_exp_t_1 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 1 ], computing_parameters [ 'voltage_zone' ]) if current_parameters [ 'pola_current_parameters' ][ 1 ][ 'i_max_pola' ] < i_exp_t_1 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_1 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 2 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_2 , U_exp_t_2 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 2 ], computing_parameters [ 'voltage_zone' ]) if current_parameters [ 'pola_current_parameters' ][ 2 ][ 'i_max_pola' ] < i_exp_t_2 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_2 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 3 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_3 , U_exp_t_3 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 3 ], computing_parameters [ 'voltage_zone' ]) if current_parameters [ 'pola_current_parameters' ][ 3 ][ 'i_max_pola' ] < i_exp_t_3 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_3 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None and computing_parameters [ 'type_fuel_cell' ][ 4 ] != \"manual_setup\" and \\ computing_parameters [ 'type_auxiliary' ] == \"forced-convective_cathode_with_flow-through_anode\" : # Experimental points are accessible i_exp_t_4 , U_exp_t_4 = pola_exp_values ( computing_parameters [ 'type_fuel_cell' ][ 4 ], computing_parameters [ 'voltage_zone' ]) if current_parameters [ 'pola_current_parameters' ][ 4 ][ 'i_max_pola' ] < i_exp_t_4 [ - 1 ]: raise ValueError ( 'The given maximum current density of the polarization curve i_max_pola_4 is lower than the ' 'maximum current density of the experimental values. Please increase it.' ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Certain conditions must be met. if ( computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None ): raise ValueError ( 'dynamic plot is not currently intended for use with different inputs.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_ini_pola' ] # (s). delta_t_load_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_load_pola' ] # (s). delta_t_break_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_break_pola' ] # (s). delta_i_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_i_pola' ] # (A.m-2). i_max_pola = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'i_max_pola' ] # (A.m-2). # Calculation delta_t_pola = delta_t_load_pola + delta_t_break_pola # s. It is the time of one load. tf = delta_t_ini_pola + int ( i_max_pola / delta_i_pola ) * delta_t_pola # s. It is the polarization current duration. n = int ( tf / delta_t_pola ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola + delta_t_pola ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 ), initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator_1 . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola + ( i + 2 ) * delta_t_pola time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator_1 . solver_variable_names : initial_variable_values . append ( Simulator_1 . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 )) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 = AlphaPEM ( select_nth_elements ( operating_inputs , 2 ), select_nth_elements ( current_parameters , 2 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 2 )) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 = AlphaPEM ( select_nth_elements ( operating_inputs , 3 ), select_nth_elements ( current_parameters , 3 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 3 )) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 = AlphaPEM ( select_nth_elements ( operating_inputs , 4 ), select_nth_elements ( current_parameters , 4 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 4 )) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator_1 . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) return Simulator_1","title":"launch_AlphaPEM_for_polarization_current"},{"location":"functions/modules/main_modules/#modules.main_modules.launch_AlphaPEM_for_polarization_current_for_calibration","text":"Launch the AlphaPEM simulator for a polarization current density made for the calibration of the undetermined parameters, and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def launch_AlphaPEM_for_polarization_current_for_calibration ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a polarization current density made for the calibration of the undetermined parameters, and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Certain conditions must be met. if ( computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None or computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None ): raise ValueError ( 'dynamic plot is not currently intended for use with different inputs.' ) if computing_parameters [ 'type_current' ] == \"polarization_for_cali\" : raise ValueError ( 'calibration should not use dynamic plot, as it is not intended for real-time display.' ) # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters delta_t_ini_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_ini_pola_cali' ] # (s). delta_t_load_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_load_pola_cali' ] # (s). delta_t_break_pola_cali = current_parameters [ 'pola_current_parameters' ][ 1 ][ 'delta_t_break_pola_cali' ] # (s). i_exp_cali_t , U_exp_cali_t = pola_exp_values_calibration ( computing_parameters [ 'type_fuel_cell' ][ 1 ], computing_parameters [ 'voltage_zone' ]) # (A.m-2, V). # Calculation delta_t_pola_cali = delta_t_load_pola_cali + delta_t_break_pola_cali # s. It is the time of one load. tf = delta_t_ini_pola_cali + len ( i_exp_cali_t ) * delta_t_pola_cali # s. It is the polarization current duration. n = int ( tf / delta_t_pola_cali ) # It is the plot update number. time_interval = [ 0 , delta_t_ini_pola_cali + delta_t_pola_cali ] # It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 ), initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator_1 . variables [ 't' ][ - 1 ] tf_interval = delta_t_ini_pola_cali + ( i + 2 ) * delta_t_pola_cali time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator_1 . solver_variable_names : initial_variable_values . append ( Simulator_1 . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Certain conditions must be met. if ( computing_parameters [ 'type_current' ] == \"polarization_for_cali\" and ( computing_parameters [ 'type_fuel_cell' ][ 1 ] == \"manual_setup\" or \\ computing_parameters [ 'type_auxiliary' ] != \"forced-convective_cathode_with_flow-through_anode\" )): raise ValueError ( 'polarization current for calibration should be done with experimental data.' ) # Simulation Simulator_1 = AlphaPEM ( select_nth_elements ( operating_inputs , 1 ), select_nth_elements ( current_parameters , 1 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 1 )) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 = AlphaPEM ( select_nth_elements ( operating_inputs , 2 ), select_nth_elements ( current_parameters , 2 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 2 )) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 = AlphaPEM ( select_nth_elements ( operating_inputs , 3 ), select_nth_elements ( current_parameters , 3 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 3 )) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 = AlphaPEM ( select_nth_elements ( operating_inputs , 4 ), select_nth_elements ( current_parameters , 4 ), accessible_physical_parameters , undetermined_physical_parameters , select_nth_elements ( computing_parameters , 4 )) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator_1 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 2 ] is not None : Simulator_2 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 3 ] is not None : Simulator_3 . Display ( ax1 , ax2 , ax3 ) if computing_parameters [ 'type_fuel_cell' ][ 4 ] is not None : Simulator_4 . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator_1 . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) return Simulator_1","title":"launch_AlphaPEM_for_polarization_current_for_calibration"},{"location":"functions/modules/main_modules/#modules.main_modules.launch_AlphaPEM_for_step_current","text":"Launch the AlphaPEM simulator for a step current density and display the results. Parameters: operating_inputs ( dict ) \u2013 Dictionary containing the operating inputs for the simulation. current_parameters ( dict ) \u2013 Dictionary containing the current parameters for the simulation. accessible_physical_parameters ( dict ) \u2013 Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters ( dict ) \u2013 Dictionary containing the undetermined physical parameters for the simulation. computing_parameters ( dict ) \u2013 Dictionary containing the computing parameters for the simulation. Source code in modules/main_modules.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def launch_AlphaPEM_for_step_current ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ): \"\"\"Launch the AlphaPEM simulator for a step current density and display the results. Parameters ---------- operating_inputs : dict Dictionary containing the operating inputs for the simulation. current_parameters : dict Dictionary containing the current parameters for the simulation. accessible_physical_parameters : dict Dictionary containing the accessible physical parameters for the simulation. undetermined_physical_parameters : dict Dictionary containing the undetermined physical parameters for the simulation. computing_parameters : dict Dictionary containing the computing parameters for the simulation. \"\"\" # Starting time start_time = time . time () # Figures preparation fig1 , ax1 , fig2 , ax2 , fig3 , ax3 = figures_preparation ( computing_parameters ) # Certain conditions must be met. if computing_parameters [ 'type_display' ] == \"multiple\" : raise ValueError ( 'step current is not thought to be used with step current and multiple display.' + 'There would be too much plots to handle.' ) # Dynamic display requires a dedicated use of the AlphaPEM class. if computing_parameters [ 'type_plot' ] == \"dynamic\" : # Initialization # Calculation of the plot update number (n) and the initial time interval (time_interval). initial_variable_values = None # Extraction of the parameters tf_step = ( current_parameters [ 'step_current_parameters' ][ 'delta_t_ini_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_load_step' ] + current_parameters [ 'step_current_parameters' ][ 'delta_t_break_step' ]) # (s). delta_t_dyn_step = current_parameters [ 'step_current_parameters' ][ 'delta_t_dyn_step' ] # (s). # Calculation n = int ( tf_step / delta_t_dyn_step ) # It is the plot update number. time_interval = [ 0 , delta_t_dyn_step ] # (s). It is the initial time interval. # Dynamic simulation for i in range ( n ): Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters , initial_variable_values , time_interval ) # time_interval actualization if i < ( n - 1 ): # The final simulation does not require actualization. t0_interval = Simulator . variables [ 't' ][ - 1 ] tf_interval = ( i + 2 ) * delta_t_dyn_step time_interval = [ t0_interval , tf_interval ] # Reset of the time interval # Recovery of the internal states from the end of the preceding simulation. initial_variable_values = [] for x in Simulator . solver_variable_names : initial_variable_values . append ( Simulator . variables [ x ][ - 1 ]) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) else : # elif computing_parameters['type_plot'] == \"fixed\": # Simulation Simulator = AlphaPEM ( operating_inputs , current_parameters , accessible_physical_parameters , undetermined_physical_parameters , computing_parameters ) # Display if computing_parameters [ 'type_display' ] != \"no_display\" : Simulator . Display ( ax1 , ax2 , ax3 ) # Plot saving Simulator . Save_plot ( fig1 , fig2 , fig3 ) # Ending time algo_time = time . time () - start_time print ( 'Time of the algorithm in second :' , algo_time ) return Simulator","title":"launch_AlphaPEM_for_step_current"},{"location":"functions/modules/main_modules/#modules.main_modules.select_nth_elements","text":"Select the n-th element from each list in a dictionary. Parameters: d ( dict ) \u2013 Dictionary where values are lists or other objects. n ( int ) \u2013 Index of the element to select from each list. Returns: dict \u2013 New dictionary with the n-th element from each list, or the original value if it is not a list or the list is too short. Source code in modules/main_modules.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def select_nth_elements ( d , n ): \"\"\"Select the n-th element from each list in a dictionary. Parameters ---------- d : dict Dictionary where values are lists or other objects. n : int Index of the element to select from each list. Returns ------- dict New dictionary with the n-th element from each list, or the original value if it is not a list or the list is too short. \"\"\" return { k : ( v [ n ] if isinstance ( v , list ) and len ( v ) > n else v ) for k , v in d . items ()}","title":"select_nth_elements"},{"location":"functions/modules/settings_modules/","text":"Settings modules This modul contains some of the required functions for the settings. EIS_parameters ( f_EIS ) This function gives the time parameters for the EIS_current density function. Parameters: f_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. Returns: t_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. Source code in modules/settings_modules.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def EIS_parameters ( f_EIS ): \"\"\"This function gives the time parameters for the EIS_current density function. Parameters ---------- f_EIS : tuple EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. Returns ------- t_EIS : tuple EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. \"\"\" # Initialisation # Frequencies f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is the tested frequencies nb_period_break_EIS , nb_period_measurement_EIS = 50 , 50 # They are the number of temporal periods which are used # for break and for measurement. It is more accurate to use # periods than time as the frequency range is big. # Time parameters delta_t_break_EIS = np . array ([]) # It is the estimated time for reaching equilibrium at each frequency. delta_t_measurement_EIS = np . array ([]) # It is the estimated time for measuring the voltage response. # Time parameters calculation t0_EIS = 120 * 60 # s. It is the simulation starting time. [0, t0_EIS] is used to let the stack equilibrate to i_EIS. t_new_start_EIS = np . array ([ t0_EIS ]) # It is a list of time parameters which gives the beginning of each frequency # change. for i in range ( nb_f_EIS ): # The goal is to measure nb_f_EIS periods of the signal in order to have precise enough values. T_i = 1 / ( f [ i ]) # s. It is the period of the signal. if i < ( nb_f_EIS - 1 ): delta_t_break_EIS = np . concatenate (( delta_t_break_EIS , [ nb_period_break_EIS * T_i ])) delta_t_measurement_EIS = np . concatenate (( delta_t_measurement_EIS , [ nb_period_measurement_EIS * T_i ])) next_start_EIS = t_new_start_EIS [ i ] + delta_t_break_EIS [ i ] + delta_t_measurement_EIS [ i ] t_new_start_EIS = np . concatenate (( t_new_start_EIS , [ next_start_EIS ])) else : delta_t_break_EIS = np . concatenate (( delta_t_break_EIS , [ nb_period_break_EIS * T_i ])) delta_t_measurement_EIS = np . concatenate (( delta_t_measurement_EIS , [ nb_period_measurement_EIS * T_i ])) tf_EIS = t_new_start_EIS [ - 1 ] + delta_t_break_EIS [ - 1 ] + delta_t_measurement_EIS [ - 1 ] # s. It is the # simulation ending time t_EIS = t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS return t_EIS stored_operating_inputs ( type_fuel_cell , voltage_zone ) This function gives the operating inputs which correspond to the given type_fuel_cell. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. voltage_zone ( str ) \u2013 Zone of the polarization curve which is considered. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. i_max_pola ( float ) \u2013 Maximum current density for the polarization curve. Source code in modules/settings_modules.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def stored_operating_inputs ( type_fuel_cell , voltage_zone ): \"\"\"This function gives the operating inputs which correspond to the given type_fuel_cell. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. voltage_zone : str Zone of the polarization curve which is considered. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. i_max_pola : float Maximum current density for the polarization curve. \"\"\" # For the ZSW Generic Stack fuel cell if type_fuel_cell == \"ZSW-GenStack\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.700e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 1.61e5 , 1.41e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.200e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 0.700e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.01e5 , 1.81e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.300e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.4e5 , 2.2e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.900e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.8e5 , 2.6e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.900e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_T_62\" : T_des = 62 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_T_76\" : T_des = 76 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.100e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_T_84\" : T_des = 84 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.000e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 0.700e4 # A.m-2. It is the maximum current density for the polarization curve. # For EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 1.5e5 , 1.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.300e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.700e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.0\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.300e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.25\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.25e5 , 2.25e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.800e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.700e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.5\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.5e5 , 2.5e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 3.000e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.600e4 # A.m-2. It is the maximum current density for the polarization curve. # For other fuel cells else : raise ValueError ( 'the type_fuel_cell given is not valid.' ) return T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , i_max_pola stored_physical_parameters ( type_fuel_cell ) This function gives the physical parameters which correspond to the given type_fuel_cell. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: Hacl ( float ) \u2013 Thickness of the anode catalyst layer in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer in m. epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the CL. Hmem ( float ) \u2013 Thickness of the membrane in m. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in m. epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_c ( float ) \u2013 Compression ratio of the GDL. Hagc ( float ) \u2013 Thickness of the anode gas channel in m. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in m. Wagc ( float ) \u2013 Width of the anode gas channel in m. Wcgc ( float ) \u2013 Width of the cathode gas channel in m. Lgc ( float ) \u2013 Length of the gas channel in m. Aact ( float ) \u2013 Active area of the cell in m\u00b2. e ( float ) \u2013 Capillary exponent. i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode in A.m-2. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c ( float ) \u2013 Overpotential correction exponent. a_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of slim function. b_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the intercept of slim function. a_switch ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl ( float ) \u2013 Volumetric double layer capacitance in F.m-3. Source code in modules/settings_modules.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def stored_physical_parameters ( type_fuel_cell ): \"\"\"This function gives the physical parameters which correspond to the given type_fuel_cell. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- Hacl : float Thickness of the anode catalyst layer in m. Hccl : float Thickness of the cathode catalyst layer in m. epsilon_mc : float Volume fraction of ionomer in the CL. Hmem : float Thickness of the membrane in m. Hgdl : float Thickness of the gas diffusion layer in m. epsilon_gdl : float Anode/cathode GDL porosity. epsilon_c : float Compression ratio of the GDL. Hagc : float Thickness of the anode gas channel in m. Hcgc : float Thickness of the cathode gas channel in m. Wagc : float Width of the anode gas channel in m. Wcgc : float Width of the cathode gas channel in m. Lgc : float Length of the gas channel in m. Aact : float Active area of the cell in m\u00b2. e : float Capillary exponent. i0_c_ref : float Reference exchange current density at the cathode in A.m-2. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c : float Overpotential correction exponent. a_slim : float One of the limit liquid saturation coefficients: the slop of slim function. b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function. a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl : float Volumetric double layer capacitance in F.m-3. \"\"\" # For the ZSW Generic Stack fuel cell if type_fuel_cell == \"ZSW-GenStack\" or type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" or type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" or type_fuel_cell == \"ZSW-GenStack_T_62\" or \\ type_fuel_cell == \"ZSW-GenStack_T_76\" or type_fuel_cell == \"ZSW-GenStack_T_84\" : # Global Aact = 283.87e-4 # m\u00b2. It is the MEA active area. nb_cell = 26 # . It is the number of cell in the stack. # Catalyst layer Hacl = 8e-6 # m. It is the thickness of the anode catalyst layer. Hccl = 17e-6 # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.25 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 15e-6 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 127e-6 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.788 # It is the anode/cathode GDL porosity. epsilon_cl = 0.5 # It is the porosity of the catalyst layer, without units. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 70e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.425 # It is the porosity of the microporous layer. # Gas channel Hagc = 230e-6 # m. It is the thickness of the anode gas channel. Hcgc = 300e-6 # m. It is the thickness of the cathode gas channel. Wagc = 430e-6 # m. It is the width of the anode gas channel. Wcgc = 532e-6 # m. It is the width of the cathode gas channel. Lgc = 246.2e-3 # m. It is the length of one channel in the bipolar plate. nb_channel_in_gc = 105 # . It is the number of channels in the bipolar plate. Ldist = 7.11e-2 # m. It is the length of the distributor, which is the volume between the gas channel and the manifold. # Auxiliaries Lm = 25.8e-3 # m. It is the length of the manifold. A_T_a = 9.01e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = 22.61e-4 # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = Lm * A_T_a , Lm * A_T_c # m3. It is the supply manifold volume. Vaem , Vcem = Vasm , Vcsm # m-3. It is the exhaust manifold volume. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # ohm.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.43 # A.m-2. It is the dry reference exchange current density at the cathode. i0_h_c_ref = 1.0 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 5 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.026 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # For EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Global Aact = 85e-4 # m\u00b2. It is the active area of the catalyst layer. nb_cell = 1 # . It is the number of cell in the stack. # Catalyst layer Hacl = 8.593e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.3986 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 16.06e-6 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 200e-6 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.5002 # It is the anode/cathode GDL porosity. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 30e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. # Gas channel Hagc = 500e-6 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Wagc = 450e-6 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 144e-3 # m. It is the length of one channel in the bipolar plate. nb_channel_in_gc = 67 # . It is the number of channels in the bipolar plate. Ldist = 5e-2 # m. It is the estimated length of the distributor, which is the volume between the gas channel and the manifold. # Auxiliaries Lm = 2.03 # m. It is the length of the manifold. A_T_a = 11.8e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = 34.4e-4 # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = Lm * A_T_a , Lm * A_T_c # m3. It is the supply manifold volume. Vaem , Vcem = Vasm , Vcsm # m-3. It is the exhaust manifold volume. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # ohm.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.43 # A.m-2. It is the dry reference exchange current density at the cathode. i0_h_c_ref = 1.0 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 30.42 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.4152 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.82 # It is the limit liquid saturation coefficients. C_scl = 20e6 # F.m-3. It is the volumetric space-charge layer capacitance. # For other fuel cells else : raise ValueError ( 'the type_input given is not valid.' ) return ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , nb_channel_in_gc , Ldist , Lm , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , Aact , nb_cell , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl )","title":"Settings modules"},{"location":"functions/modules/settings_modules/#settings-modules","text":"This modul contains some of the required functions for the settings.","title":"Settings modules"},{"location":"functions/modules/settings_modules/#modules.settings_modules.EIS_parameters","text":"This function gives the time parameters for the EIS_current density function. Parameters: f_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. Returns: t_EIS ( tuple ) \u2013 EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. Source code in modules/settings_modules.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def EIS_parameters ( f_EIS ): \"\"\"This function gives the time parameters for the EIS_current density function. Parameters ---------- f_EIS : tuple EIS parameters. It is a tuple containing the power of the initial frequency 'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period 'nb_points_EIS'. Returns ------- t_EIS : tuple EIS parameters. It is a tuple containing the initial EIS time after stack equilibrium 't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS', the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for measuring the voltage response at each frequency 'delta_t_measurement_EIS'. \"\"\" # Initialisation # Frequencies f_power_min_EIS , f_power_max_EIS , nb_f_EIS , nb_points_EIS = f_EIS # They are the frequency parameters for the EIS # simulation. f = np . logspace ( f_power_min_EIS , f_power_max_EIS , num = nb_f_EIS ) # It is the tested frequencies nb_period_break_EIS , nb_period_measurement_EIS = 50 , 50 # They are the number of temporal periods which are used # for break and for measurement. It is more accurate to use # periods than time as the frequency range is big. # Time parameters delta_t_break_EIS = np . array ([]) # It is the estimated time for reaching equilibrium at each frequency. delta_t_measurement_EIS = np . array ([]) # It is the estimated time for measuring the voltage response. # Time parameters calculation t0_EIS = 120 * 60 # s. It is the simulation starting time. [0, t0_EIS] is used to let the stack equilibrate to i_EIS. t_new_start_EIS = np . array ([ t0_EIS ]) # It is a list of time parameters which gives the beginning of each frequency # change. for i in range ( nb_f_EIS ): # The goal is to measure nb_f_EIS periods of the signal in order to have precise enough values. T_i = 1 / ( f [ i ]) # s. It is the period of the signal. if i < ( nb_f_EIS - 1 ): delta_t_break_EIS = np . concatenate (( delta_t_break_EIS , [ nb_period_break_EIS * T_i ])) delta_t_measurement_EIS = np . concatenate (( delta_t_measurement_EIS , [ nb_period_measurement_EIS * T_i ])) next_start_EIS = t_new_start_EIS [ i ] + delta_t_break_EIS [ i ] + delta_t_measurement_EIS [ i ] t_new_start_EIS = np . concatenate (( t_new_start_EIS , [ next_start_EIS ])) else : delta_t_break_EIS = np . concatenate (( delta_t_break_EIS , [ nb_period_break_EIS * T_i ])) delta_t_measurement_EIS = np . concatenate (( delta_t_measurement_EIS , [ nb_period_measurement_EIS * T_i ])) tf_EIS = t_new_start_EIS [ - 1 ] + delta_t_break_EIS [ - 1 ] + delta_t_measurement_EIS [ - 1 ] # s. It is the # simulation ending time t_EIS = t0_EIS , t_new_start_EIS , tf_EIS , delta_t_break_EIS , delta_t_measurement_EIS return t_EIS","title":"EIS_parameters"},{"location":"functions/modules/settings_modules/#modules.settings_modules.stored_operating_inputs","text":"This function gives the operating inputs which correspond to the given type_fuel_cell. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. voltage_zone ( str ) \u2013 Zone of the polarization curve which is considered. Returns: T_des ( float ) \u2013 Desired fuel cell temperature in Kelvin. Pa_des ( float ) \u2013 Desired anode pressure in Pascal. Pc_des ( float ) \u2013 Desired cathode pressure in Pascal. Sa ( float ) \u2013 Stoichiometric ratio of hydrogen. Sc ( float ) \u2013 Stoichiometric ratio of oxygen. Phi_a_des ( float ) \u2013 Desired anode relative humidity. Phi_c_des ( float ) \u2013 Desired cathode relative humidity. i_max_pola ( float ) \u2013 Maximum current density for the polarization curve. Source code in modules/settings_modules.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def stored_operating_inputs ( type_fuel_cell , voltage_zone ): \"\"\"This function gives the operating inputs which correspond to the given type_fuel_cell. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. voltage_zone : str Zone of the polarization curve which is considered. Returns ------- T_des : float Desired fuel cell temperature in Kelvin. Pa_des : float Desired anode pressure in Pascal. Pc_des : float Desired cathode pressure in Pascal. Sa : float Stoichiometric ratio of hydrogen. Sc : float Stoichiometric ratio of oxygen. Phi_a_des : float Desired anode relative humidity. Phi_c_des : float Desired cathode relative humidity. i_max_pola : float Maximum current density for the polarization curve. \"\"\" # For the ZSW Generic Stack fuel cell if type_fuel_cell == \"ZSW-GenStack\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.700e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 1.61e5 , 1.41e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.200e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 0.700e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.01e5 , 1.81e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.300e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.4e5 , 2.2e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.900e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" : T_des = 68 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.8e5 , 2.6e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.900e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_T_62\" : T_des = 62 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_T_76\" : T_des = 76 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.100e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"ZSW-GenStack_T_84\" : T_des = 84 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.2e5 , 2.0e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.6 , 1.6 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.398 , 0.50 # It is the desired relative humidity. y_H2_in = 0.7 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.000e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 0.700e4 # A.m-2. It is the maximum current density for the polarization curve. # For EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 1.5e5 , 1.5e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.300e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.700e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.0\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.0e5 , 2.0e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.500e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.300e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.25\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.25e5 , 2.25e5 # Pa. It is the desired pressure of the fuel gas (at the anode/cathode). Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 2.800e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.700e4 # A.m-2. It is the maximum current density for the polarization curve. elif type_fuel_cell == \"EH-31_2.5\" : T_des = 74 + 273.15 # K. It is the desired fuel cell temperature. Pa_des , Pc_des = 2.5e5 , 2.5e5 # Pa. It is the desired pressures of the fuel gas. Sa , Sc = 1.2 , 2.0 # It is the stoichiometric ratio (of hydrogen and oxygen). Phi_a_des , Phi_c_des = 0.4 , 0.6 # It is the desired relative humidity. y_H2_in = 1 # It is the molar fraction of H2 in the dry anode gas mixture (H2/N2) injected at the inlet. if voltage_zone == \"full\" : i_max_pola = 3.000e4 # A.m-2. It is the maximum current density for the polarization curve. elif voltage_zone == \"before_voltage_drop\" : i_max_pola = 1.600e4 # A.m-2. It is the maximum current density for the polarization curve. # For other fuel cells else : raise ValueError ( 'the type_fuel_cell given is not valid.' ) return T_des , Pa_des , Pc_des , Sa , Sc , Phi_a_des , Phi_c_des , y_H2_in , i_max_pola","title":"stored_operating_inputs"},{"location":"functions/modules/settings_modules/#modules.settings_modules.stored_physical_parameters","text":"This function gives the physical parameters which correspond to the given type_fuel_cell. Parameters: type_fuel_cell ( str ) \u2013 Type of fuel cell configuration. Returns: Hacl ( float ) \u2013 Thickness of the anode catalyst layer in m. Hccl ( float ) \u2013 Thickness of the cathode catalyst layer in m. epsilon_mc ( float ) \u2013 Volume fraction of ionomer in the CL. Hmem ( float ) \u2013 Thickness of the membrane in m. Hgdl ( float ) \u2013 Thickness of the gas diffusion layer in m. epsilon_gdl ( float ) \u2013 Anode/cathode GDL porosity. epsilon_c ( float ) \u2013 Compression ratio of the GDL. Hagc ( float ) \u2013 Thickness of the anode gas channel in m. Hcgc ( float ) \u2013 Thickness of the cathode gas channel in m. Wagc ( float ) \u2013 Width of the anode gas channel in m. Wcgc ( float ) \u2013 Width of the cathode gas channel in m. Lgc ( float ) \u2013 Length of the gas channel in m. Aact ( float ) \u2013 Active area of the cell in m\u00b2. e ( float ) \u2013 Capillary exponent. i0_c_ref ( float ) \u2013 Reference exchange current density at the cathode in A.m-2. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c ( float ) \u2013 Overpotential correction exponent. a_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of slim function. b_slim ( float ) \u2013 One of the limit liquid saturation coefficients: the intercept of slim function. a_switch ( float ) \u2013 One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl ( float ) \u2013 Volumetric double layer capacitance in F.m-3. Source code in modules/settings_modules.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def stored_physical_parameters ( type_fuel_cell ): \"\"\"This function gives the physical parameters which correspond to the given type_fuel_cell. Parameters ---------- type_fuel_cell : str Type of fuel cell configuration. Returns ------- Hacl : float Thickness of the anode catalyst layer in m. Hccl : float Thickness of the cathode catalyst layer in m. epsilon_mc : float Volume fraction of ionomer in the CL. Hmem : float Thickness of the membrane in m. Hgdl : float Thickness of the gas diffusion layer in m. epsilon_gdl : float Anode/cathode GDL porosity. epsilon_c : float Compression ratio of the GDL. Hagc : float Thickness of the anode gas channel in m. Hcgc : float Thickness of the cathode gas channel in m. Wagc : float Width of the anode gas channel in m. Wcgc : float Width of the cathode gas channel in m. Lgc : float Length of the gas channel in m. Aact : float Active area of the cell in m\u00b2. e : float Capillary exponent. i0_c_ref : float Reference exchange current density at the cathode in A.m-2. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. kappa_c : float Overpotential correction exponent. a_slim : float One of the limit liquid saturation coefficients: the slop of slim function. b_slim : float One of the limit liquid saturation coefficients: the intercept of slim function. a_switch : float One of the limit liquid saturation coefficients: the slop of s_switch function. C_dl : float Volumetric double layer capacitance in F.m-3. \"\"\" # For the ZSW Generic Stack fuel cell if type_fuel_cell == \"ZSW-GenStack\" or type_fuel_cell == \"ZSW-GenStack_Pa_1.61_Pc_1.41\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.01_Pc_1.81\" or type_fuel_cell == \"ZSW-GenStack_Pa_2.4_Pc_2.2\" or \\ type_fuel_cell == \"ZSW-GenStack_Pa_2.8_Pc_2.6\" or type_fuel_cell == \"ZSW-GenStack_T_62\" or \\ type_fuel_cell == \"ZSW-GenStack_T_76\" or type_fuel_cell == \"ZSW-GenStack_T_84\" : # Global Aact = 283.87e-4 # m\u00b2. It is the MEA active area. nb_cell = 26 # . It is the number of cell in the stack. # Catalyst layer Hacl = 8e-6 # m. It is the thickness of the anode catalyst layer. Hccl = 17e-6 # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.25 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 15e-6 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 127e-6 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.788 # It is the anode/cathode GDL porosity. epsilon_cl = 0.5 # It is the porosity of the catalyst layer, without units. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 70e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.425 # It is the porosity of the microporous layer. # Gas channel Hagc = 230e-6 # m. It is the thickness of the anode gas channel. Hcgc = 300e-6 # m. It is the thickness of the cathode gas channel. Wagc = 430e-6 # m. It is the width of the anode gas channel. Wcgc = 532e-6 # m. It is the width of the cathode gas channel. Lgc = 246.2e-3 # m. It is the length of one channel in the bipolar plate. nb_channel_in_gc = 105 # . It is the number of channels in the bipolar plate. Ldist = 7.11e-2 # m. It is the length of the distributor, which is the volume between the gas channel and the manifold. # Auxiliaries Lm = 25.8e-3 # m. It is the length of the manifold. A_T_a = 9.01e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = 22.61e-4 # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = Lm * A_T_a , Lm * A_T_c # m3. It is the supply manifold volume. Vaem , Vcem = Vasm , Vcsm # m-3. It is the exhaust manifold volume. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # ohm.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.43 # A.m-2. It is the dry reference exchange current density at the cathode. i0_h_c_ref = 1.0 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 5 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 1.026 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.63654 # It is the limit liquid saturation coefficients. C_scl = 2e7 # F.m-3. It is the volumetric space-charge layer capacitance. # For EH-31 fuel cell elif type_fuel_cell == \"EH-31_1.5\" or type_fuel_cell == \"EH-31_2.0\" or type_fuel_cell == \"EH-31_2.25\" or \\ type_fuel_cell == \"EH-31_2.5\" : # Global Aact = 85e-4 # m\u00b2. It is the active area of the catalyst layer. nb_cell = 1 # . It is the number of cell in the stack. # Catalyst layer Hacl = 8.593e-6 # m. It is the thickness of the anode catalyst layer. Hccl = Hacl # m. It is the thickness of the cathode catalyst layer. epsilon_mc = 0.3986 # It is the volume fraction of ionomer in the CL. # Membrane Hmem = 16.06e-6 # m. It is the thickness of the membrane. # Gas diffusion layer Hgdl = 200e-6 # m. It is the thickness of the gas diffusion layer. epsilon_gdl = 0.5002 # It is the anode/cathode GDL porosity. epsilon_cl = 0.25 # It is the porosity of the catalyst layer, without units. epsilon_c = 0.2 # It is the compression ratio of the GDL. # Microporous layer Hmpl = 30e-6 # m. It is the thickness of the microporous layer. epsilon_mpl = 0.4 # It is the porosity of the microporous layer. # Gas channel Hagc = 500e-6 # m. It is the thickness of the anode gas channel. Hcgc = Hagc # m. It is the thickness of the cathode gas channel. Wagc = 450e-6 # m. It is the width of the anode gas channel. Wcgc = Wagc # m. It is the width of the cathode gas channel. Lgc = 144e-3 # m. It is the length of one channel in the bipolar plate. nb_channel_in_gc = 67 # . It is the number of channels in the bipolar plate. Ldist = 5e-2 # m. It is the estimated length of the distributor, which is the volume between the gas channel and the manifold. # Auxiliaries Lm = 2.03 # m. It is the length of the manifold. A_T_a = 11.8e-4 # m\u00b2. It is the inlet/exhaust anode manifold throttle area A_T_c = 34.4e-4 # m\u00b2. It is the inlet/exhaust cathode manifold throttle area Vasm , Vcsm = Lm * A_T_a , Lm * A_T_c # m3. It is the supply manifold volume. Vaem , Vcem = Vasm , Vcsm # m-3. It is the exhaust manifold volume. # Interaction parameters between water and PEMFC structure e = 4.0 # It is the capillary exponent # Voltage polarization Re = 1e-06 # ohm.m\u00b2. It is the electron conduction resistance of the circuit. i0_d_c_ref = 14.43 # A.m-2. It is the dry reference exchange current density at the cathode. i0_h_c_ref = 1.0 # A.m-2. It is the fully humidified reference exchange current density at the cathode. kappa_co = 30.42 # mol.m-1.s-1.Pa-1. It is the crossover correction coefficient. kappa_c = 0.4152 # It is the overpotential correction exponent. a_slim , b_slim , a_switch = 0.05553 , 0.10514 , 0.82 # It is the limit liquid saturation coefficients. C_scl = 20e6 # F.m-3. It is the volumetric space-charge layer capacitance. # For other fuel cells else : raise ValueError ( 'the type_input given is not valid.' ) return ( Hacl , Hccl , epsilon_mc , Hmem , Hgdl , epsilon_gdl , epsilon_cl , epsilon_c , Hmpl , epsilon_mpl , Hagc , Hcgc , Wagc , Wcgc , Lgc , nb_channel_in_gc , Ldist , Lm , A_T_a , A_T_c , Vasm , Vcsm , Vaem , Vcem , Aact , nb_cell , e , Re , i0_d_c_ref , i0_h_c_ref , kappa_co , kappa_c , a_slim , b_slim , a_switch , C_scl )","title":"stored_physical_parameters"},{"location":"functions/modules/transitory_functions/","text":"Transitory functions This module contains transitory functions which all have a specific physical meaning for modeling the PEM fuel cell. C_v_sat ( T ) This function calculates the saturated vapor concentration for a perfect gas, in mol.m-3, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Saturated vapor concentration for a perfect gas in mol.m-3. Source code in modules/transitory_functions.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def C_v_sat ( T ): \"\"\"This function calculates the saturated vapor concentration for a perfect gas, in mol.m-3, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Saturated vapor concentration for a perfect gas in mol.m-3. \"\"\" return Psat ( T ) / ( R * T ) Cp0 ( component , T ) This function calculates the specific heat capacity of fluids, in J.kg-1.K-1, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Specific heat capacity of the selected fluid in J.kg-1.K-1. Notes Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition Source code in modules/transitory_functions.py 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 def Cp0 ( component , T ): \"\"\"This function calculates the specific heat capacity of fluids, in J.kg-1.K-1, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Specific heat capacity of the selected fluid in J.kg-1.K-1. Notes ----- Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition\"\"\" if component == 'H2O_l' : # For T >= 298 and T <= 500 K. return 1 / M_H2O * ( - 203.6060 + 1523.290 * ( T / 1000 ) - 3196.413 * ( T / 1000 ) ** 2 + 2474.455 * ( T / 1000 ) ** 3 + 3.855326 / ( T / 1000 ) ** 2 ) elif component == 'H2O_v' : # For T = 350 K. I failed to find a proper equation at the good range of temperature. return 1880 elif component == 'H2' : # For T >= 298 K and T <= 1000 K. return 1 / M_H2 * ( 33.066178 - 11.363417 * ( T / 1000 ) + 11.432816 * ( T / 1000 ) ** 2 - 2.772874 * ( T / 1000 ) ** 3 - 0.158558 / ( T / 1000 ) ** 2 ) elif component == 'O2' : # For T >= 100 K and T <= 700 K. return 1 / M_O2 * ( 31.32234 - 20.23531 * ( T / 1000 ) + 57.86644 * ( T / 1000 ) ** 2 - 36.50624 * ( T / 1000 ) ** 3 - 0.007374 / ( T / 1000 ) ** 2 ) elif component == 'N2' : # For T >= 100 K and T <= 500 K. return 1 / M_N2 * ( 28.98641 + 1.853978 * ( T / 1000 ) - 9.647459 * ( T / 1000 ) ** 2 + 16.63537 * ( T / 1000 ) ** 3 + 0.000117 / ( T / 1000 ) ** 2 ) else : raise ValueError ( \"The element should be either 'H2O_l', 'H2O_v', 'H2', 'O2' or 'N2'.\" ) D ( lambdaa ) This function calculates the diffusion coefficient of water in the membrane, in m\u00b2.s-1. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. Returns: float \u2013 Diffusion coefficient of water in the membrane in m\u00b2.s-1. Source code in modules/transitory_functions.py 606 607 608 609 610 611 612 613 614 615 616 617 618 619 def D ( lambdaa ): \"\"\"This function calculates the diffusion coefficient of water in the membrane, in m\u00b2.s-1. Parameters ---------- lambdaa : float Water content in the membrane. Returns ------- float Diffusion coefficient of water in the membrane in m\u00b2.s-1. \"\"\" return 4.1e-10 * ( lambdaa / 25.0 ) ** 0.15 * ( 1.0 + math . tanh (( lambdaa - 2.5 ) / 1.4 )) Da ( P , T ) This function calculates the diffusion coefficient at the anode, in m\u00b2.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Diffusion coefficient at the anode in m\u00b2.s-1. Source code in modules/transitory_functions.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def Da ( P , T ): \"\"\"This function calculates the diffusion coefficient at the anode, in m\u00b2.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Returns ------- float Diffusion coefficient at the anode in m\u00b2.s-1. \"\"\" return 1.644e-4 * ( T / 333 ) ** 2.334 * ( 101325 / P ) Da_eff ( element , s , T , P , epsilon , epsilon_c = None ) This function calculates the effective diffusion coefficient at the GDL, TL, MPL or the CL and at the anode, in m\u00b2.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. P ( float ) \u2013 Pressure in Pa. epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective diffusion coefficient at the anode in m\u00b2.s-1. Source code in modules/transitory_functions.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 def Da_eff ( element , s , T , P , epsilon , epsilon_c = None ): \"\"\"This function calculates the effective diffusion coefficient at the GDL, TL, MPL or the CL and at the anode, in m\u00b2.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. P : float Pressure in Pa. epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Effective diffusion coefficient at the anode in m\u00b2.s-1. \"\"\" if element == 'gdl' : # The effective diffusion coefficient at the GDL using Tomadakis and Sotirchos model. # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta2 = - 1.59 else : beta2 = - 0.90 tau_gdl = 1 / ((( epsilon - epsilon_p ) / ( 1 - epsilon_p )) ** alpha_p ) return epsilon / tau_gdl * math . exp ( beta2 * epsilon_c ) * ( 1 - s ) ** r_s_gdl * Da ( P , T ) elif element == 'mpl' : # The effective diffusion coefficient at the MPL using Bruggeman model. return epsilon / tau_mpl * ( 1 - s ) ** r_s_mpl * Da ( P , T ) elif element == 'cl' : # The effective diffusion coefficient at the CL using Bruggeman model. return epsilon / tau_cl * ( 1 - s ) ** r_s_cl * Da ( P , T ) else : raise ValueError ( \"The element should be either 'gdl', 'tl', 'mpl' or 'cl'.\" ) Dc ( P , T ) This function calculates the diffusion coefficient at the cathode, in m\u00b2.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Diffusion coefficient at the cathode in m\u00b2.s-1. Source code in modules/transitory_functions.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def Dc ( P , T ): \"\"\"This function calculates the diffusion coefficient at the cathode, in m\u00b2.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Returns ------- float Diffusion coefficient at the cathode in m\u00b2.s-1. \"\"\" return 3.242e-5 * ( T / 333 ) ** 2.334 * ( 101325 / P ) Dc_eff ( element , s , T , P , epsilon , epsilon_c = None ) This function calculates the effective diffusion coefficient at the GDL, MPL, TL or the CL and at the cathode, in m\u00b2.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. P ( float ) \u2013 Pressure in Pa. epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective diffusion coefficient at the cathode in m\u00b2.s-1. Source code in modules/transitory_functions.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def Dc_eff ( element , s , T , P , epsilon , epsilon_c = None ): \"\"\"This function calculates the effective diffusion coefficient at the GDL, MPL, TL or the CL and at the cathode, in m\u00b2.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. P : float Pressure in Pa. epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Effective diffusion coefficient at the cathode in m\u00b2.s-1. \"\"\" if element == 'gdl' : # The effective diffusion coefficient at the GDL using Tomadakis and Sotirchos model. # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta2 = - 1.59 else : beta2 = - 0.90 tau_gdl = 1 / ((( epsilon - epsilon_p ) / ( 1 - epsilon_p )) ** alpha_p ) return epsilon / tau_gdl * math . exp ( beta2 * epsilon_c ) * ( 1 - s ) ** r_s_gdl * Dc ( P , T ) elif element == 'mpl' : # The effective diffusion coefficient at the MPL using Bruggeman model. return epsilon / tau_mpl * ( 1 - s ) ** r_s_mpl * Dc ( P , T ) elif element == 'cl' : # The effective diffusion coefficient at the CL using Bruggeman model. return epsilon / tau_cl * ( 1 - s ) ** r_s_cl * Dc ( P , T ) else : raise ValueError ( \"The element should be either 'gdl', 'tl', 'mpl' or 'cl'.\" ) Dcap ( element , s , T , epsilon , e , epsilon_c = None ) This function calculates the capillary coefficient at the GDL or the CL and at the anode, in kg.m.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the capillary coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. epsilon ( float ) \u2013 Porosity. e ( float ) \u2013 Capillary exponent. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Source code in modules/transitory_functions.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def Dcap ( element , s , T , epsilon , e , epsilon_c = None ): \"\"\" This function calculates the capillary coefficient at the GDL or the CL and at the anode, in kg.m.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the capillary coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. epsilon : float Porosity. e : float Capillary exponent. epsilon_c : float, optional Compression ratio of the GDL. \"\"\" K0_value = K0 ( element , epsilon , epsilon_c ) if element == 'gdl' : theta_c_value = theta_c_gdl elif element == 'mpl' : theta_c_value = theta_c_mpl elif element == 'cl' : theta_c_value = theta_c_cl else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" ) return sigma ( T ) * K0_value / nu_l ( T ) * abs ( math . cos ( theta_c_value )) * \\ ( epsilon / K0_value ) ** 0.5 * ( s ** e + 1e-7 ) * ( 1.417 - 4.24 * s + 3.789 * s ** 2 ) K0 ( element , epsilon , epsilon_c = None ) cached This function calculates the intrinsic permeability, in m\u00b2, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the intrinsic permeability is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Intrinsic permeability in m\u00b2. Sources Qin Chen 2020 - Two-dimensional multi-physics modeling of porous transport layer in polymer electrolyte membrane electrolyzer for water splitting - for the Blake-Kozeny equation. M.L. Stewart 2005 - A study of pore geometry effects on anisotropy in hydraulic permeability using the lattice-Boltzmann method - for the Blake-Kozeny equation. Source code in modules/transitory_functions.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 @lru_cache ( maxsize = None ) # Cache the results to optimize performance def K0 ( element , epsilon , epsilon_c = None ): \"\"\"This function calculates the intrinsic permeability, in m\u00b2, considering GDL compression. Parameters ---------- element : str Specifies the element for which the intrinsic permeability is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Intrinsic permeability in m\u00b2. Sources ------- 1. Qin Chen 2020 - Two-dimensional multi-physics modeling of porous transport layer in polymer electrolyte membrane electrolyzer for water splitting - for the Blake-Kozeny equation. 2. M.L. Stewart 2005 - A study of pore geometry effects on anisotropy in hydraulic permeability using the lattice-Boltzmann method - for the Blake-Kozeny equation. \"\"\" if element == 'gdl' : # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta1 = - 3.60 else : beta1 = - 2.60 return epsilon / ( 8 * math . log ( epsilon ) ** 2 ) * ( epsilon - epsilon_p ) ** ( alpha_p + 2 ) * \\ 4.6e-6 ** 2 / (( 1 - epsilon_p ) ** alpha_p * (( alpha_p + 1 ) * epsilon - epsilon_p ) ** 2 ) * math . exp ( beta1 * epsilon_c ) elif element == 'mpl' : return ( Dp_mpl ** 2 / 150 ) * ( epsilon ** 3 / (( 1 - epsilon ) ** 2 )) # Using the Blake-Kozeny equation elif element == 'cl' : return ( Dp_cl ** 2 / 150 ) * ( epsilon ** 3 / (( 1 - epsilon ) ** 2 )) # Using the Blake-Kozeny equation else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" ) Psat ( T ) This function calculates the saturated partial pressure of vapor, in Pa, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Saturated partial pressure of vapor in Pa. Source code in modules/transitory_functions.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def Psat ( T ): \"\"\"This function calculates the saturated partial pressure of vapor, in Pa, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Saturated partial pressure of vapor in Pa. \"\"\" Tcelsius = T - 273.15 return 101325 * 10 ** ( - 2.1794 + 0.02953 * Tcelsius - 9.1837e-5 * Tcelsius ** 2 + 1.4454e-7 * Tcelsius ** 3 ) Svl ( element , s , C_v , Ctot , T , epsilon ) This function calculates the phase transfer rate of water condensation or evaporation, in mol.m-3.s-1. Parameters: element ( str ) \u2013 Specifies the element for which the phase transfer rate is calculated. s ( float ) \u2013 Liquid water saturation variable. C_v ( float ) \u2013 Water concentration variable in mol.m-3. Ctot ( float ) \u2013 Total gas concentration in mol.m-3. T ( float ) \u2013 Temperature in K. epsilon ( float ) \u2013 Porosity. Returns: float \u2013 Phase transfer rate of water condensation or evaporation in mol.m-3.s-1. Source code in modules/transitory_functions.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 def Svl ( element , s , C_v , Ctot , T , epsilon ): \"\"\"This function calculates the phase transfer rate of water condensation or evaporation, in mol.m-3.s-1. Parameters ---------- element : str Specifies the element for which the phase transfer rate is calculated. s : float Liquid water saturation variable. C_v : float Water concentration variable in mol.m-3. Ctot : float Total gas concentration in mol.m-3. T : float Temperature in K. epsilon : float Porosity. Returns ------- float Phase transfer rate of water condensation or evaporation in mol.m-3.s-1. \"\"\" # Calculation of the total and partial pressures Ptot = Ctot * R * T # Total pressure P_v = C_v * R * T # Partial pressure of vapor # Determination of the diffusion coefficient at the anode or the cathode if element == 'anode' : D_value = Da ( Ptot , T ) # Diffusion coefficient at the anode else : # element == 'cathode' D_value = Dc ( Ptot , T ) # Diffusion coefficient at the cathode Svl_cond = gamma_cond * M_H2O / ( R * T ) * epsilon * ( 1 - s ) * D_value * Ptot * math . log (( Ptot - Psat ( T )) / ( Ptot - P_v )) Svl_evap = gamma_evap * M_H2O / ( R * T ) * epsilon * s * D_value * Ptot * math . log (( Ptot - Psat ( T )) / ( Ptot - P_v )) w = 0.5 * ( 1 + math . tanh ( K_transition * ( C_v_sat ( T ) - C_v ))) # transition function return w * Svl_evap + ( 1 - w ) * Svl_cond # interpolation between condensation and evaporation average ( terms , weights = None ) Calculate the weighted arithmetic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling average from numpy. Parameters: terms \u2013 The terms to calculate the average for. weights \u2013 The weights corresponding to each term. If None, uniform weights are assumed. Returns: float \u2013 The weighted arithmetic mean. Source code in modules/transitory_functions.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def average ( terms , weights = None ): \"\"\" Calculate the weighted arithmetic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling average from numpy. Parameters ---------- terms (list of float): The terms to calculate the average for. weights (list of float, optional): The weights corresponding to each term. If None, uniform weights are assumed. Returns ------- float: The weighted arithmetic mean. \"\"\" n = len ( terms ) if weights is None : total_weight = n weighted_sum = 0.0 for t in terms : weighted_sum += t else : if n != len ( weights ): raise ValueError ( \"The length of terms and weights must be the same.\" ) total_weight = 0.0 weighted_sum = 0.0 for i in range ( n ): w = weights [ i ] total_weight += w weighted_sum += w * terms [ i ] if total_weight == 0 : return float ( 'nan' ) return weighted_sum / total_weight calculate_rho_Cp0 ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None ) This function calculates the volumetric heat capacity, in J.m-3.K-1, in either the GDL, the MPL, the CL or the membrane. Parameters: element ( str ) \u2013 Specifies the element for which the volumetric heat capacity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T ( float ) \u2013 Temperature in K. C_v ( float , default: None ) \u2013 Water concentration variable in mol.m-3. s ( float , default: None ) \u2013 Liquid water saturation variable. lambdaa ( float , default: None ) \u2013 Water content in the membrane. C_H2 ( float , default: None ) \u2013 Concentration of hydrogen in the AGDL or ACL. C_O2 ( float , default: None ) \u2013 Concentration of oxygen in the CGDL or CCL. C_N2 ( float , default: None ) \u2013 Concentration of nitrogen in the CGDL or CCL. epsilon ( float , default: None ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Volumetric heat capacity in J.m-3.K-1. Source code in modules/transitory_functions.py 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 def calculate_rho_Cp0 ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None ): \"\"\"This function calculates the volumetric heat capacity, in J.m-3.K-1, in either the GDL, the MPL, the CL or the membrane. Parameters ---------- element : str Specifies the element for which the volumetric heat capacity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T : float Temperature in K. C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. C_H2 : float Concentration of hydrogen in the AGDL or ACL. C_O2 : float Concentration of oxygen in the CGDL or CCL. C_N2 : float Concentration of nitrogen in the CGDL or CCL. epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. Returns ------- float Volumetric heat capacity in J.m-3.K-1.\"\"\" if element in ( 'agdl' , 'cgdl' , 'ampl' , 'cmpl' ): # The volumetric heat capacity at the GDL if element in ( 'agdl' , 'ampl' ): # In the anode sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 ]) else : # In the cathode sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 ]) if element in ( 'agdl' , 'cgdl' ): # In the GDLs return average ([ rho_gdl * Cp_gdl , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) else : # In the MPLs return average ([ rho_mpl * Cp_mpl , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element == 'acl' or element == 'ccl' : # The volumetric heat capacity at the CL if element == 'acl' : # The heat capacity of the gas mixture in the ACL sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 ]) else : # The heat capacity of the gas mixture in the CCL sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 ]) return average ([ rho_cl * Cp_cl , rho_mem * Cp_mem , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon - epsilon_mc , epsilon_mc , epsilon * s , epsilon * ( 1 - s )]) elif element == 'mem' : # The volumetric heat capacity at the membrane fv_val = fv ( lambdaa , T ) return average ([ rho_mem * Cp_mem , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T )], weights = [ 1 - fv_val , fv_val ]) else : raise ValueError ( \"The element should be either 'agdl', 'cgdl', 'ampl', 'cmpl', 'acl', 'ccl' or 'mem'.\" ) d2_dx2 ( y_minus , y_0 , y_plus , dx_minus , dx_plus = None ) Computes the centered second derivative (second order) with different steps to the left and right. Parameters: y_minus ( float ) \u2013 Value at the left point (i-1). y_0 ( float ) \u2013 Value at the central point (i). y_plus ( float ) \u2013 Value at the right point (i+1). dx_minus ( float ) \u2013 Step between (i-1) and i. dx_plus ( float , default: None ) \u2013 Step between i and (i+1). Returns: float \u2013 Approximation of the second derivative at i. Source code in modules/transitory_functions.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def d2_dx2 ( y_minus , y_0 , y_plus , dx_minus , dx_plus = None ): \"\"\" Computes the centered second derivative (second order) with different steps to the left and right. Parameters ---------- y_minus : float Value at the left point (i-1). y_0 : float Value at the central point (i). y_plus : float Value at the right point (i+1). dx_minus : float Step between (i-1) and i. dx_plus : float Step between i and (i+1). Returns ------- float Approximation of the second derivative at i. \"\"\" if dx_plus is None : dx = dx_minus return ( y_plus - 2 * y_0 + y_minus ) / dx ** 2 else : return 2 * ( y_plus * dx_minus - y_0 * ( dx_minus + dx_plus ) + y_minus * dx_plus ) / \\ ( dx_minus * dx_plus * ( dx_minus + dx_plus )) d_dx ( y_minus , y_plus , dx = None , dx_minus = None , dx_plus = None ) Computes the centered first derivative (second order) with different steps to the left and right. Parameters: y_minus ( float ) \u2013 Value at the left point (i-1). y_plus ( float ) \u2013 Value at the right point (i+1). dx ( float , default: None ) \u2013 Step between (i-1) and (i+1) when dx_minus = dx_plus. dx_minus ( float , default: None ) \u2013 Step between (i-1) and i. dx_plus ( float , default: None ) \u2013 Step between i and (i+1). Returns: float \u2013 Approximation of the first derivative at i. Source code in modules/transitory_functions.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def d_dx ( y_minus , y_plus , dx = None , dx_minus = None , dx_plus = None ): \"\"\" Computes the centered first derivative (second order) with different steps to the left and right. Parameters ---------- y_minus : float Value at the left point (i-1). y_plus : float Value at the right point (i+1). dx : float Step between (i-1) and (i+1) when dx_minus = dx_plus. dx_minus : float Step between (i-1) and i. dx_plus : float Step between i and (i+1). Returns ------- float Approximation of the first derivative at i. \"\"\" # Case of uniform grid spacing if dx is None : if dx_minus is None or dx_plus is None : raise ValueError ( \"Either dx or both dx_minus and dx_plus must be provided.\" ) else : if dx == 0 : raise ValueError ( \"dx must be non-zero.\" ) return ( y_plus - y_minus ) / ( 2.0 * dx ) # Case of non-uniform grid spacing (dx is None and dx_minus and dx_plus are provided) if dx_minus <= 0 or dx_plus <= 0 : raise ValueError ( \"dx_minus and dx_plus must be positive non-zero values.\" ) y_0 = interpolate ([ y_minus , y_plus ], [ dx_minus , dx_plus ]) return ( y_plus * dx_minus ** 2 + y_0 * ( dx_plus ** 2 - dx_minus ** 2 ) - y_minus * dx_plus ** 2 ) / \\ ( dx_minus * dx_plus * ( dx_minus + dx_plus )) delta_h_abs ( T ) This function computes the molar enthalpy of absorption of water at a given temperature, in J.mol-1. This reaction is exothermic. Parameters T : float Temperature in K. Returns delta_h_sorp : float Molar enthalpy of absorption in the CL in J.mol-1. Notes For Nafion, the enthalpy of absorption is almost equal to that of liquefaction [vetterFreeOpenReference2019]. Source code in modules/transitory_functions.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 def delta_h_abs ( T ): \"\"\"This function computes the molar enthalpy of absorption of water at a given temperature, in J.mol-1. This reaction is exothermic. Parameters ---------- T : float Temperature in K. Returns ------- delta_h_sorp : float Molar enthalpy of absorption in the CL in J.mol-1. Notes ----- For Nafion, the enthalpy of absorption is almost equal to that of liquefaction [vetterFreeOpenReference2019]. \"\"\" return delta_h_liq ( T ) delta_h_liq ( T ) This function computes the molar enthalpy of liquefaction of water at a given temperature, in J.mol-1. It is calculated as the difference in molar enthalpy between liquid water (H2O_l) and water vapor (H2O_v). Parameters T : float Temperature in K. Returns delta_h_liq : float Molar enthalpy of liquefaction in J.mol-1. Notes This value should be close to -42 000 J.mol-1 [vetterFreeOpenReference2019]. Source code in modules/transitory_functions.py 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 def delta_h_liq ( T ): \"\"\"This function computes the molar enthalpy of liquefaction of water at a given temperature, in J.mol-1. It is calculated as the difference in molar enthalpy between liquid water (H2O_l) and water vapor (H2O_v). Parameters ---------- T : float Temperature in K. Returns ------- delta_h_liq : float Molar enthalpy of liquefaction in J.mol-1. Notes ----- This value should be close to -42 000 J.mol-1 [vetterFreeOpenReference2019]. \"\"\" return h0 ( 'H2O_l' , T ) - h0 ( 'H2O_v' , T ) fv ( lambdaa , T ) This function calculates the water volume fraction of the membrane. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. Returns: float \u2013 Water volume fraction of the membrane. Source code in modules/transitory_functions.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 def fv ( lambdaa , T ): \"\"\"This function calculates the water volume fraction of the membrane. Parameters ---------- lambdaa : float Water content in the membrane. Returns ------- float Water volume fraction of the membrane. \"\"\" return ( lambdaa * M_H2O / rho_H2O_l ( T )) / ( M_eq / rho_mem + lambdaa * M_H2O / rho_H2O_l ( T )) gamma_sorp ( C_v , s , lambdaa , T , Hcl ) This function calculates the sorption rate of water in the membrane, in s-1. Parameters: C_v ( float ) \u2013 Water concentration variable in mol.m-3. s ( float ) \u2013 Liquid water saturation variable. lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. Hcl ( float ) \u2013 Thickness of the CL layer. Returns: float \u2013 Sorption rate of water in the membrane in s-1. Source code in modules/transitory_functions.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 def gamma_sorp ( C_v , s , lambdaa , T , Hcl ): \"\"\"This function calculates the sorption rate of water in the membrane, in s-1. Parameters ---------- C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. T : float Temperature in K. Hcl : float Thickness of the CL layer. Returns ------- float Sorption rate of water in the membrane in s-1. \"\"\" fv_value = fv ( lambdaa , T ) gamma_abs = ( 1.14e-5 * fv_value ) / Hcl * math . exp ( 2416 * ( 1 / 303 - 1 / T )) gamma_des = ( 4.59e-5 * fv_value ) / Hcl * math . exp ( 2416 * ( 1 / 303 - 1 / T )) w = 0.5 * ( 1 + math . tanh ( K_transition * ( lambda_eq ( C_v , s , T ) - lambdaa ))) # transition function return w * gamma_abs + ( 1 - w ) * gamma_des # interpolation between absorption and desorption h0 ( component , T ) This function calculates the standard enthalpy of fluids, in J.mol-1, as a function of the temperature. The variation of the enthalpy of reaction with temperature is given by Kirchhoff's Law of Thermochemistry. Parameters: component ( str ) \u2013 Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water) or 'H2O_v' (vapor). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Standard enthalpy of the selected fluid in J.mol-1. Notes Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition Source code in modules/transitory_functions.py 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 def h0 ( component , T ): \"\"\"This function calculates the standard enthalpy of fluids, in J.mol-1, as a function of the temperature. The variation of the enthalpy of reaction with temperature is given by Kirchhoff's Law of Thermochemistry. Parameters ---------- component : str Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water) or 'H2O_v' (vapor). T : float Temperature in K. Returns ------- float Standard enthalpy of the selected fluid in J.mol-1. Notes ----- Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition\"\"\" if component == 'H2O_l' : # For T >= 298 and T <= 500 K. return ( - 285.83 - 203.6060 * ( T / 1000 ) + 1523.290 * ( T / 1000 ) ** 2 / 2 - 3196.413 * ( T / 1000 ) ** 3 / 3 + 2474.455 * ( T / 1000 ) ** 4 / 4 - 3.855326 / ( T / 1000 ) - 256.5478 + 285.8304 ) * 1e3 elif component == 'H2O_v' : # For T = 298.15 K. I failed to find a proper equation at the good range of temperature. return - 241.83 * 1e3 + Cp0 ( 'H2O_v' , T ) * M_H2O * ( T - 298.15 ) else : raise ValueError ( \"The element should be either 'H2O_l' or 'H2O_v'\" ) h_a ( P , T , Wgc , Hgc ) This function calculates the effective convective-conductive mass transfer coefficient at the anode, in m.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Wgc ( float ) \u2013 Width of the gas channel in m. Hgc ( float ) \u2013 Thickness of the gas channel in m. Returns: float \u2013 Effective convective-conductive mass transfer coefficient at the anode in m.s-1. Source code in modules/transitory_functions.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def h_a ( P , T , Wgc , Hgc ): \"\"\"This function calculates the effective convective-conductive mass transfer coefficient at the anode, in m.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Wgc : float Width of the gas channel in m. Hgc : float Thickness of the gas channel in m. Returns ------- float Effective convective-conductive mass transfer coefficient at the anode in m.s-1. \"\"\" Sh = 0.9247 * math . log ( Wgc / Hgc ) + 2.3787 # Sherwood coefficient. return Sh * Da ( P , T ) / Hgc h_c ( P , T , Wgc , Hgc ) This function calculates the effective convective-conductive mass transfer coefficient at the cathode, in m.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Wgc ( float ) \u2013 Width of the gas channel in m. Hgc ( float ) \u2013 Thickness of the gas channel in m. Returns: float \u2013 Effective convective-conductive mass transfer coefficient at the cathode in m.s-1. Source code in modules/transitory_functions.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 def h_c ( P , T , Wgc , Hgc ): \"\"\"This function calculates the effective convective-conductive mass transfer coefficient at the cathode, in m.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Wgc : float Width of the gas channel in m. Hgc : float Thickness of the gas channel in m. Returns ------- float Effective convective-conductive mass transfer coefficient at the cathode in m.s-1. \"\"\" Sh = 0.9247 * math . log ( Wgc / Hgc ) + 2.3787 # Sherwood coefficient. return Sh * Dc ( P , T ) / Hgc hmean ( terms , weights = None ) Calculate the weighted harmonic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling hmean from scipy.stats. Parameters: terms \u2013 The terms to calculate the harmonic mean for. weights \u2013 The weights corresponding to each term. If None, uniform weights are assumed. Returns: float \u2013 The weighted harmonic mean. Source code in modules/transitory_functions.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def hmean ( terms , weights = None ): \"\"\" Calculate the weighted harmonic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling hmean from scipy.stats. Parameters ---------- terms (list of float): The terms to calculate the harmonic mean for. weights (list of float): The weights corresponding to each term. If None, uniform weights are assumed. Returns ------- float: The weighted harmonic mean. \"\"\" n = len ( terms ) if weights is None : weights = [ 1 ] * n # Assign equal weights if not provided if len ( weights ) != n : raise ValueError ( \"The length of terms and weights must be the same.\" ) # Calculate the weighted harmonic mean weighted_sum = 0 total_weight = 0 for w , t in zip ( weights , terms ): if t != 0 : weighted_sum += w / t total_weight += w if weighted_sum == 0 : return float ( 'inf' ) # Avoid division by zero return total_weight / weighted_sum interpolate ( terms , distances ) Fast inverse distance interpolation for exactly 2 points. Parameters: terms ( list of float ) \u2013 The values at each node ([y1, y2]). distances ( list of float ) \u2013 The distances from each node to the interpolation point ([d1, d2]). Returns: float \u2013 The interpolated value. Source code in modules/transitory_functions.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def interpolate ( terms , distances ): \"\"\" Fast inverse distance interpolation for exactly 2 points. Parameters ---------- terms : list of float The values at each node ([y1, y2]). distances : list of float The distances from each node to the interpolation point ([d1, d2]). Returns ------- float The interpolated value. \"\"\" if len ( terms ) != 2 or len ( distances ) != 2 : raise ValueError ( \"This function only supports interpolation with 2 points.\" ) y1 , y2 = terms d1 , d2 = distances if d1 == 0 : return y1 if d2 == 0 : return y2 return ( d2 * y1 + d1 * y2 ) / ( d1 + d2 ) k_H2 ( lambdaa , T , kappa_co ) This function calculates the permeability coefficient of the membrane for hydrogen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns: float \u2013 Permeability coefficient of the membrane for hydrogen in mol.m\u22121.s\u22121.Pa\u22121. Source code in modules/transitory_functions.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 def k_H2 ( lambdaa , T , kappa_co ): \"\"\"This function calculates the permeability coefficient of the membrane for hydrogen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters ---------- lambdaa : float Water content in the membrane. T : float Temperature in K. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns ------- float Permeability coefficient of the membrane for hydrogen in mol.m\u22121.s\u22121.Pa\u22121. \"\"\" # Initialisation of the constants E_H2_v = 2.1e4 # J.mol-1. It is the activation energy of H2 for crossover in the under saturated membrane. E_H2_l = 1.8e4 # J.mol-1. It is the activation energy of H2 for crossover in the liquid-equilibrated membrane. Tref = 303.15 # K. # Calculation of the permeability coefficient of the membrane for hydrogen k_H2_d = kappa_co * ( 0.29 + 2.2 * fv ( lambdaa , T )) * 1e-14 * math . exp ( E_H2_v / R * ( 1 / Tref - 1 / T )) k_H2_l = kappa_co * 1.8 * 1e-14 * math . exp ( E_H2_l / R * ( 1 / Tref - 1 / T )) w = 0.5 * ( 1 + math . tanh ( K_transition * ( lambda_l_eq ( T ) - lambdaa ))) # transition function return w * k_H2_d + ( 1 - w ) * k_H2_l # interpolation between under-saturated and liquid-equilibrated H2 crossover k_O2 ( lambdaa , T , kappa_co ) This function calculates the permeability coefficient of the membrane for oxygen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns: float \u2013 Permeability coefficient of the membrane for oxygen in mol.m\u22121.s\u22121.Pa\u22121. Source code in modules/transitory_functions.py 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 def k_O2 ( lambdaa , T , kappa_co ): \"\"\"This function calculates the permeability coefficient of the membrane for oxygen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters ---------- lambdaa : float Water content in the membrane. T : float Temperature in K. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns ------- float Permeability coefficient of the membrane for oxygen in mol.m\u22121.s\u22121.Pa\u22121. \"\"\" # Initialisation of the constants E_O2_v = 2.2e4 # J.mol-1. It is the activation energy of oxygen for crossover in the under saturated membrane. E_O2_l = 2.0e4 # J.mol-1. It is the activation energy of oxygen for crossover in the liquid-equilibrated membrane. Tref = 303.15 # K. # Calculation of the permeability coefficient of the membrane for oxygen k_O2_v = kappa_co * ( 0.11 + 1.9 * fv ( lambdaa , T )) * 1e-14 * math . exp ( E_O2_v / R * ( 1 / Tref - 1 / T )) k_O2_l = kappa_co * 1.2 * 1e-14 * math . exp ( E_O2_l / R * ( 1 / Tref - 1 / T )) w = 0.5 * ( 1 + math . tanh ( K_transition * ( lambda_l_eq ( T ) - lambdaa ))) # transition function return w * k_O2_v + ( 1 - w ) * k_O2_l # interpolation between under-saturated and liquid-equilibrated O2 crossover k_th ( component , T ) cached This function calculates the thermal conductivity of fluids, in J.m-1.s-1.K-1, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the thermal conductivity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Thermal conductivity of the selected fluid in J.m-1.s-1.K-1. Notes Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons) Source code in modules/transitory_functions.py 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 @lru_cache ( maxsize = None ) # Cache the results to optimize performance def k_th ( component , T ): \"\"\"This function calculates the thermal conductivity of fluids, in J.m-1.s-1.K-1, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the thermal conductivity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Thermal conductivity of the selected fluid in J.m-1.s-1.K-1. Notes ----- Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons)\"\"\" if component == 'H2O_l' : # For T >= 273.16 and T <= 633.15 K. return - 0.2987 + 4.7054e-3 * T - 5.6209e-6 * T ** 2 elif component == 'H2O_v' : # For T >= 150 K and T <= 1500 k. return 5.6199e-3 + 1.5699e-5 * T + 1.0106e-7 * T ** 2 - 2.4282e-11 * T ** 3 elif component == 'H2' : # For T >= 14 K and T <= 1500 K. return 1.0979e-2 + 6.6411e-4 * T - 3.4378e-7 * T ** 2 + 9.7283e-11 * T ** 3 elif component == 'O2' : # For T >= 80 K and T <= 2000 K. return 1.5475e-4 + 9.4153e-5 * T - 2.7529e-8 * T ** 2 + 5.2069e-12 * T ** 3 elif component == 'N2' : # For T >= 63 K and T <= 1500 K. return - 2.2678e-4 + 1.0275e-4 * T - 6.0151e-8 * T ** 2 + 2.2332e-11 * T ** 3 else : raise ValueError ( \"The element should be either 'H2O_l', 'H2O_v', 'H2', 'O2' or 'N2'.\" ) k_th_eff ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None , epsilon_c = None ) This function calculates the effective thermal conductivity, in J.m-1.s-1.K-1, in either the GDL, the MPL, the CL or the membrane. A weighted harmonic average is used for characterizing the conductivity of each material in a layer, instead of a weighted arithmetic average. The physical meaning is that all the heat energy is forced to pass through all the material, as a series resistance network, instead of a parallel one [pharoahEffectiveTransportCoefficients2006]. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T ( float ) \u2013 Temperature in K. C_v ( float , default: None ) \u2013 Water concentration variable in mol.m-3. s ( float , default: None ) \u2013 Liquid water saturation variable. lambdaa ( float , default: None ) \u2013 Water content in the membrane. C_H2 ( float , default: None ) \u2013 Concentration of hydrogen in the AGDL or ACL. C_O2 ( float , default: None ) \u2013 Concentration of oxygen in the CGDL or CCL. C_N2 ( float , default: None ) \u2013 Concentration of nitrogen in the CGDL or CCL. epsilon ( float , default: None ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective thermal conductivity in J.m-1.s-1.K-1. Source code in modules/transitory_functions.py 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 def k_th_eff ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None , epsilon_c = None ): \"\"\"This function calculates the effective thermal conductivity, in J.m-1.s-1.K-1, in either the GDL, the MPL, the CL or the membrane. A weighted harmonic average is used for characterizing the conductivity of each material in a layer, instead of a weighted arithmetic average. The physical meaning is that all the heat energy is forced to pass through all the material, as a series resistance network, instead of a parallel one [pharoahEffectiveTransportCoefficients2006]. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T : float Temperature in K. C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. C_H2 : float Concentration of hydrogen in the AGDL or ACL. C_O2 : float Concentration of oxygen in the CGDL or CCL. C_N2 : float Concentration of nitrogen in the CGDL or CCL. epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. epsilon_c : float Compression ratio of the GDL. Returns ------- float Effective thermal conductivity in J.m-1.s-1.K-1.\"\"\" if element in ( 'agdl' , 'cgdl' ): # The effective thermal conductivity at the GDL # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta3 = 4.04 else : beta3 = 4.40 if element == 'agdl' : # The thermal conductivity of the gas mixture in the AGDL sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 x_v , x_h2 , x_n2 = C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_h2 , x_n2 ], [ M_H2O , M_H2 , M_N2 ]) else : # The thermal conductivity of the gas mixture in the CGDL sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 x_v , x_o2 , x_n2 = C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_o2 , x_n2 ], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_gdl * math . exp ( beta3 * epsilon_c ), k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element in ( 'ampl' , 'cmpl' ): # The effective thermal conductivity at the GDL if element == 'ampl' : # The thermal conductivity of the gas mixture in the AGDL sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 x_v , x_h2 , x_n2 = C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_h2 , x_n2 ], [ M_H2O , M_H2 , M_N2 ]) else : # The thermal conductivity of the gas mixture in the CGDL sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 x_v , x_o2 , x_n2 = C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_o2 , x_n2 ], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_mpl , k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element in ( 'acl' , 'ccl' ): # The effective thermal conductivity at the CL fv_val = fv ( lambdaa , T ) k_th_eff_mem = hmean ([ k_th_mem , k_th ( 'H2O_l' , T )], weights = [ 1 - fv_val , fv_val ]) # The effective thermal conductivity at the membrane if element == 'acl' : # The thermal conductivity of the gas mixture in the ACL sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 x_v , x_h2 , x_n2 = C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_h2 , x_n2 ], [ M_H2O , M_H2 , M_N2 ]) else : # The thermal conductivity of the gas mixture in the CCL sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 x_v , x_o2 , x_n2 = C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_o2 , x_n2 ], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_cl , k_th_eff_mem , k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon - epsilon_mc , epsilon_mc , epsilon * s , epsilon * ( 1 - s )]) elif element == 'mem' : # The effective thermal conductivity at the membrane fv_val = fv ( lambdaa , T ) return hmean ([ k_th_mem , k_th ( 'H2O_l' , T )], weights = [ 1 - fv_val , fv_val ]) else : raise ValueError ( \"The element should be either 'agdl', 'cgdl', 'ampl', 'cmpl', 'acl', 'ccl' or 'mem'.\" ) k_th_gaz_mixture ( k_th_g , mu_g , x , M ) This function calculates the thermal conductivity of a gas mixture, in J.m-1.s-1.K-1. The Lindsay\u2013Bromley (Wassiljewa) method is used. Parameters: k_th_g ( list ) \u2013 Thermal conductivities of each pure gas component, in J.m-1.s-1.K-1, at the same temperature. mu_g ( list ) \u2013 Viscosity of each pure gas component, in Pa.s, at the same temperature. x ( list ) \u2013 Mole fractions of each gas component in the mixture (must sum to 1). M ( list ) \u2013 Molar masses of each gas component (in kg.mol-1). Returns: lambda_mix ( float ) \u2013 Thermal conductivity of the gas mixture, in J.m-1.s-1.K-1. Notes Source : [wuMathematicalModelingTransient2009] and [polingPropertiesGasesLiquids2001] Source code in modules/transitory_functions.py 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 def k_th_gaz_mixture ( k_th_g , mu_g , x , M ): \"\"\"This function calculates the thermal conductivity of a gas mixture, in J.m-1.s-1.K-1. The Lindsay\u2013Bromley (Wassiljewa) method is used. Parameters ---------- k_th_g : list Thermal conductivities of each pure gas component, in J.m-1.s-1.K-1, at the same temperature. mu_g : list Viscosity of each pure gas component, in Pa.s, at the same temperature. x : list Mole fractions of each gas component in the mixture (must sum to 1). M : list Molar masses of each gas component (in kg.mol-1). Returns ------- lambda_mix : float Thermal conductivity of the gas mixture, in J.m-1.s-1.K-1. Notes ----- Source : [wuMathematicalModelingTransient2009] and [polingPropertiesGasesLiquids2001]\"\"\" total_x = 0.0 for xi in x : total_x += xi if abs ( total_x - 1.0 ) > 1e-6 : raise ValueError ( \"The sum of the molar fractions should be 1.\" ) n = len ( k_th_g ) epsilon_TS = 0.85 # Value suggested by Tandon and Saxena in 1965. # Calculation of A_W using Maxon and Saxena suggestion. A_W = [] for i in range ( n ): row = [] for j in range ( n ): if i == j : row . append ( 1.0 ) else : val = ( epsilon_TS * ( 1 + ( mu_g [ i ] / mu_g [ j ]) ** 0.5 * ( M [ j ] / M [ i ]) ** 0.25 ) ** 2 ) / \\ ( 8 * ( 1 + M [ i ] / M [ j ])) ** 0.5 row . append ( val ) A_W . append ( row ) # Calculation of the thermal conductivity of the gas mixture. k_th_gaz_mixture = 0.0 for i in range ( n ): prod_x_A_w = 0.0 for j in range ( n ): prod_x_A_w += x [ j ] * A_W [ i ][ j ] k_th_gaz_mixture += x [ i ] * k_th_g [ i ] / prod_x_A_w return k_th_gaz_mixture lambda_eq ( C_v , s , T ) This function calculates the equilibrium water content in the membrane. Hinatsu's expression modified with Bao's formulation has been selected. Parameters: C_v ( float ) \u2013 Water concentration variable in mol.m-3. s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Equilibrium water content in the membrane. Source code in modules/transitory_functions.py 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def lambda_eq ( C_v , s , T ): \"\"\"This function calculates the equilibrium water content in the membrane. Hinatsu's expression modified with Bao's formulation has been selected. Parameters ---------- C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. T : float Temperature in K. Returns ------- float Equilibrium water content in the membrane. \"\"\" a_w = C_v / C_v_sat ( T ) + 2 * s # water activity return 0.5 * lambda_v_eq ( a_w ) * ( 1 - math . tanh ( 100 * ( a_w - 1 ))) + \\ 0.5 * ( lambda_v_eq ( 1 ) + (( lambda_l_eq ( T ) - lambda_v_eq ( 1 )) / 2 ) * ( 1 - math . exp ( - Kshape * ( a_w - 1 )))) * \\ ( 1 + math . tanh ( 100 * ( a_w - 1 ))) lambda_l_eq ( T ) This function calculates the equilibrium water content in the membrane from the liquid phase. Hinatsu's expression has been selected. It is valid for N-form membranes for 25 to 100 \u00b0C. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Equilibrium water content in the membrane from the liquid phase. Source code in modules/transitory_functions.py 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def lambda_l_eq ( T ): \"\"\"This function calculates the equilibrium water content in the membrane from the liquid phase. Hinatsu's expression has been selected. It is valid for N-form membranes for 25 to 100 \u00b0C. Parameters ---------- T : float Temperature in K. Returns ------- float Equilibrium water content in the membrane from the liquid phase. \"\"\" return 10.0 * 1.84e-2 * ( T - 273.15 ) + 9.90e-4 * ( T - 273.15 ) ** 2 lambda_v_eq ( a_w ) This function calculates the equilibrium water content in the membrane from the vapor phase. Hinatsu's expression has been selected. Parameters: a_w \u2013 Water activity. Returns: float \u2013 Equilibrium water content in the membrane from the vapor phase. Source code in modules/transitory_functions.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def lambda_v_eq ( a_w ): \"\"\"This function calculates the equilibrium water content in the membrane from the vapor phase. Hinatsu's expression has been selected. Parameters ---------- a_w: float Water activity. Returns ------- float Equilibrium water content in the membrane from the vapor phase. \"\"\" return 0.300 + 10.8 * a_w - 16.0 * a_w ** 2 + 14.1 * a_w ** 3 mu_gaz ( component , T ) This function calculates the dynamic viscosity of different gases, in Pa.s, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the dynamic viscosity is calculated. Must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Dynamic viscosity of the selected gas in Pa.s. Notes Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons) Source code in modules/transitory_functions.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def mu_gaz ( component , T ): \"\"\"This function calculates the dynamic viscosity of different gases, in Pa.s, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the dynamic viscosity is calculated. Must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Dynamic viscosity of the selected gas in Pa.s. Notes ----- Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons)\"\"\" if component == 'H2O_v' : # For T >= 150 K and T <= 1500 k. return ( 22.8211 + 1.7387e-1 * T + 3.2465e-4 * T ** 2 - 1.4334e-7 * T ** 3 ) * 10 **- 7 elif component == 'H2' : # For T >= 15 K and T <= 1500 K. return ( 1.7611 + 3.4165e-1 * T - 1.8368e-4 * T ** 2 + 5.1147e-8 * T ** 3 ) * 10 **- 7 elif component == 'O2' : # For T >= 54 K and T <= 1500 K. return ( - 4.9433 + 8.0673e-1 * T - 4.0416e-4 * T ** 2 + 1.0111e-7 * T ** 3 ) * 10 **- 7 elif component == 'N2' : # For T >= 63 K and T <= 1970 K. return ( 4.4656 + 6.3814e-1 * T - 2.6596e-4 * T ** 2 + 5.4113e-8 * T ** 3 ) * 10 **- 7 else : raise ValueError ( \"The element should be either 'H2O_v', 'H2', 'O2' or 'N2'.\" ) mu_mixture_gases ( components , x , T ) This function calculates the dynamic viscosity of a gas mixture, in Pa.s, as a function of the temperature. Parameters: components ( list of str ) \u2013 List of gas components in the mixture. Each component must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). x ( list of float ) \u2013 List of mole fractions corresponding to each gas component in the mixture. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Dynamic viscosity of the gas mixture in Pa.s. Notes A simple mixture law is used here to calculate the dynamic viscosity of the gas mixture. Source code in modules/transitory_functions.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def mu_mixture_gases ( components , x , T ): \"\"\"This function calculates the dynamic viscosity of a gas mixture, in Pa.s, as a function of the temperature. Parameters ---------- components : list of str List of gas components in the mixture. Each component must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). x : list of float List of mole fractions corresponding to each gas component in the mixture. T : float Temperature in K. Returns ------- float Dynamic viscosity of the gas mixture in Pa.s. Notes ----- A simple mixture law is used here to calculate the dynamic viscosity of the gas mixture. \"\"\" # Calculate the dynamic viscosities of each gas component in Pa.s. mu_values = [ mu_gaz ( comp , T ) for comp in components ] # Calculate the molar mass of the gas mixture in kg/mol. M_mix = 0.0 for j in range ( len ( components )): M_j = M_H2O if components [ j ] == 'H2O_v' else M_H2 if components [ j ] == 'H2' else M_O2 if components [ j ] == 'O2' \\ else M_N2 if components [ j ] == 'N2' else None M_mix += M_j * x [ j ] inv_mu_mix = 0.0 for j , mu_j in enumerate ( mu_values ): M_j = M_H2O if components [ j ] == 'H2O_v' else M_H2 if components [ j ] == 'H2' else M_O2 if components [ j ] == 'O2' else M_N2 c_j = M_j * x [ j ] / M_mix inv_mu_mix += c_j / mu_j return 1 / inv_mu_mix nu_l ( T ) This function calculates the liquid water kinematic viscosity, in m\u00b2.s-1, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Liquid water kinematic viscosity in m\u00b2.s-1. Source code in modules/transitory_functions.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def nu_l ( T ): \"\"\"This function calculates the liquid water kinematic viscosity, in m\u00b2.s-1, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Liquid water kinematic viscosity in m\u00b2.s-1. \"\"\" mu_l = 2.414 * 10 ** ( - 5 + 247.8 / ( T - 140.0 )) # Pa.s. It is the liquid water dynamic viscosity. return mu_l / rho_H2O_l ( T ) rho_H2O_l ( T ) This function calculates the water density, in kg.m-3, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Water density in kg.m-3. Source code in modules/transitory_functions.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def rho_H2O_l ( T ): \"\"\"This function calculates the water density, in kg.m-3, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Water density in kg.m-3. \"\"\" T_Celsius = T - 273.15 return (( 999.83952 + 16.945176 * T_Celsius - 7.9870401e-3 * T_Celsius ** 2 - 46.170461e-6 * T_Celsius ** 3 + 105.56302e-9 * T_Celsius ** 4 - 280.54253e-12 * T_Celsius ** 5 ) / ( 1 + 16.879850e-3 * T_Celsius )) sigma ( T ) This function calculates the water surface tension, in N.m-1, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Water surface tension in N.m-1. Source code in modules/transitory_functions.py 708 709 710 711 712 713 714 715 716 717 718 719 720 721 def sigma ( T ): \"\"\"This function calculates the water surface tension, in N.m-1, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Water surface tension in N.m-1. \"\"\" return 235.8e-3 * (( 647.15 - T ) / 647.15 ) ** 1.256 * ( 1 - 0.625 * ( 647.15 - T ) / 647.15 ) sigma_e_eff ( element , epsilon , epsilon_c = None , epsilon_mc = None ) cached This function calculates the effective electrical conductivity, in \u03a9-1.m-1, in either the GDL, the MPL or the CL, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Effective electrical conductivity in \u03a9-1.m-1. Source code in modules/transitory_functions.py 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 @lru_cache ( maxsize = None ) # Cache the results to optimize performance def sigma_e_eff ( element , epsilon , epsilon_c = None , epsilon_mc = None ): \"\"\"This function calculates the effective electrical conductivity, in \u03a9-1.m-1, in either the GDL, the MPL or the CL, considering GDL compression. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. epsilon_mc : float, optional Volume fraction of ionomer in the CL. Returns ------- float Effective electrical conductivity in \u03a9-1.m-1. \"\"\" if element == 'gdl' : # The effective electrical conductivity at the GDL # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta3 = 4.04 else : beta3 = 4.40 return ( 1 - epsilon ) * sigma_e_gdl * math . exp ( beta3 * epsilon_c ) # Using the volume fraction of conductive material. elif element == 'mpl' : # The effective electrical conductivity at the MPL return ( 1 - epsilon ) * sigma_e_mpl # Using the volume fraction of conductive material. elif element == 'cl' : # The effective electrical conductivity at the CL return ( 1 - epsilon - epsilon_mc ) * sigma_e_cl # Using the volume fraction of conductive material. else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" ) sigma_p_eff ( element , lambdaa , T , epsilon_mc = None ) This function calculates the effective proton conductivity, in \u03a9-1.m-1, in either the membrane or the CCL. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'mem' (membrane) or 'ccl' (cathode catalyst layer). lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CCL. Returns: float \u2013 Proton conductivity in \u03a9-1.m-1. Source code in modules/transitory_functions.py 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 def sigma_p_eff ( element , lambdaa , T , epsilon_mc = None ): \"\"\"This function calculates the effective proton conductivity, in \u03a9-1.m-1, in either the membrane or the CCL. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'mem' (membrane) or 'ccl' (cathode catalyst layer). lambdaa : float Water content in the membrane. T : float Temperature in K. epsilon_mc : float Volume fraction of ionomer in the CCL. Returns ------- float Proton conductivity in \u03a9-1.m-1. \"\"\" lambda_transition = 1 if element == 'mem' : # The proton conductivity at the membrane sigma_p_eff_low = 0.1879 * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) sigma_p_eff_high = ( 0.5139 * lambdaa - 0.326 ) * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) elif element == 'ccl' : # The effective proton conductivity at the cathode catalyst layer sigma_p_eff_low = epsilon_mc * 0.1879 * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) sigma_p_eff_high = epsilon_mc * ( 0.5139 * lambdaa - 0.326 ) * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) else : raise ValueError ( \"The element should be either 'mem' or 'ccl'.\" ) w = 0.5 * ( 1 + math . tanh ( K_transition * ( lambda_transition - lambdaa ))) # transition function return w * sigma_p_eff_low + ( 1 - w ) * sigma_p_eff_high # interpolation between sigma_p_eff value at low and high lambda.","title":"Transitory functions"},{"location":"functions/modules/transitory_functions/#transitory-functions","text":"This module contains transitory functions which all have a specific physical meaning for modeling the PEM fuel cell.","title":"Transitory functions"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.C_v_sat","text":"This function calculates the saturated vapor concentration for a perfect gas, in mol.m-3, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Saturated vapor concentration for a perfect gas in mol.m-3. Source code in modules/transitory_functions.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def C_v_sat ( T ): \"\"\"This function calculates the saturated vapor concentration for a perfect gas, in mol.m-3, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Saturated vapor concentration for a perfect gas in mol.m-3. \"\"\" return Psat ( T ) / ( R * T )","title":"C_v_sat"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Cp0","text":"This function calculates the specific heat capacity of fluids, in J.kg-1.K-1, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Specific heat capacity of the selected fluid in J.kg-1.K-1. Notes Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition Source code in modules/transitory_functions.py 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 def Cp0 ( component , T ): \"\"\"This function calculates the specific heat capacity of fluids, in J.kg-1.K-1, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Specific heat capacity of the selected fluid in J.kg-1.K-1. Notes ----- Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition\"\"\" if component == 'H2O_l' : # For T >= 298 and T <= 500 K. return 1 / M_H2O * ( - 203.6060 + 1523.290 * ( T / 1000 ) - 3196.413 * ( T / 1000 ) ** 2 + 2474.455 * ( T / 1000 ) ** 3 + 3.855326 / ( T / 1000 ) ** 2 ) elif component == 'H2O_v' : # For T = 350 K. I failed to find a proper equation at the good range of temperature. return 1880 elif component == 'H2' : # For T >= 298 K and T <= 1000 K. return 1 / M_H2 * ( 33.066178 - 11.363417 * ( T / 1000 ) + 11.432816 * ( T / 1000 ) ** 2 - 2.772874 * ( T / 1000 ) ** 3 - 0.158558 / ( T / 1000 ) ** 2 ) elif component == 'O2' : # For T >= 100 K and T <= 700 K. return 1 / M_O2 * ( 31.32234 - 20.23531 * ( T / 1000 ) + 57.86644 * ( T / 1000 ) ** 2 - 36.50624 * ( T / 1000 ) ** 3 - 0.007374 / ( T / 1000 ) ** 2 ) elif component == 'N2' : # For T >= 100 K and T <= 500 K. return 1 / M_N2 * ( 28.98641 + 1.853978 * ( T / 1000 ) - 9.647459 * ( T / 1000 ) ** 2 + 16.63537 * ( T / 1000 ) ** 3 + 0.000117 / ( T / 1000 ) ** 2 ) else : raise ValueError ( \"The element should be either 'H2O_l', 'H2O_v', 'H2', 'O2' or 'N2'.\" )","title":"Cp0"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.D","text":"This function calculates the diffusion coefficient of water in the membrane, in m\u00b2.s-1. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. Returns: float \u2013 Diffusion coefficient of water in the membrane in m\u00b2.s-1. Source code in modules/transitory_functions.py 606 607 608 609 610 611 612 613 614 615 616 617 618 619 def D ( lambdaa ): \"\"\"This function calculates the diffusion coefficient of water in the membrane, in m\u00b2.s-1. Parameters ---------- lambdaa : float Water content in the membrane. Returns ------- float Diffusion coefficient of water in the membrane in m\u00b2.s-1. \"\"\" return 4.1e-10 * ( lambdaa / 25.0 ) ** 0.15 * ( 1.0 + math . tanh (( lambdaa - 2.5 ) / 1.4 ))","title":"D"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Da","text":"This function calculates the diffusion coefficient at the anode, in m\u00b2.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Diffusion coefficient at the anode in m\u00b2.s-1. Source code in modules/transitory_functions.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def Da ( P , T ): \"\"\"This function calculates the diffusion coefficient at the anode, in m\u00b2.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Returns ------- float Diffusion coefficient at the anode in m\u00b2.s-1. \"\"\" return 1.644e-4 * ( T / 333 ) ** 2.334 * ( 101325 / P )","title":"Da"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Da_eff","text":"This function calculates the effective diffusion coefficient at the GDL, TL, MPL or the CL and at the anode, in m\u00b2.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. P ( float ) \u2013 Pressure in Pa. epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective diffusion coefficient at the anode in m\u00b2.s-1. Source code in modules/transitory_functions.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 def Da_eff ( element , s , T , P , epsilon , epsilon_c = None ): \"\"\"This function calculates the effective diffusion coefficient at the GDL, TL, MPL or the CL and at the anode, in m\u00b2.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. P : float Pressure in Pa. epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Effective diffusion coefficient at the anode in m\u00b2.s-1. \"\"\" if element == 'gdl' : # The effective diffusion coefficient at the GDL using Tomadakis and Sotirchos model. # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta2 = - 1.59 else : beta2 = - 0.90 tau_gdl = 1 / ((( epsilon - epsilon_p ) / ( 1 - epsilon_p )) ** alpha_p ) return epsilon / tau_gdl * math . exp ( beta2 * epsilon_c ) * ( 1 - s ) ** r_s_gdl * Da ( P , T ) elif element == 'mpl' : # The effective diffusion coefficient at the MPL using Bruggeman model. return epsilon / tau_mpl * ( 1 - s ) ** r_s_mpl * Da ( P , T ) elif element == 'cl' : # The effective diffusion coefficient at the CL using Bruggeman model. return epsilon / tau_cl * ( 1 - s ) ** r_s_cl * Da ( P , T ) else : raise ValueError ( \"The element should be either 'gdl', 'tl', 'mpl' or 'cl'.\" )","title":"Da_eff"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Dc","text":"This function calculates the diffusion coefficient at the cathode, in m\u00b2.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Diffusion coefficient at the cathode in m\u00b2.s-1. Source code in modules/transitory_functions.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def Dc ( P , T ): \"\"\"This function calculates the diffusion coefficient at the cathode, in m\u00b2.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Returns ------- float Diffusion coefficient at the cathode in m\u00b2.s-1. \"\"\" return 3.242e-5 * ( T / 333 ) ** 2.334 * ( 101325 / P )","title":"Dc"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Dc_eff","text":"This function calculates the effective diffusion coefficient at the GDL, MPL, TL or the CL and at the cathode, in m\u00b2.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. P ( float ) \u2013 Pressure in Pa. epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective diffusion coefficient at the cathode in m\u00b2.s-1. Source code in modules/transitory_functions.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def Dc_eff ( element , s , T , P , epsilon , epsilon_c = None ): \"\"\"This function calculates the effective diffusion coefficient at the GDL, MPL, TL or the CL and at the cathode, in m\u00b2.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the effective diffusion coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. P : float Pressure in Pa. epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Effective diffusion coefficient at the cathode in m\u00b2.s-1. \"\"\" if element == 'gdl' : # The effective diffusion coefficient at the GDL using Tomadakis and Sotirchos model. # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta2 = - 1.59 else : beta2 = - 0.90 tau_gdl = 1 / ((( epsilon - epsilon_p ) / ( 1 - epsilon_p )) ** alpha_p ) return epsilon / tau_gdl * math . exp ( beta2 * epsilon_c ) * ( 1 - s ) ** r_s_gdl * Dc ( P , T ) elif element == 'mpl' : # The effective diffusion coefficient at the MPL using Bruggeman model. return epsilon / tau_mpl * ( 1 - s ) ** r_s_mpl * Dc ( P , T ) elif element == 'cl' : # The effective diffusion coefficient at the CL using Bruggeman model. return epsilon / tau_cl * ( 1 - s ) ** r_s_cl * Dc ( P , T ) else : raise ValueError ( \"The element should be either 'gdl', 'tl', 'mpl' or 'cl'.\" )","title":"Dc_eff"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Dcap","text":"This function calculates the capillary coefficient at the GDL or the CL and at the anode, in kg.m.s-1, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the capillary coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. epsilon ( float ) \u2013 Porosity. e ( float ) \u2013 Capillary exponent. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Source code in modules/transitory_functions.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def Dcap ( element , s , T , epsilon , e , epsilon_c = None ): \"\"\" This function calculates the capillary coefficient at the GDL or the CL and at the anode, in kg.m.s-1, considering GDL compression. Parameters ---------- element : str Specifies the element for which the capillary coefficient is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). s : float Liquid water saturation variable. T : float Temperature in K. epsilon : float Porosity. e : float Capillary exponent. epsilon_c : float, optional Compression ratio of the GDL. \"\"\" K0_value = K0 ( element , epsilon , epsilon_c ) if element == 'gdl' : theta_c_value = theta_c_gdl elif element == 'mpl' : theta_c_value = theta_c_mpl elif element == 'cl' : theta_c_value = theta_c_cl else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" ) return sigma ( T ) * K0_value / nu_l ( T ) * abs ( math . cos ( theta_c_value )) * \\ ( epsilon / K0_value ) ** 0.5 * ( s ** e + 1e-7 ) * ( 1.417 - 4.24 * s + 3.789 * s ** 2 )","title":"Dcap"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.K0","text":"This function calculates the intrinsic permeability, in m\u00b2, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the intrinsic permeability is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Intrinsic permeability in m\u00b2. Sources Qin Chen 2020 - Two-dimensional multi-physics modeling of porous transport layer in polymer electrolyte membrane electrolyzer for water splitting - for the Blake-Kozeny equation. M.L. Stewart 2005 - A study of pore geometry effects on anisotropy in hydraulic permeability using the lattice-Boltzmann method - for the Blake-Kozeny equation. Source code in modules/transitory_functions.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 @lru_cache ( maxsize = None ) # Cache the results to optimize performance def K0 ( element , epsilon , epsilon_c = None ): \"\"\"This function calculates the intrinsic permeability, in m\u00b2, considering GDL compression. Parameters ---------- element : str Specifies the element for which the intrinsic permeability is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. Returns ------- float Intrinsic permeability in m\u00b2. Sources ------- 1. Qin Chen 2020 - Two-dimensional multi-physics modeling of porous transport layer in polymer electrolyte membrane electrolyzer for water splitting - for the Blake-Kozeny equation. 2. M.L. Stewart 2005 - A study of pore geometry effects on anisotropy in hydraulic permeability using the lattice-Boltzmann method - for the Blake-Kozeny equation. \"\"\" if element == 'gdl' : # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta1 = - 3.60 else : beta1 = - 2.60 return epsilon / ( 8 * math . log ( epsilon ) ** 2 ) * ( epsilon - epsilon_p ) ** ( alpha_p + 2 ) * \\ 4.6e-6 ** 2 / (( 1 - epsilon_p ) ** alpha_p * (( alpha_p + 1 ) * epsilon - epsilon_p ) ** 2 ) * math . exp ( beta1 * epsilon_c ) elif element == 'mpl' : return ( Dp_mpl ** 2 / 150 ) * ( epsilon ** 3 / (( 1 - epsilon ) ** 2 )) # Using the Blake-Kozeny equation elif element == 'cl' : return ( Dp_cl ** 2 / 150 ) * ( epsilon ** 3 / (( 1 - epsilon ) ** 2 )) # Using the Blake-Kozeny equation else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" )","title":"K0"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Psat","text":"This function calculates the saturated partial pressure of vapor, in Pa, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Saturated partial pressure of vapor in Pa. Source code in modules/transitory_functions.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def Psat ( T ): \"\"\"This function calculates the saturated partial pressure of vapor, in Pa, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Saturated partial pressure of vapor in Pa. \"\"\" Tcelsius = T - 273.15 return 101325 * 10 ** ( - 2.1794 + 0.02953 * Tcelsius - 9.1837e-5 * Tcelsius ** 2 + 1.4454e-7 * Tcelsius ** 3 )","title":"Psat"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.Svl","text":"This function calculates the phase transfer rate of water condensation or evaporation, in mol.m-3.s-1. Parameters: element ( str ) \u2013 Specifies the element for which the phase transfer rate is calculated. s ( float ) \u2013 Liquid water saturation variable. C_v ( float ) \u2013 Water concentration variable in mol.m-3. Ctot ( float ) \u2013 Total gas concentration in mol.m-3. T ( float ) \u2013 Temperature in K. epsilon ( float ) \u2013 Porosity. Returns: float \u2013 Phase transfer rate of water condensation or evaporation in mol.m-3.s-1. Source code in modules/transitory_functions.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 def Svl ( element , s , C_v , Ctot , T , epsilon ): \"\"\"This function calculates the phase transfer rate of water condensation or evaporation, in mol.m-3.s-1. Parameters ---------- element : str Specifies the element for which the phase transfer rate is calculated. s : float Liquid water saturation variable. C_v : float Water concentration variable in mol.m-3. Ctot : float Total gas concentration in mol.m-3. T : float Temperature in K. epsilon : float Porosity. Returns ------- float Phase transfer rate of water condensation or evaporation in mol.m-3.s-1. \"\"\" # Calculation of the total and partial pressures Ptot = Ctot * R * T # Total pressure P_v = C_v * R * T # Partial pressure of vapor # Determination of the diffusion coefficient at the anode or the cathode if element == 'anode' : D_value = Da ( Ptot , T ) # Diffusion coefficient at the anode else : # element == 'cathode' D_value = Dc ( Ptot , T ) # Diffusion coefficient at the cathode Svl_cond = gamma_cond * M_H2O / ( R * T ) * epsilon * ( 1 - s ) * D_value * Ptot * math . log (( Ptot - Psat ( T )) / ( Ptot - P_v )) Svl_evap = gamma_evap * M_H2O / ( R * T ) * epsilon * s * D_value * Ptot * math . log (( Ptot - Psat ( T )) / ( Ptot - P_v )) w = 0.5 * ( 1 + math . tanh ( K_transition * ( C_v_sat ( T ) - C_v ))) # transition function return w * Svl_evap + ( 1 - w ) * Svl_cond # interpolation between condensation and evaporation","title":"Svl"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.average","text":"Calculate the weighted arithmetic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling average from numpy. Parameters: terms \u2013 The terms to calculate the average for. weights \u2013 The weights corresponding to each term. If None, uniform weights are assumed. Returns: float \u2013 The weighted arithmetic mean. Source code in modules/transitory_functions.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def average ( terms , weights = None ): \"\"\" Calculate the weighted arithmetic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling average from numpy. Parameters ---------- terms (list of float): The terms to calculate the average for. weights (list of float, optional): The weights corresponding to each term. If None, uniform weights are assumed. Returns ------- float: The weighted arithmetic mean. \"\"\" n = len ( terms ) if weights is None : total_weight = n weighted_sum = 0.0 for t in terms : weighted_sum += t else : if n != len ( weights ): raise ValueError ( \"The length of terms and weights must be the same.\" ) total_weight = 0.0 weighted_sum = 0.0 for i in range ( n ): w = weights [ i ] total_weight += w weighted_sum += w * terms [ i ] if total_weight == 0 : return float ( 'nan' ) return weighted_sum / total_weight","title":"average"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.calculate_rho_Cp0","text":"This function calculates the volumetric heat capacity, in J.m-3.K-1, in either the GDL, the MPL, the CL or the membrane. Parameters: element ( str ) \u2013 Specifies the element for which the volumetric heat capacity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T ( float ) \u2013 Temperature in K. C_v ( float , default: None ) \u2013 Water concentration variable in mol.m-3. s ( float , default: None ) \u2013 Liquid water saturation variable. lambdaa ( float , default: None ) \u2013 Water content in the membrane. C_H2 ( float , default: None ) \u2013 Concentration of hydrogen in the AGDL or ACL. C_O2 ( float , default: None ) \u2013 Concentration of oxygen in the CGDL or CCL. C_N2 ( float , default: None ) \u2013 Concentration of nitrogen in the CGDL or CCL. epsilon ( float , default: None ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Volumetric heat capacity in J.m-3.K-1. Source code in modules/transitory_functions.py 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 def calculate_rho_Cp0 ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None ): \"\"\"This function calculates the volumetric heat capacity, in J.m-3.K-1, in either the GDL, the MPL, the CL or the membrane. Parameters ---------- element : str Specifies the element for which the volumetric heat capacity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T : float Temperature in K. C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. C_H2 : float Concentration of hydrogen in the AGDL or ACL. C_O2 : float Concentration of oxygen in the CGDL or CCL. C_N2 : float Concentration of nitrogen in the CGDL or CCL. epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. Returns ------- float Volumetric heat capacity in J.m-3.K-1.\"\"\" if element in ( 'agdl' , 'cgdl' , 'ampl' , 'cmpl' ): # The volumetric heat capacity at the GDL if element in ( 'agdl' , 'ampl' ): # In the anode sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 ]) else : # In the cathode sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 ]) if element in ( 'agdl' , 'cgdl' ): # In the GDLs return average ([ rho_gdl * Cp_gdl , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) else : # In the MPLs return average ([ rho_mpl * Cp_mpl , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element == 'acl' or element == 'ccl' : # The volumetric heat capacity at the CL if element == 'acl' : # The heat capacity of the gas mixture in the ACL sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_H2 * C_H2 * Cp0 ( 'H2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 ]) else : # The heat capacity of the gas mixture in the CCL sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 rho_Cp0_gaz = average ([ M_H2O * C_v * Cp0 ( 'H2O_v' , T ), M_O2 * C_O2 * Cp0 ( 'O2' , T ), M_N2 * C_N2 * Cp0 ( 'N2' , T )], weights = [ C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 ]) return average ([ rho_cl * Cp_cl , rho_mem * Cp_mem , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T ), rho_Cp0_gaz ], weights = [ 1 - epsilon - epsilon_mc , epsilon_mc , epsilon * s , epsilon * ( 1 - s )]) elif element == 'mem' : # The volumetric heat capacity at the membrane fv_val = fv ( lambdaa , T ) return average ([ rho_mem * Cp_mem , rho_H2O_l ( T ) * Cp0 ( 'H2O_l' , T )], weights = [ 1 - fv_val , fv_val ]) else : raise ValueError ( \"The element should be either 'agdl', 'cgdl', 'ampl', 'cmpl', 'acl', 'ccl' or 'mem'.\" )","title":"calculate_rho_Cp0"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.d2_dx2","text":"Computes the centered second derivative (second order) with different steps to the left and right. Parameters: y_minus ( float ) \u2013 Value at the left point (i-1). y_0 ( float ) \u2013 Value at the central point (i). y_plus ( float ) \u2013 Value at the right point (i+1). dx_minus ( float ) \u2013 Step between (i-1) and i. dx_plus ( float , default: None ) \u2013 Step between i and (i+1). Returns: float \u2013 Approximation of the second derivative at i. Source code in modules/transitory_functions.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def d2_dx2 ( y_minus , y_0 , y_plus , dx_minus , dx_plus = None ): \"\"\" Computes the centered second derivative (second order) with different steps to the left and right. Parameters ---------- y_minus : float Value at the left point (i-1). y_0 : float Value at the central point (i). y_plus : float Value at the right point (i+1). dx_minus : float Step between (i-1) and i. dx_plus : float Step between i and (i+1). Returns ------- float Approximation of the second derivative at i. \"\"\" if dx_plus is None : dx = dx_minus return ( y_plus - 2 * y_0 + y_minus ) / dx ** 2 else : return 2 * ( y_plus * dx_minus - y_0 * ( dx_minus + dx_plus ) + y_minus * dx_plus ) / \\ ( dx_minus * dx_plus * ( dx_minus + dx_plus ))","title":"d2_dx2"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.d_dx","text":"Computes the centered first derivative (second order) with different steps to the left and right. Parameters: y_minus ( float ) \u2013 Value at the left point (i-1). y_plus ( float ) \u2013 Value at the right point (i+1). dx ( float , default: None ) \u2013 Step between (i-1) and (i+1) when dx_minus = dx_plus. dx_minus ( float , default: None ) \u2013 Step between (i-1) and i. dx_plus ( float , default: None ) \u2013 Step between i and (i+1). Returns: float \u2013 Approximation of the first derivative at i. Source code in modules/transitory_functions.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def d_dx ( y_minus , y_plus , dx = None , dx_minus = None , dx_plus = None ): \"\"\" Computes the centered first derivative (second order) with different steps to the left and right. Parameters ---------- y_minus : float Value at the left point (i-1). y_plus : float Value at the right point (i+1). dx : float Step between (i-1) and (i+1) when dx_minus = dx_plus. dx_minus : float Step between (i-1) and i. dx_plus : float Step between i and (i+1). Returns ------- float Approximation of the first derivative at i. \"\"\" # Case of uniform grid spacing if dx is None : if dx_minus is None or dx_plus is None : raise ValueError ( \"Either dx or both dx_minus and dx_plus must be provided.\" ) else : if dx == 0 : raise ValueError ( \"dx must be non-zero.\" ) return ( y_plus - y_minus ) / ( 2.0 * dx ) # Case of non-uniform grid spacing (dx is None and dx_minus and dx_plus are provided) if dx_minus <= 0 or dx_plus <= 0 : raise ValueError ( \"dx_minus and dx_plus must be positive non-zero values.\" ) y_0 = interpolate ([ y_minus , y_plus ], [ dx_minus , dx_plus ]) return ( y_plus * dx_minus ** 2 + y_0 * ( dx_plus ** 2 - dx_minus ** 2 ) - y_minus * dx_plus ** 2 ) / \\ ( dx_minus * dx_plus * ( dx_minus + dx_plus ))","title":"d_dx"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.delta_h_abs","text":"This function computes the molar enthalpy of absorption of water at a given temperature, in J.mol-1. This reaction is exothermic. Parameters T : float Temperature in K. Returns delta_h_sorp : float Molar enthalpy of absorption in the CL in J.mol-1. Notes For Nafion, the enthalpy of absorption is almost equal to that of liquefaction [vetterFreeOpenReference2019]. Source code in modules/transitory_functions.py 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 def delta_h_abs ( T ): \"\"\"This function computes the molar enthalpy of absorption of water at a given temperature, in J.mol-1. This reaction is exothermic. Parameters ---------- T : float Temperature in K. Returns ------- delta_h_sorp : float Molar enthalpy of absorption in the CL in J.mol-1. Notes ----- For Nafion, the enthalpy of absorption is almost equal to that of liquefaction [vetterFreeOpenReference2019]. \"\"\" return delta_h_liq ( T )","title":"delta_h_abs"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.delta_h_liq","text":"This function computes the molar enthalpy of liquefaction of water at a given temperature, in J.mol-1. It is calculated as the difference in molar enthalpy between liquid water (H2O_l) and water vapor (H2O_v). Parameters T : float Temperature in K. Returns delta_h_liq : float Molar enthalpy of liquefaction in J.mol-1. Notes This value should be close to -42 000 J.mol-1 [vetterFreeOpenReference2019]. Source code in modules/transitory_functions.py 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 def delta_h_liq ( T ): \"\"\"This function computes the molar enthalpy of liquefaction of water at a given temperature, in J.mol-1. It is calculated as the difference in molar enthalpy between liquid water (H2O_l) and water vapor (H2O_v). Parameters ---------- T : float Temperature in K. Returns ------- delta_h_liq : float Molar enthalpy of liquefaction in J.mol-1. Notes ----- This value should be close to -42 000 J.mol-1 [vetterFreeOpenReference2019]. \"\"\" return h0 ( 'H2O_l' , T ) - h0 ( 'H2O_v' , T )","title":"delta_h_liq"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.fv","text":"This function calculates the water volume fraction of the membrane. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. Returns: float \u2013 Water volume fraction of the membrane. Source code in modules/transitory_functions.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 def fv ( lambdaa , T ): \"\"\"This function calculates the water volume fraction of the membrane. Parameters ---------- lambdaa : float Water content in the membrane. Returns ------- float Water volume fraction of the membrane. \"\"\" return ( lambdaa * M_H2O / rho_H2O_l ( T )) / ( M_eq / rho_mem + lambdaa * M_H2O / rho_H2O_l ( T ))","title":"fv"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.gamma_sorp","text":"This function calculates the sorption rate of water in the membrane, in s-1. Parameters: C_v ( float ) \u2013 Water concentration variable in mol.m-3. s ( float ) \u2013 Liquid water saturation variable. lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. Hcl ( float ) \u2013 Thickness of the CL layer. Returns: float \u2013 Sorption rate of water in the membrane in s-1. Source code in modules/transitory_functions.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 def gamma_sorp ( C_v , s , lambdaa , T , Hcl ): \"\"\"This function calculates the sorption rate of water in the membrane, in s-1. Parameters ---------- C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. T : float Temperature in K. Hcl : float Thickness of the CL layer. Returns ------- float Sorption rate of water in the membrane in s-1. \"\"\" fv_value = fv ( lambdaa , T ) gamma_abs = ( 1.14e-5 * fv_value ) / Hcl * math . exp ( 2416 * ( 1 / 303 - 1 / T )) gamma_des = ( 4.59e-5 * fv_value ) / Hcl * math . exp ( 2416 * ( 1 / 303 - 1 / T )) w = 0.5 * ( 1 + math . tanh ( K_transition * ( lambda_eq ( C_v , s , T ) - lambdaa ))) # transition function return w * gamma_abs + ( 1 - w ) * gamma_des # interpolation between absorption and desorption","title":"gamma_sorp"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.h0","text":"This function calculates the standard enthalpy of fluids, in J.mol-1, as a function of the temperature. The variation of the enthalpy of reaction with temperature is given by Kirchhoff's Law of Thermochemistry. Parameters: component ( str ) \u2013 Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water) or 'H2O_v' (vapor). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Standard enthalpy of the selected fluid in J.mol-1. Notes Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition Source code in modules/transitory_functions.py 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 def h0 ( component , T ): \"\"\"This function calculates the standard enthalpy of fluids, in J.mol-1, as a function of the temperature. The variation of the enthalpy of reaction with temperature is given by Kirchhoff's Law of Thermochemistry. Parameters ---------- component : str Specifies the gas for which the specific heat capacity is calculated. Must be either 'H2O_l' (liquid water) or 'H2O_v' (vapor). T : float Temperature in K. Returns ------- float Standard enthalpy of the selected fluid in J.mol-1. Notes ----- Source : Chase, M. W. (1998). NIST-JANAF Thermochemical Tables, 4th edition\"\"\" if component == 'H2O_l' : # For T >= 298 and T <= 500 K. return ( - 285.83 - 203.6060 * ( T / 1000 ) + 1523.290 * ( T / 1000 ) ** 2 / 2 - 3196.413 * ( T / 1000 ) ** 3 / 3 + 2474.455 * ( T / 1000 ) ** 4 / 4 - 3.855326 / ( T / 1000 ) - 256.5478 + 285.8304 ) * 1e3 elif component == 'H2O_v' : # For T = 298.15 K. I failed to find a proper equation at the good range of temperature. return - 241.83 * 1e3 + Cp0 ( 'H2O_v' , T ) * M_H2O * ( T - 298.15 ) else : raise ValueError ( \"The element should be either 'H2O_l' or 'H2O_v'\" )","title":"h0"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.h_a","text":"This function calculates the effective convective-conductive mass transfer coefficient at the anode, in m.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Wgc ( float ) \u2013 Width of the gas channel in m. Hgc ( float ) \u2013 Thickness of the gas channel in m. Returns: float \u2013 Effective convective-conductive mass transfer coefficient at the anode in m.s-1. Source code in modules/transitory_functions.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def h_a ( P , T , Wgc , Hgc ): \"\"\"This function calculates the effective convective-conductive mass transfer coefficient at the anode, in m.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Wgc : float Width of the gas channel in m. Hgc : float Thickness of the gas channel in m. Returns ------- float Effective convective-conductive mass transfer coefficient at the anode in m.s-1. \"\"\" Sh = 0.9247 * math . log ( Wgc / Hgc ) + 2.3787 # Sherwood coefficient. return Sh * Da ( P , T ) / Hgc","title":"h_a"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.h_c","text":"This function calculates the effective convective-conductive mass transfer coefficient at the cathode, in m.s-1. Parameters: P ( float ) \u2013 Pressure in Pa. T ( float ) \u2013 Temperature in K. Wgc ( float ) \u2013 Width of the gas channel in m. Hgc ( float ) \u2013 Thickness of the gas channel in m. Returns: float \u2013 Effective convective-conductive mass transfer coefficient at the cathode in m.s-1. Source code in modules/transitory_functions.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 def h_c ( P , T , Wgc , Hgc ): \"\"\"This function calculates the effective convective-conductive mass transfer coefficient at the cathode, in m.s-1. Parameters ---------- P : float Pressure in Pa. T : float Temperature in K. Wgc : float Width of the gas channel in m. Hgc : float Thickness of the gas channel in m. Returns ------- float Effective convective-conductive mass transfer coefficient at the cathode in m.s-1. \"\"\" Sh = 0.9247 * math . log ( Wgc / Hgc ) + 2.3787 # Sherwood coefficient. return Sh * Dc ( P , T ) / Hgc","title":"h_c"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.hmean","text":"Calculate the weighted harmonic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling hmean from scipy.stats. Parameters: terms \u2013 The terms to calculate the harmonic mean for. weights \u2013 The weights corresponding to each term. If None, uniform weights are assumed. Returns: float \u2013 The weighted harmonic mean. Source code in modules/transitory_functions.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def hmean ( terms , weights = None ): \"\"\" Calculate the weighted harmonic mean of a list of terms with corresponding weights. It is more efficient to express this function in the code than calling hmean from scipy.stats. Parameters ---------- terms (list of float): The terms to calculate the harmonic mean for. weights (list of float): The weights corresponding to each term. If None, uniform weights are assumed. Returns ------- float: The weighted harmonic mean. \"\"\" n = len ( terms ) if weights is None : weights = [ 1 ] * n # Assign equal weights if not provided if len ( weights ) != n : raise ValueError ( \"The length of terms and weights must be the same.\" ) # Calculate the weighted harmonic mean weighted_sum = 0 total_weight = 0 for w , t in zip ( weights , terms ): if t != 0 : weighted_sum += w / t total_weight += w if weighted_sum == 0 : return float ( 'inf' ) # Avoid division by zero return total_weight / weighted_sum","title":"hmean"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.interpolate","text":"Fast inverse distance interpolation for exactly 2 points. Parameters: terms ( list of float ) \u2013 The values at each node ([y1, y2]). distances ( list of float ) \u2013 The distances from each node to the interpolation point ([d1, d2]). Returns: float \u2013 The interpolated value. Source code in modules/transitory_functions.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def interpolate ( terms , distances ): \"\"\" Fast inverse distance interpolation for exactly 2 points. Parameters ---------- terms : list of float The values at each node ([y1, y2]). distances : list of float The distances from each node to the interpolation point ([d1, d2]). Returns ------- float The interpolated value. \"\"\" if len ( terms ) != 2 or len ( distances ) != 2 : raise ValueError ( \"This function only supports interpolation with 2 points.\" ) y1 , y2 = terms d1 , d2 = distances if d1 == 0 : return y1 if d2 == 0 : return y2 return ( d2 * y1 + d1 * y2 ) / ( d1 + d2 )","title":"interpolate"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_H2","text":"This function calculates the permeability coefficient of the membrane for hydrogen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns: float \u2013 Permeability coefficient of the membrane for hydrogen in mol.m\u22121.s\u22121.Pa\u22121. Source code in modules/transitory_functions.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 def k_H2 ( lambdaa , T , kappa_co ): \"\"\"This function calculates the permeability coefficient of the membrane for hydrogen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters ---------- lambdaa : float Water content in the membrane. T : float Temperature in K. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns ------- float Permeability coefficient of the membrane for hydrogen in mol.m\u22121.s\u22121.Pa\u22121. \"\"\" # Initialisation of the constants E_H2_v = 2.1e4 # J.mol-1. It is the activation energy of H2 for crossover in the under saturated membrane. E_H2_l = 1.8e4 # J.mol-1. It is the activation energy of H2 for crossover in the liquid-equilibrated membrane. Tref = 303.15 # K. # Calculation of the permeability coefficient of the membrane for hydrogen k_H2_d = kappa_co * ( 0.29 + 2.2 * fv ( lambdaa , T )) * 1e-14 * math . exp ( E_H2_v / R * ( 1 / Tref - 1 / T )) k_H2_l = kappa_co * 1.8 * 1e-14 * math . exp ( E_H2_l / R * ( 1 / Tref - 1 / T )) w = 0.5 * ( 1 + math . tanh ( K_transition * ( lambda_l_eq ( T ) - lambdaa ))) # transition function return w * k_H2_d + ( 1 - w ) * k_H2_l # interpolation between under-saturated and liquid-equilibrated H2 crossover","title":"k_H2"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_O2","text":"This function calculates the permeability coefficient of the membrane for oxygen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters: lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. kappa_co ( float ) \u2013 Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns: float \u2013 Permeability coefficient of the membrane for oxygen in mol.m\u22121.s\u22121.Pa\u22121. Source code in modules/transitory_functions.py 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 def k_O2 ( lambdaa , T , kappa_co ): \"\"\"This function calculates the permeability coefficient of the membrane for oxygen, in mol.m\u22121.s\u22121.Pa\u22121. Parameters ---------- lambdaa : float Water content in the membrane. T : float Temperature in K. kappa_co : float Crossover correction coefficient in mol.m-1.s-1.Pa-1. Returns ------- float Permeability coefficient of the membrane for oxygen in mol.m\u22121.s\u22121.Pa\u22121. \"\"\" # Initialisation of the constants E_O2_v = 2.2e4 # J.mol-1. It is the activation energy of oxygen for crossover in the under saturated membrane. E_O2_l = 2.0e4 # J.mol-1. It is the activation energy of oxygen for crossover in the liquid-equilibrated membrane. Tref = 303.15 # K. # Calculation of the permeability coefficient of the membrane for oxygen k_O2_v = kappa_co * ( 0.11 + 1.9 * fv ( lambdaa , T )) * 1e-14 * math . exp ( E_O2_v / R * ( 1 / Tref - 1 / T )) k_O2_l = kappa_co * 1.2 * 1e-14 * math . exp ( E_O2_l / R * ( 1 / Tref - 1 / T )) w = 0.5 * ( 1 + math . tanh ( K_transition * ( lambda_l_eq ( T ) - lambdaa ))) # transition function return w * k_O2_v + ( 1 - w ) * k_O2_l # interpolation between under-saturated and liquid-equilibrated O2 crossover","title":"k_O2"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_th","text":"This function calculates the thermal conductivity of fluids, in J.m-1.s-1.K-1, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the thermal conductivity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Thermal conductivity of the selected fluid in J.m-1.s-1.K-1. Notes Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons) Source code in modules/transitory_functions.py 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 @lru_cache ( maxsize = None ) # Cache the results to optimize performance def k_th ( component , T ): \"\"\"This function calculates the thermal conductivity of fluids, in J.m-1.s-1.K-1, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the thermal conductivity is calculated. Must be either 'H2O_l' (liquid water), 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Thermal conductivity of the selected fluid in J.m-1.s-1.K-1. Notes ----- Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons)\"\"\" if component == 'H2O_l' : # For T >= 273.16 and T <= 633.15 K. return - 0.2987 + 4.7054e-3 * T - 5.6209e-6 * T ** 2 elif component == 'H2O_v' : # For T >= 150 K and T <= 1500 k. return 5.6199e-3 + 1.5699e-5 * T + 1.0106e-7 * T ** 2 - 2.4282e-11 * T ** 3 elif component == 'H2' : # For T >= 14 K and T <= 1500 K. return 1.0979e-2 + 6.6411e-4 * T - 3.4378e-7 * T ** 2 + 9.7283e-11 * T ** 3 elif component == 'O2' : # For T >= 80 K and T <= 2000 K. return 1.5475e-4 + 9.4153e-5 * T - 2.7529e-8 * T ** 2 + 5.2069e-12 * T ** 3 elif component == 'N2' : # For T >= 63 K and T <= 1500 K. return - 2.2678e-4 + 1.0275e-4 * T - 6.0151e-8 * T ** 2 + 2.2332e-11 * T ** 3 else : raise ValueError ( \"The element should be either 'H2O_l', 'H2O_v', 'H2', 'O2' or 'N2'.\" )","title":"k_th"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_th_eff","text":"This function calculates the effective thermal conductivity, in J.m-1.s-1.K-1, in either the GDL, the MPL, the CL or the membrane. A weighted harmonic average is used for characterizing the conductivity of each material in a layer, instead of a weighted arithmetic average. The physical meaning is that all the heat energy is forced to pass through all the material, as a series resistance network, instead of a parallel one [pharoahEffectiveTransportCoefficients2006]. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T ( float ) \u2013 Temperature in K. C_v ( float , default: None ) \u2013 Water concentration variable in mol.m-3. s ( float , default: None ) \u2013 Liquid water saturation variable. lambdaa ( float , default: None ) \u2013 Water content in the membrane. C_H2 ( float , default: None ) \u2013 Concentration of hydrogen in the AGDL or ACL. C_O2 ( float , default: None ) \u2013 Concentration of oxygen in the CGDL or CCL. C_N2 ( float , default: None ) \u2013 Concentration of nitrogen in the CGDL or CCL. epsilon ( float , default: None ) \u2013 Porosity. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. Returns: float \u2013 Effective thermal conductivity in J.m-1.s-1.K-1. Source code in modules/transitory_functions.py 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 def k_th_eff ( element , T , C_v = None , s = None , lambdaa = None , C_H2 = None , C_O2 = None , C_N2 = None , epsilon = None , epsilon_mc = None , epsilon_c = None ): \"\"\"This function calculates the effective thermal conductivity, in J.m-1.s-1.K-1, in either the GDL, the MPL, the CL or the membrane. A weighted harmonic average is used for characterizing the conductivity of each material in a layer, instead of a weighted arithmetic average. The physical meaning is that all the heat energy is forced to pass through all the material, as a series resistance network, instead of a parallel one [pharoahEffectiveTransportCoefficients2006]. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'agdl' (anode gas diffusion layer), 'cgdl' (cathode gas diffusion layer), 'acl' (anode catalyst layer), 'ccl' (cathode catalyst layer) or 'mem' (membrane). T : float Temperature in K. C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. lambdaa : float Water content in the membrane. C_H2 : float Concentration of hydrogen in the AGDL or ACL. C_O2 : float Concentration of oxygen in the CGDL or CCL. C_N2 : float Concentration of nitrogen in the CGDL or CCL. epsilon : float Porosity. epsilon_mc : float Volume fraction of ionomer in the CL. epsilon_c : float Compression ratio of the GDL. Returns ------- float Effective thermal conductivity in J.m-1.s-1.K-1.\"\"\" if element in ( 'agdl' , 'cgdl' ): # The effective thermal conductivity at the GDL # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta3 = 4.04 else : beta3 = 4.40 if element == 'agdl' : # The thermal conductivity of the gas mixture in the AGDL sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 x_v , x_h2 , x_n2 = C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_h2 , x_n2 ], [ M_H2O , M_H2 , M_N2 ]) else : # The thermal conductivity of the gas mixture in the CGDL sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 x_v , x_o2 , x_n2 = C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_o2 , x_n2 ], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_gdl * math . exp ( beta3 * epsilon_c ), k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element in ( 'ampl' , 'cmpl' ): # The effective thermal conductivity at the GDL if element == 'ampl' : # The thermal conductivity of the gas mixture in the AGDL sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 x_v , x_h2 , x_n2 = C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_h2 , x_n2 ], [ M_H2O , M_H2 , M_N2 ]) else : # The thermal conductivity of the gas mixture in the CGDL sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 x_v , x_o2 , x_n2 = C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_o2 , x_n2 ], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_mpl , k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon , epsilon * s , epsilon * ( 1 - s )]) elif element in ( 'acl' , 'ccl' ): # The effective thermal conductivity at the CL fv_val = fv ( lambdaa , T ) k_th_eff_mem = hmean ([ k_th_mem , k_th ( 'H2O_l' , T )], weights = [ 1 - fv_val , fv_val ]) # The effective thermal conductivity at the membrane if element == 'acl' : # The thermal conductivity of the gas mixture in the ACL sum_C_v_C_H2_C_N2 = C_v + C_H2 + C_N2 x_v , x_h2 , x_n2 = C_v / sum_C_v_C_H2_C_N2 , C_H2 / sum_C_v_C_H2_C_N2 , C_N2 / sum_C_v_C_H2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'H2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'H2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_h2 , x_n2 ], [ M_H2O , M_H2 , M_N2 ]) else : # The thermal conductivity of the gas mixture in the CCL sum_C_v_C_O2_C_N2 = C_v + C_O2 + C_N2 x_v , x_o2 , x_n2 = C_v / sum_C_v_C_O2_C_N2 , C_O2 / sum_C_v_C_O2_C_N2 , C_N2 / sum_C_v_C_O2_C_N2 k_th_gaz = k_th_gaz_mixture ([ k_th ( 'H2O_v' , T ), k_th ( 'O2' , T ), k_th ( 'N2' , T )], [ mu_gaz ( 'H2O_v' , T ), mu_gaz ( 'O2' , T ), mu_gaz ( 'N2' , T )], [ x_v , x_o2 , x_n2 ], [ M_H2O , M_O2 , M_N2 ]) return hmean ([ k_th_cl , k_th_eff_mem , k_th ( 'H2O_l' , T ), k_th_gaz ], weights = [ 1 - epsilon - epsilon_mc , epsilon_mc , epsilon * s , epsilon * ( 1 - s )]) elif element == 'mem' : # The effective thermal conductivity at the membrane fv_val = fv ( lambdaa , T ) return hmean ([ k_th_mem , k_th ( 'H2O_l' , T )], weights = [ 1 - fv_val , fv_val ]) else : raise ValueError ( \"The element should be either 'agdl', 'cgdl', 'ampl', 'cmpl', 'acl', 'ccl' or 'mem'.\" )","title":"k_th_eff"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.k_th_gaz_mixture","text":"This function calculates the thermal conductivity of a gas mixture, in J.m-1.s-1.K-1. The Lindsay\u2013Bromley (Wassiljewa) method is used. Parameters: k_th_g ( list ) \u2013 Thermal conductivities of each pure gas component, in J.m-1.s-1.K-1, at the same temperature. mu_g ( list ) \u2013 Viscosity of each pure gas component, in Pa.s, at the same temperature. x ( list ) \u2013 Mole fractions of each gas component in the mixture (must sum to 1). M ( list ) \u2013 Molar masses of each gas component (in kg.mol-1). Returns: lambda_mix ( float ) \u2013 Thermal conductivity of the gas mixture, in J.m-1.s-1.K-1. Notes Source : [wuMathematicalModelingTransient2009] and [polingPropertiesGasesLiquids2001] Source code in modules/transitory_functions.py 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 def k_th_gaz_mixture ( k_th_g , mu_g , x , M ): \"\"\"This function calculates the thermal conductivity of a gas mixture, in J.m-1.s-1.K-1. The Lindsay\u2013Bromley (Wassiljewa) method is used. Parameters ---------- k_th_g : list Thermal conductivities of each pure gas component, in J.m-1.s-1.K-1, at the same temperature. mu_g : list Viscosity of each pure gas component, in Pa.s, at the same temperature. x : list Mole fractions of each gas component in the mixture (must sum to 1). M : list Molar masses of each gas component (in kg.mol-1). Returns ------- lambda_mix : float Thermal conductivity of the gas mixture, in J.m-1.s-1.K-1. Notes ----- Source : [wuMathematicalModelingTransient2009] and [polingPropertiesGasesLiquids2001]\"\"\" total_x = 0.0 for xi in x : total_x += xi if abs ( total_x - 1.0 ) > 1e-6 : raise ValueError ( \"The sum of the molar fractions should be 1.\" ) n = len ( k_th_g ) epsilon_TS = 0.85 # Value suggested by Tandon and Saxena in 1965. # Calculation of A_W using Maxon and Saxena suggestion. A_W = [] for i in range ( n ): row = [] for j in range ( n ): if i == j : row . append ( 1.0 ) else : val = ( epsilon_TS * ( 1 + ( mu_g [ i ] / mu_g [ j ]) ** 0.5 * ( M [ j ] / M [ i ]) ** 0.25 ) ** 2 ) / \\ ( 8 * ( 1 + M [ i ] / M [ j ])) ** 0.5 row . append ( val ) A_W . append ( row ) # Calculation of the thermal conductivity of the gas mixture. k_th_gaz_mixture = 0.0 for i in range ( n ): prod_x_A_w = 0.0 for j in range ( n ): prod_x_A_w += x [ j ] * A_W [ i ][ j ] k_th_gaz_mixture += x [ i ] * k_th_g [ i ] / prod_x_A_w return k_th_gaz_mixture","title":"k_th_gaz_mixture"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.lambda_eq","text":"This function calculates the equilibrium water content in the membrane. Hinatsu's expression modified with Bao's formulation has been selected. Parameters: C_v ( float ) \u2013 Water concentration variable in mol.m-3. s ( float ) \u2013 Liquid water saturation variable. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Equilibrium water content in the membrane. Source code in modules/transitory_functions.py 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 def lambda_eq ( C_v , s , T ): \"\"\"This function calculates the equilibrium water content in the membrane. Hinatsu's expression modified with Bao's formulation has been selected. Parameters ---------- C_v : float Water concentration variable in mol.m-3. s : float Liquid water saturation variable. T : float Temperature in K. Returns ------- float Equilibrium water content in the membrane. \"\"\" a_w = C_v / C_v_sat ( T ) + 2 * s # water activity return 0.5 * lambda_v_eq ( a_w ) * ( 1 - math . tanh ( 100 * ( a_w - 1 ))) + \\ 0.5 * ( lambda_v_eq ( 1 ) + (( lambda_l_eq ( T ) - lambda_v_eq ( 1 )) / 2 ) * ( 1 - math . exp ( - Kshape * ( a_w - 1 )))) * \\ ( 1 + math . tanh ( 100 * ( a_w - 1 )))","title":"lambda_eq"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.lambda_l_eq","text":"This function calculates the equilibrium water content in the membrane from the liquid phase. Hinatsu's expression has been selected. It is valid for N-form membranes for 25 to 100 \u00b0C. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Equilibrium water content in the membrane from the liquid phase. Source code in modules/transitory_functions.py 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def lambda_l_eq ( T ): \"\"\"This function calculates the equilibrium water content in the membrane from the liquid phase. Hinatsu's expression has been selected. It is valid for N-form membranes for 25 to 100 \u00b0C. Parameters ---------- T : float Temperature in K. Returns ------- float Equilibrium water content in the membrane from the liquid phase. \"\"\" return 10.0 * 1.84e-2 * ( T - 273.15 ) + 9.90e-4 * ( T - 273.15 ) ** 2","title":"lambda_l_eq"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.lambda_v_eq","text":"This function calculates the equilibrium water content in the membrane from the vapor phase. Hinatsu's expression has been selected. Parameters: a_w \u2013 Water activity. Returns: float \u2013 Equilibrium water content in the membrane from the vapor phase. Source code in modules/transitory_functions.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def lambda_v_eq ( a_w ): \"\"\"This function calculates the equilibrium water content in the membrane from the vapor phase. Hinatsu's expression has been selected. Parameters ---------- a_w: float Water activity. Returns ------- float Equilibrium water content in the membrane from the vapor phase. \"\"\" return 0.300 + 10.8 * a_w - 16.0 * a_w ** 2 + 14.1 * a_w ** 3","title":"lambda_v_eq"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.mu_gaz","text":"This function calculates the dynamic viscosity of different gases, in Pa.s, as a function of the temperature. Parameters: component ( str ) \u2013 Specifies the gas for which the dynamic viscosity is calculated. Must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T ( float ) \u2013 Temperature in K. Returns: float \u2013 Dynamic viscosity of the selected gas in Pa.s. Notes Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons) Source code in modules/transitory_functions.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def mu_gaz ( component , T ): \"\"\"This function calculates the dynamic viscosity of different gases, in Pa.s, as a function of the temperature. Parameters ---------- component : str Specifies the gas for which the dynamic viscosity is calculated. Must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (hydrogen), or 'N2' (nitrogen). T : float Temperature in K. Returns ------- float Dynamic viscosity of the selected gas in Pa.s. Notes ----- Source : Carl L. Yaws - Manuel 2014 - Transport properties of chemicals and hydrocarbons (https://www.sciencedirect.com/book/9780323286589/transport-properties-of-chemicals-and-hydrocarbons)\"\"\" if component == 'H2O_v' : # For T >= 150 K and T <= 1500 k. return ( 22.8211 + 1.7387e-1 * T + 3.2465e-4 * T ** 2 - 1.4334e-7 * T ** 3 ) * 10 **- 7 elif component == 'H2' : # For T >= 15 K and T <= 1500 K. return ( 1.7611 + 3.4165e-1 * T - 1.8368e-4 * T ** 2 + 5.1147e-8 * T ** 3 ) * 10 **- 7 elif component == 'O2' : # For T >= 54 K and T <= 1500 K. return ( - 4.9433 + 8.0673e-1 * T - 4.0416e-4 * T ** 2 + 1.0111e-7 * T ** 3 ) * 10 **- 7 elif component == 'N2' : # For T >= 63 K and T <= 1970 K. return ( 4.4656 + 6.3814e-1 * T - 2.6596e-4 * T ** 2 + 5.4113e-8 * T ** 3 ) * 10 **- 7 else : raise ValueError ( \"The element should be either 'H2O_v', 'H2', 'O2' or 'N2'.\" )","title":"mu_gaz"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.mu_mixture_gases","text":"This function calculates the dynamic viscosity of a gas mixture, in Pa.s, as a function of the temperature. Parameters: components ( list of str ) \u2013 List of gas components in the mixture. Each component must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). x ( list of float ) \u2013 List of mole fractions corresponding to each gas component in the mixture. T ( float ) \u2013 Temperature in K. Returns: float \u2013 Dynamic viscosity of the gas mixture in Pa.s. Notes A simple mixture law is used here to calculate the dynamic viscosity of the gas mixture. Source code in modules/transitory_functions.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def mu_mixture_gases ( components , x , T ): \"\"\"This function calculates the dynamic viscosity of a gas mixture, in Pa.s, as a function of the temperature. Parameters ---------- components : list of str List of gas components in the mixture. Each component must be either 'H2O_v' (vapor), 'H2' (hydrogen), 'O2' (oxygen), or 'N2' (nitrogen). x : list of float List of mole fractions corresponding to each gas component in the mixture. T : float Temperature in K. Returns ------- float Dynamic viscosity of the gas mixture in Pa.s. Notes ----- A simple mixture law is used here to calculate the dynamic viscosity of the gas mixture. \"\"\" # Calculate the dynamic viscosities of each gas component in Pa.s. mu_values = [ mu_gaz ( comp , T ) for comp in components ] # Calculate the molar mass of the gas mixture in kg/mol. M_mix = 0.0 for j in range ( len ( components )): M_j = M_H2O if components [ j ] == 'H2O_v' else M_H2 if components [ j ] == 'H2' else M_O2 if components [ j ] == 'O2' \\ else M_N2 if components [ j ] == 'N2' else None M_mix += M_j * x [ j ] inv_mu_mix = 0.0 for j , mu_j in enumerate ( mu_values ): M_j = M_H2O if components [ j ] == 'H2O_v' else M_H2 if components [ j ] == 'H2' else M_O2 if components [ j ] == 'O2' else M_N2 c_j = M_j * x [ j ] / M_mix inv_mu_mix += c_j / mu_j return 1 / inv_mu_mix","title":"mu_mixture_gases"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.nu_l","text":"This function calculates the liquid water kinematic viscosity, in m\u00b2.s-1, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Liquid water kinematic viscosity in m\u00b2.s-1. Source code in modules/transitory_functions.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def nu_l ( T ): \"\"\"This function calculates the liquid water kinematic viscosity, in m\u00b2.s-1, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Liquid water kinematic viscosity in m\u00b2.s-1. \"\"\" mu_l = 2.414 * 10 ** ( - 5 + 247.8 / ( T - 140.0 )) # Pa.s. It is the liquid water dynamic viscosity. return mu_l / rho_H2O_l ( T )","title":"nu_l"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.rho_H2O_l","text":"This function calculates the water density, in kg.m-3, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Water density in kg.m-3. Source code in modules/transitory_functions.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def rho_H2O_l ( T ): \"\"\"This function calculates the water density, in kg.m-3, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Water density in kg.m-3. \"\"\" T_Celsius = T - 273.15 return (( 999.83952 + 16.945176 * T_Celsius - 7.9870401e-3 * T_Celsius ** 2 - 46.170461e-6 * T_Celsius ** 3 + 105.56302e-9 * T_Celsius ** 4 - 280.54253e-12 * T_Celsius ** 5 ) / ( 1 + 16.879850e-3 * T_Celsius ))","title":"rho_H2O_l"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.sigma","text":"This function calculates the water surface tension, in N.m-1, as a function of the temperature. Parameters: T ( float ) \u2013 Temperature in K. Returns: float \u2013 Water surface tension in N.m-1. Source code in modules/transitory_functions.py 708 709 710 711 712 713 714 715 716 717 718 719 720 721 def sigma ( T ): \"\"\"This function calculates the water surface tension, in N.m-1, as a function of the temperature. Parameters ---------- T : float Temperature in K. Returns ------- float Water surface tension in N.m-1. \"\"\" return 235.8e-3 * (( 647.15 - T ) / 647.15 ) ** 1.256 * ( 1 - 0.625 * ( 647.15 - T ) / 647.15 )","title":"sigma"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.sigma_e_eff","text":"This function calculates the effective electrical conductivity, in \u03a9-1.m-1, in either the GDL, the MPL or the CL, considering GDL compression. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon ( float ) \u2013 Porosity. epsilon_c ( float , default: None ) \u2013 Compression ratio of the GDL. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CL. Returns: float \u2013 Effective electrical conductivity in \u03a9-1.m-1. Source code in modules/transitory_functions.py 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 @lru_cache ( maxsize = None ) # Cache the results to optimize performance def sigma_e_eff ( element , epsilon , epsilon_c = None , epsilon_mc = None ): \"\"\"This function calculates the effective electrical conductivity, in \u03a9-1.m-1, in either the GDL, the MPL or the CL, considering GDL compression. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'gdl' (gas diffusion layer) or 'cl' (catalyst layer). epsilon : float Porosity. epsilon_c : float, optional Compression ratio of the GDL. epsilon_mc : float, optional Volume fraction of ionomer in the CL. Returns ------- float Effective electrical conductivity in \u03a9-1.m-1. \"\"\" if element == 'gdl' : # The effective electrical conductivity at the GDL # According to the GDL porosity, the GDL compression effect is different. if epsilon < 0.67 : beta3 = 4.04 else : beta3 = 4.40 return ( 1 - epsilon ) * sigma_e_gdl * math . exp ( beta3 * epsilon_c ) # Using the volume fraction of conductive material. elif element == 'mpl' : # The effective electrical conductivity at the MPL return ( 1 - epsilon ) * sigma_e_mpl # Using the volume fraction of conductive material. elif element == 'cl' : # The effective electrical conductivity at the CL return ( 1 - epsilon - epsilon_mc ) * sigma_e_cl # Using the volume fraction of conductive material. else : raise ValueError ( \"The element should be either 'gdl', 'mpl' or 'cl'.\" )","title":"sigma_e_eff"},{"location":"functions/modules/transitory_functions/#modules.transitory_functions.sigma_p_eff","text":"This function calculates the effective proton conductivity, in \u03a9-1.m-1, in either the membrane or the CCL. Parameters: element ( str ) \u2013 Specifies the element for which the proton conductivity is calculated. Must be either 'mem' (membrane) or 'ccl' (cathode catalyst layer). lambdaa ( float ) \u2013 Water content in the membrane. T ( float ) \u2013 Temperature in K. epsilon_mc ( float , default: None ) \u2013 Volume fraction of ionomer in the CCL. Returns: float \u2013 Proton conductivity in \u03a9-1.m-1. Source code in modules/transitory_functions.py 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 def sigma_p_eff ( element , lambdaa , T , epsilon_mc = None ): \"\"\"This function calculates the effective proton conductivity, in \u03a9-1.m-1, in either the membrane or the CCL. Parameters ---------- element : str Specifies the element for which the proton conductivity is calculated. Must be either 'mem' (membrane) or 'ccl' (cathode catalyst layer). lambdaa : float Water content in the membrane. T : float Temperature in K. epsilon_mc : float Volume fraction of ionomer in the CCL. Returns ------- float Proton conductivity in \u03a9-1.m-1. \"\"\" lambda_transition = 1 if element == 'mem' : # The proton conductivity at the membrane sigma_p_eff_low = 0.1879 * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) sigma_p_eff_high = ( 0.5139 * lambdaa - 0.326 ) * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) elif element == 'ccl' : # The effective proton conductivity at the cathode catalyst layer sigma_p_eff_low = epsilon_mc * 0.1879 * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) sigma_p_eff_high = epsilon_mc * ( 0.5139 * lambdaa - 0.326 ) * math . exp ( 1268 * ( 1 / 303.15 - 1 / T )) else : raise ValueError ( \"The element should be either 'mem' or 'ccl'.\" ) w = 0.5 * ( 1 + math . tanh ( K_transition * ( lambda_transition - lambdaa ))) # transition function return w * sigma_p_eff_low + ( 1 - w ) * sigma_p_eff_high # interpolation between sigma_p_eff value at low and high lambda.","title":"sigma_p_eff"}]}