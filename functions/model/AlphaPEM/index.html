<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>AlphaPEM - AlphaPEM</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "AlphaPEM";
        var mkdocs_page_input_path = "functions/model/AlphaPEM.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> AlphaPEM
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Functions</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../../GUI/">GUI</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../main/">Main</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Calibration</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../calibration/experimental_values/">Experimental values</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../calibration/parameter_calibration/">Parameter calibration</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Configuration</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../configuration/current_densities/">Current densities</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../configuration/settings/">Settings</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" >Model</a>
    <ul class="current">
                <li class="toctree-l2 current"><a class="reference internal current" href="#">AlphaPEM</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../auxiliaries/">Auxiliaries</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../cell_voltage/">Cell voltage</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../control/">Control</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../dif_eq/">Differentiel equations</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../flows/">Flows</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Modules</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/auxiliaries_modules/">Auxiliaries modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/calibration_modules/">Calibration modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/dif_eq_modules/">Differential equations modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/display_modules/">Display modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/flows_modules/">Flows modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/GUI_modules/">GUI modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/main_modules/">Main modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/settings_modules/">Settings modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../modules/transitory_functions/">Transitory functions</a>
                </li>
    </ul>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../about/">About</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">AlphaPEM</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Functions</li>
          <li class="breadcrumb-item">Model</li>
      <li class="breadcrumb-item active">AlphaPEM</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="alphapem">AlphaPEM</h1>


<div class="doc doc-object doc-module">



<a id="model.AlphaPEM"></a>
    <div class="doc doc-contents first">

        <ul>
<li>Objectives: Create an open-source software package to simulate the PEM fuel cell for control system applications.</li>
</ul>


<details class="--authors:-raphaël-gass,-zhongliang-li,-rachid-outbib,-samir-jemei-and-daniel-hissel." open>
  <summary><ul>
<li>Authors: Raphaël GASS, Zhongliang LI, Rachid OUTBIB, Samir JEMEI and Daniel HISSEL.</li>
</ul></summary>
  <p>This file describes the AlphaPEM class, which is a PEM fuel cell system simulator.
The model is one-dimensional, dynamic, biphasic, and isothermal. It has been published in the following articles:
- Gass et al 2024 J. Electrochem. Soc. https://doi.org/10.1149/1945-7111/ad305a
- Gass et al 2024 SSRN http://dx.doi.org/10.2139/ssrn.4812343</p>
</details>







  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="model.AlphaPEM.AlphaPEM" class="doc doc-heading">
            <code>AlphaPEM</code>


</h2>


    <div class="doc doc-contents ">







              <details class="quote">
                <summary>Source code in <code>model/AlphaPEM.py</code></summary>
                <pre class="highlight"><code class="language-python">class AlphaPEM:

    def __init__(self, current_density, Tfc, Pa_des, Pc_des, Sa, Sc, Phi_a_des, Phi_c_des, t_step, i_step, i_max_pola,
                 delta_pola, i_EIS, ratio_EIS, t_EIS, f_EIS, Aact, Hgdl, Hmem, Hcl, Hgc, Wgc, Lgc, epsilon_gdl, tau,
                 epsilon_mc, epsilon_c, e, Re, i0_c_ref, kappa_co, kappa_c, a_slim, b_slim, a_switch, C_scl, max_step,
                 n_gdl, t_purge, type_fuel_cell, type_current, type_auxiliary, type_control, type_purge, type_display,
                 type_plot, initial_variable_values=None, time_interval=None):
        """Initialise all parameters defining a fuel cell stack operation: nominal operating conditions,
        applied electrical load, dimensions, and undetermined variables.

        Parameters
        ----------
        current_density : function
            Current density evolution over time (operating input). It is a function of time and parameters dictionary.
        Tfc : float
            Desired fuel cell temperature in Kelvin (operating input).
        Pa_des : float
            Desired anode pressure in Pascal (operating input).
        Pc_des : float
            Desired cathode pressure in Pascal (operating input).
        Sa : float
            Stoichiometric ratio of hydrogen (operating input).
        Sc : float
            Stoichiometric ratio of oxygen (operating input).
        Phi_a_des : float
            Desired anode relative humidity (operating input).
        Phi_c_des : float
            Desired cathode relative humidity (operating input).
        t_step : tuple
            Time parameters for the step_current density function (current parameters).
            It is a tuple containing the initial time 't0_step', final time 'tf_step', loading time 'delta_t_load_step'
            and dynamic time for display 'delta_t_dyn_step'.
        i_step : tuple
            Current parameters for the step_current density function (current parameters).
            It is a tuple containing the initial and final current density value 'i_ini_step' and 'i_final_step'.
        i_max_pola : float
            Maximum current density for the polarization curve (current parameter).
        delta_pola : tuple
            Parameters for the polarization curve (current parameters). It is a tuple containing the loading time
            'delta_t_load_pola', the breaking time 'delta_t_break_pola', the current density step 'delta_i_pola', and
            the initial breaking time 'delta_t_ini_pola'.
        i_EIS : float
            Current for which a ratio_EIS perturbation is added (current parameter).
        ratio_EIS : float
            Value of the perturbation on the current density for building the EIS curve (current parameter).
        t_EIS : tuple
            EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium
            't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS',
            the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium
            at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for
            measuring the voltage response at each frequency 'delta_t_measurement_EIS'.
        f_EIS : tuple
            EIS parameters (current parameters). It is a tuple containing the power of the initial frequency
            'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the
            number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period
            'nb_points_EIS'.
        Aact : float
            Active area of the cell in m² (accessible physical parameter).
        Hgdl : float
            Thickness of the gas diffusion layer in m (accessible physical parameter).
        Hmem : float
            Thickness of the membrane in m (accessible physical parameter).
        Hcl : float
            Thickness of the catalyst layer in m (accessible physical parameter).
        Hgc : float
            Thickness of the gas channel in m (accessible physical parameter).
        Wgc : float
            Width of the gas channel in m (accessible physical parameter).
        Lgc : float
            Length of the gas channel in m (accessible physical parameter).
        epsilon_gdl : float
            Anode/cathode GDL porosity (undetermined physical parameter).
        tau : float
            Pore structure coefficient (undetermined physical parameter).
        epsilon_mc : float
            Volume fraction of ionomer in the CL (undetermined physical parameter).
        epsilon_c : float
            Compression ratio of the GDL (undetermined physical parameter).
        e : float
            Capillary exponent (undetermined physical parameter).
        Re : float
            Electron conduction resistance of the circuit in ohm.m² (undetermined physical parameter).
        i0_c_ref : float
            Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter).
        kappa_co : float
            Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter).
        kappa_c : float
            Overpotential correction exponent (undetermined physical parameter).
        a_slim : float
            One of the limit liquid saturation coefficients: the slop of slim function
            (undetermined physical parameter).
        b_slim : float
            One of the limit liquid saturation coefficients: the intercept of slim function
            (undetermined physical parameter).
        a_switch : float
            One of the limit liquid saturation coefficients: the slop of s_switch function
            (undetermined physical parameter).
        C_scl : float
            Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter).
        max_step : float
            Maximum time step for the solver (computing parameter).
        n_gdl : int
            Number of points considered in the GDL (computing parameter).
        t_purge : tuple
            Time parameters for purging the system (computing parameter).
            It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'.
        type_fuel_cell : str
            Type of fuel cell configuration (computing parameter).
        type_current : str
            Type of current density function (computing parameter).
        type_auxiliary : str
            Type of auxiliary system (computing parameter).
        type_control : str
            Type of control system (computing parameter).
        type_purge : str
            Type of purge system (computing parameter).
        type_display : str
            Type of display (computing parameter).
        type_plot : str
            Type of plot (computing parameter).
        initial_variable_values : list, optional
            Initial values of the solver variables. The default is None, which implies that initial values are
            generated considering an equilibrium at the operating inputs without current.
        time_interval : list, optional
            Time intervals for numerical resolution. The default is None, which implies that it is automatically
            generated according to the data given in the current density parameters.
        """

        # Initialize the operating inputs and parameters dictionaries.
        self.operating_inputs = {'current_density': current_density, 'Tfc': Tfc, 'Pa_des': Pa_des, 'Pc_des': Pc_des,
                                 'Sa': Sa, 'Sc': Sc, 'Phi_a_des': Phi_a_des, 'Phi_c_des': Phi_c_des}
        self.current_parameters = {'t_step': t_step, 'i_step': i_step, 'delta_pola': delta_pola,
                                   'i_max_pola': i_max_pola, 'i_EIS': i_EIS, 'ratio_EIS': ratio_EIS, 't_EIS': t_EIS,
                                   'f_EIS': f_EIS}
        self.accessible_physical_parameters = {'Aact': Aact, 'Hgdl': Hgdl, 'Hmem': Hmem, 'Hcl': Hcl, 'Hgc': Hgc,
                                               'Wgc': Wgc, 'Lgc': Lgc}
        self.undetermined_physical_parameters = {'epsilon_gdl': epsilon_gdl, 'tau': tau, 'epsilon_mc': epsilon_mc,
                                                   'epsilon_c': epsilon_c, 'e': e, 'kappa_co': kappa_co, 'Re': Re,
                                                   'i0_c_ref': i0_c_ref, 'kappa_c': kappa_c, 'a_slim': a_slim,
                                                   'b_slim': b_slim, 'a_switch': a_switch, 'C_scl': C_scl}
        self.computing_parameters = {'max_step': max_step, 'n_gdl': n_gdl, 't_purge': t_purge,
                                     'type_fuel_cell': type_fuel_cell, 'type_current': type_current,
                                     'type_auxiliary': type_auxiliary, 'type_control': type_control,
                                     'type_purge': type_purge, 'type_display': type_display, 'type_plot': type_plot}
        self.parameters = {**self.current_parameters, **self.accessible_physical_parameters,
                           **self.undetermined_physical_parameters, **self.computing_parameters}
        if self.operating_inputs['Pa_des'] &lt; Pext or self.operating_inputs['Pc_des'] &lt; Pext:
            raise ValueError('The desired pressure is too low. It cannot be lower than the pressure outside the stack.')

        # Initialize the variables' dictionary.
        self.solver_variable_names = ['C_v_agc', 'C_v_agdl', 'C_v_acl', 'C_v_ccl', 'C_v_cgdl', 'C_v_cgc', 's_agdl',
                                      's_acl', 's_ccl', 's_cgdl', 'lambda_acl', 'lambda_mem', 'lambda_ccl', 'C_H2_agc',
                                      'C_H2_agdl', 'C_H2_acl', 'C_O2_ccl', 'C_O2_cgdl', 'C_O2_cgc', 'C_N2', 'eta_c',
                                      'Pasm', 'Paem', 'Pcsm', 'Pcem', 'Phi_asm', 'Phi_aem', 'Phi_csm', 'Phi_cem',
                                      'Wcp', 'Wa_inj', 'Wc_inj', 'Abp_a', 'Abp_c']
        self.solver_variable_names_extension()  # Several points are considered in each GDL and must be inserted into
        #                                        the solver_variable_names.
        self.all_variable_names = self.solver_variable_names + ['t', 'Ucell', 'S_sorp_acl', 'S_sorp_ccl'] + \
                                  ['J_lambda_mem_acl', 'J_lambda_mem_ccl', 'Pagc', 'Pcgc', 'Phi_a_des', 'Phi_c_des']
        self.variables = {key: [] for key in self.all_variable_names}

        # Initialize the control_variables dictionary.
        self.control_variables = {'t_control_Phi': self.parameters['t_step'][0],
                                  'Phi_a_des': self.operating_inputs['Phi_a_des'],
                                  'Phi_c_des': self.operating_inputs['Phi_c_des']}

        # Create the dynamic evolution.
        #       Create time intervals
        if time_interval is not None:  # Initial time interval may be given to the Simulator.
            self.time_interval = time_interval
        else:  # If not, it is automatically generated.
            self.time_interval = self._create_time_interval()

        #       Create the initial variable values
        if initial_variable_values is not None:  # Initial variable values may be given to the Simulator.
            self.initial_variable_values = initial_variable_values
        else:  # If not, they are generated considering an equilibrium at the operating inputs without current.
            self.initial_variable_values = self._create_initial_variable_values()

        #       Resolution of the system of differential equations.
        event_negative.terminal = True  # Integration is stopped if one of the crucial variables becomes negative.
        self.sol = solve_ivp(dydt, self.time_interval, self.initial_variable_values, method='BDF',
                             max_step=self.parameters['max_step'], events=event_negative,
                             args=(self.operating_inputs, self.parameters, self.solver_variable_names,
                                   self.control_variables))

        #       Recover the variable values calculated by the solver into the dictionary.
        self._recovery()

        #       Calculate the cell voltage after computing the internal states of the cell.
        self.variables["Ucell"].extend(calculate_cell_voltage(self.variables, self.operating_inputs, self.parameters))

    def solver_variable_names_extension(self):
        """Several points are considered in each GDL and must be inserted into the solver_variable_names.
        """

        new_points_location = ['C_v_agdl', 'C_v_cgdl', 's_agdl', 's_cgdl', 'C_H2_agdl', 'C_O2_cgdl']
        for variable in new_points_location:
            index = self.solver_variable_names.index(variable)
            # Delete the previous points
            self.solver_variable_names.pop(index)
            # Increase the number of points
            self.solver_variable_names[index:index] = [f'{variable}_{i}' for i in
                                                       range(1, self.parameters['n_gdl'] + 1)]

    def _create_time_interval(self):
        """Calculate the time intervals for numerical resolution, according to the current chosen,
        if it is not provided.

        Returns
        -------
        list
            Time interval for numerical resolution. It is used when initial_variable_values == None.
        """

        # Extraction of the parameters
        t_step, delta_pola, i_max_pola = self.parameters['t_step'], self.parameters['delta_pola'], self.parameters['i_max_pola']
        type_current = self.parameters['type_current']

        # Recovery of the good time interval
        if type_current == "step":
            t0_step, tf_step, delta_t_load_step, delta_t_dyn_step = t_step
            t0_interval = t0_step
            tf_interval = tf_step
        elif type_current == "polarization":
            delta_t_load_pola, delta_t_break_pola, delta_i_pola, delta_t_ini_pola = delta_pola
            t0_interval = 0
            tf_interval = delta_t_ini_pola + int(i_max_pola / delta_i_pola + 1) * (delta_t_load_pola + delta_t_break_pola)
        else:  # EIS time_interval is calculated in the main.py file.
            raise ValueError("Please enter a recognized type_current option for calculating the time interval.")

        # To be reviewed
        self.control_variables['t_control_Phi'] = t0_interval

        return [t0_interval, tf_interval]

    def _create_initial_variable_values(self):
        """Create the initial values of the solver variables if it is not provided.
        It is generated considering an equilibrium at the operating inputs without current.

        Returns
        -------
        list
            Initial values of the solver variables. It is used when initial_variable_values == None.
        """

        # Extraction of the operating inputs and parameters
        current_density, Tfc = self.operating_inputs['current_density'], self.operating_inputs['Tfc']
        Pa_des, Pc_des = self.operating_inputs['Pa_des'], self.operating_inputs['Pc_des']
        Phi_a_des, Phi_c_des = self.operating_inputs['Phi_a_des'], self.operating_inputs['Phi_c_des']
        Hmem, kappa_co, i0_c_ref, = self.parameters['Hmem'], self.parameters['kappa_co'], self.parameters['i0_c_ref']
        kappa_c = self.parameters['kappa_c']
        a_slim, b_slim, a_switch = self.parameters['a_slim'], self.parameters['b_slim'], self.parameters['a_switch']
        n_gdl = self.parameters['n_gdl']

        # Mean value of the operating inputs
        Phi_des_moy = (Phi_a_des + Phi_c_des) / 2
        P_des_moy = (Pa_des + Pc_des) / 2

        # Initial fuel cell states
        #   Intermediate values
        Psat_ini = 101325 * 10 ** (-2.1794 + 0.02953 * (Tfc - 273.15) - 9.1837e-5 * (Tfc - 273.15) ** 2 +
                                   1.4454e-7 * (Tfc - 273.15) ** 3)
        slim = a_slim * (Pc_des / 1e5) + b_slim
        s_switch = a_switch * slim
        #   Initial fuel cell states
        C_v_ini = Phi_des_moy * Psat_ini / (R * Tfc)  # mol.m-3. It is the initial vapor concentration.
        C_H2_ini = (P_des_moy - Phi_des_moy * Psat_ini) / (R * Tfc)  # mol.m-3. It is the initial H2 concentration
        #                                                              in the fuel cell.
        C_O2_ini = yO2_ext * (P_des_moy - Phi_des_moy * Psat_ini) / (R * Tfc)  # mol.m-3. It is the initial O2
        #                                                                        concentration in the fuel cell.
        C_N2_ini = (1 - yO2_ext) * (P_des_moy - Phi_des_moy * Psat_ini) / (R * Tfc)  # mol.m-3. It is the initial N2
        #                                                                              concentration in the fuel cell.
        s_ini = 0  # It is the initial liquid water saturation in the fuel cell.
        lambda_mem_ini = lambda_eq(C_v_ini, s_ini, Tfc, Kshape)  # It is the initial water
        #                                                                                  content in the fuel cell.
        i_fc_ini = current_density(self.time_interval[0], self.parameters)
        i_n_ini = 2 * F * R * Tfc / Hmem * C_H2_ini * k_H2(lambda_mem_ini, Tfc, kappa_co) + \
                  4 * F * R * Tfc / Hmem * C_O2_ini * k_O2(lambda_mem_ini, Tfc, kappa_co)
        f_drop_ini = 0.5 * (1.0 - np.tanh((4 * s_ini - 2 * slim - 2 * s_switch) / (slim - s_switch)))
        eta_c_ini = 1 / f_drop_ini * R * Tfc / (alpha_c * F) * \
                    np.log((i_fc_ini + i_n_ini) / i0_c_ref * (C_O2ref / C_O2_ini) ** kappa_c)  # It is the initial
        #                                                                       cathode overpotential in the fuel cell.

        # Initial auxiliary system state
        Pasm_ini, Paem_ini = Pa_des, P_des_moy  # Pa. It is the supply/exhaust manifold pressure at the anode side.
        Pcsm_ini, Pcem_ini = Pc_des, P_des_moy  # Pa. It is the supply/exhaust manifold pressure at the cathode side.
        Phi_asm_ini, Phi_aem_ini = Phi_a_des, Phi_des_moy  # It is the supply/exhaust manifold relative humidity
        #                                                  at the anode side.
        Phi_csm_ini, Phi_cem_ini = Phi_c_des, Phi_des_moy  # It is the supply/exhaust manifold relative humidity
        #                                                  at the cathode side.
        Wcp_ini = 0  # kg.s-1. It is the flow rate of the air compressor.
        Wa_inj_ini = 0  # kg.s-1. It is the flow rate of the air compressor at the anode side.
        Wc_inj_ini = 0  # kg.s-1. It is the flow rate of the air compressor at the cathode side.
        Abp_a_ini = 0  # It is the throttle area of the back pressure valve at the anode.
        Abp_c_ini = 0  # It is the throttle area of the back pressure valve at the cathode.

        # Main variable initialization
        C_v_agc, C_v_agdl, C_v_acl, C_v_ccl, C_v_cgdl, C_v_cgc = [C_v_ini] * 6
        s_agdl, s_acl, s_ccl, s_cgdl = [s_ini] * 4
        s_boundary = 0  # Dirichlet boundary condition
        lambda_acl, lambda_mem, lambda_ccl = [lambda_mem_ini] * 3
        C_H2_agc, C_H2_agdl, C_H2_acl = C_H2_ini, C_H2_ini, C_H2_ini
        C_O2_ccl, C_O2_cgdl, C_O2_cgc = C_O2_ini, C_O2_ini, C_O2_ini
        C_N2, eta_c = C_N2_ini, eta_c_ini
        Pasm, Paem, Pcsm, Pcem = Pasm_ini, Paem_ini, Pcsm_ini, Pcem_ini
        Phi_asm, Phi_aem, Phi_csm, Phi_cem = Phi_asm_ini, Phi_aem_ini, Phi_csm_ini, Phi_cem_ini
        Wcp, Wa_inj, Wc_inj, Abp_a, Abp_c = Wcp_ini, Wa_inj_ini, Wc_inj_ini, Abp_a_ini, Abp_c_ini

        # Gathering of the variables initial value into one list
        initial_variable_values = [C_v_agc] + [C_v_agdl] * n_gdl + [C_v_acl, C_v_ccl] + [C_v_cgdl] * n_gdl + \
                                  [C_v_cgc] + \
                                  [s_boundary] + [s_agdl] * (n_gdl - 1) + [s_acl, s_ccl] + [s_cgdl] * (n_gdl - 1) + \
                                  [s_boundary] + [lambda_acl, lambda_mem, lambda_ccl] + \
                                  [C_H2_agc] + [C_H2_agdl] * n_gdl + [C_H2_acl, C_O2_ccl] + [C_O2_cgdl] * n_gdl + \
                                  [C_O2_cgc, C_N2] + [eta_c] + \
                                  [Pasm, Paem, Pcsm, Pcem, Phi_asm, Phi_aem, Phi_csm, Phi_cem] + \
                                  [Wcp, Wa_inj, Wc_inj, Abp_a, Abp_c]

        return initial_variable_values

    def _recovery(self):
        """Recover the values which have been calculated by the solver and add them into the variables' dictionary.
        However, the numerical resolution method does not, by design, recover all the internal states of the stack,
        even though they are calculated during this process. They therefore have to be recovered manually.
        """

        # Recovery of the time span
        self.variables['t'].extend(list(self.sol.t))

        # Recovery of the main variables dynamic evolution
        for index, key in enumerate(self.solver_variable_names):
            self.variables[key].extend(list(self.sol.y[index]))

        # Recovery of more variables
        #   The control variables should be reinitialized. To be reviewed.
        if self.parameters['type_current'] == "step":
            self.control_variables['t_control_Phi'] = self.parameters['t_step'][0]
        else:
            self.control_variables['t_control_Phi'] = 0
        self.control_variables['Phi_a_des'] = self.operating_inputs['Phi_a_des']
        self.control_variables['Phi_c_des'] = self.operating_inputs['Phi_c_des']

        for j in range(len(self.sol.t)):  # For each time...
            # ... recovery of i_fc.
            i_fc = self.operating_inputs["current_density"](self.variables['t'][j], self.parameters)
            # ... recovery of S_sorp_acl, S_sorp_ccl, Jmem_acl, Jmem_ccl, Pagc, Pcgc.
            last_solver_variables = {key: self.variables[key][j] for key in self.solver_variable_names}
            flows_recovery = calculate_flows(self.variables['t'][j], last_solver_variables, self.control_variables,
                                             i_fc, self.operating_inputs, self.parameters)
            for key in ['S_sorp_acl', 'S_sorp_ccl', 'J_lambda_mem_acl', 'J_lambda_mem_ccl', 'Pagc', 'Pcgc']:
                self.variables[key].append(flows_recovery[key])
            # ... recovery of Phi_a_des and Phi_c_des.
            if self.parameters["type_control"] == "Phi_des":
                sv = {'lambda_mem': self.variables['lambda_mem'][j], 's_ccl': self.variables['s_ccl'][j]}
                control_operating_conditions(self.variables['t'][j], sv, self.operating_inputs,
                                             self.parameters, self.control_variables)
                for key in ['Phi_a_des', 'Phi_c_des']: self.variables[key].append(self.control_variables[key])

    def Display(self, ax1=None, ax2=None, ax3=None):
        """Display the plots of the program.

        Parameters
        ----------
        ax1 : matplotlib.axes.Axes, optional
            Axes for the first set of plots. The default is None.
        ax2 : matplotlib.axes.Axes, optional
            Axes for the second set of plots. The default is None.
        """

        # Extraction of the operating inputs and parameters
        Tfc = self.operating_inputs['Tfc']
        n_gdl, type_fuel_cell = self.parameters['n_gdl'], self.parameters['type_fuel_cell']
        type_current, type_display = self.parameters['type_current'], self.parameters['type_display']

        # Parameters' preparation
        n = len(self.variables['t'])
        subfolder_name = type_fuel_cell[:type_fuel_cell.rfind('_')] if type_fuel_cell.rfind('_') != -1 \
            else type_fuel_cell

        # Display
        if type_current == "step":
            if type_display == "multiple":

                figs, axes = zip(*[plt.subplots(figsize=(8, 8)) for _ in range(12)])

                plot_ifc(self.variables, self.operating_inputs, self.parameters, n, axes[0])
                plot_J(self.variables, self.parameters, axes[1])
                plot_C_v(self.variables, n_gdl, C_v_sat(Tfc), n, axes[2])
                plot_lambda(self.variables, self.operating_inputs, self.parameters, axes[3])
                plot_s(self.variables, self.operating_inputs, self.parameters, axes[4])
                plot_C_O2(self.variables, n_gdl, axes[5])
                plot_C_H2(self.variables, n_gdl, axes[6])
                plot_C_N2(self.variables, axes[7])
                plot_Ucell(self.variables, axes[8])
                plot_P(self.variables, axes[9])
                plot_Phi_a(self.variables, self.operating_inputs, axes[10])
                plot_Phi_c(self.variables, self.operating_inputs, axes[11])

                # Considering the number of plots, the saving instructions are made here and not in the main.py file.
                saving_instructions("results", subfolder_name, "step_current_ifc_1.pdf", figs[0])
                saving_instructions("results", subfolder_name, "step_current_J_1.pdf", figs[1])
                saving_instructions("results", subfolder_name, "step_current_Cv_1.pdf", figs[2])
                saving_instructions("results", subfolder_name, "step_current_lambda_1.pdf", figs[3])
                saving_instructions("results", subfolder_name, "step_current_s_1.pdf", figs[4])
                saving_instructions("results", subfolder_name, "step_current_C_O2_1.pdf", figs[5])
                saving_instructions("results", subfolder_name, "step_current_C_H2_1.pdf", figs[6])
                saving_instructions("results", subfolder_name, "step_current_C_N2_1.pdf", figs[7])
                saving_instructions("results", subfolder_name, "step_current_Ucell_1.pdf", figs[8])
                saving_instructions("results", subfolder_name, "step_current_P_1.pdf", figs[9])
                saving_instructions("results", subfolder_name, "step_current_Phi_a_1.pdf", figs[10])
                saving_instructions("results", subfolder_name, "step_current_Phi_c_1.pdf", figs[11])

                plt.pause(0.001)  # A break is necessary to plot the new points in dynamic mode

            elif type_display == "synthetic":

                plot_ifc(self.variables, self.operating_inputs, self.parameters, n, ax1[0, 0])
                plot_Ucell(self.variables, ax1[0, 1])
                plot_J(self.variables, self.parameters, ax1[0, 2])
                plot_C_v(self.variables, n_gdl, C_v_sat(Tfc), n, ax1[1, 0])
                plot_s(self.variables, self.operating_inputs, self.parameters, ax1[1, 1])
                plot_lambda(self.variables, self.operating_inputs, self.parameters, ax1[1, 2])
                plot_C_H2(self.variables, n_gdl, ax1[2, 0])
                plot_C_O2(self.variables, n_gdl, ax1[2, 1])
                plot_P(self.variables, ax1[2, 2])

                plt.pause(0.001)  # A break is necessary to plot the new points in dynamic mode

        elif type_current == "polarization":
            if type_display == "multiple":

                plot_polarisation_curve(self.variables, self.operating_inputs, self.parameters, ax1[0])
                plot_power_density_curve(self.variables, self.operating_inputs, self.parameters, n, ax1[1])
                plot_cell_efficiency(self.variables, self.operating_inputs, self.parameters, n, ax1[2])

                plot_Phi_des(self.variables, self.operating_inputs, self.parameters, ax2[0])
                plot_lambda(self.variables, self.operating_inputs, self.parameters, ax2[1])
                plot_s(self.variables, self.operating_inputs, self.parameters, ax2[2])

                plt.pause(0.001)  # A break is necessary to plot the new points in dynamic mode

            elif type_display == "synthetic":

                plot_polarisation_curve(self.variables, self.operating_inputs, self.parameters, ax1)
                plt.pause(0.001)  # A break is necessary to plot the new points in dynamic mode

        elif type_current == "EIS":
            if type_display == "multiple":

                Fourier_results = make_Fourier_transformation(self.variables, self.operating_inputs, self.parameters)
                plot_EIS_curve_Nyquist(self.parameters, Fourier_results, ax1)
                plot_EIS_curve_Bode_amplitude(self.parameters, Fourier_results, ax2)
                plot_EIS_curve_Bode_angle(self.parameters, Fourier_results, ax3)

                # # Tests to verify the accuracy of EIS simulation.
                # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results)

                plt.pause(0.1)  # A break is necessary to plot the new points in dynamic mode

            elif type_display == "synthetic":

                Fourier_results = make_Fourier_transformation(self.variables, self.operating_inputs, self.parameters)
                plot_EIS_curve_Nyquist(self.parameters, Fourier_results, ax1[0])
                plot_EIS_curve_Bode_amplitude(self.parameters, Fourier_results, ax1[1])
                plot_EIS_curve_Bode_angle(self.parameters, Fourier_results, ax1[2])

                # # Tests to verify the accuracy of EIS simulation.
                # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results)

                plt.pause(0.1)  # A break is necessary to plot the new points in dynamic mode</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="model.AlphaPEM.AlphaPEM.Display" class="doc doc-heading">
            <code class="highlight language-python">Display(ax1=None, ax2=None, ax3=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Display the plots of the program.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>ax1</code></b>
                  (<code><span title="matplotlib.axes.Axes">Axes</span></code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>Axes for the first set of plots. The default is None.</p>
              </div>
            </li>
            <li>
              <b><code>ax2</code></b>
                  (<code><span title="matplotlib.axes.Axes">Axes</span></code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>Axes for the second set of plots. The default is None.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>model/AlphaPEM.py</code></summary>
              <pre class="highlight"><code class="language-python">def Display(self, ax1=None, ax2=None, ax3=None):
    """Display the plots of the program.

    Parameters
    ----------
    ax1 : matplotlib.axes.Axes, optional
        Axes for the first set of plots. The default is None.
    ax2 : matplotlib.axes.Axes, optional
        Axes for the second set of plots. The default is None.
    """

    # Extraction of the operating inputs and parameters
    Tfc = self.operating_inputs['Tfc']
    n_gdl, type_fuel_cell = self.parameters['n_gdl'], self.parameters['type_fuel_cell']
    type_current, type_display = self.parameters['type_current'], self.parameters['type_display']

    # Parameters' preparation
    n = len(self.variables['t'])
    subfolder_name = type_fuel_cell[:type_fuel_cell.rfind('_')] if type_fuel_cell.rfind('_') != -1 \
        else type_fuel_cell

    # Display
    if type_current == "step":
        if type_display == "multiple":

            figs, axes = zip(*[plt.subplots(figsize=(8, 8)) for _ in range(12)])

            plot_ifc(self.variables, self.operating_inputs, self.parameters, n, axes[0])
            plot_J(self.variables, self.parameters, axes[1])
            plot_C_v(self.variables, n_gdl, C_v_sat(Tfc), n, axes[2])
            plot_lambda(self.variables, self.operating_inputs, self.parameters, axes[3])
            plot_s(self.variables, self.operating_inputs, self.parameters, axes[4])
            plot_C_O2(self.variables, n_gdl, axes[5])
            plot_C_H2(self.variables, n_gdl, axes[6])
            plot_C_N2(self.variables, axes[7])
            plot_Ucell(self.variables, axes[8])
            plot_P(self.variables, axes[9])
            plot_Phi_a(self.variables, self.operating_inputs, axes[10])
            plot_Phi_c(self.variables, self.operating_inputs, axes[11])

            # Considering the number of plots, the saving instructions are made here and not in the main.py file.
            saving_instructions("results", subfolder_name, "step_current_ifc_1.pdf", figs[0])
            saving_instructions("results", subfolder_name, "step_current_J_1.pdf", figs[1])
            saving_instructions("results", subfolder_name, "step_current_Cv_1.pdf", figs[2])
            saving_instructions("results", subfolder_name, "step_current_lambda_1.pdf", figs[3])
            saving_instructions("results", subfolder_name, "step_current_s_1.pdf", figs[4])
            saving_instructions("results", subfolder_name, "step_current_C_O2_1.pdf", figs[5])
            saving_instructions("results", subfolder_name, "step_current_C_H2_1.pdf", figs[6])
            saving_instructions("results", subfolder_name, "step_current_C_N2_1.pdf", figs[7])
            saving_instructions("results", subfolder_name, "step_current_Ucell_1.pdf", figs[8])
            saving_instructions("results", subfolder_name, "step_current_P_1.pdf", figs[9])
            saving_instructions("results", subfolder_name, "step_current_Phi_a_1.pdf", figs[10])
            saving_instructions("results", subfolder_name, "step_current_Phi_c_1.pdf", figs[11])

            plt.pause(0.001)  # A break is necessary to plot the new points in dynamic mode

        elif type_display == "synthetic":

            plot_ifc(self.variables, self.operating_inputs, self.parameters, n, ax1[0, 0])
            plot_Ucell(self.variables, ax1[0, 1])
            plot_J(self.variables, self.parameters, ax1[0, 2])
            plot_C_v(self.variables, n_gdl, C_v_sat(Tfc), n, ax1[1, 0])
            plot_s(self.variables, self.operating_inputs, self.parameters, ax1[1, 1])
            plot_lambda(self.variables, self.operating_inputs, self.parameters, ax1[1, 2])
            plot_C_H2(self.variables, n_gdl, ax1[2, 0])
            plot_C_O2(self.variables, n_gdl, ax1[2, 1])
            plot_P(self.variables, ax1[2, 2])

            plt.pause(0.001)  # A break is necessary to plot the new points in dynamic mode

    elif type_current == "polarization":
        if type_display == "multiple":

            plot_polarisation_curve(self.variables, self.operating_inputs, self.parameters, ax1[0])
            plot_power_density_curve(self.variables, self.operating_inputs, self.parameters, n, ax1[1])
            plot_cell_efficiency(self.variables, self.operating_inputs, self.parameters, n, ax1[2])

            plot_Phi_des(self.variables, self.operating_inputs, self.parameters, ax2[0])
            plot_lambda(self.variables, self.operating_inputs, self.parameters, ax2[1])
            plot_s(self.variables, self.operating_inputs, self.parameters, ax2[2])

            plt.pause(0.001)  # A break is necessary to plot the new points in dynamic mode

        elif type_display == "synthetic":

            plot_polarisation_curve(self.variables, self.operating_inputs, self.parameters, ax1)
            plt.pause(0.001)  # A break is necessary to plot the new points in dynamic mode

    elif type_current == "EIS":
        if type_display == "multiple":

            Fourier_results = make_Fourier_transformation(self.variables, self.operating_inputs, self.parameters)
            plot_EIS_curve_Nyquist(self.parameters, Fourier_results, ax1)
            plot_EIS_curve_Bode_amplitude(self.parameters, Fourier_results, ax2)
            plot_EIS_curve_Bode_angle(self.parameters, Fourier_results, ax3)

            # # Tests to verify the accuracy of EIS simulation.
            # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results)

            plt.pause(0.1)  # A break is necessary to plot the new points in dynamic mode

        elif type_display == "synthetic":

            Fourier_results = make_Fourier_transformation(self.variables, self.operating_inputs, self.parameters)
            plot_EIS_curve_Nyquist(self.parameters, Fourier_results, ax1[0])
            plot_EIS_curve_Bode_amplitude(self.parameters, Fourier_results, ax1[1])
            plot_EIS_curve_Bode_angle(self.parameters, Fourier_results, ax1[2])

            # # Tests to verify the accuracy of EIS simulation.
            # plot_EIS_curve_tests(self.variables, self.operating_inputs, self.parameters, Fourier_results)

            plt.pause(0.1)  # A break is necessary to plot the new points in dynamic mode</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="model.AlphaPEM.AlphaPEM.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(current_density, Tfc, Pa_des, Pc_des, Sa, Sc, Phi_a_des, Phi_c_des, t_step, i_step, i_max_pola, delta_pola, i_EIS, ratio_EIS, t_EIS, f_EIS, Aact, Hgdl, Hmem, Hcl, Hgc, Wgc, Lgc, epsilon_gdl, tau, epsilon_mc, epsilon_c, e, Re, i0_c_ref, kappa_co, kappa_c, a_slim, b_slim, a_switch, C_scl, max_step, n_gdl, t_purge, type_fuel_cell, type_current, type_auxiliary, type_control, type_purge, type_display, type_plot, initial_variable_values=None, time_interval=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialise all parameters defining a fuel cell stack operation: nominal operating conditions,
applied electrical load, dimensions, and undetermined variables.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>current_density</code></b>
                  (<code>function</code>)
              –
              <div class="doc-md-description">
                <p>Current density evolution over time (operating input). It is a function of time and parameters dictionary.</p>
              </div>
            </li>
            <li>
              <b><code>Tfc</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Desired fuel cell temperature in Kelvin (operating input).</p>
              </div>
            </li>
            <li>
              <b><code>Pa_des</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Desired anode pressure in Pascal (operating input).</p>
              </div>
            </li>
            <li>
              <b><code>Pc_des</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Desired cathode pressure in Pascal (operating input).</p>
              </div>
            </li>
            <li>
              <b><code>Sa</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Stoichiometric ratio of hydrogen (operating input).</p>
              </div>
            </li>
            <li>
              <b><code>Sc</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Stoichiometric ratio of oxygen (operating input).</p>
              </div>
            </li>
            <li>
              <b><code>Phi_a_des</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Desired anode relative humidity (operating input).</p>
              </div>
            </li>
            <li>
              <b><code>Phi_c_des</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Desired cathode relative humidity (operating input).</p>
              </div>
            </li>
            <li>
              <b><code>t_step</code></b>
                  (<code>tuple</code>)
              –
              <div class="doc-md-description">
                <p>Time parameters for the step_current density function (current parameters).
It is a tuple containing the initial time 't0_step', final time 'tf_step', loading time 'delta_t_load_step'
and dynamic time for display 'delta_t_dyn_step'.</p>
              </div>
            </li>
            <li>
              <b><code>i_step</code></b>
                  (<code>tuple</code>)
              –
              <div class="doc-md-description">
                <p>Current parameters for the step_current density function (current parameters).
It is a tuple containing the initial and final current density value 'i_ini_step' and 'i_final_step'.</p>
              </div>
            </li>
            <li>
              <b><code>i_max_pola</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Maximum current density for the polarization curve (current parameter).</p>
              </div>
            </li>
            <li>
              <b><code>delta_pola</code></b>
                  (<code>tuple</code>)
              –
              <div class="doc-md-description">
                <p>Parameters for the polarization curve (current parameters). It is a tuple containing the loading time
'delta_t_load_pola', the breaking time 'delta_t_break_pola', the current density step 'delta_i_pola', and
the initial breaking time 'delta_t_ini_pola'.</p>
              </div>
            </li>
            <li>
              <b><code>i_EIS</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Current for which a ratio_EIS perturbation is added (current parameter).</p>
              </div>
            </li>
            <li>
              <b><code>ratio_EIS</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Value of the perturbation on the current density for building the EIS curve (current parameter).</p>
              </div>
            </li>
            <li>
              <b><code>t_EIS</code></b>
                  (<code>tuple</code>)
              –
              <div class="doc-md-description">
                <p>EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium
't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS',
the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium
at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for
measuring the voltage response at each frequency 'delta_t_measurement_EIS'.</p>
              </div>
            </li>
            <li>
              <b><code>f_EIS</code></b>
                  (<code>tuple</code>)
              –
              <div class="doc-md-description">
                <p>EIS parameters (current parameters). It is a tuple containing the power of the initial frequency
'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the
number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period
'nb_points_EIS'.</p>
              </div>
            </li>
            <li>
              <b><code>Aact</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Active area of the cell in m² (accessible physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>Hgdl</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Thickness of the gas diffusion layer in m (accessible physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>Hmem</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Thickness of the membrane in m (accessible physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>Hcl</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Thickness of the catalyst layer in m (accessible physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>Hgc</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Thickness of the gas channel in m (accessible physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>Wgc</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Width of the gas channel in m (accessible physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>Lgc</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Length of the gas channel in m (accessible physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>epsilon_gdl</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Anode/cathode GDL porosity (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>tau</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Pore structure coefficient (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>epsilon_mc</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Volume fraction of ionomer in the CL (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>epsilon_c</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Compression ratio of the GDL (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>e</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Capillary exponent (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>Re</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Electron conduction resistance of the circuit in ohm.m² (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>i0_c_ref</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>kappa_co</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>kappa_c</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Overpotential correction exponent (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>a_slim</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>One of the limit liquid saturation coefficients: the slop of slim function
(undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>b_slim</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>One of the limit liquid saturation coefficients: the intercept of slim function
(undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>a_switch</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>One of the limit liquid saturation coefficients: the slop of s_switch function
(undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>C_scl</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter).</p>
              </div>
            </li>
            <li>
              <b><code>max_step</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>Maximum time step for the solver (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>n_gdl</code></b>
                  (<code>int</code>)
              –
              <div class="doc-md-description">
                <p>Number of points considered in the GDL (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>t_purge</code></b>
                  (<code>tuple</code>)
              –
              <div class="doc-md-description">
                <p>Time parameters for purging the system (computing parameter).
It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'.</p>
              </div>
            </li>
            <li>
              <b><code>type_fuel_cell</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                <p>Type of fuel cell configuration (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>type_current</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                <p>Type of current density function (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>type_auxiliary</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                <p>Type of auxiliary system (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>type_control</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                <p>Type of control system (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>type_purge</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                <p>Type of purge system (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>type_display</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                <p>Type of display (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>type_plot</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                <p>Type of plot (computing parameter).</p>
              </div>
            </li>
            <li>
              <b><code>initial_variable_values</code></b>
                  (<code>list</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>Initial values of the solver variables. The default is None, which implies that initial values are
generated considering an equilibrium at the operating inputs without current.</p>
              </div>
            </li>
            <li>
              <b><code>time_interval</code></b>
                  (<code>list</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>Time intervals for numerical resolution. The default is None, which implies that it is automatically
generated according to the data given in the current density parameters.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>model/AlphaPEM.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, current_density, Tfc, Pa_des, Pc_des, Sa, Sc, Phi_a_des, Phi_c_des, t_step, i_step, i_max_pola,
             delta_pola, i_EIS, ratio_EIS, t_EIS, f_EIS, Aact, Hgdl, Hmem, Hcl, Hgc, Wgc, Lgc, epsilon_gdl, tau,
             epsilon_mc, epsilon_c, e, Re, i0_c_ref, kappa_co, kappa_c, a_slim, b_slim, a_switch, C_scl, max_step,
             n_gdl, t_purge, type_fuel_cell, type_current, type_auxiliary, type_control, type_purge, type_display,
             type_plot, initial_variable_values=None, time_interval=None):
    """Initialise all parameters defining a fuel cell stack operation: nominal operating conditions,
    applied electrical load, dimensions, and undetermined variables.

    Parameters
    ----------
    current_density : function
        Current density evolution over time (operating input). It is a function of time and parameters dictionary.
    Tfc : float
        Desired fuel cell temperature in Kelvin (operating input).
    Pa_des : float
        Desired anode pressure in Pascal (operating input).
    Pc_des : float
        Desired cathode pressure in Pascal (operating input).
    Sa : float
        Stoichiometric ratio of hydrogen (operating input).
    Sc : float
        Stoichiometric ratio of oxygen (operating input).
    Phi_a_des : float
        Desired anode relative humidity (operating input).
    Phi_c_des : float
        Desired cathode relative humidity (operating input).
    t_step : tuple
        Time parameters for the step_current density function (current parameters).
        It is a tuple containing the initial time 't0_step', final time 'tf_step', loading time 'delta_t_load_step'
        and dynamic time for display 'delta_t_dyn_step'.
    i_step : tuple
        Current parameters for the step_current density function (current parameters).
        It is a tuple containing the initial and final current density value 'i_ini_step' and 'i_final_step'.
    i_max_pola : float
        Maximum current density for the polarization curve (current parameter).
    delta_pola : tuple
        Parameters for the polarization curve (current parameters). It is a tuple containing the loading time
        'delta_t_load_pola', the breaking time 'delta_t_break_pola', the current density step 'delta_i_pola', and
        the initial breaking time 'delta_t_ini_pola'.
    i_EIS : float
        Current for which a ratio_EIS perturbation is added (current parameter).
    ratio_EIS : float
        Value of the perturbation on the current density for building the EIS curve (current parameter).
    t_EIS : tuple
        EIS parameters (current parameters). It is a tuple containing the initial EIS time after stack equilibrium
        't0_EIS', a list of time parameters which gives the beginning of each frequency change 't_new_start_EIS',
        the final time 'tf_EIS', a list of time parameters which gives the estimated time for reaching equilibrium
        at each frequency 'delta_t_break_EIS', and a list of time parameters which gives the estimated time for
        measuring the voltage response at each frequency 'delta_t_measurement_EIS'.
    f_EIS : tuple
        EIS parameters (current parameters). It is a tuple containing the power of the initial frequency
        'f_power_min_EIS': f_min_EIS = 10**f_power_min_EIS, the power of the final frequency 'f_power_max_EIS', the
        number of frequencies tested 'nb_f_EIS' and the number of points calculated per specific period
        'nb_points_EIS'.
    Aact : float
        Active area of the cell in m² (accessible physical parameter).
    Hgdl : float
        Thickness of the gas diffusion layer in m (accessible physical parameter).
    Hmem : float
        Thickness of the membrane in m (accessible physical parameter).
    Hcl : float
        Thickness of the catalyst layer in m (accessible physical parameter).
    Hgc : float
        Thickness of the gas channel in m (accessible physical parameter).
    Wgc : float
        Width of the gas channel in m (accessible physical parameter).
    Lgc : float
        Length of the gas channel in m (accessible physical parameter).
    epsilon_gdl : float
        Anode/cathode GDL porosity (undetermined physical parameter).
    tau : float
        Pore structure coefficient (undetermined physical parameter).
    epsilon_mc : float
        Volume fraction of ionomer in the CL (undetermined physical parameter).
    epsilon_c : float
        Compression ratio of the GDL (undetermined physical parameter).
    e : float
        Capillary exponent (undetermined physical parameter).
    Re : float
        Electron conduction resistance of the circuit in ohm.m² (undetermined physical parameter).
    i0_c_ref : float
        Reference exchange current density at the cathode in A.m-2 (undetermined physical parameter).
    kappa_co : float
        Crossover correction coefficient in mol.m-1.s-1.Pa-1 (undetermined physical parameter).
    kappa_c : float
        Overpotential correction exponent (undetermined physical parameter).
    a_slim : float
        One of the limit liquid saturation coefficients: the slop of slim function
        (undetermined physical parameter).
    b_slim : float
        One of the limit liquid saturation coefficients: the intercept of slim function
        (undetermined physical parameter).
    a_switch : float
        One of the limit liquid saturation coefficients: the slop of s_switch function
        (undetermined physical parameter).
    C_scl : float
        Volumetric space-charge layer capacitance in F.m-3 (undetermined physical parameter).
    max_step : float
        Maximum time step for the solver (computing parameter).
    n_gdl : int
        Number of points considered in the GDL (computing parameter).
    t_purge : tuple
        Time parameters for purging the system (computing parameter).
        It is the purge time interval 'purge_time' and the time between two purges 'delta_purge'.
    type_fuel_cell : str
        Type of fuel cell configuration (computing parameter).
    type_current : str
        Type of current density function (computing parameter).
    type_auxiliary : str
        Type of auxiliary system (computing parameter).
    type_control : str
        Type of control system (computing parameter).
    type_purge : str
        Type of purge system (computing parameter).
    type_display : str
        Type of display (computing parameter).
    type_plot : str
        Type of plot (computing parameter).
    initial_variable_values : list, optional
        Initial values of the solver variables. The default is None, which implies that initial values are
        generated considering an equilibrium at the operating inputs without current.
    time_interval : list, optional
        Time intervals for numerical resolution. The default is None, which implies that it is automatically
        generated according to the data given in the current density parameters.
    """

    # Initialize the operating inputs and parameters dictionaries.
    self.operating_inputs = {'current_density': current_density, 'Tfc': Tfc, 'Pa_des': Pa_des, 'Pc_des': Pc_des,
                             'Sa': Sa, 'Sc': Sc, 'Phi_a_des': Phi_a_des, 'Phi_c_des': Phi_c_des}
    self.current_parameters = {'t_step': t_step, 'i_step': i_step, 'delta_pola': delta_pola,
                               'i_max_pola': i_max_pola, 'i_EIS': i_EIS, 'ratio_EIS': ratio_EIS, 't_EIS': t_EIS,
                               'f_EIS': f_EIS}
    self.accessible_physical_parameters = {'Aact': Aact, 'Hgdl': Hgdl, 'Hmem': Hmem, 'Hcl': Hcl, 'Hgc': Hgc,
                                           'Wgc': Wgc, 'Lgc': Lgc}
    self.undetermined_physical_parameters = {'epsilon_gdl': epsilon_gdl, 'tau': tau, 'epsilon_mc': epsilon_mc,
                                               'epsilon_c': epsilon_c, 'e': e, 'kappa_co': kappa_co, 'Re': Re,
                                               'i0_c_ref': i0_c_ref, 'kappa_c': kappa_c, 'a_slim': a_slim,
                                               'b_slim': b_slim, 'a_switch': a_switch, 'C_scl': C_scl}
    self.computing_parameters = {'max_step': max_step, 'n_gdl': n_gdl, 't_purge': t_purge,
                                 'type_fuel_cell': type_fuel_cell, 'type_current': type_current,
                                 'type_auxiliary': type_auxiliary, 'type_control': type_control,
                                 'type_purge': type_purge, 'type_display': type_display, 'type_plot': type_plot}
    self.parameters = {**self.current_parameters, **self.accessible_physical_parameters,
                       **self.undetermined_physical_parameters, **self.computing_parameters}
    if self.operating_inputs['Pa_des'] &lt; Pext or self.operating_inputs['Pc_des'] &lt; Pext:
        raise ValueError('The desired pressure is too low. It cannot be lower than the pressure outside the stack.')

    # Initialize the variables' dictionary.
    self.solver_variable_names = ['C_v_agc', 'C_v_agdl', 'C_v_acl', 'C_v_ccl', 'C_v_cgdl', 'C_v_cgc', 's_agdl',
                                  's_acl', 's_ccl', 's_cgdl', 'lambda_acl', 'lambda_mem', 'lambda_ccl', 'C_H2_agc',
                                  'C_H2_agdl', 'C_H2_acl', 'C_O2_ccl', 'C_O2_cgdl', 'C_O2_cgc', 'C_N2', 'eta_c',
                                  'Pasm', 'Paem', 'Pcsm', 'Pcem', 'Phi_asm', 'Phi_aem', 'Phi_csm', 'Phi_cem',
                                  'Wcp', 'Wa_inj', 'Wc_inj', 'Abp_a', 'Abp_c']
    self.solver_variable_names_extension()  # Several points are considered in each GDL and must be inserted into
    #                                        the solver_variable_names.
    self.all_variable_names = self.solver_variable_names + ['t', 'Ucell', 'S_sorp_acl', 'S_sorp_ccl'] + \
                              ['J_lambda_mem_acl', 'J_lambda_mem_ccl', 'Pagc', 'Pcgc', 'Phi_a_des', 'Phi_c_des']
    self.variables = {key: [] for key in self.all_variable_names}

    # Initialize the control_variables dictionary.
    self.control_variables = {'t_control_Phi': self.parameters['t_step'][0],
                              'Phi_a_des': self.operating_inputs['Phi_a_des'],
                              'Phi_c_des': self.operating_inputs['Phi_c_des']}

    # Create the dynamic evolution.
    #       Create time intervals
    if time_interval is not None:  # Initial time interval may be given to the Simulator.
        self.time_interval = time_interval
    else:  # If not, it is automatically generated.
        self.time_interval = self._create_time_interval()

    #       Create the initial variable values
    if initial_variable_values is not None:  # Initial variable values may be given to the Simulator.
        self.initial_variable_values = initial_variable_values
    else:  # If not, they are generated considering an equilibrium at the operating inputs without current.
        self.initial_variable_values = self._create_initial_variable_values()

    #       Resolution of the system of differential equations.
    event_negative.terminal = True  # Integration is stopped if one of the crucial variables becomes negative.
    self.sol = solve_ivp(dydt, self.time_interval, self.initial_variable_values, method='BDF',
                         max_step=self.parameters['max_step'], events=event_negative,
                         args=(self.operating_inputs, self.parameters, self.solver_variable_names,
                               self.control_variables))

    #       Recover the variable values calculated by the solver into the dictionary.
    self._recovery()

    #       Calculate the cell voltage after computing the internal states of the cell.
    self.variables["Ucell"].extend(calculate_cell_voltage(self.variables, self.operating_inputs, self.parameters))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="model.AlphaPEM.AlphaPEM.solver_variable_names_extension" class="doc doc-heading">
            <code class="highlight language-python">solver_variable_names_extension()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Several points are considered in each GDL and must be inserted into the solver_variable_names.</p>

            <details class="quote">
              <summary>Source code in <code>model/AlphaPEM.py</code></summary>
              <pre class="highlight"><code class="language-python">def solver_variable_names_extension(self):
    """Several points are considered in each GDL and must be inserted into the solver_variable_names.
    """

    new_points_location = ['C_v_agdl', 'C_v_cgdl', 's_agdl', 's_cgdl', 'C_H2_agdl', 'C_O2_cgdl']
    for variable in new_points_location:
        index = self.solver_variable_names.index(variable)
        # Delete the previous points
        self.solver_variable_names.pop(index)
        # Increase the number of points
        self.solver_variable_names[index:index] = [f'{variable}_{i}' for i in
                                                   range(1, self.parameters['n_gdl'] + 1)]</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../configuration/settings/" class="btn btn-neutral float-left" title="Settings"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../auxiliaries/" class="btn btn-neutral float-right" title="Auxiliaries">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../configuration/settings/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../auxiliaries/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
